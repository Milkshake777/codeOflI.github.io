{"meta":{"title":"nicolas","subtitle":"Yesterday you said tomorow.","description":"Yesterday you said tomorow.","author":"nicolas lee","url":"https://codeofli.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-10-09T02:10:12.000Z","updated":"2019-11-14T01:56:35.177Z","comments":true,"path":"categories/index.html","permalink":"https://codeofli.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-07T02:31:20.000Z","updated":"2019-11-14T01:56:35.162Z","comments":true,"path":"about/index.html","permalink":"https://codeofli.github.io/about/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-09T02:11:44.000Z","updated":"2019-11-14T01:56:35.162Z","comments":true,"path":"about/index-1.html","permalink":"https://codeofli.github.io/about/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-09T02:17:04.000Z","updated":"2019-11-14T01:56:35.177Z","comments":true,"path":"tags/index.html","permalink":"https://codeofli.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker实用篇","slug":"java-note/SpringCloud/docker/Docker实用篇","date":"2021-10-26T02:40:06.000Z","updated":"2021-10-31T04:54:41.143Z","comments":true,"path":"2021/10/java-note/SpringCloud/docker/Docker实用篇/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/docker/Docker实用篇/","excerpt":"Docker实用篇1.初识Docker1.1.什么是Docker微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 1.1.1.应用部署的环境问题大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：","text":"Docker实用篇1.初识Docker1.1.什么是Docker微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 1.1.1.应用部署的环境问题大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题： 依赖关系复杂，容易出现兼容性问题 开发、测试、生产环境有差异 例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。 1.1.2.Docker解决依赖兼容问题而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？ Docker为了解决依赖的兼容问题的，采用了两个手段： 将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包 将每个应用放到一个隔离容器去运行，避免互相干扰 这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。 虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？ 1.1.3.Docker解决操作系统环境差异要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下： 结构包括： 计算机硬件：例如CPU、内存、磁盘等 系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。 系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。 应用于计算机交互的流程如下： 1）应用调用操作系统应用（函数库），实现各种功能 2）系统函数库是对内核指令集的封装，会调用内核指令 3）内核指令操作计算机硬件 Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异： 此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了： Docker如何解决不同系统环境的问题？ Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包 Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行 如图： 1.1.4.小结Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？ Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像 Docker应用运行在容器中，使用沙箱机制，相互隔离 Docker如何解决开发、测试、生产环境有差异的问题？ Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行 Docker是一个快速交付应用、运行应用的技术，具备下列优势： 可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统 运行时利用** 形成隔离容器**，各个应用互不干扰 启动、移除都可以通过一行命令完成，方便快捷 1.2.Docker和虚拟机的区别Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。 两者有什么差异呢？ 虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。 Docker仅仅是封装函数库，并没有模拟完整的操作系统，如图： 对比来看： 小结： Docker和虚拟机的差异： docker是一个系统进程；虚拟机是在操作系统中的操作系统 docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般 1.3.Docker架构1.3.1.镜像和容器Docker中有几个重要的概念： 镜像（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。 容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器进程做隔离，对外不可见。 一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的文件。只有运行时，才会加载到内存，形成进程。 而镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。 容器呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。 例如你下载了一个QQ，如果我们将QQ在磁盘上的运行文件及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。 1.3.2.DockerHub开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。 DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。 国内也有类似于DockerHub 的公开服务，比如 网易云镜像服务、阿里云镜像库等。 我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像： 1.3.3.Docker架构我们要使用Docker来操作镜像、容器，就必须要安装Docker。 Docker是一个CS架构的程序，由两部分组成： 服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等 客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。 如图： 1.3.4.小结镜像： 将应用程序及其依赖、环境、配置打包在一起 容器： 镜像运行起来就是容器，一个镜像可以运行多个容器 Docker结构： 服务端：接收命令或远程请求，操作镜像或容器 客户端：发送命令或者请求到Docker服务端 DockerHub： 一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry 1.4.安装Docker企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考课前资料中的文档： 2.Docker的基本操作0.centos启动dockerDocker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 1234# 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld 通过命令启动docker： 12345systemctl start docker # 启动docker服务systemctl stop docker # 停止docker服务systemctl restart docker # 重启docker服务 然后输入命令，可以查看docker版本： 1docker -v 如: 12[root@VM-0-5-centos ~]# docker -vDocker version 20.10.8, build 3967b7d 2.1.镜像操作1docker --help 可查看docker中的所有命令 1docker images --help 2.1.1.镜像名称首先来看下镜像的名称组成： 镜名称一般分两部分组成：[repository]:[tag]。 在没有指定tag时，默认是latest，代表最新版本的镜像 如图： 这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。 2.镜像命令/操作常见的镜像操作命令如图： 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rm image-id 删除指定的本地镜像 https://hub.docker.com/ 2.1.3.案例1-拉取、查看镜像需求：从DockerHub中拉取一个nginx镜像并查看 1）首先去镜像仓库搜索nginx镜像，比如DockerHub: 2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx 3）通过命令：docker images 查看拉取到的镜像 123[root@VM-0-5-centos ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest dd34e67e3371 13 days ago 133MB 2.1.4.案例2-保存、导入镜像需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来 1）利用docker xx –help命令查看docker save和docker load的语法 例如，查看save命令用法，可以输入命令： 1docker save --help 结果： 命令格式： 1docker save -o [保存的目标文件名称] [镜像名称] 2）使用docker save导出镜像到磁盘 运行命令： 1docker save -o nginx.tar nginx:latest 结果如图： 3）使用docker load加载镜像 先删除本地的nginx镜像： 1docker rmi nginx:latest 然后运行命令，加载本地文件： 1docker load -i nginx.tar 结果： 1234567891011[root@VM-0-5-centos ~]# docker load -i nginx.tarf68ef921efae: Loading layer [==================================================&gt;] 72.53MB/72.53MBd1279c519351: Loading layer [==================================================&gt;] 64.86MB/64.86MB678bbd796838: Loading layer [==================================================&gt;] 3.072kB/3.072kB009f1d338b57: Loading layer [==================================================&gt;] 4.096kB/4.096kB8f736d52032f: Loading layer [==================================================&gt;] 3.584kB/3.584kBfb04ab8effa8: Loading layer [==================================================&gt;] 7.168kB/7.168kBLoaded image: nginx:latest[root@VM-0-5-centos ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest dd34e67e3371 13 days ago 133MB 2.1.5.练习需求：去DockerHub搜索并拉取一个Redis镜像 目标： 1）去DockerHub搜索Redis镜像 2）查看Redis镜像的名称和版本 3）利用docker pull命令拉取镜像 4）利用docker save命令将 redis:latest打包为一个redis.tar包 5）利用docker rmi 删除本地的redis:latest 6）利用docker load 重新加载 redis.tar文件 2.2.容器操作2.2.1.容器相关命令容器操作的命令如图： 容器保护三个状态： 运行：进程正常运行 暂停：进程暂停，CPU不再运行，并不释放内存 停止：进程终止，回收进程占用的内存、CPU等资源 其中： docker run：创建并运行一个容器，处于运行状态 docker pause：让一个运行的容器暂停 docker unpause：让一个容器从暂停状态恢复运行 docker stop：停止一个运行的容器 docker start：让一个停止的容器再次运行 docker rm：删除一个容器 2.2.2.案例-创建并运行一个容器https://hub.docker.com/_/nginx 在官方镜像中都有介绍How to use this image。 创建并运行nginx容器的命令： 1docker run --name containerName -p 80:80 -d nginx 命令解读： docker run ：创建并运行一个容器 –name : 给容器起一个名字，比如叫做mn -p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 -d：后台运行容器 nginx：镜像名称，例如nginx 这里的-p参数，是将容器端口映射到宿主机端口。 默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。 现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了： 1docker run --name mn -p 80:80 -d nginx 123[root@VM-0-5-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8c282135b883 nginx \"/docker-entrypoint.…\" 41 seconds ago Up 41 seconds 0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp mn 1docker logs -f mn 2.2.3.案例-进入容器，修改文件需求：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您” 提示：进入容器要用到docker exec命令。 步骤： 1）进入容器。进入我们刚刚创建的nginx容器的命令为： 1docker exec -it mn bash 命令解读： docker exec ：进入容器内部，执行一个命令 -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 mn ：要进入的容器的名称 bash：进入容器后执行的命令，bash是一个linux终端交互命令 2）进入nginx的HTML所在目录 /usr/share/nginx/html 容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样： nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。 查看DockerHub网站中的nginx页面(Hosting some simple static content)，可以知道nginx的html目录位置在/usr/share/nginx/html 我们执行命令，进入该目录： 1cd /usr/share/nginx/html 查看目录下文件： 12root@8c282135b883:/usr/share/nginx/html# ls50x.html index.html 3）修改index.html的内容 容器内没有vi命令，无法直接修改，我们用下面的命令来修改： 1sed -i -e 's#Welcome to nginx#传智教育欢迎您#g' -e 's#&lt;head&gt;#&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;#g' index.html 在浏览器访问自己的虚拟机地址，例如我的是：http://192.168.150.101，即可看到结果： 1exit 退出 2.2.4创建并运行一个redis容器，并且支持数据持久化步骤一：到DockerHub搜索Redis镜像步骤二：查看Redis镜像文档中的帮助信息步骤三：利用docker run 命令运行一个Redis容器 1docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 123[root@VM-0-5-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3721e348e496 redis \"docker-entrypoint.s…\" 18 seconds ago Up 17 seconds 0.0.0.0:6379-&gt;6379/tcp, :::6379-&gt;6379/tcp redis 进入redis容器，并执行redis-cli客户端命令，存入num=666步骤一：进入redis容器 1docker exec -it redis bash 步骤二：执行redis-cli客户端命令 1redis-cli 也可以直接用 12[root@VM-0-5-centos ~]# docker exec -it redis redis-cli127.0.0.1:6379&gt; 得： 12root@3721e348e496:/data# redis-cli127.0.0.1:6379&gt; 步骤三：设置数据num=666 1set num 666 得： 1234127.0.0.1:6379&gt; set num 666OK127.0.0.1:6379&gt; get num\"666\" 2.2.5.小结docker run命令的常见参数有哪些？ –name：指定容器名称 -p：指定端口映射 -d：让容器后台运行 查看容器日志的命令： docker logs 添加 -f 参数可以持续查看日志 查看容器状态： docker ps docker ps -a 查看所有容器，包括已经停止的 3.数据卷（容器数据管理）在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。 这就是因为容器与数据（容器内文件）耦合带来的后果。 要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。 2.3.1.什么是数据卷数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录。 一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。 这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了 2.3.2.数据集操作命令数据卷操作的基本语法如下： 1docker volume [COMMAND] docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作： create 创建一个volume inspect 显示一个或多个volume的信息 ls 列出所有的volume prune 删除未使用的volume rm 删除一个或多个指定的volume 1234567891011121314[root@VM-0-5-centos ~]# docker volume --help Usage: docker volume COMMANDManage volumesCommands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumesRun 'docker volume COMMAND --help' for more information on a command. 2.3.3.创建和查看数据卷需求：创建一个数据卷，并查看数据卷在宿主机的目录位置 ① 创建数据卷 1docker volume create html ② 查看所有数据 1docker volume ls 结果： 1234[root@VM-0-5-centos ~]# docker volume lsDRIVER VOLUME NAMElocal 5511e44a3bb854589933ef3f2096ce5a7df5ec43b2f7279a036cb6af723c1ce4local html ③ 查看数据卷详细信息卷 1docker volume inspect html 结果： 123456789101112[root@VM-0-5-centos ~]# docker volume inspect html[ &#123; \"CreatedAt\": \"2021-08-31T11:07:21+08:00\", \"Driver\": \"local\", \"Labels\": &#123;&#125;, \"Mountpoint\": \"/var/lib/docker/volumes/html/_data\", \"Name\": \"html\", \"Options\": &#123;&#125;, \"Scope\": \"local\" &#125;] 可以看到，我们创建的html这个数据卷关联的宿主机目录为/var/lib/docker/volumes/html/_data目录。 小结： 数据卷的作用： 将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全 数据卷操作： docker volume create：创建数据卷 docker volume ls：查看所有数据卷 docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置 docker volume rm：删除指定数据卷 docker volume prune：删除所有未使用的数据卷 4.挂载数据卷我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下： 12345docker run \\ --name mn \\ -v html:/root/html \\ -p 8080:80 nginx \\ 这里的-v就是挂载数据卷的命令： -v html:/root/html ：把html数据卷挂载到容器内的/root/html这个目录中 注：如果数据卷html不存在，docker会去创建一个 2.3.5.案例-给nginx挂载数据卷需求：创建一个nginx容器，修改容器内的html目录内的index.html内容 分析：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。 提示：运行容器时使用 -v 参数挂载数据卷 步骤： ① 创建容器并挂载数据卷到容器内的HTML目录 1docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx ② 进入html数据卷所在位置，并修改HTML内容 123456# 查看html数据卷的位置docker volume inspect html# 进入该目录cd /var/lib/docker/volumes/html/_data# 修改文件vi index.html 2.3.6.案例-给MySQL挂载本地目录容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下： 带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录 直接挂载模式：宿主机目录 —&gt; 容器内目录 如图： 语法： 目录挂载与数据卷挂载的语法是类似的： -v [宿主机目录]:[容器内目录] -v [宿主机文件]:[容器内文件] 需求：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器 实现思路如下： 1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像 1docker load -i mysql.tar 2）创建目录/tmp/mysql/data 12mkdir -p mysql/datamkdir -p mysql/conf 1234567891011121314[root@VM-0-5-centos tmp]# mkdir --help Usage: mkdir [OPTION]... DIRECTORY...Create the DIRECTORY(ies), if they do not already exist.Mandatory arguments to long options are mandatory for short options too. -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask -p, --parents no error if existing, make parent directories as needed -v, --verbose print a message for each created directory -Z set SELinux security context of each created directory to the default type --context[=CTX] like -Z, or if CTX is specified then set the SELinux or SMACK security context to CTX --help display this help and exit --version output version information and exit 3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf 4）去DockerHub查阅资料，创建并运行MySQL容器，要求： ① 挂载/tmp/mysql/data到mysql容器内数据存储目录 ② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件 ③ 设置MySQL密码 1docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 1234567docker run \\ --name some-mysql \\ -p 3306:3306 \\ -v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf \\ -v /tmp/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123 \\ -d mysql:5.7.25 2.3.7.小结docker run的命令中通过 -v 参数挂载文件或目录到容器中： -v volume名称:容器内目录 -v 宿主机文件:容器内文件 -v 宿主机目录:容器内目录 数据卷挂载与目录直接挂载的 数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找 目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看 3.Dockerfile自定义镜像常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。 而要自定义镜像，就必须先了解镜像的结构才行。 3.1.镜像结构镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。 我们以MySQL为例，来看看镜像的组成结构： 简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。 我们要构建镜像，其实就是实现上述打包的过程。 3.2.Dockerfile语法构建自定义的镜像时，并不需要一个个文件去拷贝，打包。 我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。 而描述上述信息的文件就是Dockerfile文件。 Dockerfile就是一个文本文件，其中包含一个个的指令(Instruction)，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。 更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder 3.3.构建Java项目3.3.1.基于Ubuntu构建Java项目需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目 步骤1：新建一个空文件夹docker-demo 1mkdir docker-demo 步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录 步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录 步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录 12345[root@VM-0-5-centos docker-demo]# lltotal 96896-rw-r--r-- 1 root root 25620395 Aug 31 15:41 docker-demo.jar-rw-r--r-- 1 root root 494 Aug 31 15:40 Dockerfile-rw-r--r-- 1 root root 73596928 Aug 31 15:41 jdk8.tar.gz 其中的内容如下： 12345678910111213141516171819202122# 指定基础镜像FROM ubuntu:16.04# 配置环境变量，JDK的安装目录ENV JAVA_DIR=/usr/local# 拷贝jdk和java项目的包COPY ./jdk8.tar.gz $JAVA_DIR/COPY ./docker-demo.jar /tmp/app.jar# 安装JDKRUN cd $JAVA_DIR \\ &amp;&amp; tar -xf ./jdk8.tar.gz \\ &amp;&amp; mv ./jdk1.8.0_144 ./java8# 配置环境变量ENV JAVA_HOME=$JAVA_DIR/java8ENV PATH=$PATH:$JAVA_HOME/bin# 暴露端口EXPOSE 8090# 入口，java项目的启动命令ENTRYPOINT java -jar /tmp/app.jar 步骤5：进入docker-demo 将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下 步骤6：运行命令： 1docker build -t javaweb:1.0 . 1docker run --name web -p 8090:8090 -d javaweb:1.0 最后访问 http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip 3.3.2.基于java8构建Java项目虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。 例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。 需求：基于java:8-alpine镜像，将一个Java项目构建为镜像 实现思路如下： ① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile ② 拷贝课前资料提供的docker-demo.jar到这个目录中 ③ 编写Dockerfile文件： a ）基于java:8-alpine作为基础镜像 b ）将app.jar拷贝到镜像中 c ）暴露端口 d ）编写入口ENTRYPOINT 内容如下： 1234FROM java:8-alpineCOPY ./app.jar /tmp/app.jarEXPOSE 8090ENTRYPOINT java -jar /tmp/app.jar ④ 使用docker build命令构建镜像 1docker build -t javaweb:2.0 . ⑤ 使用docker run创建容器并运行 3.4.小结小结： Dockerfile的本质是一个文件，通过指令描述镜像的构建过程 Dockerfile的第一行必须是FROM，从一个基础镜像来构建 基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine 4.Docker-ComposeDocker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！ 4.1.初识DockerComposeCompose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下： 12345678910111213version: \"3.8\" services: mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - \"/tmp/mysql/data:/var/lib/mysql\" - \"/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf\" web: build: . ports: - \"8090:8090\" 上面的Compose文件就描述一个项目，其中包含两个容器： mysql：一个基于mysql:5.7.25镜像构建的容器，并且挂载了两个目录 web：一个基于docker build临时构建的镜像容器，映射端口时8090 DockerCompose的详细语法参考官网：https://docs.docker.com/compose/compose-file/ 其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。 4.2.安装DockerCompose参考课前资料 Centos7安装Docker.md 4.3.部署微服务集群需求：将之前学习的cloud-demo微服务集群利用DockerCompose部署 实现思路： ① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件 ② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名 https://www.bilibili.com/video/BV1LQ4y127n4?p=59 ③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar ④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中 ⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署 4.3.1.compose文件查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录： 内容如下： 123456789101112131415161718192021222324version: \"3.2\"services: nacos: image: nacos/nacos-server environment: MODE: standalone ports: - \"8848:8848\" mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - \"$PWD/mysql/data:/var/lib/mysql\" - \"$PWD/mysql/conf:/etc/mysql/conf.d/\" userservice: build: ./user-service orderservice: build: ./order-service gateway: build: ./gateway ports: - \"10010:10010\" 可以看到，其中包含5个service服务： nacos：作为注册中心和配置中心 image: nacos/nacos-server： 基于nacos/nacos-server镜像构建 environment：环境变量 MODE: standalone：单点模式启动 ports：端口映射，这里暴露了8848端口 mysql：数据库 image: mysql:5.7.25：镜像版本是mysql:5.7.25 environment：环境变量 MYSQL_ROOT_PASSWORD: 123：设置数据库root账户的密码为123 volumes：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据 userservice、orderservice、gateway：都是基于Dockerfile临时构建的 查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表： 查看微服务目录，可以看到都包含Dockerfile文件： 内容如下： 123FROM java:8-alpineCOPY ./app.jar /tmp/app.jarENTRYPOINT java -jar /tmp/app.jar 4.3.2.修改微服务配置因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。 如下所示： 1234567891011spring: datasource: url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false username: root password: 123 driver-class-name: com.mysql.jdbc.Driver application: name: orderservice cloud: nacos: server-addr: nacos:8848 # nacos服务地址 4.3.3.打包接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。 可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改： 12345678910&lt;build&gt; &lt;!-- 服务打包的最终名称 --&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 打包后： 4.3.4.拷贝jar包到部署目录编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。 user-service： order-service： gateway： 4.3.5.部署最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。 上传到任意目录： 部署： 进入cloud-demo目录，然后运行下面的命令： 1docker-compose up -d 查看日志，发现userservice服务未发现nacos 123[root@localhost cloud-demo]# docker-compose logs -fuserservice_1 | com.alibaba.nacos.api.exception.NacosException: failed to req API:/nacos/v1/ns/instance/list after all servers([nacos:8848]) tried: java.net.ConnectException: Connection refused (Connection refused) 原因是服务建立时，nacos还未安装好，重启服务即可 1234[root@localhost cloud-demo]# docker-compose restart gateway userservice orderserviceRestarting cloud-demo_userservice_1 ... doneRestarting cloud-demo_orderservice_1 ... doneRestarting cloud-demo_gateway_1 ... done 1docker-compose logs -f userservice 未发现错误 用浏览器访问http://192.168.194.128:10010/user/1?authorization=admin正常 5.Docker镜像仓库常见镜像仓库服务 镜像仓库（ Docker Registry ）有公共的和私有的两种形式：公共仓库：例如Docker官方的 Docker Hub，国内也有一些云服务商提供类似于 Docker Hub 的公开服务，比如 网易云镜像服务、DaoCloud 镜像服务、阿里云镜像服务等。除了使用公开仓库外，用户还可以在本地搭建私有 Docker Registry。企业自己的镜像最好是采用私有Docker Registry来实现。 5.1.搭建私有镜像仓库参考课前资料《CentOS7安装Docker.md》 5.2.推送、拉取镜像推送镜像到私有镜像服务必须先tag，步骤如下： ① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/ 1docker tag nginx:latest 192.168.194.128:8080/nginx:1.0 ② 推送镜像 1docker push 192.168.194.128:8080/nginx:1.0 ③ 拉取镜像 1docker pull 192.168.194.128:8080/nginx:1.0","categories":[{"name":"Docker","slug":"Docker","permalink":"https://codeofli.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://codeofli.github.io/tags/Docker/"}]},{"title":"RabbitMQ","slug":"java-note/SpringCloud/RabbitMQ/RabbitMQ","date":"2021-10-25T02:40:06.000Z","updated":"2021-10-31T05:01:50.236Z","comments":true,"path":"2021/10/java-note/SpringCloud/RabbitMQ/RabbitMQ/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/RabbitMQ/RabbitMQ/","excerpt":"RabbitMQ1.初识MQ1.1.同步和异步通讯微服务间通讯有同步和异步两种方式：同步通讯：就像打电话，需要实时响应。异步通讯：就像发邮件，不需要马上回复。两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。1.1.1.同步通讯","text":"RabbitMQ1.初识MQ1.1.同步和异步通讯微服务间通讯有同步和异步两种方式：同步通讯：就像打电话，需要实时响应。异步通讯：就像发邮件，不需要马上回复。两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。1.1.1.同步通讯 我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题： 总结： 同步调用的优点： 时效性较强，可以立即得到结果 同步调用的问题： 耦合度高 性能和吞吐能力下降 有额外的资源消耗 有级联失败问题 1.1.2.异步通讯 )) 我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。 在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。 订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。 为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。 Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。 好处： 吞吐量提升：无需等待订阅者处理完成，响应更快速 故障隔离：服务没有直接调用，不存在级联失败问题 调用间没有阻塞，不会造成无效的资源占用 耦合度极低，每个服务都可以灵活插拔，可替换 流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件 缺点： 架构复杂了，业务没有明显的流程线，不好管理 需要依赖于Broker的可靠、安全、性能 好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。 1.2.技术对比：MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。 比较常见的MQ实现： ActiveMQ RabbitMQ RocketMQ Kafka 几种常见MQ的对比： RabbitMQ ActiveMQ RocketMQ Kafka 公司/社区 Rabbit Apache 阿里 Apache 开发语言 Erlang Java Java Scala&amp;Java 协议支持 AMQP，XMPP，SMTP，STOMP OpenWire,STOMP，REST,XMPP,AMQP 自定义协议 自定义协议 可用性 高 一般 高 高 单机吞吐量 一般 差 高 非常高 消息延迟 微秒级 毫秒级 毫秒级 毫秒以内 消息可靠性 高 一般 高 一般 追求可用性：Kafka、 RocketMQ 、RabbitMQ 追求可靠性：RabbitMQ、RocketMQ 追求吞吐能力：RocketMQ、Kafka 追求消息低延迟：RabbitMQ、Kafka 2.RabbitMQ快速入门2.1.安装RabbitMQRabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：https://www.rabbitmq.com/ 安装RabbitMQ，参考课前资料：RabbitMQ部署指南.md MQ的基本结构： RabbitMQ中的一些角色： publisher：生产者 consumer：消费者 exchange个：交换机，负责消息路由 queue：队列，存储消息 virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离 2.2.RabbitMQ常见消息模型RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型： 2.3.导入Demo工程课前资料提供了一个Demo工程，mq-demo: 导入后可以看到结构如下： 包括三部分： mq-demo：父工程，管理项目依赖 publisher：消息的发送者 consumer：消息的消费者 2.4.入门案例HelloWorld案例： 简单队列模式的模型图： 官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色： publisher：消息发布者，将消息发送到队列queue queue：消息队列，负责接受并缓存消息 consumer：订阅队列，处理队列中的消息 2.4.1.publisher实现思路： 建立连接 创建Channel 声明队列 发送消息 关闭连接和channel 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast.mq.helloworld;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import org.junit.Test;import java.io.IOException;import java.util.concurrent.TimeoutException;public class PublisherTest &#123; @Test public void testSendMessage() throws IOException, TimeoutException &#123; // 1.建立连接 ConnectionFactory factory = new ConnectionFactory(); // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码 factory.setHost(\"192.168.150.101\"); factory.setPort(5672); factory.setVirtualHost(\"/\"); factory.setUsername(\"itcast\"); factory.setPassword(\"123321\"); // 1.2.建立连接 Connection connection = factory.newConnection(); // 2.创建通道Channel Channel channel = connection.createChannel(); // 3.创建队列 String queueName = \"simple.queue\"; channel.queueDeclare(queueName, false, false, false, null); // 4.发送消息 String message = \"hello, rabbitmq!\"; channel.basicPublish(\"\", queueName, null, message.getBytes()); System.out.println(\"发送消息成功：【\" + message + \"】\"); // 5.关闭通道和连接 channel.close(); connection.close(); &#125;&#125; 2.4.2.consumer实现代码思路： 建立连接 创建Channel 声明队列 订阅消息 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.itcast.mq.helloworld;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class ConsumerTest &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; // 1.建立连接 ConnectionFactory factory = new ConnectionFactory(); // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码 factory.setHost(\"192.168.150.101\"); factory.setPort(5672); factory.setVirtualHost(\"/\"); factory.setUsername(\"itcast\"); factory.setPassword(\"123321\"); // 1.2.建立连接 Connection connection = factory.newConnection(); // 2.创建通道Channel Channel channel = connection.createChannel(); // 3.创建队列 String queueName = \"simple.queue\"; channel.queueDeclare(queueName, false, false, false, null); // 4.订阅消息 channel.basicConsume(queueName, true, new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; // 5.处理消息 String message = new String(body); System.out.println(\"接收到消息：【\" + message + \"】\"); &#125; &#125;); System.out.println(\"等待接收消息。。。。\"); &#125;&#125; 2.5.总结基本消息队列的消息发送流程： 建立connection 创建channel 利用channel声明队列 利用channel向队列发送消息 基本消息队列的消息接收流程： 建立connection 创建channel 利用channel声明队列 定义consumer的消费行为handleDelivery() 利用channel将消费者与队列绑定 3.SpringAMQPSpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。 SpringAmqp的官方地址：https://spring.io/projects/spring-amqp SpringAMQP提供了三个功能： 自动声明队列、交换机及其绑定关系 基于注解的监听器模式，异步接收消息 封装了RabbitTemplate工具，用于发送消息 3.1.Basic Queue 简单队列模型在父工程mq-demo中引入依赖 12345&lt;!--AMQP依赖，包含RabbitMQ--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 3.1.1.消息发送首先配置MQ地址，在publisher服务的application.yml中添加配置： 1234567spring: rabbitmq: host: 192.168.194.128 # rabbitMQ的ip地址 port: 5672 # 端口 virtual-host: / # 虚拟主机 username: itcast # 用户名 password: 123321 # 密码 然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送： 1234567891011121314151617181920212223242526package cn.itcast.mq.spring;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringAmqpTest &#123; @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSendMessage2SimpleQueue() &#123; // 队列名称 String queueName = \"simple.queue\"; // 消息 String message = \"hello, spring amqp!\"; // 发送消息 rabbitTemplate.convertAndSend(queueName, message); &#125;&#125; 3.1.2.消息接收首先配置MQ地址，在consumer服务的application.yml中添加配置： 1234567spring: rabbitmq: host: 192.168.194.128 # rabbitMQ的ip地址 port: 5672 # 端口 virtual-host: / # 虚拟主机 username: itcast # 用户名 password: 123321 # 密码 然后在consumer服务的cn.itcast.mq.listener包中新建一个类SpringRabbitListener，代码如下： 12345678910111213package cn.itcast.mq.listener;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Componentpublic class SpringRabbitListener &#123; @RabbitListener(queues = \"simple.queue\") public void listenSimpleQueueMessage(String msg) throws InterruptedException &#123; System.out.println(\"spring 消费者接收到消息：【\" + msg + \"】\"); &#125;&#125; 3.1.3.测试启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息 3.2.WorkQueueWork queues，也被称为（Task queues），任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。 当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。 此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。 3.2.1.消息发送这次我们循环发送，模拟大量消息堆积现象。 在publisher服务中的SpringAmqpTest类中添加一个测试方法： 12345678910111213141516/** * workQueue * 向队列中不停发送消息，模拟消息堆积。 */@Testpublic void testWorkQueue() throws InterruptedException &#123; // 队列名称 String queueName = \"simple.queue\"; // 消息 String message = \"hello, message_\"; for (int i = 0; i &lt; 50; i++) &#123; // 发送消息 rabbitTemplate.convertAndSend(queueName, message + i); Thread.sleep(20); &#125;&#125; 3.2.2.消息接收要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法： 1234567891011@RabbitListener(queues = \"simple.queue\")public void listenWorkQueue1(String msg) throws InterruptedException &#123; System.out.println(\"消费者1接收到消息：【\" + msg + \"】\" + LocalTime.now()); Thread.sleep(20);&#125;@RabbitListener(queues = \"simple.queue\")public void listenWorkQueue2(String msg) throws InterruptedException &#123; System.err.println(\"消费者2........接收到消息：【\" + msg + \"】\" + LocalTime.now()); Thread.sleep(200);&#125; 注意到这个消费者sleep了1000秒，模拟任务耗时。 3.2.3.测试启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。 可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。 也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。 3.2.4.能者多劳消费预取限制修改application.yml文件，设置preFetch这个值，可以控制预取消息的上限（默认250条）: 12345678910spring: rabbitmq: host: 192.168.150.101 #主机名 port: 5672#端口 virtual-host: /#虚拟主机 username: itcast #用户名 password: 123321 #密码 listener: simple: prefetch: 1 #每次只能获取一条消息，处理完成才能获取下一个消息 在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置： 12345spring: rabbitmq: listener: simple: prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息 3.2.5.总结Work模型的使用： 多个消费者绑定到一个队列，同一条消息只会被一个消费者处理 通过设置prefetch来控制消费者预取的消息数量 3.3.发布/订阅(Exchange)发布订阅的模型如图： 可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化： Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机） Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型： Fanout：广播，将消息交给所有绑定到交换机的队列 Direct：定向，把消息交给符合指定routing key 的队列 Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列 Consumer：消费者，与以前一样，订阅队列，没有变化 Queue：消息队列也与以前一样，接收消息、缓存消息。 Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！ 3.4.FanoutFanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。 在广播模式下，消息发送流程是这样的： 1） 可以有多个队列 2） 每个队列都要绑定到Exchange（交换机） 3） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定 4） 交换机把消息发送给绑定过的所有队列 5） 订阅队列的消费者都能拿到消息 我们的计划是这样的： 创建一个交换机 itcast.fanout，类型是Fanout 创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout 3.4.1.声明队列和交换机Spring提供了一个接口Exchange，来表示所有不同类型的交换机： 在consumer中创建一个类，声明队列和交换机： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.itcast.mq.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.FanoutExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FanoutConfig &#123; /** * 声明交换机 * @return Fanout类型交换机 */ @Bean public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(\"itcast.fanout\"); &#125; /** * 第1个队列 */ @Bean public Queue fanoutQueue1()&#123; return new Queue(\"fanout.queue1\"); &#125; /** * 绑定队列和交换机 */ @Bean public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange)&#123; return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); &#125; /** * 第2个队列 */ @Bean public Queue fanoutQueue2()&#123; return new Queue(\"fanout.queue2\"); &#125; /** * 绑定队列和交换机 */ @Bean public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange)&#123; return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange); &#125;&#125; 3.4.2.消息接收在consumer服务的SpringRabbitListener中添加两个方法，作为消费者： 123456789@RabbitListener(queues = \"fanout.queue1\")public void listenFanoutQueue1(String msg) &#123; System.out.println(\"消费者1接收到Fanout消息：【\" + msg + \"】\");&#125;@RabbitListener(queues = \"fanout.queue2\")public void listenFanoutQueue2(String msg) &#123; System.out.println(\"消费者2接收到Fanout消息：【\" + msg + \"】\");&#125; 3.4.3.消息发送在publisher服务的SpringAmqpTest类中添加测试方法： 123456789@Testpublic void testFanoutExchange() &#123; // 交换机名称 String exchangeName = \"itcast.fanout\"; // 消息 String message = \"hello, everyone!\"; //发送消息 rabbitTemplate.convertAndSend(exchangeName, \"\", message);&#125; 3.4.4.总结交换机的作用是什么？ 接收publisher发送的消息 将消息按照规则路由到与之绑定的队列 不能缓存消息，路由失败，消息丢失 FanoutExchange的会将消息路由到每个绑定的队列 声明队列、交换机、绑定关系的Bean是什么？ Queue FanoutExchange Binding 3.5.Direct在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。 在Direct模型下： 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。 Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息 案例需求如下： 利用@RabbitListener声明Exchange、Queue、RoutingKey 在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2 在publisher中编写测试方法，向itcast. direct发送消息 3.5.1.基于注解声明队列和交换机基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。 在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机： 1234567891011121314151617@RabbitListener(bindings = @QueueBinding( value = @Queue(name = \"direct.queue1\"), exchange = @Exchange(name = \"itcast.direct\", type = ExchangeTypes.DIRECT), key = &#123;\"red\", \"blue\"&#125;))public void listenDirectQueue1(String msg)&#123; System.out.println(\"消费者接收到direct.queue1的消息：【\" + msg + \"】\");&#125;@RabbitListener(bindings = @QueueBinding( value = @Queue(name = \"direct.queue2\"), exchange = @Exchange(name = \"itcast.direct\", type = ExchangeTypes.DIRECT), key = &#123;\"red\", \"yellow\"&#125;))public void listenDirectQueue2(String msg)&#123; System.out.println(\"消费者接收到direct.queue2的消息：【\" + msg + \"】\");&#125; 3.5.2.消息发送在publisher服务的SpringAmqpTest类中添加测试方法： 123456789@Testpublic void testSendDirectExchange() &#123; // 交换机名称 String exchangeName = \"itcast.direct\"; // 消息 String message = \"红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！\"; // 发送消息 rabbitTemplate.convertAndSend(exchangeName, \"red\", message);&#125; 3.5.3.总结描述下Direct交换机与Fanout交换机的差异？ Fanout交换机将消息路由给每一个与之绑定的队列 Direct交换机根据RoutingKey判断路由给哪个队列 如果多个队列具有相同的RoutingKey，则与Fanout功能类似 基于@RabbitListener注解声明队列和交换机有哪些常见注解？ @Queue @Exchange 3.6.Topic3.6.1.说明Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！ Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert 通配符规则： #：匹配一个或多个词 *：匹配不多不少恰好1个词 举例： item.#：能够匹配item.spu.insert 或者 item.spu item.*：只能匹配item.spu ​ 图示： 解释： Queue1：绑定的是china.# ，因此凡是以 china.开头的routing key 都会被匹配到。包括china.news和china.weather Queue2：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配。包括china.news和japan.news 案例需求： 实现思路如下： 并利用@RabbitListener声明Exchange、Queue、RoutingKey 在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2 在publisher中编写测试方法，向itcast. topic发送消息 3.6.2.消息接收在consumer服务的SpringRabbitListener中添加方法： 1234567891011121314151617@RabbitListener(bindings = @QueueBinding( value = @Queue(name = \"topic.queue1\"), exchange = @Exchange(name = \"itcast.topic\", type = ExchangeTypes.TOPIC), key = \"china.#\"))public void listenTopicQueue1(String msg)&#123; System.out.println(\"消费者接收到topic.queue1的消息：【\" + msg + \"】\");&#125;@RabbitListener(bindings = @QueueBinding( value = @Queue(name = \"topic.queue2\"), exchange = @Exchange(name = \"itcast.topic\", type = ExchangeTypes.TOPIC), key = \"#.news\"))public void listenTopicQueue2(String msg)&#123; System.out.println(\"消费者接收到topic.queue2的消息：【\" + msg + \"】\");&#125; 3.6.3.消息发送在publisher服务的SpringAmqpTest类中添加测试方法： 123456789101112/** * topicExchange */@Testpublic void testSendTopicExchange() &#123; // 交换机名称 String exchangeName = \"itcast.topic\"; // 消息 String message = \"喜报！孙悟空大战哥斯拉，胜!\"; // 发送消息 rabbitTemplate.convertAndSend(exchangeName, \"china.news\", message);&#125; 3.6.4.总结描述下Direct交换机与Topic交换机的差异？ Topic交换机接收的消息RoutingKey必须是多个单词，以 **.** 分割 Topic交换机与队列绑定时的bindingKey可以指定通配符 #：代表0个或多个词 *：代表1个词 3.7.消息转换器Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。 只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题： 数据体积过大 有安全漏洞 可读性差 3.7.1.测试默认转换器测试发送Object类型消息 说明：在SpringAMQP的发送方法中，接收消息的类型是Object，也就是说我们可以发送任意对象类型的消息，SpringAMQP会帮我们序列化为字节后发送。我们在consumer中利用@Bean声明一个队列： 我们在consumer中利用@Bean声明一个队列： 1234567@Configurationpublic class FanoutConfig &#123; @Bean public Queue objectQueue() &#123; return new Queue(\"object.queue\"); &#125;&#125; 在publisher中发送消息以测试： 123456789@Testpublic void testSendObjectQueue() throws InterruptedException &#123; // 准备消息 Map&lt;String,Object&gt; msg = new HashMap&lt;&gt;(); msg.put(\"name\", \"Jack\"); msg.put(\"age\", 21); // 发送消息 rabbitTemplate.convertAndSend(\"object.queue\", msg);&#125; 发送消息后查看控制台： 3.7.2.配置JSON转换器显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。 Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。如果要修改只需要定义一个MessageConverter 类型的Bean即可。推荐用JSON方式序列化，步骤如下： 在publisher和consumer两个服务中都引入依赖,直接放在父目录pom.xml中： 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.10&lt;/version&gt;&lt;/dependency&gt; 或 1234&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt; 我们在publisher和consumer服务声明MessageConverter，可直接放在启动类中： 1234@Beanpublic MessageConverter jsonMessageConverter()&#123; return new Jackson2JsonMessageConverter();&#125; 再次测试发送object到队列中，查看后有 然后定义一个消费者，监听object.queue队列并消费消息： 1234@RabbitListener(queues = \"object.queue\")public void listenObjectQueue(Map&lt;String, Object&gt; msg) &#123; System.out.println(\"收到消息：【\" + msg + \"】\");&#125;","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://codeofli.github.io/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://codeofli.github.io/tags/RabbitMQ/"}]},{"title":"RabbitMQ部署指南","slug":"java-note/SpringCloud/RabbitMQ/RabbitMQ部署指南/RabbitMQ部署指南","date":"2021-10-25T02:40:06.000Z","updated":"2021-10-31T05:01:12.861Z","comments":true,"path":"2021/10/java-note/SpringCloud/RabbitMQ/RabbitMQ部署指南/RabbitMQ部署指南/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/RabbitMQ/RabbitMQ部署指南/RabbitMQ部署指南/","excerpt":"RabbitMQ部署指南1.单机部署我们在Centos7虚拟机中使用Docker来安装。1.1.下载镜像方式一：在线拉取1docker pull rabbitmq:3-management方式二：从本地加载在课前资料已经提供了镜像包： 上传到虚拟机中后，使用命令加载镜像即可：1docker load -i mq.tar","text":"RabbitMQ部署指南1.单机部署我们在Centos7虚拟机中使用Docker来安装。1.1.下载镜像方式一：在线拉取1docker pull rabbitmq:3-management方式二：从本地加载在课前资料已经提供了镜像包： 上传到虚拟机中后，使用命令加载镜像即可：1docker load -i mq.tar 1.2.安装MQ执行下面的命令来运行MQ容器： 123456789docker run \\ -e RABBITMQ_DEFAULT_USER=itcast \\ -e RABBITMQ_DEFAULT_PASS=123321 \\ --name mq \\ --hostname mq1 \\ -p 15672:15672 \\ -p 5672:5672 \\ -d \\ rabbitmq:3-management 浏览器访问（ip自己改）http://192.168.194.128:15672/， 2.集群部署接下来，我们看看如何安装RabbitMQ的集群。 2.1.集群分类在RabbitMQ的官方文档中，讲述了两种集群的配置方式： 普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。 镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。 我们先来看普通模式集群。 2.2.设置网络首先，我们需要让3台MQ互相知道对方的存在。 分别在3台机器中，设置 /etc/hosts文件，添加如下内容： 123192.168.150.101 mq1192.168.150.102 mq2192.168.150.103 mq3 并在每台机器上测试，是否可以ping通对方：","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://codeofli.github.io/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://codeofli.github.io/tags/RabbitMQ/"}]},{"title":"分布式事务seata","slug":"java-note/SpringCloud/seata/seate","date":"2021-10-24T02:40:06.000Z","updated":"2021-10-31T05:13:43.046Z","comments":true,"path":"2021/10/java-note/SpringCloud/seata/seate/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/seata/seate/","excerpt":"分布式事务seata事务的ACID原则演示分布式事务问题 创建数据库，名为seata_demo，然后导入课前资料提供的SQL文件： 1seata-demo.sql 导入课前资料提供的微服务: seata-demo（文件夹） 启动nacos、所有微服务 测试下单功能，发出Post请求: 12curl --location --request POST 'http://localhost:8082/order?userId=user202103032042012&amp;commodityCode=100202003032041&amp;count=2&amp;money=200'","text":"分布式事务seata事务的ACID原则演示分布式事务问题 创建数据库，名为seata_demo，然后导入课前资料提供的SQL文件： 1seata-demo.sql 导入课前资料提供的微服务: seata-demo（文件夹） 启动nacos、所有微服务 测试下单功能，发出Post请求: 12curl --location --request POST 'http://localhost:8082/order?userId=user202103032042012&amp;commodityCode=100202003032041&amp;count=2&amp;money=200' 分布式服务的事务问题在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务，要保证所有分支事务最终状态一致，这样的事务就是分布式事务。 学习目标 1理论基础CAP定理1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标： Consistency（一致性） Availability（可用性） Partition tolerance （分区容错性） Eric Brewer 说，分布式系统无法同时满足这三个指标。这个结论就叫做 CAP 定理。 CAP定理- ConsistencyConsistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致 CAP定理- AvailabilityAvailability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝 CAP定理-Partition tolerancePartition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务 总结简述CAP定理内容？ 分布式系统节点通过网络连接，一定会出现分区问题（P）当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足 思考：elasticsearch集群是CP还是AP？ ES集群出现分区时，故障节点会被剔除集群，数据分片会重新分配到其它节点，保证数据一致。因此是低可用性，高一致性，属于CP BASE理论BASE理论是对CAP的一种解决思路，包含三个思想： Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。 Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。 Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。 而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论： AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。 CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。 分布式事务模型解决分布式事务，各个子系统之间必须能感知到彼此的事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者（子系统事务）。这里的子系统事务，称为分支事务；有关联的各个分支事务在一起称为全局事务 总结 简述BASE理论三个思想： 基本可用 软状态 最终一致 解决分布式事务的思想和模型： 全局事务：整个分布式事务 分支事务：分布式事务中包含的每个子系统的事务 最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据 强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚 2初识SeataSeata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。官网地址：http://seata.io/，其中的文档、播客中提供了大量的使用说明、源码分析。 Seata架构Seata事务管理中有三个重要的角色： TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。 TM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。 RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。 初识SeataSeata提供了四种不同的分布式事务解决方案： XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入 TCC模式：最终一致的分阶段事务模式，有业务侵入AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式SAGA模式：长事务模式，有业务侵入 部署TC服务参考课前资料提供的文档《 seata的部署和集成》： 3动手实践XA模式XA模式原理XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。 seata的XA模式seata的XA模式做了一些调整，但大体相似： TM (Transaction Manager) - 事务管理器RM一阶段的工作： 注册分支事务到TC 执行分支业务sql但不提交 报告执行状态到TC TC(TC (Transaction Coordinator) - 事务协调者)二阶段的工作： TC检测各分支事务执行状态a. 如果都成功，通知所有RM提交事务b. 如果有失败，通知所有RM回滚事务 RM二阶段的工作： 接收TC指令，提交或回滚事务 XA模式的优点是什么？ 事务的强一致性，满足ACID原则。 常用数据库都支持，实现简单，并且没有代码侵入 XA模式的缺点是什么？ 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差 依赖关系型数据库实现事务 实现XA模式Seata的starter已经完成了XA模式的自动装配，实现非常简单，步骤如下： 修改application.yml文件（每个参与事务的微服务），开启XA模式： 12seata: data-source-proxy-mode: XA #开启数据源代理的XA模式 2.给发起全局事务的入口方法添加@GlobalTransactional注解，本例中是OrderServiceImpl中的create方法： 1234567891011121314151617@Override@GlobalTransactionalpublic Long create(Order order) &#123; // 创建订单 orderMapper.insert(order); try &#123; // 扣用户余额 accountClient.deduct(order.getUserId(), order.getMoney()); // 扣库存 storageClient.deduct(order.getCommodityCode(), order.getCount()); &#125; catch (FeignException e) &#123; log.error(\"下单失败，原因:&#123;&#125;\", e.contentUTF8(), e); throw new RuntimeException(e.contentUTF8(), e); &#125; return order.getId();&#125; 3.重启服务并测试 postman上测试 count=10时，数据库数据均未修改 AT模式AT模式原理AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。 阶段一RM的工作： 注册分支事务 记录undo-log（数据快照） 执行业务sql并提交 报告事务状态 阶段二提交时RM的工作： 删除undo-log即可 阶段二回滚时RM的工作： 根据undo-log恢复数据到更新前 例如，一个分支业务的SQL是这样的：update tb_account set money = money - 10 where id = 1 简述AT模式与XA模式最大的区别是什么？ XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。 XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。 XA模式强一致；AT模式最终一致 AT模式的脏写问题脏写 脏写，意思是说有两个事务，事务 A 和事务 B 同时在更新一条数据，事务 A 先把它更新为 A 值，事务 B 紧接着就把它更新为 B 值。如图： 可以看到，此时事务 B 是后更新那行数据的值，所以此时那行数据的值是 B。而且此时事务 A 更新之后会记录一条 undo log 日志。因为事务 A 是先更新的，它在更新之前，这行数据的值为 NULL。所以此时事务 A 的 undo log 日志大概就是：更新之前这行数据的值为 NULL，主键为 XX 那么此时事务 B 更新完数据的值为 B，此时事务 A 突然回滚了，就会用它的 undo log 日志去回滚。此时事务 A 一回滚，直接就会把那行数据的值更新回 NULL 值。如图： 然后就尴尬了，事务 B 一看，为什么我更新的 B 值没了？就因为你事务 A 反悔了把数据值回滚成 NULL 了，结果我更新的 B 值也不见 了。所以对于事务 B 看到的场景而言，就是自己明明更新了，结果值却没了，这就是脏写。 所谓脏写，就是我刚才明明写了一个数据值，结果过了一会却没了。而它的本质就是事务 B 去修改了事务 A 修改过的值，但是此时事务 A 还没提交，所以事务 A 随时会回滚，导致事务 B 修改的值也没了，这就是脏写的定义。 AT模式的优点： 一阶段完成直接提交事务，释放数据库资源，性能比较好 利用全局锁实现读写隔离 没有代码侵入，框架自动完成回滚和提交 AT模式的缺点： 两阶段之间属于软状态，属于最终一致 框架的快照功能会影响性能，但比XA模式要好很多 实现AT模式AT模式中的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单。1.导入课前资料提供的Sql文件：seata-at.sql，其中lock_table导入到TC服务关联的数据库，undo_log表导入到微服务关联的数据库： 1seata-at.sql lock_table导入到TC服务关联的数据库 1234567891011121314151617-- ------------------------------ Table structure for lock_table-- ----------------------------DROP TABLE IF EXISTS `lock_table`;CREATE TABLE `lock_table` ( `row_key` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `xid` varchar(96) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `transaction_id` bigint(20) NULL DEFAULT NULL, `branch_id` bigint(20) NOT NULL, `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `table_name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `pk` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `gmt_create` datetime NULL DEFAULT NULL, `gmt_modified` datetime NULL DEFAULT NULL, PRIMARY KEY (`row_key`) USING BTREE, INDEX `idx_branch_id`(`branch_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact; undo_log表导入到微服务关联的数据库 123456789101112131415161718-- ------------------------------ Table structure for undo_log-- ----------------------------DROP TABLE IF EXISTS `undo_log`;CREATE TABLE `undo_log` ( `branch_id` bigint(20) NOT NULL COMMENT 'branch transaction id', `xid` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'global transaction id', `context` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'undo_log context,such as serialization', `rollback_info` longblob NOT NULL COMMENT 'rollback info', `log_status` int(11) NOT NULL COMMENT '0:normal status,1:defense status', `log_created` datetime(6) NOT NULL COMMENT 'create datetime', `log_modified` datetime(6) NOT NULL COMMENT 'modify datetime', UNIQUE INDEX `ux_undo_log`(`xid`, `branch_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 'AT transaction mode undo table' ROW_FORMAT = Compact;-- ------------------------------ Records of undo_log-- ---------------------------- 2.修改application.yml文件，将事务模式修改为AT模式即可： 12seata: data-source-proxy-mode: AT#开启数据源代理的AT模式 3.重启服务并测试 测试内容同XA TCC模式TCC模式原理TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法： Try：资源的检测和预留； Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。 Cancel：预留资源释放，可以理解为try的反向操作。 举例，一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。 TCc的工作模型图: TCC模式的每个阶段是做什么的？ Try：资源检查和预留 Confirm：业务执行和提交 Cancel：预留资源的释放 TCC的优点是什么？ 一阶段完成直接提交事务，释放数据库资源，性能好 相比AT模型，无需生成快照，无需使用全局锁，性能最强 不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库 TCC的缺点是什么？ 有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦 软状态，事务是最终一致 需要考虑Confirm和Cancel的失败情况，做好幂等处理 案例实现改造account-service服务，利用TCC实现分布式事务 需求如下： 修改account-service，编写try、confirm、cancel逻辑try业务：添加冻结金额，扣减可用金额confirm业务：删除冻结金额cancel业务：删除冻结金额，恢复可用金额保证confirm、cancel接口的幂等性允许空回滚拒绝业务悬挂 TCC的空回滚和业务悬挂当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是空回滚。 对于已经空回滚的业务，如果以后继续执行try，就永远不可能confirm或cancel，这就是业务悬挂。应当阻止执行空回滚后的try操作，避免悬挂 业务分析 声明TCC接口TCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明，语法如下： 123456789101112131415161718@LocalTCCpublic interface TCCService &#123; /** * Try逻辑，@TwoPhaseBusinessAction中的name属性要与当前方法名一致，用于指定Try逻辑对应的方法 */ @TwoPhaseBusinessAction(name = \"prepare\", commitMethod = \"confirm\", rollbackMethod = \"cancel\") void prepare(@BusinessActionContextParameter(paramName = \"param\") String param); /** * 二阶段confirm确认方法、可以另命名，但要保证与commitMethod一致 * * @param context 上下文,可以传递try方法的参数 * @return boolean 执行是否成功 */ boolean confirm(BusinessActionContext context); /** * 二阶段回滚方法，要保证与rollbackMethod一致 */ boolean cancel(BusinessActionContext context);&#125; 1.编写AccountTCCService接口123456789101112131415161718package cn.itcast.account.service;import io.seata.rm.tcc.api.BusinessActionContext;import io.seata.rm.tcc.api.BusinessActionContextParameter;import io.seata.rm.tcc.api.LocalTCC;import io.seata.rm.tcc.api.TwoPhaseBusinessAction;@LocalTCCpublic interface AccountTCCService &#123; @TwoPhaseBusinessAction(name = \"deduct\", commitMethod = \"confirm\", rollbackMethod = \"cancel\") void deduct(@BusinessActionContextParameter(paramName = \"userId\") String userId, @BusinessActionContextParameter(paramName = \"money\")int money); boolean confirm(BusinessActionContext ctx); boolean cancel(BusinessActionContext ctx);&#125; 2.创建account_freeze_tbl表123456789101112131415161718192021222324252627282930313233343536/* Navicat Premium Data Transfer Source Server : local Source Server Type : MySQL Source Server Version : 50622 Source Host : localhost:3306 Source Schema : seata_demo Target Server Type : MySQL Target Server Version : 50622 File Encoding : 65001 Date: 23/06/2021 16:23:20*/SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for account_freeze_tbl-- ----------------------------DROP TABLE IF EXISTS `account_freeze_tbl`;CREATE TABLE `account_freeze_tbl` ( `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `user_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `freeze_money` int(11) UNSIGNED NULL DEFAULT 0, `state` int(1) NULL DEFAULT NULL COMMENT '事务状态，0:try，1:confirm，2:cancel', PRIMARY KEY (`xid`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;-- ------------------------------ Records of account_freeze_tbl-- ----------------------------SET FOREIGN_KEY_CHECKS = 1; 1234567891011121314151617181920import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;@Data@TableName(\"account_freeze_tbl\")public class AccountFreeze &#123; @TableId(type = IdType.INPUT) private String xid; private String userId; private Integer freezeMoney; private Integer state; public static abstract class State &#123; public final static int TRY = 0; public final static int CONFIRM = 1; public final static int CANCEL = 2; &#125;&#125; 因为money是unsigned int ，所以不用检查是否为负数（余额判断） 3.编写接口实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package cn.itcast.account.service.impl;import cn.itcast.account.entity.AccountFreeze;import cn.itcast.account.mapper.AccountFreezeMapper;import cn.itcast.account.mapper.AccountMapper;import cn.itcast.account.service.AccountTCCService;import io.seata.core.context.RootContext;import io.seata.rm.tcc.api.BusinessActionContext;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Service@Slf4jpublic class AccountTCCServiceImpl implements AccountTCCService &#123; @Autowired private AccountMapper accountMapper; @Autowired private AccountFreezeMapper freezeMapper; @Override @Transactional public void deduct(String userId, int money) &#123; // 0.获取事务id String xid = RootContext.getXID(); // 1.扣减可用余额 accountMapper.deduct(userId, money); // 2.记录冻结金额，事务状态 AccountFreeze freeze = new AccountFreeze(); freeze.setUserId(userId); freeze.setFreezeMoney(money); freeze.setState(AccountFreeze.State.TRY); freeze.setXid(xid); freezeMapper.insert(freeze); &#125; // 删除操作，执行多次没区别，天生幂等，没必要判断 @Override public boolean confirm(BusinessActionContext ctx) &#123; // 1.获取事务id String xid = ctx.getXid(); // 2.根据id删除冻结记录 int count = freezeMapper.deleteById(xid); return count == 1; &#125; @Override public boolean cancel(BusinessActionContext ctx) &#123; // 0.查询冻结记录 String xid = ctx.getXid(); String userId = ctx.getActionContext(\"userId\").toString(); AccountFreeze freeze = freezeMapper.selectById(xid); // 1.空回滚的判断，判断freeze是否为null，为null证明try没执行,需要空回滚 if(freeze == null)&#123; // 证明try没有执行，需要空回滚 freeze = new AccountFreeze(); freeze.setUserId(userId); freeze.setFreezeMoney(0); freeze.setState(AccountFreeze.State.CANCEL); freeze.setXid(xid); freezeMapper.insert(freeze); return true; &#125; //2.幂等判断 if(freeze.getState() == AccountFreeze.State.CANCEL)&#123; // 已经处理过一次CANCEL了，无需重复处理 return true; &#125; // 1.恢复可用余额 accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney()); // 2.将冻结金额清零，状态改为CANCEL freeze.setFreezeMoney(0); freeze.setState(AccountFreeze.State.CANCEL); int count = freezeMapper.updateById(freeze); return count == 1; &#125;&#125; 修改web中AccountService为AccountTCCService 1234@Autowiredprivate AccountService accountService;@Autowiredprivate AccountTCCService accountService; 4.重启服务测试 Saga模式Saga模式是SEATA提供的长事务解决方案。也分为两个阶段： •一阶段：直接提交本地事务 •二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚 Saga模式优点： •事务参与者可以基于事件驱动实现异步调用，吞吐高 •一阶段直接提交事务，无锁，性能好 •不用编写TCC中的三个阶段，实现简单 缺点： •软状态持续时间不确定，时效性差 •没有锁，没有事务隔离，会有脏写 四种模式对比 XA AT TCC SAGA 一致性 强一致 弱一致 弱一致 最终一致 隔离性 完全隔离 基于全局锁隔离 基于资源预留隔离 无隔离 代码侵入 无 无 有，要编写三个接口 有，要编写状态机和补偿业务 性能 差 好 非常好 非常好 场景 对一致性、隔离性有高要求的业务 基于关系型数据库的大多数分布式事务场景都可以 •对性能要求较高的事务。 •有非关系型数据库要参与的事务。 •业务流程长、业务流程多 •参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口 seata的部署和集成一、部署Seata的tc-server1.下载首先我们要下载seata-server包，地址在http://seata.io/zh-cn/blog/download.html 当然，课前资料也准备好了： 1seata-server-1.4.2.zip 2.解压在非中文目录解压缩这个zip包，其目录结构如下： 3.修改配置修改conf目录下的registry.conf文件： 内容如下： 12345678910111213141516171819202122232425262728293031registry &#123; # 注册中心类型 file 、nacos 、eureka、redis、zk、consul、etcd3、sofa # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等 type = \"nacos\" nacos &#123; # seata tc 服务注册到 nacos的服务名称，可以自定义 application = \"seata-tc-server\" serverAddr = \"127.0.0.1:8848\" group = \"DEFAULT_GROUP\" namespace = \"\" cluster = \"SH\" username = \"nacos\" password = \"nacos\" &#125;&#125;config &#123; # 配置中心 file、nacos 、apollo、zk、consul、etcd3 # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置 type = \"nacos\" # 配置nacos地址等信息 nacos &#123; serverAddr = \"127.0.0.1:8848\" namespace = \"\" group = \"SEATA_GROUP\" username = \"nacos\" password = \"nacos\" dataId = \"seataServer.properties\" &#125;&#125; 4.在nacos添加配置特别注意，为了让tc服务的集群可以共享配置，我们选择了nacos作为统一配置中心。因此服务端配置文件seataServer.properties文件需要在nacos中配好。 格式如下： 配置内容如下： 12345678910111213141516171819202122232425262728293031323334# 数据存储方式，db代表数据库store.mode=dbstore.db.datasource=druidstore.db.dbType=mysqlstore.db.driverClassName=com.mysql.cj.jdbc.Driverstore.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true&amp;serverTimezone=UTCstore.db.user=rootstore.db.password=rootstore.db.minConn=5store.db.maxConn=30store.db.globalTable=global_tablestore.db.branchTable=branch_tablestore.db.queryLimit=100store.db.lockTable=lock_tablestore.db.maxWait=5000# 事务、日志等配置server.recovery.committingRetryPeriod=1000server.recovery.asynCommittingRetryPeriod=1000server.recovery.rollbackingRetryPeriod=1000server.recovery.timeoutRetryPeriod=1000server.maxCommitRetryTimeout=-1server.maxRollbackRetryTimeout=-1server.rollbackRetryTimeoutUnlockEnable=falseserver.undo.logSaveDays=7server.undo.logDeletePeriod=86400000# 客户端与服务端传输方式transport.serialization=seatatransport.compressor=none# 关闭metrics功能，提高性能metrics.enabled=falsemetrics.registryType=compactmetrics.exporterList=prometheusmetrics.exporterPrometheusPort=9898 ==其中的数据库地址、用户名、密码都需要修改成你自己的数据库信息。== 5.创建数据库表特别注意：tc服务在管理分布式事务时，需要记录事务相关数据到数据库中，你需要提前创建好这些表。 新建一个名为seata的数据库，运行课前资料提供的sql文件： 这些表主要记录全局事务、分支事务、全局锁信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ 分支事务表-- ----------------------------DROP TABLE IF EXISTS `branch_table`;CREATE TABLE `branch_table` ( `branch_id` bigint(20) NOT NULL, `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `transaction_id` bigint(20) NULL DEFAULT NULL, `resource_group_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `branch_type` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `status` tinyint(4) NULL DEFAULT NULL, `client_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `gmt_create` datetime(6) NULL DEFAULT NULL, `gmt_modified` datetime(6) NULL DEFAULT NULL, PRIMARY KEY (`branch_id`) USING BTREE, INDEX `idx_xid`(`xid`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;-- ------------------------------ 全局事务表-- ----------------------------DROP TABLE IF EXISTS `global_table`;CREATE TABLE `global_table` ( `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `transaction_id` bigint(20) NULL DEFAULT NULL, `status` tinyint(4) NOT NULL, `application_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `transaction_service_group` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `transaction_name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `timeout` int(11) NULL DEFAULT NULL, `begin_time` bigint(20) NULL DEFAULT NULL, `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `gmt_create` datetime NULL DEFAULT NULL, `gmt_modified` datetime NULL DEFAULT NULL, PRIMARY KEY (`xid`) USING BTREE, INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) USING BTREE, INDEX `idx_transaction_id`(`transaction_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;SET FOREIGN_KEY_CHECKS = 1; 6.启动TC服务进入bin目录，运行其中的seata-server.bat即可： 启动成功后，seata-server应该已经注册到nacos注册中心了。 打开浏览器，访问nacos地址：http://localhost:8848，然后进入服务列表页面，可以看到seata-tc-server的信息： 二、微服务集成seata1.引入依赖首先，我们需要在微服务(pom.xml)中引入seata依赖： 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--版本较低，1.3.0，因此排除--&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--seata starter 采用1.4.2版本--&gt;&lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;seata.version&#125;&lt;/version&gt;&lt;/dependency&gt; 2.修改配置文件需要修改application.yml文件，添加一些配置： 然后，配置application.yml，让微服务通过注册中心找到seata-tc-server： 123456789101112131415seata: registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址 # 参考tc服务自己的registry.conf中的配置 type: nacos nacos: # tc server-addr: 127.0.0.1:8848 namespace: \"\" group: DEFAULT_GROUP application: seata-tc-server # tc服务在nacos中的服务名称 cluster: SH tx-service-group: seata-demo # 事务组，根据这个获取tc服务的cluster名称 service: vgroup-mapping: # 事务组与TC服务cluster的映射关系 seata-demo: SH 三、TC服务的高可用和异地容灾1.模拟异地容灾的TC集群3计划启动两台seata的tc服务节点： 节点名称 ip地址 端口号 集群名称 seata 127.0.0.1 8091 SH seata2 127.0.0.1 8092 HZ 之前我们已经启动了一台seata服务，端口是8091，集群名为SH。 现在，将seata目录复制一份，起名为seata2 修改seata2/conf/registry.conf内容如下： 1234567891011121314151617181920212223242526272829registry &#123; # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等 type = \"nacos\" nacos &#123; # seata tc 服务注册到 nacos的服务名称，可以自定义 application = \"seata-tc-server\" serverAddr = \"127.0.0.1:8848\" group = \"DEFAULT_GROUP\" namespace = \"\" cluster = \"HZ\" username = \"nacos\" password = \"nacos\" &#125;&#125;config &#123; # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置 type = \"nacos\" # 配置nacos地址等信息 nacos &#123; serverAddr = \"127.0.0.1:8848\" namespace = \"\" group = \"SEATA_GROUP\" username = \"nacos\" password = \"nacos\" dataId = \"seataServer.properties\" &#125;&#125; 进入seata2/bin目录，然后运行命令： 1seata-server.bat -p 8092 打开nacos控制台，查看服务列表： 点进详情查看： 2.将事务组映射配置到nacos接下来，我们需要将tx-service-group与cluster的映射关系都配置到nacos配置中心。 新建一个配置： 配置的内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 事务组映射关系service.vgroupMapping.seata-demo=SHservice.enableDegrade=falseservice.disableGlobalTransaction=false# 与TC服务的通信配置transport.type=TCPtransport.server=NIOtransport.heartbeat=truetransport.enableClientBatchSendRequest=falsetransport.threadFactory.bossThreadPrefix=NettyBosstransport.threadFactory.workerThreadPrefix=NettyServerNIOWorkertransport.threadFactory.serverExecutorThreadPrefix=NettyServerBizHandlertransport.threadFactory.shareBossWorker=falsetransport.threadFactory.clientSelectorThreadPrefix=NettyClientSelectortransport.threadFactory.clientSelectorThreadSize=1transport.threadFactory.clientWorkerThreadPrefix=NettyClientWorkerThreadtransport.threadFactory.bossThreadSize=1transport.threadFactory.workerThreadSize=defaulttransport.shutdown.wait=3# RM配置client.rm.asyncCommitBufferLimit=10000client.rm.lock.retryInterval=10client.rm.lock.retryTimes=30client.rm.lock.retryPolicyBranchRollbackOnConflict=trueclient.rm.reportRetryCount=5client.rm.tableMetaCheckEnable=falseclient.rm.tableMetaCheckerInterval=60000client.rm.sqlParserType=druidclient.rm.reportSuccessEnable=falseclient.rm.sagaBranchRegisterEnable=false# TM配置client.tm.commitRetryCount=5client.tm.rollbackRetryCount=5client.tm.defaultGlobalTransactionTimeout=60000client.tm.degradeCheck=falseclient.tm.degradeCheckAllowTimes=10client.tm.degradeCheckPeriod=2000# undo日志配置client.undo.dataValidation=trueclient.undo.logSerialization=jacksonclient.undo.onlyCareUpdateColumns=trueclient.undo.logTable=undo_logclient.undo.compress.enable=trueclient.undo.compress.type=zipclient.undo.compress.threshold=64kclient.log.exceptionRate=100 3.微服务读取nacos配置接下来，需要修改每一个微服务的application.yml文件，让微服务读取nacos中的client.properties文件： 123456789seata: config: type: nacos nacos: server-addr: 127.0.0.1:8848 username: nacos password: nacos group: SEATA_GROUP data-id: client.properties 重启微服务，现在微服务到底是连接tc的SH集群，还是tc的HZ集群，都统一由nacos的client.properties来决定了。","categories":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/tags/Java/"},{"name":"seata","slug":"seata","permalink":"https://codeofli.github.io/tags/seata/"}]},{"title":"安装elasticsearch","slug":"java-note/SpringCloud/Elasticsearch/安装elasticsearch/安装elasticsearch","date":"2021-10-24T02:40:06.000Z","updated":"2021-10-31T05:06:17.313Z","comments":true,"path":"2021/10/java-note/SpringCloud/Elasticsearch/安装elasticsearch/安装elasticsearch/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/Elasticsearch/安装elasticsearch/安装elasticsearch/","excerpt":"安装elasticsearch1.部署单点es1.1.创建网络因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：1docker network create es-net1.2.加载镜像这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。","text":"安装elasticsearch1.部署单点es1.1.创建网络因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：1docker network create es-net1.2.加载镜像这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。 课前资料提供了镜像的tar包： 大家将其上传到虚拟机中，然后运行命令加载即可： 12# 导入数据docker load -i es.tar 同理还有kibana的tar包也需要这样做。 1.3.运行运行docker命令，部署单点es： 1234567891011docker run -d \\ --name es \\ -e \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" \\ -e \"discovery.type=single-node\" \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\elasticsearch:7.12.1 命令解释： -e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称 -e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问 -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小 -e &quot;discovery.type=single-node&quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 -p 9200:9200：端口映射配置 在浏览器中输入：http://192.168.150.101:9200 即可看到elasticsearch的响应结果： 2.部署kibanakibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。 2.1.部署运行docker命令，部署kibana 123456docker run -d \\--name kibana \\-e ELASTICSEARCH_HOSTS=http://es:9200 \\--network=es-net \\-p 5601:5601 \\kibana:7.12.1 --network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中 -e ELASTICSEARCH_HOSTS=http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch -p 5601:5601：端口映射配置 kibana启动一般比较慢，需要多等待一会，可以通过命令： 1docker logs -f kibana 查看运行日志，当查看到下面的日志，说明成功： 此时，在浏览器输入地址访问：http://192.168.150.101:5601，即可看到结果 2.2.DevToolskibana中提供了一个DevTools界面： 这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。 3.安装IK分词器3.1.在线安装ik插件（较慢）12345678910# 进入容器内部docker exec -it elasticsearch /bin/bash# 在线下载并安装./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip#退出exit#重启容器docker restart elasticsearch 3.2.离线安装ik插件（推荐）1）查看数据卷目录安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看: 1docker volume inspect es-plugins 显示结果： 1234567891011[ &#123; \"CreatedAt\": \"2022-05-06T10:06:34+08:00\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/es-plugins/_data\", \"Name\": \"es-plugins\", \"Options\": null, \"Scope\": \"local\" &#125;] 说明plugins目录被挂载到了：/var/lib/docker/volumes/es-plugins/_data这个目录中。 2）解压缩分词器安装包下面我们需要把课前资料中的ik分词器解压缩，重命名为ik 3）上传到es容器的插件数据卷中也就是/var/lib/docker/volumes/es-plugins/_data： 4）重启容器12# 4、重启容器docker restart es 12# 查看es日志docker logs -f es 5）测试：IK分词器包含两种模式： ik_smart：最少切分 ik_max_word：最细切分 12345GET /_analyze&#123; \"analyzer\": \"ik_max_word\", \"text\": \"黑马程序员学习java太棒了\"&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&#123; \"tokens\" : [ &#123; \"token\" : \"黑马\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"CN_WORD\", \"position\" : 0 &#125;, &#123; \"token\" : \"程序员\", \"start_offset\" : 2, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 1 &#125;, &#123; \"token\" : \"程序\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"CN_WORD\", \"position\" : 2 &#125;, &#123; \"token\" : \"员\", \"start_offset\" : 4, \"end_offset\" : 5, \"type\" : \"CN_CHAR\", \"position\" : 3 &#125;, &#123; \"token\" : \"学习\", \"start_offset\" : 5, \"end_offset\" : 7, \"type\" : \"CN_WORD\", \"position\" : 4 &#125;, &#123; \"token\" : \"java\", \"start_offset\" : 7, \"end_offset\" : 11, \"type\" : \"ENGLISH\", \"position\" : 5 &#125;, &#123; \"token\" : \"太棒了\", \"start_offset\" : 11, \"end_offset\" : 14, \"type\" : \"CN_WORD\", \"position\" : 6 &#125;, &#123; \"token\" : \"太棒\", \"start_offset\" : 11, \"end_offset\" : 13, \"type\" : \"CN_WORD\", \"position\" : 7 &#125;, &#123; \"token\" : \"了\", \"start_offset\" : 13, \"end_offset\" : 14, \"type\" : \"CN_CHAR\", \"position\" : 8 &#125; ]&#125; 3.3 扩展词词典随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。 所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。 1）打开IK分词器config目录： 2）在IKAnalyzer.cfg.xml配置文件内容添加： 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt; &lt;entry key=\"ext_dict\"&gt;ext.dic&lt;/entry&gt;&lt;/properties&gt; 3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改 12传智播客奥力给 4）重启elasticsearch 1234docker restart es# 查看 日志docker logs -f elasticsearch 日志中已经成功加载ext.dic配置文件 5）测试效果： 12345GET /_analyze&#123; \"analyzer\": \"ik_max_word\", \"text\": \"传智播客Java就业超过90%,奥力给！\"&#125; 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 3.4 停用词词典在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。 IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。 1）IKAnalyzer.cfg.xml配置文件内容添加： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典--&gt; &lt;entry key=\"ext_dict\"&gt;ext.dic&lt;/entry&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典 *** 添加停用词词典--&gt; &lt;entry key=\"ext_stopwords\"&gt;stopword.dic&lt;/entry&gt;&lt;/properties&gt; 3）在 stopword.dic 添加停用词 1习大大 4）重启elasticsearch 123456# 重启服务docker restart elasticsearchdocker restart kibana# 查看 日志docker logs -f elasticsearch 日志中已经成功加载stopword.dic配置文件 5）测试效果： 12345GET /_analyze&#123; \"analyzer\": \"ik_max_word\", \"text\": \"传智播客Java就业率超过95%,习大大都点赞,奥力给！\"&#125; 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 4.部署es集群我们会在单机上利用docker容器运行多个es实例来模拟es集群。不过生产环境推荐大家每一台服务节点仅部署一个es的实例。 部署es集群可以直接使用docker-compose来完成，但这要求你的Linux虚拟机至少有4G的内存空间 4.1.创建es集群首先编写一个docker-compose.yml文件，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758version: '2.2'services: es01: image: elasticsearch:7.12.1 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: elasticsearch:7.12.1 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" volumes: - data02:/usr/share/elasticsearch/data ports: - 9201:9200 networks: - elastic es03: image: elasticsearch:7.12.1 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" volumes: - data03:/usr/share/elasticsearch/data networks: - elastic ports: - 9202:9200volumes: data01: driver: local data02: driver: local data03: driver: localnetworks: elastic: driver: bridge es运行需要修改一些linux系统权限，修改/etc/sysctl.conf文件 1vi /etc/sysctl.conf 添加下面的内容： 1vm.max_map_count=262144 然后执行命令，让配置生效： 1sysctl -p 通过docker-compose启动集群： 1docker-compose up -d 可查看是否成功 12docker ps docker logs -f es01 注： 先打开docker 4.2.集群状态监控kibana可以监控es集群，不过新版本需要依赖es的x-pack 功能，配置比较复杂。 这里推荐使用cerebro来监控es集群状态，官方网址：https://github.com/lmenezes/cerebro 课前资料已经提供了安装包： 解压即可使用，非常方便。 解压好的目录如下： 进入对应的bin目录： 双击其中的cerebro.bat文件即可启动服务。 访问http://localhost:9000 即可进入管理界面： 输入你的elasticsearch的任意节点的地址和端口，点击connect即可： 绿色的条，代表集群处于绿色（健康状态）。 实星是主节点，空星是候选节点 4.3.创建索引库1）利用kibana的DevTools创建索引库在DevTools中输入指令： 123456789101112PUT /itcast&#123; \"settings\": &#123; \"number_of_shards\": 3, // 分片数量 \"number_of_replicas\": 1 // 副本数量 &#125;, \"mappings\": &#123; \"properties\": &#123; // mapping映射定义 ... &#125; &#125;&#125; 2）利用cerebro创建索引库利用cerebro还可以创建索引库： 填写索引库信息： 点击右下角的create按钮： 4.4.查看分片效果回到首页，即可查看索引库分片效果：","categories":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://codeofli.github.io/categories/elasticsearch/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://codeofli.github.io/tags/elasticsearch/"}]},{"title":"Elasticsearch","slug":"java-note/SpringCloud/Elasticsearch/Elasticsearch","date":"2021-10-24T02:40:06.000Z","updated":"2021-10-31T05:16:14.778Z","comments":true,"path":"2021/10/java-note/SpringCloud/Elasticsearch/Elasticsearch/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/Elasticsearch/Elasticsearch/","excerpt":"分布式搜索引擎elasticsearch– elasticsearch基础1.初识elasticsearch1.1.了解ES1.1.1.elasticsearch的作用elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容例如： 在GitHub搜索代码 在电商网站搜索商品 在百度搜索答案 在打车软件搜索附近的车","text":"分布式搜索引擎elasticsearch– elasticsearch基础1.初识elasticsearch1.1.了解ES1.1.1.elasticsearch的作用elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容例如： 在GitHub搜索代码 在电商网站搜索商品 在百度搜索答案 在打车软件搜索附近的车 1.1.2.ELK技术栈elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域： 而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。 1.1.3.elasticsearch和luceneelasticsearch底层是基于lucene来实现的。 Lucene是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：https://lucene.apache.org/ 。 elasticsearch的发展历史： 2004年Shay Banon基于Lucene开发了Compass 2010年Shay Banon 重写了Compass，取名为Elasticsearch。 1.1.4.为什么不是其他搜索技术？目前比较知名的搜索引擎技术排名： 虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头： 1.1.5.总结什么是elasticsearch？ 一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能 什么是elastic stack（ELK）？ 是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch 什么是Lucene？ 是Apache的开源搜索引擎类库，提供了搜索引擎的核心API 1.2.倒排索引倒排索引的概念是基于MySQL这样的正向索引而言的。 1.2.1.正向索引那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引： 如果是根据id查询，那么直接走索引，查询速度非常快。 但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下： 1）用户搜索数据，条件是title符合&quot;%手机%&quot; 2）逐行获取数据，比如id为1的数据 3）判断数据中的title是否符合用户搜索条件 4）如果符合则放入结果集，不符合则丢弃。回到步骤1 逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。 1.2.2.倒排索引倒排索引中有两个非常重要的概念： 文档（Document）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息 词条（Term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条 创建倒排索引是对正向索引的一种特殊处理，流程如下： 将每一个文档的数据利用算法分词，得到一个个词条 创建表，每行数据包括词条、词条所在文档id、位置等信息 因为词条唯一性，可以给词条创建索引，例如hash表结构索引 如图： 倒排索引的搜索流程如下（以搜索”华为手机”为例）： 1）用户输入条件&quot;华为手机&quot;进行搜索。 2）对用户输入内容分词，得到词条：华为、手机。 3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。 4）拿着文档id到正向索引中查找具体文档。 如图： 虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。 1.2.3.正向和倒排那么为什么一个叫做正向索引，一个叫做倒排索引呢？ 正向索引是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是根据文档找词条的过程。 而倒排索引则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是根据词条找文档的过程。 是不是恰好反过来了？ 那么两者方式的优缺点是什么呢？ 正向索引： 优点： 可以给多个字段创建索引 根据索引字段搜索、排序速度非常快 缺点： 根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。 倒排索引： 优点： 根据词条搜索、模糊搜索时，速度非常快 缺点： 只能给词条创建索引，而不是字段 无法根据字段做排序 1.3.es的一些概念elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。 1.3.1.文档和字段elasticsearch是面向文档（Document）存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中： 而Json文档中往往包含很多的字段（Field），类似于数据库中的列。 1.3.2.索引和映射索引（Index），就是相同类型的文档的集合。 例如： 所有用户文档，就可以组织在一起，称为用户的索引； 所有商品的文档，可以组织在一起，称为商品的索引； 所有订单的文档，可以组织在一起，称为订单的索引； 因此，我们可以把索引当做是数据库中的表。 数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有映射（mapping），是索引中文档的字段约束信息，类似表的结构约束。 1.3.3.mysql与elasticsearch我们统一的把mysql与elasticsearch的概念做一下对比： MySQL Elasticsearch 说明 Table Index 索引(index)，就是文档的集合，类似数据库的表(table) Row Document 文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式 Column Field 字段（Field），就是JSON文档中的字段，类似数据库中的列（Column） Schema Mapping Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema） SQL DSL DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD 是不是说，我们学习了elasticsearch就不再需要mysql了呢？ 并不是如此，两者各自有自己的擅长支出： Mysql：擅长事务类型操作，可以确保数据的安全和一致性 Elasticsearch：擅长海量数据的搜索、分析、计算 因此在企业中，往往是两者结合使用： 对安全性要求较高的写操作，使用mysql实现 对查询性能要求较高的搜索需求，使用elasticsearch实现 两者再基于某种方式，实现数据的同步，保证一致性 1.4.安装es、kibana1.4.1.安装参考课前资料： 安装elasticsearch.md 1.4.2.分词器es在创建倒排索引时需要对文档分词；在搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理并不友好。我们在kibana的DevTools中测试： 12345POST /_analyze&#123; \"analyzer\": \"standard\", \"text\": \"黑马程序员学习java太棒了！\"&#125; 语法说明：POST：请求方式 /_analyze：请求路径，这里省略了http://192.168.150.101:9200，有kibana帮我们补充 请求参数，json风格： analyzer：分词器类型，这里是默认的standard分词器 text：要分词的内容 处理中文分词，一般会使用IK分词器。https://github.com/medcl/elasticsearch-analysis-ik安装IK分词器，参考课前资料《安装elasticsearch.md》： ik分词器包含两种模式： ik_smart：最少切分，粗粒度 ik_max_word：最细切分，细粒度 1.4.3.总结分词器的作用是什么？ 创建倒排索引时对文档分词 用户搜索时，对输入的内容分词 IK分词器有几种模式？ ik_smart：智能切分，粗粒度 ik_max_word：最细切分，细粒度 IK分词器如何拓展词条？如何停用词条？ 利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典 在词典中添加拓展词条或者停用词条 2.索引库操作索引库就类似数据库表，mapping映射就类似表的结构。 我们要向es中存储数据，必须先创建“库”和“表”。 2.1.mapping映射属性官方文档 https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html mapping是对索引库中文档的约束，常见的mapping属性包括： type：字段数据类型，常见的简单类型有： 字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址） 数值：long、integer、short、byte、double、float、 布尔：boolean 日期：date 对象：object index：是否创建索引，默认为true analyzer：使用哪种分词器 properties：该字段的子字段 例如下面的json文档： 123456789101112&#123; \"age\": 21, \"weight\": 52.1, \"isMarried\": false, \"info\": \"黑马程序员Java讲师\", \"email\": \"zy@itcast.cn\", \"score\": [99.1, 99.5, 98.9], \"name\": &#123; \"firstName\": \"云\", \"lastName\": \"赵\" &#125;&#125; 对应的每个字段映射（mapping）： age：类型为 integer；参与搜索，因此需要index为true；无需分词器 weight：类型为float；参与搜索，因此需要index为true；无需分词器 isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器 info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器 score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器 name：类型为object，需要定义多个子属性 name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器 name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器 2.2.索引库的CRUD这里我们统一使用Kibana编写DSL的方式来演示。 2.2.1.创建索引库和映射基本语法： 请求方式：PUT 请求路径：/索引库名，可以自定义 请求参数：mapping映射 格式： 1234567891011121314151617181920212223PUT /索引库名称&#123; \"mappings\": &#123; \"properties\": &#123; \"字段名\":&#123; \"type\": \"text\", \"analyzer\": \"ik_smart\" &#125;, \"字段名2\":&#123; \"type\": \"keyword\", \"index\": \"false\" &#125;, \"字段名3\":&#123; \"properties\": &#123; \"子字段\": &#123; \"type\": \"keyword\" &#125; &#125; &#125;, // ...略 &#125; &#125;&#125; 示例：1234567891011121314151617181920212223242526PUT /heima&#123; \"mappings\": &#123; \"properties\": &#123; \"info\":&#123; \"type\": \"text\", \"analyzer\": \"ik_smart\" &#125;, \"email\":&#123; \"type\": \"keyword\", \"index\": \"false\" &#125;, \"name\":&#123; \"type\": \"object\", \"properties\": &#123; \"firstName\": &#123; \"type\": \"keyword\" &#125;, \"lastName\": &#123; \"type\": \"keyword\" &#125; &#125; &#125; &#125; &#125;&#125; 在Dev Tools运行可得到 12345&#123; \"acknowledged\" : true, \"shards_acknowledged\" : true, \"index\" : \"heima\"&#125; 2.2.2.查询索引库基本语法： 请求方式：GET 请求路径：/索引库名 请求参数：无 格式： 1GET /索引库名 示例： 2.2.3.修改索引库倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库一旦创建，无法修改mapping。 虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。 语法说明： 12345678PUT /索引库名/_mapping&#123; \"properties\": &#123; \"新字段名\":&#123; \"type\": \"integer\" &#125; &#125;&#125; 示例： 123456789# 修改索引库，添加新字段PUT /heima/_mapping&#123; \"properties\":&#123; \"age\":&#123; \"type\": \"integer\" &#125; &#125;&#125; 2.2.4.删除索引库语法： 请求方式：DELETE 请求路径：/索引库名 请求参数：无 格式： 1DELETE /索引库名 在kibana中测试： 2.2.5.总结索引库操作有哪些？ 创建索引库：PUT /索引库名 查询索引库：GET /索引库名 删除索引库：DELETE /索引库名 添加字段：PUT /索引库名/_mapping 3.文档操作3.1.新增文档语法： 12345678910POST /索引库名/_doc/文档id&#123; \"字段1\": \"值1\", \"字段2\": \"值2\", \"字段3\": &#123; \"子属性1\": \"值3\", \"子属性2\": \"值4\" &#125;, // ...&#125; 示例： 12345678910# 插入文档POST /heima/_doc/1&#123; \"info\": \"黑马程序员Java讲师\", \"email\": \"zy@itcast.cn\", \"name\": &#123; \"firstName\": \"云\", \"lastName\": \"赵\" &#125;&#125; 响应： 3.2.查询文档根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。 语法： 1GET /&#123;索引库名称&#125;/_doc/&#123;id&#125; 通过kibana查看数据： 12# 查询文档GET /heima/_doc/1 查看结果： 3.3.删除文档删除使用DELETE请求，同样，需要根据id进行删除： 语法： 1DELETE /&#123;索引库名&#125;/_doc/id值 示例： 12# 根据id删除数据DELETE /heima/_doc/1 结果： 3.4.修改文档修改有两种方式： 全量修改：直接覆盖原来的文档 增量修改：修改文档中的部分字段 3.4.1.全量修改全量修改是覆盖原来的文档，其本质是： 根据指定的id删除文档 新增一个相同id的文档 注意：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。 语法： 123456PUT /&#123;索引库名&#125;/_doc/文档id&#123; \"字段1\": \"值1\", \"字段2\": \"值2\", // ... 略&#125; 示例： 12345678910# 全量修改文档PUT /heima/_doc/1&#123; \"info\": \"黑马程序员高级Java讲师\", \"email\": \"zy@itcast.cn\", \"name\": &#123; \"firstName\": \"云\", \"lastName\": \"赵\" &#125;&#125; 3.4.2.增量修改增量修改是只修改指定id匹配的文档中的部分字段。 语法： 123456POST /&#123;索引库名&#125;/_update/文档id&#123; \"doc\": &#123; \"字段名\": \"新的值\", &#125;&#125; 示例： 1234567# 局部修改文档POST /heima/_update/1&#123; \"doc\": &#123; \"email\": \"ZhaoYun@itcast.cn\" &#125;&#125; 3.5.总结文档操作有哪些？ 创建文档：POST /{索引库名}/_doc/文档id { json文档 } 查询文档：GET /{索引库名}/_doc/文档id 删除文档：DELETE /{索引库名}/_doc/文档id 修改文档： 全量修改：PUT /{索引库名}/_doc/文档id { json文档 } 增量修改：POST /{索引库名}/_update/文档id { “doc”: {字段}} 4.RestClient操作索引库什么是RestClient ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：https://www.elastic.co/guide/en/elasticsearch/client/index.html 其中的Java Rest Client又包括两种： Java Low Level Rest Client Java High Level Rest Client 我们学习的是Java HighLevel Rest Client客户端API 4.0.导入Demo工程4.0.1.导入数据首先导入课前资料提供的数据库数据： tb_hotel.sql 数据结构如下： 123456789101112131415CREATE TABLE `tb_hotel` ( `id` bigint(20) NOT NULL COMMENT '酒店id', `name` varchar(255) NOT NULL COMMENT '酒店名称；例：7天酒店', `address` varchar(255) NOT NULL COMMENT '酒店地址；例：航头路', `price` int(10) NOT NULL COMMENT '酒店价格；例：329', `score` int(2) NOT NULL COMMENT '酒店评分；例：45，就是4.5分', `brand` varchar(32) NOT NULL COMMENT '酒店品牌；例：如家', `city` varchar(32) NOT NULL COMMENT '所在城市；例：上海', `star_name` varchar(16) DEFAULT NULL COMMENT '酒店星级，从低到高分别是：1星到5星，1钻到5钻', `business` varchar(255) DEFAULT NULL COMMENT '商圈；例：虹桥', `latitude` varchar(32) NOT NULL COMMENT '纬度；例：31.2497', `longitude` varchar(32) NOT NULL COMMENT '经度；例：120.3925', `pic` varchar(255) DEFAULT NULL COMMENT '酒店图片；例:/img/1.jpg', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 4.0.2.导入项目然后导入课前资料提供的项目: hotel-demo文件夹 项目结构如图： 4.0.3.mapping映射分析创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括： 字段名 字段数据类型 是否参与搜索 是否需要分词 如果分词，分词器是什么？ 其中： 字段名、字段数据类型，可以参考数据表结构的名称和类型 是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索 是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词 分词器，我们可以统一使用ik_max_word 来看下酒店数据的索引库结构: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 酒店的mappingPUT /hotel&#123; \"mappings\": &#123; \"properties\": &#123; \"id\": &#123; \"type\": \"keyword\" &#125;, \"name\":&#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"copy_to\": \"all\" &#125;, \"address\":&#123; \"type\": \"keyword\", \"index\": false &#125;, \"price\":&#123; \"type\": \"integer\" &#125;, \"score\":&#123; \"type\": \"integer\" &#125;, \"brand\":&#123; \"type\": \"keyword\", \"copy_to\": \"all\" &#125;, \"city\":&#123; \"type\": \"keyword\", \"copy_to\": \"all\" &#125;, \"starName\":&#123; \"type\": \"keyword\" &#125;, \"business\":&#123; \"type\": \"keyword\" &#125;, \"location\":&#123; \"type\": \"geo_point\" &#125;, \"pic\":&#123; \"type\": \"keyword\", \"index\": false &#125;, \"all\":&#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\" &#125; &#125; &#125;&#125; 几个特殊字段说明： location：地理坐标，里面包含精度、纬度 all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索 地理坐标说明： copy_to说明： 4.0.4.初始化JavaRestClient在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。 分为三步： 1）引入es的RestHighLevelClient依赖： 12345&lt;!--elasticsearch--&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本： 1234&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;elasticsearch.version&gt;7.12.1&lt;/elasticsearch.version&gt;&lt;/properties&gt; 3）初始化RestHighLevelClient： 初始化的代码如下： 123RestHighLevelClient client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\"http://192.168.150.101:9200\"))); 这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中： 1234567891011121314151617181920212223242526272829package cn.itcast.hotel;import org.apache.http.HttpHost;import org.elasticsearch.client.RestHighLevelClient;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.io.IOException;public class HotelIndexTest &#123; private RestHighLevelClient client; @Test void testInit()&#123; System.out.println(client); &#125; @BeforeEach void setUp() &#123; this.client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\"http://192.168.150.101:9200\") )); &#125; @AfterEach void tearDown() throws IOException &#123; this.client.close(); &#125;&#125; 4.1.创建索引库4.1.1.代码解读创建索引库的API如下： 代码分为三步： 1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。 2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。 3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。 4.1.2.完整示例在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.itcast.hotel.constants;public class HotelConstants &#123; public static final String MAPPING_TEMPLATE = \"&#123;\\n\" + \" \\\"mappings\\\": &#123;\\n\" + \" \\\"properties\\\": &#123;\\n\" + \" \\\"id\\\": &#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\"\\n\" + \" &#125;,\\n\" + \" \\\"name\\\":&#123;\\n\" + \" \\\"type\\\": \\\"text\\\",\\n\" + \" \\\"analyzer\\\": \\\"ik_max_word\\\",\\n\" + \" \\\"copy_to\\\": \\\"all\\\"\\n\" + \" &#125;,\\n\" + \" \\\"address\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\",\\n\" + \" \\\"index\\\": false\\n\" + \" &#125;,\\n\" + \" \\\"price\\\":&#123;\\n\" + \" \\\"type\\\": \\\"integer\\\"\\n\" + \" &#125;,\\n\" + \" \\\"score\\\":&#123;\\n\" + \" \\\"type\\\": \\\"integer\\\"\\n\" + \" &#125;,\\n\" + \" \\\"brand\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\",\\n\" + \" \\\"copy_to\\\": \\\"all\\\"\\n\" + \" &#125;,\\n\" + \" \\\"city\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\",\\n\" + \" \\\"copy_to\\\": \\\"all\\\"\\n\" + \" &#125;,\\n\" + \" \\\"starName\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\"\\n\" + \" &#125;,\\n\" + \" \\\"business\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\"\\n\" + \" &#125;,\\n\" + \" \\\"location\\\":&#123;\\n\" + \" \\\"type\\\": \\\"geo_point\\\"\\n\" + \" &#125;,\\n\" + \" \\\"pic\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\",\\n\" + \" \\\"index\\\": false\\n\" + \" &#125;,\\n\" + \" \\\"all\\\":&#123;\\n\" + \" \\\"type\\\": \\\"text\\\",\\n\" + \" \\\"analyzer\\\": \\\"ik_max_word\\\"\\n\" + \" &#125;\\n\" + \" &#125;\\n\" + \" &#125;\\n\" + \"&#125;\";&#125; 在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引： 123456789@Testvoid createHotelIndex() throws IOException &#123; // 1.创建Request对象 CreateIndexRequest request = new CreateIndexRequest(\"hotel\"); // 2.准备请求的参数：DSL语句 request.source(MAPPING_TEMPLATE, XContentType.JSON); // 3.发送请求 client.indices().create(request, RequestOptions.DEFAULT);&#125; 可在http://192.168.153.128:5601/app/dev_tools#/console测试 1GET /hotel 4.2.删除索引库删除索引库的DSL语句非常简单： 1DELETE /hotel 与创建索引库相比： 请求方式从PUT变为DELTE 请求路径不变 无请求参数 所以代码的差异，注意体现在Request对象上。依然是三步走： 1）创建Request对象。这次是DeleteIndexRequest对象 2）准备参数。这里是无参 3）发送请求。改用delete方法 在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引： 1234567@Testvoid testDeleteHotelIndex() throws IOException &#123; // 1.创建Request对象 DeleteIndexRequest request = new DeleteIndexRequest(\"hotel\"); // 2.发送请求 client.indices().delete(request, RequestOptions.DEFAULT);&#125; 4.3.判断索引库是否存在判断索引库是否存在，本质就是查询，对应的DSL是： 1GET /hotel 因此与删除的Java代码流程是类似的。依然是三步走： 1）创建Request对象。这次是GetIndexRequest对象 2）准备参数。这里是无参 3）发送请求。改用exists方法 123456789@Testvoid testExistsHotelIndex() throws IOException &#123; // 1.创建Request对象 GetIndexRequest request = new GetIndexRequest(\"hotel\"); // 2.发送请求 boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); // 3.输出 System.err.println(exists ? \"索引库已经存在！\" : \"索引库不存在！\");&#125; 4.4.总结JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。 索引库操作的基本步骤： 初始化RestHighLevelClient 创建XxxIndexRequest。XXX是Create、Get、Delete 准备DSL（ Create时需要，其它是无参） 发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete 5.RestClient操作文档为了与索引库操作分离，我们再次参加一个测试类，做两件事情： 初始化RestHighLevelClient 我们的酒店数据在数据库，需要利用IHotelService去查询，所以注入这个接口 1234567891011121314151617181920212223242526272829303132package cn.itcast.hotel;import cn.itcast.hotel.pojo.Hotel;import cn.itcast.hotel.service.IHotelService;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.util.List;@SpringBootTestpublic class HotelDocumentTest &#123; @Autowired private IHotelService hotelService; private RestHighLevelClient client; @BeforeEach void setUp() &#123; this.client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\"http://192.168.150.101:9200\") )); &#125; @AfterEach void tearDown() throws IOException &#123; this.client.close(); &#125;&#125; 5.1.新增文档我们要将数据库的酒店数据查询出来，写入elasticsearch中。 5.1.1.索引库实体类数据库查询后的结果是一个Hotel类型的对象。结构如下： 1234567891011121314151617@Data@TableName(\"tb_hotel\")public class Hotel &#123; @TableId(type = IdType.INPUT) private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String longitude; private String latitude; private String pic;&#125; 与我们的索引库结构存在差异： longitude和latitude需要合并为location 因此，我们需要定义一个新的类型，与索引库结构吻合： 12345678910111213141516171819202122232425262728293031323334package cn.itcast.hotel.pojo;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \", \" + hotel.getLongitude(); this.pic = hotel.getPic(); &#125;&#125; 5.1.2.语法说明新增文档的DSL语句如下： 12345POST /&#123;索引库名&#125;/_doc/1&#123; \"name\": \"Jack\", \"age\": 21&#125; 对应的java代码如图： 可以看到与创建索引库类似，同样是三步走： 1）创建Request对象 2）准备请求参数，也就是DSL中的JSON文档 3）发送请求 变化的地方在于，这里直接使用client.xxx()的API，不再需要client.indices()了。 5.1.3.完整代码我们导入酒店数据，基本流程一致，但是需要考虑几点变化： 酒店数据来自于数据库，我们需要先查询出来，得到hotel对象 hotel对象需要转为HotelDoc对象 HotelDoc需要序列化为json格式 因此，代码整体步骤如下： 1）根据id查询酒店数据Hotel 2）将Hotel封装为HotelDoc 3）将HotelDoc序列化为JSON 4）创建IndexRequest，指定索引库名和id 5）准备请求参数，也就是JSON文档 6）发送请求 在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 12345678910111213141516@Testvoid testAddDocument() throws IOException &#123; // 1.根据id查询酒店数据 Hotel hotel = hotelService.getById(61083L); // 2.转换为文档类型 HotelDoc hotelDoc = new HotelDoc(hotel); // 3.将HotelDoc转json String json = JSON.toJSONString(hotelDoc); // 1.准备Request对象 IndexRequest request = new IndexRequest(\"hotel\").id(hotelDoc.getId().toString()); // 2.准备Json文档 request.source(json, XContentType.JSON); // 3.发送请求 client.index(request, RequestOptions.DEFAULT);&#125; 5.2.查询文档5.2.1.语法说明查询的DSL语句如下： 1GET /hotel/_doc/&#123;id&#125; 非常简单，因此代码大概分两步： 准备Request对象 发送请求 不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下： 可以看到，结果是一个JSON，其中文档放在一个_source属性中，因此解析就是拿到_source，反序列化为Java对象即可。 与之前类似，也是三步走： 1）准备Request对象。这次是查询，所以是GetRequest 2）发送请求，得到结果。因为是查询，这里调用client.get()方法 3）解析结果，就是对JSON做反序列化 5.2.2.完整代码在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 123456789101112@Testvoid testGetDocumentById() throws IOException &#123; // 1.准备Request GetRequest request = new GetRequest(\"hotel\", \"61082\"); // 2.发送请求，得到响应 GetResponse response = client.get(request, RequestOptions.DEFAULT); // 3.解析响应结果 String json = response.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); System.out.println(hotelDoc);&#125; 5.3.删除文档删除的DSL为是这样的： 1DELETE /hotel/_doc/&#123;id&#125; 与查询相比，仅仅是请求方式从DELETE变成GET，可以想象Java代码应该依然是三步走： 1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id 2）准备参数，无参 3）发送请求。因为是删除，所以是client.delete()方法 在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 1234567@Testvoid testDeleteDocument() throws IOException &#123; // 1.准备Request DeleteRequest request = new DeleteRequest(\"hotel\", \"61083\"); // 2.发送请求 client.delete(request, RequestOptions.DEFAULT);&#125; 5.4.修改文档5.4.1.语法说明修改我们讲过两种方式： 全量修改：本质是先根据id删除，再新增 增量修改：修改文档中的指定字段值 在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID： 如果新增时，ID已经存在，则修改 如果新增时，ID不存在，则新增 这里不再赘述，我们主要关注增量修改。 代码示例如图： 与之前类似，也是三步走： 1）准备Request对象。这次是修改，所以是UpdateRequest 2）准备参数。也就是JSON文档，里面包含要修改的字段 3）更新文档。这里调用client.update()方法 5.4.2.完整代码在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 123456789101112@Testvoid testUpdateDocument() throws IOException &#123; // 1.准备Request UpdateRequest request = new UpdateRequest(\"hotel\", \"61083\"); // 2.准备请求参数 request.doc( \"price\", \"952\", \"starName\", \"四钻\" ); // 3.发送请求 client.update(request, RequestOptions.DEFAULT);&#125; 5.5.批量导入文档案例需求：利用BulkRequest批量将数据库数据导入到索引库中。 步骤如下： 利用mybatis-plus查询酒店数据 将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc） 利用JavaRestClient中的BulkRequest批处理，实现批量新增文档 5.5.1.语法说明批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。 其中提供了一个add方法，用来添加其他请求： 可以看到，能添加的请求包括： IndexRequest，也就是新增 UpdateRequest，也就是修改 DeleteRequest，也就是删除 因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例： 其实还是三步走： 1）创建Request对象。这里是BulkRequest 2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest 3）发起请求。这里是批处理，调用的方法为client.bulk()方法 我们在导入酒店数据时，将上述代码改造成for循环处理即可。 5.5.2.完整代码在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 12345678910111213141516171819@Testvoid testBulkRequest() throws IOException &#123; // 批量查询酒店数据 List&lt;Hotel&gt; hotels = hotelService.list(); // 1.创建Request BulkRequest request = new BulkRequest(); // 2.准备参数，添加多个新增的Request for (Hotel hotel : hotels) &#123; // 2.1.转换为文档类型HotelDoc HotelDoc hotelDoc = new HotelDoc(hotel); // 2.2.创建新增文档的Request对象 request.add(new IndexRequest(\"hotel\") .id(hotelDoc.getId().toString()) .source(JSON.toJSONString(hotelDoc), XContentType.JSON)); &#125; // 3.发送请求 client.bulk(request, RequestOptions.DEFAULT);&#125; http://192.168.153.128:5601/app/dev_tools#/console中GET /hotel/_search可查看 5.6.小结文档操作的基本步骤： 初始化RestHighLevelClient 创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk 准备参数（Index、Update、Bulk时需要） 发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk 解析结果（Get时需要） 分布式搜索引擎02在昨天的学习中，我们已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。 所以今天，我们研究下elasticsearch的数据搜索功能。我们会分别使用DSL和RestClient实现搜索。 1.DSL查询文档elasticsearch的查询依然是基于JSON风格的DSL来实现的。 1.1.DSL查询分类Elasticsearch提供了基于JSON的DSL（Domain Specific Language）来定义查询。常见的查询类型包括： 查询所有：查询出所有数据，一般测试用。例如：match_all 全文检索（full text）查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如： match_query multi_match_query 精确查询：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如： ids range term 地理（geo）查询：根据经纬度查询。例如： geo_distance geo_bounding_box 复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如： bool function_score 查询的语法基本一致： 12345678GET /indexName/_search&#123; \"query\": &#123; \"查询类型\": &#123; \"查询条件\": \"条件值\" &#125; &#125;&#125; 我们以查询所有为例，其中： 查询类型为match_all 没有查询条件 12345678// 查询所有GET /indexName/_search&#123; \"query\": &#123; \"match_all\": &#123; &#125; &#125;&#125; 其它查询无非就是查询类型、查询条件的变化。 1.2.全文检索查询1.2.1.使用场景全文检索查询的基本流程如下： 对用户搜索的内容做分词，得到词条 根据词条去倒排索引库中匹配，得到文档id 根据文档id找到文档，返回给用户 比较常用的场景包括： 商城的输入框搜索 百度输入框搜索 例如京东： 因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。 1.2.2.基本语法常见的全文检索查询包括： match查询：单字段查询 multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件 match查询语法如下： 12345678GET /indexName/_search&#123; \"query\": &#123; \"match\": &#123; \"FIELD\": \"TEXT\" &#125; &#125;&#125; mulit_match语法如下： 123456789GET /indexName/_search&#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"TEXT\", \"fields\": [\"FIELD1\", \" FIELD12\"] &#125; &#125;&#125; 1.2.3.示例match查询示例： 123456789# match查询GET /hotel/_search&#123; \"query\": &#123; \"match\": &#123; \"all\": \"如家外滩\" &#125; &#125;&#125; multi_match查询示例： 12345678910# mutil_match查询GET /hotel/_search&#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"外滩如家\", \"fields\": [\"brand\",\"name\",\"business\"] &#125; &#125;&#125; 可以看到，两种查询结果是一样的，为什么？ 因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。 但是，搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。 1.2.4.总结match和multi_match的区别是什么？ match：根据一个字段查询 multi_match：根据多个字段查询，参与查询字段越多，查询性能越差 1.3.精准查询精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以不会对搜索条件分词。常见的有： term：根据词条精确值查询 range：根据值的范围查询 1.3.1.term查询因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是不分词的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。 语法说明： 1234567891011// term查询GET /indexName/_search&#123; \"query\": &#123; \"term\": &#123; \"FIELD\": &#123; \"value\": \"VALUE\" &#125; &#125; &#125;&#125; 示例： 当我搜索的是精确词条时，能正确查询出结果： 1234567891011# term查询GET /hotel/_search&#123; \"query\": &#123; \"term\": &#123; \"city\": &#123; \"value\": \"上海\" &#125; &#125; &#125;&#125; 但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到： 1.3.2.range查询范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。 gte: greater than or equal 基本语法： 123456789101112// range查询GET /indexName/_search&#123; \"query\": &#123; \"range\": &#123; \"FIELD\": &#123; \"gte\": 10, // 这里的gte代表大于等于，gt则代表大于 \"lte\": 20 // lte代表小于等于，lt则代表小于 &#125; &#125; &#125;&#125; 示例： 123456789101112# range查询GET /hotel/_search&#123; \"query\": &#123; \"range\": &#123; \"price\": &#123; \"gte\": 100, \"lte\": 300 &#125; &#125; &#125;&#125; 1.3.3.总结精确查询常见的有哪些？ term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段 range查询：根据数值范围查询，可以是数值、日期的范围 1.4.地理坐标查询所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html 常见的使用场景包括： 携程：搜索我附近的酒店 滴滴：搜索我附近的出租车 微信：搜索我附近的人 附近的酒店： 附近的车： 1.4.1.矩形范围查询矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档： 查询时，需要指定矩形的左上、右下两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。 语法如下： 123456789101112131415161718// geo_bounding_box查询GET /indexName/_search&#123; \"query\": &#123; \"geo_bounding_box\": &#123; \"FIELD\": &#123; \"top_left\": &#123; // 左上点 \"lat\": 31.1, \"lon\": 121.5 &#125;, \"bottom_right\": &#123; // 右下点 \"lat\": 30.9, \"lon\": 121.7 &#125; &#125; &#125; &#125;&#125; 这种并不符合“附近的人”这样的需求，所以我们就不做了。 用的少 1.4.2.附近查询附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。 换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件： 语法说明： 12345678910// geo_distance 查询GET /indexName/_search&#123; \"query\": &#123; \"geo_distance\": &#123; \"distance\": \"15km\", // 半径 \"FIELD\": \"31.21,121.5\" // 圆心 &#125; &#125;&#125; 示例： 我们先搜索陆家嘴附近15km的酒店： 12345678910# distance查询GET /hotel/_search&#123; \"query\": &#123; \"geo_distance\": &#123; \"distance\": \"15km\", \"location\": \"31.21, 121.5\" &#125; &#125;&#125; 发现共有47家酒店。 然后把半径缩短到3公里： 可以发现，搜索到的酒店数量减少到了5家。 1.5.复合查询复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种： fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名 bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索 1.5.1.相关性算分当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。 例如，我们搜索 “虹桥如家”，结果如下： 1234567891011121314151617181920[ &#123; \"_score\" : 17.850193, \"_source\" : &#123; \"name\" : \"虹桥如家酒店真不错\", &#125; &#125;, &#123; \"_score\" : 12.259849, \"_source\" : &#123; \"name\" : \"外滩如家酒店真不错\", &#125; &#125;, &#123; \"_score\" : 11.91091, \"_source\" : &#123; \"name\" : \"迪士尼如家酒店真不错\", &#125; &#125;] 在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下： 在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下： TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑： 小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种： TF-IDF算法 BM25算法，elasticsearch5.1版本后采用的算法 1.5.2.算分函数查询根据相关度打分是比较合理的需求，但合理的不一定是产品经理需要的。 以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图： 要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。 1）语法说明 function score 查询中包含四部分内容： 原始查询条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，原始算分（query score) 过滤条件：filter部分，符合该条件的文档才会重新算分 算分函数：符合filter条件的文档要根据这个函数做运算，得到的函数算分（function score），有四种函数 weight：函数结果是常量 field_value_factor：以文档中的某个字段值作为函数结果 random_score：以随机数作为函数结果 script_score：自定义算分函数算法 运算模式：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括： multiply：相乘 replace：用function score替换query score 其它，例如：sum、avg、max、min function score的运行流程如下： 1）根据原始条件查询搜索文档，并且计算相关性算分，称为原始算分（query score） 2）根据过滤条件，过滤文档 3）符合过滤条件的文档，基于算分函数运算，得到函数算分（function score） 4）将原始算分（query score）和函数算分（function score）基于运算模式做运算，得到最终结果，作为相关性算分。 因此，其中的关键点是： 过滤条件：决定哪些文档的算分被修改 算分函数：决定函数算分的算法 运算模式：决定最终算分结果 2）示例需求：给“如家”这个品牌的酒店排名靠前一些 翻译一下这个需求，转换为之前说的四个要点： 原始条件：不确定，可以任意变化 过滤条件：brand = “如家” 算分函数：可以简单粗暴，直接给固定的算分结果，weight 运算模式：比如求和 因此最终的DSL语句如下： 12345678910111213141516171819GET /hotel/_search&#123; \"query\": &#123; \"function_score\": &#123; \"query\": &#123; .... &#125;, // 原始查询，可以是任意条件 \"functions\": [ // 算分函数 &#123; \"filter\": &#123; // 满足的条件，品牌必须是如家 \"term\": &#123; \"brand\": \"如家\" &#125; &#125;, \"weight\": 2 // 算分权重为2 &#125; ], \"boost_mode\": \"sum\" // 加权模式，求和 &#125; &#125;&#125; 测试，在未添加算分函数时，如家得分如下： 123456789101112GET /hotel/_search&#123; \"query\": &#123; \"function_score\": &#123; \"query\": &#123; \"match\": &#123; \"all\": \"外滩\" &#125; &#125; &#125; &#125;&#125; 添加了算分函数后，如家得分就提升了： 123456789101112131415161718192021222324# function_score查询GET /hotel/_search&#123; \"query\": &#123; \"function_score\": &#123; \"query\": &#123; \"match\": &#123; \"all\": \"外滩\" &#125; &#125;, \"functions\": [ &#123; \"filter\":&#123; \"term\":&#123; \"brand\":\"如家\" &#125; &#125;, \"weight\": 10 &#125; ], \"boost_mode\": \"sum\" &#125; &#125;&#125; 3）小结function score query定义的三要素是什么？ 过滤条件：哪些文档要加分 算分函数：如何计算function score 加权方式：function score 与 query score如何运算 1.5.3.布尔查询布尔查询是一个或多个查询子句的组合，每一个子句就是一个子查询。子查询的组合方式有： must：必须匹配每个子查询，类似“与” should：选择性匹配子查询，类似“或” must_not：必须不匹配，不参与算分，类似“非” filter：必须匹配，不参与算分 不算分效率高 比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤： 每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。 需要注意的是，搜索时，参与打分的字段越多，查询的性能也越差。因此这种多条件查询时，建议这样做： 搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分 其它过滤条件，采用filter查询。不参与算分 1）语法示例：1234567891011121314151617181920GET /hotel/_search&#123; \"query\": &#123; \"bool\": &#123; \"must\": [ &#123;\"term\": &#123;\"city\": \"上海\" &#125;&#125; ], \"should\": [ &#123;\"term\": &#123;\"brand\": \"皇冠假日\" &#125;&#125;, &#123;\"term\": &#123;\"brand\": \"华美达\" &#125;&#125; ], \"must_not\": [ &#123; \"range\": &#123; \"price\": &#123; \"lte\": 500 &#125; &#125;&#125; ], \"filter\": [ &#123; \"range\": &#123;\"score\": &#123; \"gte\": 45 &#125; &#125;&#125; ] &#125; &#125;&#125; 2）示例需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。 分析： 名称搜索，属于全文检索查询，应该参与算分。放到must中 价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中 周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中 12345678910111213141516171819202122232425262728293031323334GET /hotel/_search&#123; \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"match\": &#123; \"name\": \"如家\" &#125; &#125; ], \"must_not\": [ &#123; \"range\": &#123; \"price\": &#123; \"gt\": 400 &#125; &#125; &#125; ], \"filter\": [ &#123; \"geo_distance\": &#123; \"distance\": \"10km\", \"location\": &#123; \"lat\": 31.21, \"lon\": 121.5 &#125; &#125; &#125; ] &#125; &#125;&#125; 3）小结bool查询有几种逻辑关系？ must：必须匹配的条件，可以理解为“与” should：选择性匹配的条件，可以理解为“或” must_not：必须不匹配的条件，不参与打分 filter：必须匹配的条件，不参与打分 2.搜索结果处理搜索的结果可以按照用户指定的方式去处理或展示。 2.1.排序elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索结果排序。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。 2.1.1.普通字段排序keyword、数值、日期类型排序的语法基本一致。 语法： 1234567891011GET /indexName/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"sort\": [ &#123; \"FIELD\": \"desc\" // 排序字段、排序方式ASC、DESC &#125; ]&#125; 排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推 示例： 需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序 1234567891011121314# sort排序GET /hotel/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"sort\": [ &#123; \"score\": \"desc\" &#125;,&#123; \"price\": \"asc\" &#125; ]&#125; 2.1.2.地理坐标排序地理坐标排序略有不同。 语法说明： 123456789101112131415GET /indexName/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"sort\": [ &#123; \"_geo_distance\" : &#123; \"FIELD\" : \"纬度，经度\", // 文档中geo_point类型的字段名、目标坐标点 \"order\" : \"asc\", // 排序方式 \"unit\" : \"km\" // 排序的距离单位 &#125; &#125; ]&#125; 这个查询的含义是： 指定一个坐标，作为目标点 计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少 根据距离排序 示例： 需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序 提示：获取你的位置的经纬度的方式：https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/ 1234567891011121314151617# 找到121,31周围的酒店，距离升序排序GET /hotel/_search&#123; \"query\": &#123;\"match_all\": &#123;&#125;&#125;, \"sort\": [ &#123; \"_geo_distance\": &#123; \"location\": &#123; \"lat\": 31, \"lon\": 121 &#125;, \"order\": \"asc\", \"unit\": \"km\" &#125; &#125; ]&#125; 假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。 2.2.分页elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果： from：从第几个文档开始 size：总共查询几个文档 类似于mysql中的limit ?, ? 2.2.1.基本的分页分页的基本语法如下： 123456789101112# 分页查询GET /hotel/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"from\": 0, // 分页开始的位置，默认为0 \"size\": 10, // 期望获取的文档总数 \"sort\": [ &#123;\"price\": \"asc\"&#125; ]&#125; 2.2.2.深度分页问题现在，我要查询990~1000的数据，查询逻辑要这么写： 1234567891011GET /hotel/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"from\": 990, // 分页开始的位置，默认为0 \"size\": 10, // 期望获取的文档总数 \"sort\": [ &#123;\"price\": \"asc\"&#125; ]&#125; 这里是查询990开始的数据，也就是 第990~第1000条 数据。 不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条： 查询TOP1000，如果es是单点模式，这并无太大影响。 但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。 因为节点A的TOP200，在另一个节点可能排到10000名以外了。 因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。 那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？ 当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。 针对深度分页，ES提供了两种解决方案，官方文档： search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。 scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。 2.2.3.小结分页查询的常见实现方案以及优缺点： from + size： 优点：支持随机翻页 缺点：深度分页问题，默认查询上限（from + size）是10000 场景：百度、京东、谷歌、淘宝这样的随机翻页搜索 after search： 优点：没有查询上限（单次查询的size不超过10000） 缺点：只能向后逐页查询，不支持随机翻页 场景：没有随机翻页需求的搜索，例如手机向下滚动翻页 scroll： 优点：没有查询上限（单次查询的size不超过10000） 缺点：会有额外内存消耗，并且搜索结果是非实时的 场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。 2.3.高亮2.3.1.高亮原理什么是高亮显示呢？ 我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示： 高亮显示的实现分为两步： 1）给文档中的所有关键字都添加一个标签，例如&lt;em&gt;标签 2）页面给&lt;em&gt;标签编写CSS样式 2.3.2.实现高亮高亮的语法： 12345678910111213141516GET /hotel/_search&#123; \"query\": &#123; \"match\": &#123; \"FIELD\": \"TEXT\" // 查询条件，高亮一定要使用全文检索查询 &#125; &#125;, \"highlight\": &#123; \"fields\": &#123; // 指定要高亮的字段 \"FIELD\": &#123; \"pre_tags\": \"&lt;em&gt;\", // 用来标记高亮字段的前置标签 \"post_tags\": \"&lt;/em&gt;\" // 用来标记高亮字段的后置标签 &#125; &#125; &#125;&#125; 注意： 高亮是对关键字高亮，因此搜索条件必须带有关键字，而不能是范围这样的查询。 默认情况下，高亮的字段，必须与搜索指定的字段一致，否则无法高亮 如果要对非搜索字段高亮，则需要添加一个属性：required_field_match=false 12345678910111213141516GET /hotel/_search&#123; \"query\": &#123; \"match\": &#123; \"FIELD\": \"TEXT\" // 查询条件，高亮一定要使用全文检索查询 &#125; &#125;, \"highlight\": &#123; \"fields\": &#123; // 指定要高亮的字段 \"FIELD\": &#123; \"pre_tags\": \"&lt;em&gt;\", // 用来标记高亮字段的前置标签 \"post_tags\": \"&lt;/em&gt;\" // 用来标记高亮字段的后置标签 &#125; &#125; &#125;&#125; 示例： 123456789101112131415161718# 高亮查询，默认情况下，ES搜索字段必须与高亮字段一致GET /hotel/_search&#123; \"query\": &#123; \"match\": &#123; \"all\": \"如家\" &#125; &#125;, \"highlight\": &#123; \"fields\": &#123; \"name\": &#123; \"require_field_match\": \"false\", \"pre_tags\": \"&lt;em&gt;\", \"post_tags\": \"&lt;/em&gt;\" &#125; &#125; &#125;&#125; 2.4.总结查询的DSL是一个大的JSON对象，包含下列属性： query：查询条件 from和size：分页条件 sort：排序条件 highlight：高亮条件 示例： 3.RestClient查询文档文档的查询同样适用昨天学习的 RestHighLevelClient对象，基本步骤包括： 1）准备Request对象 2）准备请求参数 3）发起请求 4）解析响应 3.1.快速入门我们以match_all查询为例 3.1.1.发起查询请求 代码解读： 第一步，创建SearchRequest对象，指定索引库名 第二步，利用request.source()构建DSL，DSL中可以包含查询、分页、排序、高亮等 query()：代表查询条件，利用QueryBuilders.matchAllQuery()构建一个match_all查询的DSL 第三步，利用client.search()发送请求，得到响应 这里关键的API有两个，一个是request.source()，其中包含了查询、排序、分页、高亮等所有功能： 另一个是QueryBuilders，其中包含match、term、function_score、bool等各种查询： 3.1.2.解析响应响应结果的解析： elasticsearch返回的结果是一个JSON字符串，结构包含： hits：命中的结果 total：总条数，其中的value是具体的总条数值 max_score：所有结果中得分最高的文档的相关性算分 hits：搜索结果的文档数组，其中的每个文档都是一个json对象 _source：文档中的原始数据，也是json对象 因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下： SearchHits：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果 SearchHits#getTotalHits().value：获取总条数信息 SearchHits#getHits()：获取SearchHit数组，也就是文档数组 SearchHit#getSourceAsString()：获取文档结果中的_source，也就是原始的json文档数据 3.1.3.完整代码完整代码如下： 12345678910111213141516171819202122232425262728293031@Testvoid testMatchAll() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL request.source() .query(QueryBuilders.matchAllQuery()); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125;private void handleResponse(SearchResponse response) &#123; // 4.解析响应 SearchHits searchHits = response.getHits(); // 4.1.获取总条数 long total = searchHits.getTotalHits().value; System.out.println(\"共搜索到\" + total + \"条数据\"); // 4.2.文档数组 SearchHit[] hits = searchHits.getHits(); // 4.3.遍历 for (SearchHit hit : hits) &#123; // 获取文档source String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); System.out.println(\"hotelDoc = \" + hotelDoc); &#125;&#125; 3.1.4.小结查询的基本步骤是： 创建SearchRequest对象 准备Request.source()，也就是DSL。 ① QueryBuilders来构建查询条件 ② 传入Request.source() 的 query() 方法 发送请求，得到结果 解析结果（参考JSON结果，从外到内，逐层解析） 3.2.match查询全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。 因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法： 而结果解析代码则完全一致，可以抽取并共享。 完整代码如下： 12345678910111213@Testvoid testMatch() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL request.source() .query(QueryBuilders.matchQuery(\"all\", \"如家\")); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.3.精确查询精确查询主要是两者： term：词条精确匹配 range：范围查询 与之前的查询相比，差异同样在查询条件，其它都一样。 查询条件构造的API如下： 3.4.布尔查询布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下： 可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。 完整代码如下： 12345678910111213141516171819@Testvoid testBool() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.准备BooleanQuery BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 2.2.添加term boolQuery.must(QueryBuilders.termQuery(\"city\", \"杭州\")); // 2.3.添加range boolQuery.filter(QueryBuilders.rangeQuery(\"price\").lte(250)); request.source().query(boolQuery); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.5.排序、分页搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。 对应的API如下： 完整代码示例： 1234567891011121314151617181920@Testvoid testPageAndSort() throws IOException &#123; // 页码，每页大小 int page = 1, size = 5; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.query request.source().query(QueryBuilders.matchAllQuery()); // 2.2.排序 sort request.source().sort(\"price\", SortOrder.ASC); // 2.3.分页 from、size request.source().from((page - 1) * size).size(5); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.6.高亮高亮的代码与之前代码差异较大，有两点： 查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。 结果解析：结果除了要解析_source文档数据，还要解析高亮结果 3.6.1.高亮请求构建高亮请求的构建API如下： 上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。 完整代码如下： 123456789101112131415@Testvoid testHighlight() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.query request.source().query(QueryBuilders.matchQuery(\"all\", \"如家\")); // 2.2.高亮 request.source().highlighter(new HighlightBuilder().field(\"name\").requireFieldMatch(false)); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.6.2.高亮结果解析高亮的结果与查询的文档结果默认是分离的，并不在一起。 因此解析高亮的代码需要额外处理： 代码解读： 第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象 第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值 第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField 第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了 第五步：用高亮的结果替换HotelDoc中的非高亮结果 完整代码如下： 1234567891011121314151617181920212223242526272829private void handleResponse(SearchResponse response) &#123; // 4.解析响应 SearchHits searchHits = response.getHits(); // 4.1.获取总条数 long total = searchHits.getTotalHits().value; System.out.println(\"共搜索到\" + total + \"条数据\"); // 4.2.文档数组 SearchHit[] hits = searchHits.getHits(); // 4.3.遍历 for (SearchHit hit : hits) &#123; // 获取文档source String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); // 获取高亮结果 Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields(); if (!CollectionUtils.isEmpty(highlightFields)) &#123; // 根据字段名获取高亮结果 HighlightField highlightField = highlightFields.get(\"name\"); if (highlightField != null) &#123; // 获取高亮值 String name = highlightField.getFragments()[0].string(); // 覆盖非高亮结果 hotelDoc.setName(name); &#125; &#125; System.out.println(\"hotelDoc = \" + hotelDoc); &#125;&#125; 4.黑马旅游案例下面，我们通过黑马旅游的案例来实战演练下之前学习的知识。 我们实现四部分功能： 酒店搜索和分页 酒店结果过滤 我周边的酒店 酒店竞价排名 启动我们提供的hotel-demo项目，其默认端口是8089，访问http://localhost:8090，就能看到项目页面了： 4.1.酒店搜索和分页案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页 4.1.1.需求分析在项目的首页，有一个大大的搜索框，还有分页按钮： 点击搜索按钮，可以看到浏览器控制台发出了请求： 请求参数如下： 由此可以知道，我们这个请求的信息如下： 请求方式：POST 请求路径：/hotel/list 请求参数：JSON对象，包含4个字段： key：搜索关键字 page：页码 size：每页大小 sortBy：排序，目前暂不实现 返回值：分页查询，需要返回分页结果PageResult，包含两个属性： total：总条数 List&lt;HotelDoc&gt;：当前页的数据 因此，我们实现业务的流程如下： 步骤一：定义实体类，接收请求参数的JSON对象 步骤二：编写controller，接收页面的请求 步骤三：编写业务实现，利用RestHighLevelClient实现搜索、分页 4.1.2.定义实体类实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。 1）请求参数 前端请求的json结构如下： 123456&#123; \"key\": \"搜索关键字\", \"page\": 1, \"size\": 3, \"sortBy\": \"default\"&#125; 因此，我们在cn.itcast.hotel.pojo包下定义一个实体类： 1234567891011package cn.itcast.hotel.pojo;import lombok.Data;@Datapublic class RequestParams &#123; private String key; private Integer page; private Integer size; private String sortBy;&#125; 2）返回值 分页查询，需要返回分页结果PageResult，包含两个属性： total：总条数 List&lt;HotelDoc&gt;：当前页的数据 因此，我们在cn.itcast.hotel.pojo中定义返回结果： 12345678910111213141516171819package cn.itcast.hotel.pojo;import lombok.Data;import java.util.List;@Datapublic class PageResult &#123; private Long total; private List&lt;HotelDoc&gt; hotels; public PageResult() &#123; &#125; public PageResult(Long total, List&lt;HotelDoc&gt; hotels) &#123; this.total = total; this.hotels = hotels; &#125;&#125; 4.1.3.定义controller定义一个HotelController，声明查询接口，满足下列要求： 请求方式：Post 请求路径：/hotel/list 请求参数：对象，类型为RequestParam 返回值：PageResult，包含两个属性 Long total：总条数 List&lt;HotelDoc&gt; hotels：酒店数据 因此，我们在cn.itcast.hotel.web中定义HotelController： 123456789101112@RestController@RequestMapping(\"/hotel\")public class HotelController &#123; @Autowired private IHotelService hotelService; // 搜索酒店数据 @PostMapping(\"/list\") public PageResult search(@RequestBody RequestParams params)&#123; return hotelService.search(params); &#125;&#125; 4.1.4.实现搜索业务我们在controller调用了IHotelService，并没有实现该方法，因此下面我们就在IHotelService中定义方法，并且去实现业务逻辑。 1）在cn.itcast.hotel.service中的IHotelService接口中定义一个方法： 123456/** * 根据关键字搜索酒店信息 * @param params 请求参数对象，包含用户输入的关键字 * @return 酒店文档列表 */PageResult search(RequestParams params); 2）实现搜索业务，肯定离不开RestHighLevelClient，我们需要把它注册到Spring中作为一个Bean。在cn.itcast.hotel中的HotelDemoApplication中声明这个Bean： 123456@Beanpublic RestHighLevelClient client()&#123; return new RestHighLevelClient(RestClient.builder( HttpHost.create(\"http://192.168.150.101:9200\") ));&#125; 3）在cn.itcast.hotel.service.impl中的HotelService中实现search方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Servicepublic class HotelService extends ServiceImpl&lt;HotelMapper, Hotel&gt; implements IHotelService &#123; @Autowired private RestHighLevelClient client; @Override public PageResult search(RequestParams params) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.query String key = params.getKey(); if (key == null || \"\".equals(key)) &#123; request.source().query(QueryBuilders.matchAllQuery()); &#125; else &#123; request.source().query(QueryBuilders.matchQuery(\"all\", key)); &#125; // 2.2.分页 int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 return handleResponse(response); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; // 结果解析 private PageResult handleResponse(SearchResponse response) &#123; // 4.解析响应 SearchHits searchHits = response.getHits(); // 4.1.获取总条数 long total = searchHits.getTotalHits().value; // 4.2.文档数组 SearchHit[] hits = searchHits.getHits(); // 4.3.遍历 List&lt;HotelDoc&gt; hotels = new ArrayList&lt;&gt;(); for (SearchHit hit : hits) &#123; // 获取文档source String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); // 放入集合 hotels.add(hotelDoc); &#125; // 4.4.封装返回 return new PageResult(total, hotels); &#125;&#125; 4.2.酒店结果过滤需求：添加品牌、城市、星级、价格等过滤功能 4.2.1.需求分析在页面搜索框下面，会有一些过滤项： 传递的参数如图： 包含的过滤条件有： brand：品牌值 city：城市 minPrice~maxPrice：价格范围 starName：星级 我们需要做两件事情： 修改请求参数的对象RequestParams，接收上述参数 修改业务逻辑，在搜索条件之外，添加一些过滤条件 4.2.2.修改实体类修改在cn.itcast.hotel.pojo包下的实体类RequestParams： 12345678910111213@Datapublic class RequestParams &#123; private String key; private Integer page; private Integer size; private String sortBy; // 下面是新增的过滤条件参数 private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice;&#125; 4.2.3.修改搜索业务在HotelService的search方法中，只有一个地方需要修改：requet.source().query( … )其中的查询条件。 在之前的业务中，只有match查询，根据关键字搜索，现在要添加条件过滤，包括： 品牌过滤：是keyword类型，用term查询 星级过滤：是keyword类型，用term查询 价格过滤：是数值类型，用range查询 城市过滤：是keyword类型，用term查询 多个查询条件组合，肯定是boolean查询来组合： 关键字搜索放到must中，参与算分 其它过滤条件放到filter中，不参与算分 因为条件构建的逻辑比较复杂，这里先封装为一个函数： buildBasicQuery的代码如下： 123456789101112131415161718192021222324252627282930313233private void buildBasicQuery(RequestParams params, SearchRequest request) &#123; // 1.构建BooleanQuery BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 2.关键字搜索 String key = params.getKey(); if (key == null || \"\".equals(key)) &#123; boolQuery.must(QueryBuilders.matchAllQuery()); &#125; else &#123; boolQuery.must(QueryBuilders.matchQuery(\"all\", key)); &#125; // 3.城市条件 if (params.getCity() != null &amp;&amp; !params.getCity().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"city\", params.getCity())); &#125; // 4.品牌条件 if (params.getBrand() != null &amp;&amp; !params.getBrand().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"brand\", params.getBrand())); &#125; // 5.星级条件 if (params.getStarName() != null &amp;&amp; !params.getStarName().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"starName\", params.getStarName())); &#125; // 6.价格 if (params.getMinPrice() != null &amp;&amp; params.getMaxPrice() != null) &#123; boolQuery.filter(QueryBuilders .rangeQuery(\"price\") .gte(params.getMinPrice()) .lte(params.getMaxPrice()) ); &#125; // 7.放入source request.source().query(boolQuery);&#125; 4.3.我周边的酒店需求：我附近的酒店 4.3.1.需求分析在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置： 并且，在前端会发起查询请求，将你的坐标发送到服务端： 我们要做的事情就是基于这个location坐标，然后按照距离对周围酒店排序。实现思路如下： 修改RequestParams参数，接收location字段 修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能 4.3.2.修改实体类修改在cn.itcast.hotel.pojo包下的实体类RequestParams： 123456789101112131415161718package cn.itcast.hotel.pojo;import lombok.Data;@Datapublic class RequestParams &#123; private String key; private Integer page; private Integer size; private String sortBy; private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice; // 我当前的地理坐标 private String location;&#125; 4.3.3.距离排序API我们以前学习过排序功能，包括两种： 普通字段排序 地理坐标排序 我们只讲了普通字段排序对应的java写法。地理坐标排序只学过DSL语法，如下： 123456789101112131415161718GET /indexName/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"sort\": [ &#123; \"price\": \"asc\" &#125;, &#123; \"_geo_distance\" : &#123; \"FIELD\" : \"纬度，经度\", \"order\" : \"asc\", \"unit\" : \"km\" &#125; &#125; ]&#125; 对应的java代码示例： 4.3.4.添加距离排序在cn.itcast.hotel.service.impl的HotelService的search方法中，添加一个排序功能： 完整代码： 1234567891011121314151617181920212223242526272829303132@Overridepublic PageResult search(RequestParams params) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.query buildBasicQuery(params, request); // 2.2.分页 int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // 2.3.排序 String location = params.getLocation(); if (location != null &amp;&amp; !location.equals(\"\")) &#123; request.source().sort(SortBuilders .geoDistanceSort(\"location\", new GeoPoint(location)) .order(SortOrder.ASC) .unit(DistanceUnit.KILOMETERS) ); &#125; // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 return handleResponse(response); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125; 4.3.5.排序距离显示重启服务后，测试我的酒店功能： 发现确实可以实现对我附近酒店的排序，不过并没有看到酒店到底距离我多远，这该怎么办？ 排序完成后，页面还要获取我附近每个酒店的具体距离值，这个值在响应结果中是独立的： 因此，我们在结果解析阶段，除了解析source部分以外，还要得到sort部分，也就是排序的距离，然后放到响应结果中。 我们要做两件事： 修改HotelDoc，添加排序距离字段，用于页面显示 修改HotelService类中的handleResponse方法，添加对sort值的获取 1）修改HotelDoc类，添加距离字段 12345678910111213141516171819202122232425262728293031323334353637package cn.itcast.hotel.pojo;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; // 排序时的 距离值 private Object distance; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \", \" + hotel.getLongitude(); this.pic = hotel.getPic(); &#125;&#125; 2）修改HotelService中的handleResponse方法 12345678910111213141516171819202122232425262728// 结果解析 private PageResult handleResponse(SearchResponse response) &#123; // 4.解析响应 SearchHits searchHits = response.getHits(); // 4.1.获取总条数 long total = searchHits.getTotalHits().value; // 4.2.文档数组 SearchHit[] hits = searchHits.getHits(); // 4.3.遍历 List&lt;HotelDoc&gt; hotels = new ArrayList&lt;&gt;(); for (SearchHit hit : hits) &#123; // 获取文档source String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); // 获取排序值 Object[] sortValues = hit.getSortValues(); if(sortValues.length &gt; 0)&#123; Object sortValue = sortValues[0]; hotelDoc.setDistance(sortValue); &#125; // 放入集合 hotels.add(hotelDoc); &#125; // 4.4.封装返回 return new PageResult(total, hotels); &#125; 重启后测试，发现页面能成功显示距离了： 4.4.酒店竞价排名需求：让指定的酒店在搜索结果中排名置顶 4.4.1.需求分析要让指定酒店在搜索结果中排名置顶，效果如图： 页面会给指定的酒店添加广告标记。 那怎样才能让指定的酒店排名置顶呢？ 我们之前学习过的function_score查询可以影响算分，算分高了，自然排名也就高了。而function_score包含3个要素： 过滤条件：哪些文档要加分 算分函数：如何计算function score 加权方式：function score 与 query score如何运算 这里的需求是：让指定酒店排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以根据这个标记来判断，是否要提高算分。 比如，我们给酒店添加一个字段：isAD，Boolean类型： true：是广告 false：不是广告 这样function_score包含3个要素就很好确定了： 过滤条件：判断isAD 是否为true 算分函数：我们可以用最简单暴力的weight，固定加权值 加权方式：可以用默认的相乘，大大提高算分 因此，业务的实现步骤包括： 给HotelDoc类添加isAD字段，Boolean类型 挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true 修改search方法，添加function score功能，给isAD值为true的酒店增加权重 4.4.2.修改HotelDoc实体给cn.itcast.hotel.pojo包下的HotelDoc类添加isAD字段： 123456789101112131415161718@Data@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; // 排序时的 距离值 private Object distance; // 广告标记 private Boolean isAD; 4.4.3.添加广告标记接下来，我们挑几个酒店，添加isAD字段，设置为true： 123456789101112131415161718192021222324POST /hotel/_update/1902197537&#123; \"doc\": &#123; \"isAD\": true &#125;&#125;POST /hotel/_update/2056126831&#123; \"doc\": &#123; \"isAD\": true &#125;&#125;POST /hotel/_update/1989806195&#123; \"doc\": &#123; \"isAD\": true &#125;&#125;POST /hotel/_update/2056105938&#123; \"doc\": &#123; \"isAD\": true &#125;&#125; 4.4.4.添加算分函数查询接下来我们就要修改查询条件了。之前是用的boolean 查询，现在要改成function_socre查询。 function_score查询结构如下： 对应的JavaAPI如下： 我们可以将之前写的boolean查询作为原始查询条件放到query中，接下来就是添加过滤条件、算分函数、加权模式了。所以原来的代码依然可以沿用。 修改cn.itcast.hotel.service.impl包下的HotelService类中的buildBasicQuery方法，添加算分函数查询： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void buildBasicQuery(RequestParams params, SearchRequest request) &#123; // 1.构建BooleanQuery BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 关键字搜索 String key = params.getKey(); if (key == null || \"\".equals(key)) &#123; boolQuery.must(QueryBuilders.matchAllQuery()); &#125; else &#123; boolQuery.must(QueryBuilders.matchQuery(\"all\", key)); &#125; // 城市条件 if (params.getCity() != null &amp;&amp; !params.getCity().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"city\", params.getCity())); &#125; // 品牌条件 if (params.getBrand() != null &amp;&amp; !params.getBrand().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"brand\", params.getBrand())); &#125; // 星级条件 if (params.getStarName() != null &amp;&amp; !params.getStarName().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"starName\", params.getStarName())); &#125; // 价格 if (params.getMinPrice() != null &amp;&amp; params.getMaxPrice() != null) &#123; boolQuery.filter(QueryBuilders .rangeQuery(\"price\") .gte(params.getMinPrice()) .lte(params.getMaxPrice()) ); &#125; // 2.算分控制 FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery( // 原始查询，相关性算分的查询 boolQuery, // function score的数组 new FunctionScoreQueryBuilder.FilterFunctionBuilder[]&#123; // 其中的一个function score 元素 new FunctionScoreQueryBuilder.FilterFunctionBuilder( // 过滤条件 QueryBuilders.termQuery(\"isAD\", true), // 算分函数 ScoreFunctionBuilders.weightFactorFunction(10) ) &#125;); request.source().query(functionScoreQuery);&#125; 分布式搜索引擎030.学习目标1.数据聚合聚合（aggregations）可以让我们极其方便的实现对数据的统计、分析、运算。例如： 什么品牌的手机最受欢迎？ 这些手机的平均价格、最高价格、最低价格？ 这些手机每月的销售情况如何？ 实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。 1.1.聚合的种类聚合常见的有三类： 桶（Bucket）聚合：用来对文档做分组 TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组 Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组 度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等 Avg：求平均值 Max：求最大值 Min：求最小值 Stats：同时求max、min、avg、sum等 管道（pipeline）聚合：其它聚合的结果为基础做聚合 注意：参加聚合的字段必须是keyword、日期、数值、布尔类型 1.2.DSL实现聚合现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。 1.2.1.Bucket聚合语法语法如下： 123456789101112GET /hotel/_search&#123; \"size\": 0, // 设置size为0，结果中不包含文档，只包含聚合结果 \"aggs\": &#123; // 定义聚合 \"brandAgg\": &#123; //给聚合起个名字 \"terms\": &#123; // 聚合的类型，按照品牌值聚合，所以选择term \"field\": \"brand\", // 参与聚合的字段 \"size\": 20 // 希望获取的聚合结果数量 &#125; &#125; &#125;&#125; 结果如图： 12345678910111213# 聚合功能GET /hotel/_search&#123; \"size\": 0, \"aggs\": &#123; \"brandAgg\": &#123; \"terms\": &#123; \"field\": \"brand\", \"size\": 20 &#125; &#125; &#125;&#125; 1.2.2.聚合结果排序默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。 我们可以指定order属性，自定义聚合的排序方式： 12345678910111213141516# 聚合功能,自定义排序规则GET /hotel/_search&#123; \"size\": 0, \"aggs\": &#123; \"brandAgg\": &#123; \"terms\": &#123; \"field\": \"brand\", \"order\": &#123; \"_count\": \"asc\" // 按照_count升序排列 &#125;, \"size\": 20 &#125; &#125; &#125;&#125; 1.2.3.限定聚合范围默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。 我们可以限定要聚合的文档范围，只要添加query条件即可： 1234567891011121314151617181920# 聚合功能,限定聚合范围GET /hotel/_search&#123; \"query\": &#123; \"range\": &#123; \"price\": &#123; \"lte\": 200 // 只对200元以下的文档聚合 &#125; &#125; &#125;, \"size\": 0, \"aggs\": &#123; \"brandAgg\": &#123; \"terms\": &#123; \"field\": \"brand\", \"size\": 20 &#125; &#125; &#125;&#125; 这次，聚合得到的品牌明显变少了： 1.2.4.Metric聚合语法上节课，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。 这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。 语法如下： 12345678910111213141516171819GET /hotel/_search&#123; \"size\": 0, \"aggs\": &#123; \"brandAgg\": &#123; \"terms\": &#123; \"field\": \"brand\", \"size\": 20 &#125;, \"aggs\": &#123; // 是brands聚合的子聚合，也就是分组后对每组分别计算 \"score_stats\": &#123; // 聚合名称 \"stats\": &#123; // 聚合类型，这里stats可以计算min、max、avg等 \"field\": \"score\" // 聚合字段，这里是score &#125; &#125; &#125; &#125; &#125;&#125; 这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。 另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序： 1234567891011121314151617181920212223# 嵌套聚合metricGET /hotel/_search&#123; \"size\": 0, \"aggs\": &#123; \"brandAgg\": &#123; \"terms\": &#123; \"field\": \"brand\", \"size\": 20, \"order\": &#123; \"scoreAgg.avg\": \"desc\" &#125; &#125;, \"aggs\": &#123; \"scoreAgg\": &#123; \"stats\": &#123; \"field\": \"score\" &#125; &#125; &#125; &#125; &#125;&#125; 1.2.5.小结aggs代表聚合，与query同级，此时query的作用是？ 限定聚合的的文档范围 聚合必须的三要素： 聚合名称 聚合类型 聚合字段 聚合可配置属性有： size：指定聚合结果数量 order：指定聚合结果排序方式 field：指定聚合字段 1.3.RestAPI实现聚合1.3.1.API语法聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。 聚合条件的语法： 聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析： 1234567891011121314151617181920212223242526@Test void testAggregation() throws IOException &#123; // 1.准备请求 SearchRequest request = new SearchRequest(\"hotel\"); // 2.请求参数 // 2.1.size request.source().size(0); // 2.2.聚合 request.source().aggregation( AggregationBuilders.terms(\"brandAgg\").field(\"brand\").size(20)); // 3.发出请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析结果 Aggregations aggregations = response.getAggregations(); // 4.1.根据聚合名称，获取聚合结果 Terms brandAgg = aggregations.get(\"brandAgg\"); // 4.2.获取buckets List&lt;? extends Terms.Bucket&gt; buckets = brandAgg.getBuckets(); // 4.3.遍历 for (Terms.Bucket bucket : buckets) &#123; String brandName = bucket.getKeyAsString(); System.out.println(\"brandName = \" + brandName); long docCount = bucket.getDocCount(); System.out.println(\"docCount = \" + docCount); &#125; &#125; 1.3.2.业务需求需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的： 分析： 目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。 例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。 也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。 如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？ 使用聚合功能，利用Bucket聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。 因为是对搜索结果聚合，因此聚合是限定范围的聚合，也就是说聚合的限定条件跟搜索文档的条件一致。 查看浏览器可以发现，前端其实已经发出了这样的一个请求： 请求参数与搜索文档的参数完全一致。 返回值类型就是页面要展示的最终结果： 结果是一个Map结构： key是字符串，城市、星级、品牌、价格 value是集合，例如多个城市的名称 1.3.3.业务实现在cn.itcast.hotel.web包的HotelController中添加一个方法，遵循下面的要求： 请求方式：POST 请求路径：/hotel/filters 请求参数：RequestParams，与搜索文档的参数一致 返回值类型：Map&lt;String, List&lt;String&gt;&gt; 代码： 1234@PostMapping(\"filters\")public Map&lt;String, List&lt;String&gt;&gt; getFilters(@RequestBody RequestParams params)&#123; return hotelService.getFilters(params);&#125; 这里调用了IHotelService中的getFilters方法，尚未实现。 在cn.itcast.hotel.service.IHotelService中定义新方法： 1Map&lt;String, List&lt;String&gt;&gt; filters(RequestParams params); 在cn.itcast.hotel.service.impl.HotelService中实现该方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Overridepublic Map&lt;String, List&lt;String&gt;&gt; filters(RequestParams params) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.query buildBasicQuery(params, request); // 2.2.设置size request.source().size(0); // 2.3.聚合 buildAggregation(request); // 3.发出请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析结果 Map&lt;String, List&lt;String&gt;&gt; result = new HashMap&lt;&gt;(); Aggregations aggregations = response.getAggregations(); // 4.1.根据品牌名称，获取品牌结果 List&lt;String&gt; brandList = getAggByName(aggregations, \"brandAgg\"); result.put(\"品牌\", brandList); // 4.2.根据品牌名称，获取品牌结果 List&lt;String&gt; cityList = getAggByName(aggregations, \"cityAgg\"); result.put(\"城市\", cityList); // 4.3.根据品牌名称，获取品牌结果 List&lt;String&gt; starList = getAggByName(aggregations, \"starAgg\"); result.put(\"星级\", starList); return result; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125;private void buildAggregation(SearchRequest request) &#123; request.source().aggregation(AggregationBuilders .terms(\"brandAgg\") .field(\"brand\") .size(100) ); request.source().aggregation(AggregationBuilders .terms(\"cityAgg\") .field(\"city\") .size(100) ); request.source().aggregation(AggregationBuilders .terms(\"starAgg\") .field(\"starName\") .size(100) );&#125;private List&lt;String&gt; getAggByName(Aggregations aggregations, String aggName) &#123; // 4.1.根据聚合名称获取聚合结果 Terms brandTerms = aggregations.get(aggName); // 4.2.获取buckets List&lt;? extends Terms.Bucket&gt; buckets = brandTerms.getBuckets(); // 4.3.遍历 List&lt;String&gt; brandList = new ArrayList&lt;&gt;(); for (Terms.Bucket bucket : buckets) &#123; // 4.4.获取key String key = bucket.getKeyAsString(); brandList.add(key); &#125; return brandList;&#125; 2.自动补全当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图： 这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。 因为需要根据拼音字母来推断，因此要用到拼音分词功能。 2.1.拼音分词器要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：https://github.com/medcl/elasticsearch-analysis-pinyin 课前资料中也提供了拼音分词器的安装包： 安装方式与IK分词器一样，分三步： ​ ①解压 ​ ②上传到虚拟机中，elasticsearch的plugin目录 ​ /var/lib/docker/volumes/es-plugins/_data ​ ③重启elasticsearch ​ ④测试 详细安装步骤可以参考IK分词器的安装过程。 测试用法如下： 12345POST /_analyze&#123; \"text\": \"如家酒店还不错\", \"analyzer\": \"pinyin\"&#125; 结果： 2.2.自定义分词器默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。 elasticsearch中分词器（analyzer）的组成包含三部分： character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符 tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等 文档分词时会依次由这三部分来处理文档： 声明自定义分词器的语法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667PUT /test&#123; \"settings\": &#123; \"analysis\": &#123; \"analyzer\": &#123; // 自定义分词器 \"my_analyzer\": &#123; // 分词器名称 \"tokenizer\": \"ik_max_word\", \"filter\": \"py\" &#125; &#125;, \"filter\": &#123; // 自定义tokenizer filter \"py\": &#123; // 过滤器名称 \"type\": \"pinyin\", // 过滤器类型，这里是pinyin \"keep_full_pinyin\": false, \"keep_joined_full_pinyin\": true, \"keep_original\": true, \"limit_first_letter_length\": 16, \"remove_duplicated_term\": true, \"none_chinese_pinyin_tokenize\": false &#125; &#125; &#125; &#125;, \"mappings\": &#123; \"properties\": &#123; \"name\": &#123; \"type\": \"text\", \"analyzer\": \"my_analyzer\", //创建时使用 \"search_analyzer\": \"ik_smart\" //search使用 &#125; &#125; &#125;&#125;PUT /test&#123; \"settings\": &#123; \"analysis\": &#123; \"analyzer\": &#123; \"my_analyzer\": &#123; \"tokenizer\": \"ik_max_word\", \"filter\": \"py\" &#125; &#125;, \"filter\": &#123; \"py\": &#123; \"type\": \"pinyin\", \"keep_full_pinyin\": false, \"keep_joined_full_pinyin\": true, \"keep_original\": true, \"limit_first_letter_length\": 16, \"remove_duplicated_term\": true, \"none_chinese_pinyin_tokenize\": false &#125; &#125; &#125; &#125;, \"mappings\": &#123; \"properties\": &#123; \"name\": &#123; \"type\": \"text\", \"analyzer\": \"my_analyzer\", \"search_analyzer\": \"ik_smart\" &#125; &#125; &#125;&#125; 测试： 总结： 如何使用拼音分词器？ ①下载pinyin分词器 ②解压并放到elasticsearch的plugin目录 ③重启即可 如何自定义分词器？ ①创建索引库时，在settings中配置，可以包含三部分 ②character filter ③tokenizer ④filter 拼音分词器注意事项？ 为了避免搜索到同音字，搜索时不要使用拼音分词器 2.3.自动补全查询elasticsearch提供了Completion Suggester查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束： 参与补全查询的字段必须是completion类型。 字段的内容一般是用来补全的多个词条形成的数组。 比如，一个这样的索引库： 1234567891011# 创建索引库PUT test2&#123; \"mappings\": &#123; \"properties\": &#123; \"title\":&#123; \"type\": \"completion\" &#125; &#125; &#125;&#125; 然后插入下面的数据： 12345678910111213# 示例数据POST test2/_doc&#123; \"title\": [\"Sony\", \"WH-1000XM3\"]&#125;POST test2/_doc&#123; \"title\": [\"SK-II\", \"PITERA\"]&#125;POST test2/_doc&#123; \"title\": [\"Nintendo\", \"switch\"]&#125; 查询的DSL语句如下： 123456789101112131415161718192021222324252627282930// 自动补全查询GET /test/_search&#123; \"suggest\": &#123; \"title_suggest\": &#123; \"text\": \"s\", // 关键字 \"completion\": &#123; \"field\": \"title\", // 补全查询的字段 \"skip_duplicates\": true, // 跳过重复的 \"size\": 10 // 获取前10条结果 &#125; &#125; &#125;&#125;# 自动补全查询GET /test2/_search&#123; \"suggest\": &#123; \"title_suggest\": &#123; \"text\": \"s\", \"completion\": &#123; \"field\": \"title\", \"skip_duplicates\": true, \"size\": 10 &#125; &#125; &#125;&#125; 2.4.实现酒店搜索框自动补全现在，我们的hotel索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。 另外，我们需要添加一个字段，用来做自动补全，将brand、suggestion、city等都放进去，作为自动补全的提示。 因此，总结一下，我们需要做的事情包括： 修改hotel索引库结构，设置自定义拼音分词器 修改索引库的name、all字段，使用自定义分词器 索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器 给HotelDoc类添加suggestion字段，内容包含brand、business 重新导入数据到hotel库 2.4.1.修改酒店映射结构12# 查看酒店数据结构GET /hotel/_mapping 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 酒店数据索引库PUT /hotel&#123; \"settings\": &#123; \"analysis\": &#123; \"analyzer\": &#123; \"text_anlyzer\": &#123; \"tokenizer\": \"ik_max_word\", \"filter\": \"py\" &#125;, \"completion_analyzer\": &#123; \"tokenizer\": \"keyword\", \"filter\": \"py\" &#125; &#125;, \"filter\": &#123; \"py\": &#123; \"type\": \"pinyin\", \"keep_full_pinyin\": false, \"keep_joined_full_pinyin\": true, \"keep_original\": true, \"limit_first_letter_length\": 16, \"remove_duplicated_term\": true, \"none_chinese_pinyin_tokenize\": false &#125; &#125; &#125; &#125;, \"mappings\": &#123; \"properties\": &#123; \"id\":&#123; \"type\": \"keyword\" &#125;, \"name\":&#123; \"type\": \"text\", \"analyzer\": \"text_anlyzer\", \"search_analyzer\": \"ik_smart\", \"copy_to\": \"all\" &#125;, \"address\":&#123; \"type\": \"keyword\", \"index\": false &#125;, \"price\":&#123; \"type\": \"integer\" &#125;, \"score\":&#123; \"type\": \"integer\" &#125;, \"brand\":&#123; \"type\": \"keyword\", \"copy_to\": \"all\" &#125;, \"city\":&#123; \"type\": \"keyword\" &#125;, \"starName\":&#123; \"type\": \"keyword\" &#125;, \"business\":&#123; \"type\": \"keyword\", \"copy_to\": \"all\" &#125;, \"location\":&#123; \"type\": \"geo_point\" &#125;, \"pic\":&#123; \"type\": \"keyword\", \"index\": false &#125;, \"all\":&#123; \"type\": \"text\", \"analyzer\": \"text_anlyzer\", \"search_analyzer\": \"ik_smart\" &#125;, \"suggestion\":&#123; \"type\": \"completion\", \"analyzer\": \"completion_analyzer\" &#125; &#125; &#125;&#125; 2.4.2.修改HotelDoc实体HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。 因此我们在HotelDoc中添加一个suggestion字段，类型为List&lt;String&gt;，然后将brand、city、business等信息放到里面。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.itcast.hotel.pojo;import lombok.Data;import lombok.NoArgsConstructor;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;@Data@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; private Object distance; private Boolean isAD; private List&lt;String&gt; suggestion; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \", \" + hotel.getLongitude(); this.pic = hotel.getPic(); // 组装suggestion if(this.business.contains(\"/\"))&#123; // business有多个值，需要切割 String[] arr = this.business.split(\"/\"); // 添加元素 this.suggestion = new ArrayList&lt;&gt;(); this.suggestion.add(this.brand); Collections.addAll(this.suggestion, arr); &#125;else &#123; this.suggestion = Arrays.asList(this.brand, this.business); &#125; &#125;&#125; 2.4.3.重新导入cn.itcast.hotel.HotelDocumentTest#testBulkRequest方法 重新执行之前编写的导入数据功能，可以看到新的酒店数据中包含了suggestion： 123456GET /hotel/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125; 测试自动补全 12345678910111213GET /hotel/_search&#123; \"suggest\": &#123; \"suggestions\": &#123; \"text\": \"h\", \"completion\": &#123; \"field\": \"suggestion\", \"skip_duplicates\": true, \"size\": 10 &#125; &#125; &#125;&#125; 2.4.4.自动补全查询的JavaAPI之前我们学习了自动补全查询的DSL，而没有学习对应的JavaAPI，这里给出一个示例： 而自动补全的结果也比较特殊，解析的代码如下： 1234567891011121314151617181920212223242526272829@Testvoid testSuggest() throws IOException &#123; // 1.准备request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL request.source().suggest( new SuggestBuilder().addSuggestion( \"suggestions\", SuggestBuilders.completionSuggestion(\"suggestion\") .prefix(\"h\") .skipDuplicates(true) .size(10) ) ); // 3.发送请求，得到响应 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.结果解析 Suggest suggest = response.getSuggest(); // 4.1根据补全查询名称，获取补全结果 CompletionSuggestion suggestions = suggest.getSuggestion(\"suggestions\"); // 4.2.获取options List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions(); // 4.3.遍历 for (CompletionSuggestion.Entry.Option option : options) &#123; String text = option.getText().toString(); System.out.println(text); &#125;&#125; 2.4.5.实现搜索框自动补全查看前端页面，可以发现当我们在输入框键入时，前端会发起ajax请求： 返回值是补全词条的集合，类型为List&lt;String&gt; 1）在cn.itcast.hotel.web包下的HotelController中添加新接口，接收新的请求： 1234@GetMapping(\"suggestion\")public List&lt;String&gt; getSuggestions(@RequestParam(\"key\") String prefix) &#123; return hotelService.getSuggestions(prefix);&#125; 2）在cn.itcast.hotel.service包下的IhotelService中添加方法： 1List&lt;String&gt; getSuggestions(String prefix); 3）在cn.itcast.hotel.service.impl.HotelService中实现该方法： 1234567891011121314151617181920212223242526272829303132@Overridepublic List&lt;String&gt; getSuggestions(String prefix) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL request.source().suggest(new SuggestBuilder().addSuggestion( \"suggestions\", SuggestBuilders.completionSuggestion(\"suggestion\") .prefix(prefix) .skipDuplicates(true) .size(10) )); // 3.发起请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析结果 Suggest suggest = response.getSuggest(); // 4.1.根据补全查询名称，获取补全结果 CompletionSuggestion suggestions = suggest.getSuggestion(\"suggestions\"); // 4.2.获取options List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions(); // 4.3.遍历 List&lt;String&gt; list = new ArrayList&lt;&gt;(options.size()); for (CompletionSuggestion.Entry.Option option : options) &#123; String text = option.getText().toString(); list.add(text); &#125; return list; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125; 3.数据同步elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的数据同步。 3.1.思路分析常见的数据同步方案有三种： 同步调用 异步通知 监听binlog 3.1.1.同步调用方案一：同步调用 基本步骤如下： hotel-demo对外提供接口，用来修改elasticsearch中的数据 酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口， 3.1.2.异步通知方案二：异步通知 流程如下： hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息 hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改 3.1.3.监听binlog方案三：监听binlog 流程如下： 给mysql开启binlog功能 mysql完成增、删、改操作都会记录在binlog中 hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容 3.1.4.选择方式一：同步调用 优点：实现简单，粗暴 缺点：业务耦合度高 方式二：异步通知 优点：低耦合，实现难度一般 缺点：依赖mq的可靠性 方式三：监听binlog 优点：完全解除服务间耦合 缺点：开启binlog增加数据库负担、实现复杂度高 3.2.基于mq实现数据同步3.2.1.思路利用课前资料提供的hotel-admin项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。 步骤： 导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD 声明exchange、queue、RoutingKey 在hotel-admin中的增、删、改业务中完成消息发送 在hotel-demo中完成消息监听，并更新elasticsearch中数据 启动并测试数据同步功能 3.2.2.导入demo导入课前资料提供的hotel-admin项目： 运行后，访问 http://localhost:8099 其中包含了酒店的CRUD功能： 3.2.3.声明交换机、队列MQ结构如图： 1）引入依赖在hotel-admin、hotel-demo中引入rabbitmq的依赖： 12345&lt;!--amqp--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 配置mq 1234567spring: rabbitmq: host: 192.168.153.128 port: 5672 username: itcast password: 123321 virtual-host: / mq应用端口是5672 管理页面端口是15672 2）声明队列交换机名称在hotel-admin和hotel-demo中的cn.itcast.hotel.constatnts包下新建一个类MqConstants： 123456789101112131415161718192021222324package cn.itcast.hotel.constatnts; public class MqConstants &#123; /** * 交换机 */ public final static String HOTEL_EXCHANGE = \"hotel.topic\"; /** * 监听新增和修改的队列 */ public final static String HOTEL_INSERT_QUEUE = \"hotel.insert.queue\"; /** * 监听删除的队列 */ public final static String HOTEL_DELETE_QUEUE = \"hotel.delete.queue\"; /** * 新增或修改的RoutingKey */ public final static String HOTEL_INSERT_KEY = \"hotel.insert\"; /** * 删除的RoutingKey */ public final static String HOTEL_DELETE_KEY = \"hotel.delete\";&#125; 3）声明队列交换机在hotel-demo中，定义配置类，声明队列、交换机： 12345678910111213141516171819202122232425262728293031323334353637package cn.itcast.hotel.config;import cn.itcast.hotel.constants.MqConstants;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.Queue;import org.springframework.amqp.core.TopicExchange;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MqConfig &#123; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(MqConstants.HOTEL_EXCHANGE, true, false); &#125; @Bean public Queue insertQueue()&#123; return new Queue(MqConstants.HOTEL_INSERT_QUEUE, true); &#125; @Bean public Queue deleteQueue()&#123; return new Queue(MqConstants.HOTEL_DELETE_QUEUE, true); &#125; @Bean public Binding insertQueueBinding()&#123; return BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY); &#125; @Bean public Binding deleteQueueBinding()&#123; return BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY); &#125;&#125; 3.2.4.发送MQ消息在hotel-admin中的增、删、改业务中分别发送MQ消息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@RestController@RequestMapping(\"hotel\")public class HotelController &#123; @Autowired private IHotelService hotelService; @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\"/&#123;id&#125;\") public Hotel queryById(@PathVariable(\"id\") Long id)&#123; return hotelService.getById(id); &#125; @GetMapping(\"/list\") public PageResult hotelList( @RequestParam(value = \"page\", defaultValue = \"1\") Integer page, @RequestParam(value = \"size\", defaultValue = \"1\") Integer size )&#123; Page&lt;Hotel&gt; result = hotelService.page(new Page&lt;&gt;(page, size)); return new PageResult(result.getTotal(), result.getRecords()); &#125; @PostMapping public void saveHotel(@RequestBody Hotel hotel)&#123; // 新增酒店 hotelService.save(hotel); // 发送MQ消息 rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_INSERT_KEY, hotel.getId()); &#125; @PutMapping() public void updateById(@RequestBody Hotel hotel)&#123; if (hotel.getId() == null) &#123; throw new InvalidParameterException(\"id不能为空\"); &#125; hotelService.updateById(hotel); // 发送MQ消息 rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_INSERT_KEY, hotel.getId()); &#125; @DeleteMapping(\"/&#123;id&#125;\") public void deleteById(@PathVariable(\"id\") Long id) &#123; hotelService.removeById(id); // 发送MQ消息 rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_DELETE_KEY, id); &#125;&#125; 3.2.5.接收MQ消息hotel-demo接收到MQ消息要做的事情包括： 新增消息：根据传递的hotel的id查询hotel信息，然后新增一条数据到索引库 删除消息：根据传递的hotel的id删除索引库中的一条数据 1）首先在hotel-demo的cn.itcast.hotel.service包下的IHotelService中新增新增、删除业务 123void deleteById(Long id);void insertById(Long id); 2）给hotel-demo中的cn.itcast.hotel.service.impl包下的HotelService中实现业务： 123456789101112131415161718192021222324252627282930@Overridepublic void deleteById(Long id) &#123; try &#123; // 1.准备Request DeleteRequest request = new DeleteRequest(\"hotel\", id.toString()); // 2.发送请求 client.delete(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125;@Overridepublic void insertById(Long id) &#123; try &#123; // 0.根据id查询酒店数据 Hotel hotel = getById(id); // 转换为文档类型 HotelDoc hotelDoc = new HotelDoc(hotel); // 1.准备Request对象 IndexRequest request = new IndexRequest(\"hotel\").id(hotel.getId().toString()); // 2.准备Json文档 request.source(JSON.toJSONString(hotelDoc), XContentType.JSON); // 3.发送请求 client.index(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125; 3）编写监听器 在hotel-demo中的cn.itcast.hotel.mq包新增一个类： 1234567891011121314151617181920212223242526272829303132package cn.itcast.hotel.mq;import cn.itcast.hotel.constants.MqConstants;import cn.itcast.hotel.service.IHotelService;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class HotelListener &#123; @Autowired private IHotelService hotelService; /** * 监听酒店新增或修改的业务 * @param id 酒店id */ @RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE) public void listenHotelInsertOrUpdate(Long id)&#123; hotelService.insertById(id); &#125; /** * 监听酒店删除的业务 * @param id 酒店id */ @RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE) public void listenHotelDelete(Long id)&#123; hotelService.deleteById(id); &#125;&#125; 最后测试即可 4.es集群单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。 海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点 单点故障问题：将分片数据在不同节点备份（replica ） ES集群相关概念: 集群（cluster）：一组拥有共同的 cluster name 的 节点。 节点（node) ：集群中的一个 Elasticearch 实例 分片（shard）：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中 解决问题：数据量太大，单点存储量有限的问题。 此处，我们把数据分成3片：shard0、shard1、shard2 主分片（Primary shard）：相对于副本分片的定义。 副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。 ​ 数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！ 为了在高可用和成本间寻求平衡，我们可以这样做： 首先对数据分片，存储到不同节点 然后对每个分片进行备份，放到对方节点，完成互相备份 这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例： 现在，每个分片都有1个备份，存储在3个节点： node0：保存了分片0和1 node1：保存了分片0和2 node2：保存了分片1和2 4.1.搭建ES集群参考课前资料的文档： 其中的第四章节： 4.2.集群脑裂问题4.2.1.集群职责划分elasticsearch中集群节点有不同的职责划分： 默认情况下，集群中的任何一个节点都同时具备上述四种角色。 但是真实的集群一定要将集群职责分离： master节点：对CPU要求高，但是内存要求第 data节点：对CPU和内存要求都高 coordinating节点：对网络带宽、CPU要求高 职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。 一个典型的es集群职责划分如图： 4.2.2.脑裂问题脑裂是因为集群中的节点失联导致的。 例如一个集群中，主节点与其它节点失联： 此时，node2和node3认为node1宕机，就会重新选主： 当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。 当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况： 解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题 例如：3个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。 4.2.3.小结master eligible节点的作用是什么？ 参与集群选主 主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求 data节点的作用是什么？ 数据的CRUD coordinator节点的作用是什么？ 路由请求到其它节点 合并查询到的结果，返回给用户 4.3.集群分布式存储当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？ 4.3.1.分片存储测试使用insomnia 插入三条数据： 测试可以看到，三条数据分别在不同分片： 加上explain字段 结果： 4.3.2.分片存储原理elasticsearch会通过hash算法来计算文档应该存储到哪个分片： 说明： _routing默认是文档的id 算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！ 新增文档的流程如下： 解读： 1）新增一个id=1的文档 2）对id做hash运算，假如得到的是2，则应该存储到shard-2 3）shard-2的主分片在node3节点，将数据路由到node3 4）保存文档 5）同步给shard-2的副本replica-2，在node2节点 6）返回结果给coordinating-node节点 4.4.集群分布式查询elasticsearch的查询分成两个阶段： scatter phase：分散阶段，coordinating node会把请求分发到每一个分片 gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户 4.5.集群故障转移集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。 1）例如一个集群结构如图： 现在，node1是主节点，其它两个节点是从节点。 2）突然，node1发生了故障： 宕机后的第一件事，需要重新选主，例如选中了node2： node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3： 模拟故障 1[root@localhost ~]# docker-compose stop es01 重新启动 1[root@localhost ~]# docker-compose restart es01 会恢复","categories":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://codeofli.github.io/categories/Elasticsearch/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://codeofli.github.io/tags/Elasticsearch/"}]},{"title":"Nacos安装指南","slug":"java-note/SpringCloud/Nacos安装指南","date":"2021-10-23T02:40:06.000Z","updated":"2021-10-31T05:02:37.527Z","comments":true,"path":"2021/10/java-note/SpringCloud/Nacos安装指南/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/Nacos安装指南/","excerpt":"Nacos安装指南1.Windows安装开发阶段采用单机安装即可。1.1.下载安装包在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：GitHub主页：https://github.com/alibaba/nacosGitHub的Release下载页：https://github.com/alibaba/nacos/releases","text":"Nacos安装指南1.Windows安装开发阶段采用单机安装即可。1.1.下载安装包在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：GitHub主页：https://github.com/alibaba/nacosGitHub的Release下载页：https://github.com/alibaba/nacos/releases 如图： 本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包： windows版本使用nacos-server-1.4.1.zip包即可。 1.2.解压将这个包解压到任意非中文目录下，如图： 目录说明： bin：启动脚本 conf：配置文件 1.3.端口配置Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。 如果无法关闭占用8848端口的进程，也可以进入nacos的conf目录，修改配置文件中的端口： 修改其中的内容： 1.4.启动启动非常简单，进入bin目录，结构如下： 然后执行命令即可： windows命令： 1startup.cmd -m standalone 执行后的效果如图： 1.5.访问在浏览器输入地址：http://127.0.0.1:8848/nacos即可： 默认的账号和密码都是nacos，进入后： 2.Linux安装Linux或者Mac安装方式与Windows类似。 2.1.安装JDKNacos依赖于JDK运行，索引Linux上也需要安装JDK才行。 上传jdk安装包： 上传到某个目录，例如：/usr/local/ 然后解压缩： 1tar -xvf jdk-8u144-linux-x64.tar.gz 然后重命名为java 配置环境变量： 12export JAVA_HOME=/usr/local/javaexport PATH=$PATH:$JAVA_HOME/bin 设置环境变量： 1source /etc/profile 2.2.上传安装包如图： 也可以直接使用课前资料中的tar.gz： 上传到Linux服务器的某个目录，例如/usr/local/src目录下： 2.3.解压命令解压缩安装包： 1tar -xvf nacos-server-1.4.1.tar.gz 然后删除安装包： 1rm -rf nacos-server-1.4.1.tar.gz 目录中最终样式： 目录内部： 2.4.端口配置与windows中类似 2.5.启动在nacos/bin目录中，输入命令启动Nacos： 1sh startup.sh -m standalone 3.Nacos的依赖父工程： 1234567&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 客户端： 12345&lt;!-- nacos客户端依赖包 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/tags/Java/"},{"name":"Nacos","slug":"Nacos","permalink":"https://codeofli.github.io/tags/Nacos/"}]},{"title":"Nacos集群搭建","slug":"java-note/SpringCloud/nacos集群搭建","date":"2021-10-23T02:40:06.000Z","updated":"2021-10-31T05:03:50.140Z","comments":true,"path":"2021/10/java-note/SpringCloud/nacos集群搭建/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/nacos集群搭建/","excerpt":"Nacos集群搭建1.集群结构图官方给出的Nacos集群图：SLB，Server Load Balancer，服务器负载均衡其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。我们计划的集群结构：三个nacos节点的地址： 节点 ip port nacos1 192.168.150.1 8845 nacos2 192.168.150.1 8846 nacos3 192.168.150.1 8847","text":"Nacos集群搭建1.集群结构图官方给出的Nacos集群图：SLB，Server Load Balancer，服务器负载均衡其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。我们计划的集群结构：三个nacos节点的地址： 节点 ip port nacos1 192.168.150.1 8845 nacos2 192.168.150.1 8846 nacos3 192.168.150.1 8847 2.搭建集群搭建集群的基本步骤： 搭建数据库，初始化数据库表结构 下载nacos安装包 配置nacos 启动nacos集群 nginx反向代理 2.1.初始化数据库Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。 官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库可以参考传智教育的后续高手课程。 这里我们以单点的数据库为例来讲解。 首先新建一个数据库，命名为nacos，而后导入下面的SQL： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198CREATE TABLE `config_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(255) DEFAULT NULL, `content` longtext NOT NULL COMMENT 'content', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip', `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', `c_desc` varchar(256) DEFAULT NULL, `c_use` varchar(64) DEFAULT NULL, `effect` varchar(64) DEFAULT NULL, `type` varchar(64) DEFAULT NULL, `c_schema` text, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_aggr *//******************************************/CREATE TABLE `config_info_aggr` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(255) NOT NULL COMMENT 'group_id', `datum_id` varchar(255) NOT NULL COMMENT 'datum_id', `content` longtext NOT NULL COMMENT '内容', `gmt_modified` datetime NOT NULL COMMENT '修改时间', `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='增加租户字段';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_beta *//******************************************/CREATE TABLE `config_info_beta` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL COMMENT 'content', `beta_ips` varchar(1024) DEFAULT NULL COMMENT 'betaIps', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip', `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_beta';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_tag *//******************************************/CREATE TABLE `config_info_tag` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id', `tag_id` varchar(128) NOT NULL COMMENT 'tag_id', `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL COMMENT 'content', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_tag';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_tags_relation *//******************************************/CREATE TABLE `config_tags_relation` ( `id` bigint(20) NOT NULL COMMENT 'id', `tag_name` varchar(128) NOT NULL COMMENT 'tag_name', `tag_type` varchar(64) DEFAULT NULL COMMENT 'tag_type', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id', `nid` bigint(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`nid`), UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_tag_relation';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = group_capacity *//******************************************/CREATE TABLE `group_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID', `group_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Group ID，空字符表示整个集群', `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值', `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量', `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值', `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数，，0表示使用默认值', `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值', `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_group_id` (`group_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='集群、各Group容量信息表';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = his_config_info *//******************************************/CREATE TABLE `his_config_info` ( `id` bigint(64) unsigned NOT NULL, `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `data_id` varchar(255) NOT NULL, `group_id` varchar(128) NOT NULL, `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL, `md5` varchar(32) DEFAULT NULL, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `src_user` text, `src_ip` varchar(50) DEFAULT NULL, `op_type` char(10) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`nid`), KEY `idx_gmt_create` (`gmt_create`), KEY `idx_gmt_modified` (`gmt_modified`), KEY `idx_did` (`data_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='多租户改造';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = tenant_capacity *//******************************************/CREATE TABLE `tenant_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID', `tenant_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Tenant ID', `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值', `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量', `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值', `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数', `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值', `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='租户容量信息表';CREATE TABLE `tenant_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `kp` varchar(128) NOT NULL COMMENT 'kp', `tenant_id` varchar(128) default '' COMMENT 'tenant_id', `tenant_name` varchar(128) default '' COMMENT 'tenant_name', `tenant_desc` varchar(256) DEFAULT NULL COMMENT 'tenant_desc', `create_source` varchar(32) DEFAULT NULL COMMENT 'create_source', `gmt_create` bigint(20) NOT NULL COMMENT '创建时间', `gmt_modified` bigint(20) NOT NULL COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='tenant_info';CREATE TABLE `users` ( `username` varchar(50) NOT NULL PRIMARY KEY, `password` varchar(500) NOT NULL, `enabled` boolean NOT NULL);CREATE TABLE `roles` ( `username` varchar(50) NOT NULL, `role` varchar(50) NOT NULL, UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE);CREATE TABLE `permissions` ( `role` varchar(50) NOT NULL, `resource` varchar(255) NOT NULL, `action` varchar(8) NOT NULL, UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE);INSERT INTO users (username, password, enabled) VALUES ('nacos', '$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu', TRUE);INSERT INTO roles (username, role) VALUES ('nacos', 'ROLE_ADMIN'); 2.2.下载nacosnacos在GitHub上有下载地址：https://github.com/alibaba/nacos/tags，可以选择任意版本下载。 本例中才用1.4.1版本： 2.3.配置Nacos将这个包解压到任意非中文目录下，如图： 目录说明： bin：启动脚本 conf：配置文件 进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf： 然后添加内容： 123127.0.0.1:8845127.0.0.1.8846127.0.0.1.8847 然后修改application.properties文件，添加数据库配置 1234567spring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTCdb.user.0=rootdb.password.0=123 2.4.启动将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3 然后分别修改三个文件夹中的application.properties， nacos1: 1server.port=8845 nacos2: 1server.port=8846 nacos3: 1server.port=8847 然后分别启动三个nacos节点： 1startup.cmd 2.5.nginx反向代理找到课前资料提供的nginx安装包： 解压到任意非中文目录下： 修改conf/nginx.conf文件，配置如下： 1234567891011121314upstream nacos-cluster &#123; server 127.0.0.1:8845; server 127.0.0.1:8846; server 127.0.0.1:8847;&#125;server &#123; listen 80; server_name localhost; location /nacos &#123; proxy_pass http://nacos-cluster; &#125;&#125; 而后在浏览器访问：http://localhost/nacos即可。 代码中application.yml文件配置如下： 1234spring: cloud: nacos: server-addr: localhost:80 # Nacos地址 2.6.优化 实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置. Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"Nacos","slug":"Nacos","permalink":"https://codeofli.github.io/tags/Nacos/"},{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"}]},{"title":"微服务保护Sentinel","slug":"java-note/SpringCloud/Sentinel/Sentinel","date":"2021-10-23T02:40:06.000Z","updated":"2021-10-31T03:03:59.378Z","comments":true,"path":"2021/10/java-note/SpringCloud/Sentinel/Sentinel/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/Sentinel/Sentinel/","excerpt":"微服务保护1.初识Sentinel1.1.雪崩问题及解决方案1.1.1.雪崩问题微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。 如图，如果服务提供者I发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I的业务似乎不受影响。 但是，依赖服务I的业务请求被阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：","text":"微服务保护1.初识Sentinel1.1.雪崩问题及解决方案1.1.1.雪崩问题微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。 如图，如果服务提供者I发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I的业务似乎不受影响。 但是，依赖服务I的业务请求被阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞： 服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，那么当前服务也就不可用了。 那么，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，雪崩就发生了： 微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。 2解决雪崩问题1.1.2.超时处理解决雪崩问题的常见方式有四种： •超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待 1.1.3.仓壁模式方案2：仓壁模式 限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离。 仓壁模式来源于船舱的设计： 船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。 于此类似，我们可以限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离。 1.1.4.断路器断路器模式：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。 比较好的一种方案 断路器会统计访问某个服务的请求数量，异常比例： 当发现访问服务D的请求异常比例过高时，认为服务D有导致雪崩的风险，会拦截访问服务D的一切请求，形成熔断： 1.1.5.限流流量控制：限制业务访问的QPS，避免服务因流量的突增而故障。 这是一种预防雪崩的方式。 QPS每秒查询率(Query Per Second) 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 1.1.6.总结什么是雪崩问题？ 微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。 如何避免因瞬间高并发流量而导致服务故障？ 流量控制 如何避免因服务故障引起的雪崩问题？ 超时处理线程隔离降级熔断 可以认为： 限流是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种预防措施。 超时处理、线程隔离、降级熔断是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种补救措施。 1.2.服务保护技术对比在SpringCloud当中支持多种服务保护技术： Netfix Hystrix Sentinel Resilience4J 早期比较流行的是Hystrix框架，但目前国内实用最广泛的还是阿里巴巴的Sentinel框架，这里我们做下对比： Sentinel Hystrix 隔离策略 信号量隔离 线程池隔离/信号量隔离 熔断降级策略 基于慢调用比例或异常比例 基于失败比率 实时指标实现 滑动窗口 滑动窗口（基于 RxJava） 规则配置 支持多种数据源 支持多种数据源 扩展性 多个扩展点 插件的形式 基于注解的支持 支持 支持 限流 基于 QPS，支持基于调用关系的限流 有限的支持 流量整形 支持慢启动、匀速排队模式 不支持 系统自适应保护 支持 不支持 控制台 开箱即用，可配置规则、查看秒级监控、机器发现等 不完善 常见框架的适配 Servlet、Spring Cloud、Dubbo、gRPC 等 Servlet、Spring Cloud Netflix 1.3.Sentinel介绍和安装1.3.1.初识SentinelSentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：https://sentinelguard.io/zh-cn/index.html Sentinel 具有以下特征: •丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。 •完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。 •广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。 •完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。 1.3.2.安装Sentinel1）下载 sentinel官方提供了UI控制台，方便我们对系统做限流设置。大家可以在GitHub下载。 课前资料也提供了下载好的jar包： sentinel-dashboard-1.8.1.jar 2）运行 将jar包放到任意非中文目录，执行命令： 1java -jar sentinel-dashboard-1.8.1.jar 如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置： 配置项 默认值 说明 server.port 8080 服务端口 sentinel.dashboard.auth.username sentinel 默认用户名 sentinel.dashboard.auth.password sentinel 默认密码 例如，修改端口： 1java -Dserver.port=8090 -jar sentinel-dashboard-1.8.1.jar 官方文档 3）访问 访问http://localhost:8080页面，就可以看到sentinel的控制台了： 需要输入账号和密码，默认都是：sentinel 登录后，发现一片空白，什么都没有： 这是因为我们还没有与微服务整合。 1.4.微服务整合Sentinel我们在order-service中整合sentinel，并连接sentinel的控制台，步骤如下： 1）引入sentinel依赖 12345&lt;!--sentinel--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置控制台 修改application.yaml文件，添加下面内容： 1234567server: port: 8088spring: cloud: sentinel: transport: dashboard: localhost:8080 # sentinel控制台地址 3）访问order-service的任意端点 打开浏览器，访问http://localhost:8088/order/101，这样才能触发sentinel的监控。 然后再访问sentinel的控制台，查看效果： 2.流量控制雪崩问题虽然有四种方案，但是限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。我们先学习这种模式。 2.1.簇点链路当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做簇点链路。簇点链路中被监控的每一个接口就是一个资源。 默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。 例如，我们刚才访问的order-service中的OrderController中的端点：/order/{orderId} 流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则： 流控：流量控制 降级：降级熔断 热点：热点参数限流，是限流的一种 授权：请求的权限控制 2.1.快速入门2.1.1.示例点击资源/order/{orderId}后面的流控按钮，就可以弹出表单。 表单中可以填写限流规则，如下： 其含义是限制 /order/{orderId}这个资源的单机QPS为1，即每秒只允许1次请求，超出的请求会被拦截并报错。 default默认是所以来源 2.1.2.练习：需求：给 /order/{orderId}这个资源设置流控规则，QPS不能超过 5，然后测试。 1）首先在sentinel控制台添加限流规则 2）利用jmeter测试 如果没有用过jmeter，可以参考课前资料提供的文档《Jmeter快速入门.md》 课前资料提供了编写好的Jmeter测试样例： sentinel测试.jmx 打开jmeter，导入课前资料提供的测试样例： 选择： 20个用户，2秒内运行完，QPS是10，超过了5. 选中流控入门，QPS&lt;5右键运行： 注意，不要点击菜单中的执行按钮来运行。 结果： 可以看到，成功的请求每次只有5个 2.2.流控模式在添加限流规则时，点击高级选项，可以选择三种流控模式： 直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式 关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流 链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流 快速入门测试的就是直接模式。 2.2.1.关联模式关联模式：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流 配置规则： 语法说明：当/write资源访问量触发阈值时，就会对/read资源限流，避免影响/write资源。 使用场景：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。 需求说明： 在OrderController新建两个端点：/order/query和/order/update，无需实现业务 配置流控规则，当/order/ update资源被访问的QPS超过5时，对/order/query请求限流 1）定义/order/query端点，模拟订单查询 1234@GetMapping(\"/query\")public String queryOrder() &#123; return \"查询订单成功\";&#125; 2）定义/order/update端点，模拟订单更新 1234@GetMapping(\"/update\")public String updateOrder() &#123; return \"更新订单成功\";&#125; 重启服务，查看sentinel控制台的簇点链路： 3）配置流控规则 对哪个端点限流，就对谁配置流控规则，就点击哪个端点后面的按钮。我们是对订单查询/order/query限流，因此点击它后面的按钮： 在表单中填写流控规则： 4）在Jmeter测试 选择《流控模式-关联》： 可以看到1000个用户，100秒，因此QPS为10，超过了我们设定的阈值：5 查看http请求： 请求的目标是/order/update，这样这个断点就会触发阈值。 但限流的目标是/order/query，我们在浏览器访问，可以发现： 确实被限流了。 5）总结 2.2.2.链路模式链路模式：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。 配置示例： 例如有两条请求链路： /test1 –&gt; /common /test2 –&gt; /common 如果只希望统计从/test2进入到/common的请求，则可以这样配置： 实战案例 需求：有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。 步骤： 在OrderService中添加一个queryGoods方法，不用实现业务 在OrderController中，改造/order/query端点，调用OrderService中的queryGoods方法 在OrderController中添加一个/order/save的端点，调用OrderService的queryGoods方法 给queryGoods设置限流规则，从/order/query进入queryGoods的方法限制QPS必须小于2 实现： 1）添加查询商品方法在order-service服务中，给OrderService类添加一个queryGoods方法： 123public void queryGoods()&#123; System.err.println(\"查询商品\");&#125; 2）查询订单时，查询商品在order-service的OrderController中，修改/order/query端点的业务逻辑： 12345678@GetMapping(\"/query\")public String queryOrder() &#123; // 查询商品 orderService.queryGoods(); // 查询订单 System.out.println(\"查询订单\"); return \"查询订单成功\";&#125; 3）新增订单，查询商品在order-service的OrderController中，修改/order/save端点，模拟新增订单： 12345678@GetMapping(\"/save\")public String saveOrder() &#123; // 查询商品 orderService.queryGoods(); // 查询订单 System.err.println(\"新增订单\"); return \"新增订单成功\";&#125; 4）给查询商品添加资源标记默认情况下，OrderService中的方法是不被Sentinel监控的，需要我们自己通过注解来标记要监控的方法。 给OrderService的queryGoods方法添加@SentinelResource注解： 1234@SentinelResource(\"goods\")public void queryGoods()&#123; System.err.println(\"查询商品\");&#125; 链路模式中，是对不同来源的两个链路做监控。但是sentinel默认会给进入SpringMVC的所有请求设置同一个root资源，会导致链路模式失效。 我们需要关闭这种对SpringMVC的资源聚合，修改order-service服务的application.yml文件： 1234spring: cloud: sentinel: web-context-unify: false # 关闭context整合 重启服务，访问/order/query和/order/save，可以查看到sentinel的簇点链路规则中，出现了新的资源： 5）添加流控规则点击goods资源后面的流控按钮，在弹出的表单中填写下面信息： 只统计从/order/query进入/goods的资源，QPS阈值为2，超出则被限流。 6）Jmeter测试选择《流控模式-链路》： 可以看到这里200个用户，50秒内发完，QPS为4，超过了我们设定的阈值2 一个http请求是访问/order/save： 运行的结果： 完全不受影响。 另一个是访问/order/query： 运行结果： 每次只有2个通过。 2.2.3.总结流控模式有哪些？ •直接：对当前资源限流 •关联：高优先级资源触发阈值，对低优先级资源限流。 •链路：阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流 2.3.流控效果在流控的高级选项中，还有一个流控效果选项： 流控效果是指请求达到流控阈值时应该采取的措施，包括三种： 快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。 warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。 排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长 2.3.1.warm up阈值一般是一个微服务能承担的最大QPS，但是一个服务刚刚启动时，一切资源尚未初始化（冷启动），如果直接将QPS跑到最大值，可能导致服务瞬间宕机。 warm up也叫预热模式，是应对服务冷启动的一种方案。请求阈值初始值是 maxThreshold / coldFactor，持续指定时长后，逐渐提高到maxThreshold值。而coldFactor的默认值是3. 例如，我设置QPS的maxThreshold为10，预热时间为5秒，那么初始阈值就是 10 / 3 ，也就是3，然后在5秒后逐渐增长到10. 案例 需求：给/order/{orderId}这个资源设置限流，最大QPS为10，利用warm up效果，预热时长为5秒 1）配置流控规则： 2）Jmeter测试选择《流控效果，warm up》： QPS为10. 刚刚启动时，大部分请求失败，成功的只有3个，说明QPS被限定在3： 随着时间推移，成功比例越来越高： 到Sentinel控制台查看实时监控： 一段时间后： 2.3.2.排队等待当请求超过QPS阈值时，快速失败和warm up 会拒绝新的请求并抛出异常。 而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。 工作原理 例如：QPS = 5，意味着每200ms处理一个队列中的请求；timeout = 2000，意味着预期等待时长超过2000ms的请求会被拒绝并抛出异常。 那什么叫做预期等待时长呢？ 比如现在一下子来了12 个请求，因为每200ms执行一个请求，那么： 第6个请求的预期等待时长 = 200 * （6 - 1） = 1000ms 第12个请求的预期等待时长 = 200 * （12-1） = 2200ms 现在，第1秒同时接收到10个请求，但第2秒只有1个请求，此时QPS的曲线这样的： 如果使用队列模式做流控，所有进入的请求都要排队，以固定的200ms的间隔执行，QPS会变的很平滑： 平滑的QPS曲线，对于服务器来说是更友好的。 案例 需求：给/order/{orderId}这个资源设置限流，最大QPS为10，利用排队的流控效果，超时时长设置为5s 1）添加流控规则 2）Jmeter测试选择《流控效果，队列》： QPS为15，已经超过了我们设定的10。 如果是之前的 快速失败、warmup模式，超出的请求应该会直接报错。 但是我们看看队列模式的运行结果： 全部都通过了。 再去sentinel查看实时监控的QPS曲线： QPS非常平滑，一致保持在10，但是超出的请求没有被拒绝，而是放入队列。因此响应时间（等待时间）会越来越长。 当队列满了以后，才会有部分请求失败： 2.3.3.总结流控效果有哪些？ 快速失败：QPS超过阈值时，拒绝新的请求 warm up： QPS超过阈值时，拒绝新的请求；QPS阈值是逐渐提升的，可以避免冷启动时高并发导致服务宕机。 排队等待：请求会进入队列，按照阈值允许的时间间隔依次执行请求；如果请求预期等待时长大于超时时间，直接拒绝 2.4.热点参数限流之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是分别统计参数值相同的请求，判断是否超过QPS阈值。 2.4.1.全局参数限流例如，一个根据id查询商品的接口： 访问/goods/{id}的请求中，id参数值会有变化，热点参数限流会根据参数值分别统计QPS，统计结果： 当id=1的请求触发阈值被限流时，id值不为1的请求不受影响。 配置示例： 代表的含义是：对hot这个资源的0号参数（第一个参数）做统计，每1秒相同参数值的请求数不能超过5 2.4.2.热点参数限流刚才的配置中，对查询商品这个接口的所有商品一视同仁，QPS都限定为5. 而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样，高一些。那就需要配置热点参数限流的高级选项了： 结合上一个配置，这里的含义是对0号的long类型参数限流，每1秒相同参数的QPS不能超过5，有两个例外： •如果参数值是100，则每1秒允许的QPS为10 •如果参数值是101，则每1秒允许的QPS为15 2.4.4.案例案例需求：给/order/{orderId}这个资源添加热点参数限流，规则如下： •默认的热点参数规则是每1秒请求量不超过2 •给102这个参数设置例外：每1秒请求量不超过4 •给103这个参数设置例外：每1秒请求量不超过10 注意事项：热点参数限流对默认的SpringMVC资源无效，需要利用@SentinelResource注解标记资源 1）标记资源给order-service中的OrderController中的/order/{orderId}资源添加注解： 2）热点参数限流规则访问该接口，可以看到我们标记的hot资源出现了： 这里不要点击hot后面的按钮，页面有BUG 点击左侧菜单中热点规则菜单： 点击新增，填写表单： 3）Jmeter测试选择《热点参数限流 QPS1》： 这里发起请求的QPS为5. 包含3个http请求： 普通参数，QPS阈值为2 运行结果： 例外项，QPS阈值为4 运行结果： 例外项，QPS阈值为10 运行结果： 3.隔离和降级限流是一种预防措施，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。 而要将这些故障控制在一定范围，避免雪崩，就要靠线程隔离（舱壁模式）和熔断降级手段了。 线程隔离之前讲到过：调用者在调用服务提供者时，给每个调用的请求分配独立线程池，出现故障时，最多消耗这个线程池内资源，避免把调用者的所有资源耗尽。 熔断降级：是在调用方这边加入断路器，统计对服务提供者的调用，如果调用的失败比例过高，则熔断该业务，不允许访问该服务的提供者了。 可以看到，不管是线程隔离还是熔断降级，都是对客户端（调用方）的保护。需要在调用方 发起远程调用时做线程隔离、或者服务熔断。 而我们的微服务远程调用都是基于Feign来完成的，因此我们需要将Feign与Sentinel整合，在Feign里面实现线程隔离和服务熔断。 3.1.FeignClient整合SentinelSpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel。 3.1.1.修改配置，开启sentinel功能修改OrderService的application.yml文件，开启Feign的Sentinel功能： 123feign: sentinel: enabled: true # 开启feign对sentinel的支持 3.1.2.编写失败降级逻辑业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。 给FeignClient编写失败后的降级逻辑 ①方式一：FallbackClass，无法对远程调用的异常做处理 ②方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种 这里我们演示方式二的失败降级处理。 步骤一：在feing-api项目中定义类，实现FallbackFactory： 代码： 1234567891011121314151617181920package cn.itcast.feign.clients.fallback;import cn.itcast.feign.clients.UserClient;import cn.itcast.feign.pojo.User;import feign.hystrix.FallbackFactory;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class UserClientFallbackFactory implements FallbackFactory&lt;UserClient&gt; &#123; @Override public UserClient create(Throwable throwable) &#123; return new UserClient() &#123; @Override public User findById(Long id) &#123; log.error(\"查询用户异常\", throwable); return new User(); &#125; &#125;; &#125;&#125; 步骤二：在feing-api项目中的DefaultFeignConfiguration类中将UserClientFallbackFactory注册为一个Bean： 1234@Beanpublic UserClientFallbackFactory userClientFallbackFactory()&#123; return new UserClientFallbackFactory();&#125; 步骤三：在feing-api项目中的UserClient接口中使用UserClientFallbackFactory： 123456789101112import cn.itcast.feign.clients.fallback.UserClientFallbackFactory;import cn.itcast.feign.pojo.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(value = \"userservice\", fallbackFactory = UserClientFallbackFactory.class)public interface UserClient &#123; @GetMapping(\"/user/&#123;id&#125;\") User findById(@PathVariable(\"id\") Long id);&#125; 重启后，访问一次订单查询业务，然后查看sentinel控制台，可以看到新的簇点链路： 3.1.3.总结Sentinel支持的雪崩解决方案： 线程隔离（仓壁模式） 降级熔断 Feign整合Sentinel的步骤： 在application.yml中配置：feign.sentienl.enable=true 给FeignClient编写FallbackFactory并注册为Bean 将FallbackFactory配置到FeignClient 3.2.线程隔离（舱壁模式）3.2.1.线程隔离的实现方式线程隔离有两种方式实现： 线程池隔离 信号量隔离（Sentinel默认采用） 如图： 线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果 信号量隔离：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。 两者的优缺点： 3.2.2.sentinel的线程隔离用法说明： 在添加限流规则时，可以选择两种阈值类型： QPS：就是每秒的请求数，在快速入门中已经演示过 线程数：是该资源能使用用的tomcat线程数的最大值。也就是通过限制线程数量，实现线程隔离（舱壁模式）。 案例需求：给 order-service服务中的UserClient的查询用户接口设置流控规则，线程数不能超过 2。然后利用jemeter测试。 1）配置隔离规则选择feign接口后面的流控按钮： 填写表单： 2）Jmeter测试选择《阈值类型-线程数&lt;2》： 一次发生10个请求，有较大概率并发线程数超过2，而超出的请求会走之前定义的失败降级逻辑。 查看运行结果： 发现虽然结果都是通过了，不过部分请求得到的响应是降级返回的null信息。 3.2.3.总结线程隔离的两种手段是？ 信号量隔离 线程池隔离 信号量隔离的特点是？ 基于计数器模式，简单，开销小 线程池隔离的特点是？ 基于线程池模式，有额外开销，但隔离控制更强 3.3.熔断降级熔断降级是解决雪崩问题的重要手段。其思路是由断路器统计服务调用的异常比例、慢请求比例，如果超出阈值则会熔断该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。 断路器控制熔断和放行是通过状态机来完成的： 状态机包括三个状态： closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态 open：打开状态，服务调用被熔断，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态5秒后会进入half-open状态 half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 请求成功：则切换到closed状态 请求失败：则切换到open状态 断路器熔断策略有三种：慢调用、异常比例、异常数 3.3.1.慢调用慢调用：业务的响应时长（RT，Response Time）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。 例如： 解读：RT超过500ms的调用是慢调用，统计最近10000ms内的请求，如果请求量超过10次，并且慢调用比例不低于0.5，则触发熔断，熔断时长为5秒。然后进入half-open状态，放行一次请求做测试。 案例 需求：给 UserClient的查询用户接口设置降级规则，慢调用的RT阈值为50ms，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5 1）设置慢调用修改user-service中的/user/{id}这个接口的业务。通过休眠模拟一个延迟时间： 1234567891011121314151617/** * 路径： /user/110 * * @param id 用户id * @return 用户 */@GetMapping(\"/&#123;id&#125;\")public User queryById(@PathVariable(\"id\") Long id, @RequestHeader(value = \"Truth\", required = false) String truth) throws InterruptedException &#123; if (id == 1) &#123; // 休眠，触发熔断 Thread.sleep(60); &#125; else if (id == 2) &#123; throw new RuntimeException(\"故意出错，触发熔断\"); &#125; return userService.queryById(id);&#125; 此时，orderId=101的订单，关联的是id为1的用户，调用时长为60ms： orderId=102的订单，关联的是id为2的用户，调用时长为非常短； 2）设置熔断规则下面，给feign接口设置降级规则： 规则： 超过50ms的请求都会被认为是慢请求 3）测试在浏览器访问：http://localhost:8088/order/101，快速**刷新5次**，可以发现： 触发了熔断，请求时长缩短至5ms，快速失败了，并且走降级逻辑，返回的null 在浏览器访问：http://localhost:8088/order/102，竟然也被熔断了： 3.3.2.异常比例、异常数异常比例或异常数：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。 例如，一个异常比例设置： 解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于0.4，则触发熔断。 一个异常数设置： 解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于2次，则触发熔断。 案例 需求：给 UserClient的查询用户接口设置降级规则，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5s 1）设置异常请求首先，修改user-service中的/user/{id}这个接口的业务。手动抛出异常，以触发异常比例的熔断： 也就是说，id 为 2时，就会触发异常 2）设置熔断规则下面，给feign接口设置降级规则： 规则： 在5次请求中，只要异常比例超过0.4，也就是有2次以上的异常，就会触发熔断。 3）测试在浏览器快速访问：http://localhost:8088/order/102，快速刷新5次，触发熔断： 此时，我们去访问本来应该正常的103： 4.授权规则授权规则可以对请求方来源做判断和控制。 4.1.授权规则4.1.1.基本规则授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。 白名单：来源（origin）在白名单内的调用者允许访问 黑名单：来源（origin）在黑名单内的调用者不允许访问 点击左侧菜单的授权，可以看到授权规则： 资源名：就是受保护的资源，例如/order/{orderId} 流控应用：是来源者的名单， 如果是勾选白名单，则名单中的来源被许可访问。 如果是勾选黑名单，则名单中的来源被禁止访问。 比如： 我们允许请求从gateway到order-service，不允许浏览器访问order-service，那么白名单中就要填写网关的来源名称（origin）。 4.1.2.如何获取originSentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的。 123456public interface RequestOriginParser &#123; /** * 从请求request对象中获取origin，获取方式自定义 */ String parseOrigin(HttpServletRequest request);&#125; 这个方法的作用就是从request对象中，获取请求者的origin值并返回。 默认情况下，sentinel不管请求者从哪里来，返回值永远是default，也就是说一切请求的来源都被认为是一样的值default。 因此，我们需要自定义这个接口的实现，让不同的请求，返回不同的origin。 例如order-service服务中，我们定义一个RequestOriginParser的实现类： 123456789101112131415161718192021package cn.itcast.order.sentinel;import com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.RequestOriginParser;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import javax.servlet.http.HttpServletRequest;@Componentpublic class HeaderOriginParser implements RequestOriginParser &#123; @Override public String parseOrigin(HttpServletRequest request) &#123; // 1.获取请求头 String origin = request.getHeader(\"origin\"); // 2.非空判断 if (StringUtils.isEmpty(origin)) &#123; origin = \"blank\"; &#125; return origin; &#125;&#125; 我们会尝试从request-header中获取origin值。 4.1.3.给网关添加请求头既然获取请求origin的方式是从reques-header中获取origin值，我们必须让所有从gateway路由到微服务的请求都带上origin头。 这个需要利用之前学习的一个GatewayFilter来实现，AddRequestHeaderGatewayFilter。 修改gateway服务中的application.yml，添加一个defaultFilter： 1234567spring: cloud: gateway: default-filters: - AddRequestHeader=origin,gateway # 添加名为origin的请求头，值为gateway routes: # ...略 这样，从gateway路由的所有请求都会带上origin头，值为gateway。而从其它地方到达微服务的请求则没有这个头。 4.1.4.配置授权规则接下来，我们添加一个授权规则，放行origin值为gateway的请求。 配置如下： 现在，我们直接跳过网关，访问order-service服务： 通过网关访问： 4.2.自定义异常结果默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。 4.2.1.异常类型而如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口： 123456public interface BlockExceptionHandler &#123; /** * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException */ void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception;&#125; 这个方法有三个参数： HttpServletRequest request：request对象 HttpServletResponse response：response对象 BlockException e：被sentinel拦截时抛出的异常 这里的BlockException包含多个不同的子类： 异常 说明 FlowException 限流异常 ParamFlowException 热点参数限流的异常 DegradeException 降级异常 AuthorityException 授权规则异常 SystemBlockException 系统规则异常 4.2.2.自定义异常处理下面，我们就在order-service定义一个自定义异常处理类： 123456789101112131415161718192021222324252627282930313233343536package cn.itcast.order.sentinel;import com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.BlockExceptionHandler;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.alibaba.csp.sentinel.slots.block.authority.AuthorityException;import com.alibaba.csp.sentinel.slots.block.degrade.DegradeException;import com.alibaba.csp.sentinel.slots.block.flow.FlowException;import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Componentpublic class SentinelExceptionHandler implements BlockExceptionHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception &#123; String msg = \"未知异常\"; int status = 429; if (e instanceof FlowException) &#123; msg = \"请求被限流了\"; &#125; else if (e instanceof ParamFlowException) &#123; msg = \"请求被热点参数限流\"; &#125; else if (e instanceof DegradeException) &#123; msg = \"请求被降级了\"; &#125; else if (e instanceof AuthorityException) &#123; msg = \"没有权限访问\"; status = 401; &#125; response.setContentType(\"application/json;charset=utf-8\"); response.setStatus(status); response.getWriter().println(\"&#123;\\\"msg\\\": \" + msg + \", \\\"status\\\": \" + status + \"&#125;\"); &#125;&#125; 重启测试，在不同场景下，会返回不同的异常消息. 限流： 授权拦截时： 5.规则持久化现在，sentinel的所有规则都是内存存储，重启后所有规则都会丢失。在生产环境下，我们必须确保这些规则的持久化，避免丢失。 5.1.规则管理模式规则是否能持久化，取决于规则管理模式，sentinel支持三种规则管理模式： 原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。 pull模式 push模式，推荐使用 5.1.1.pull模式pull模式：控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。 5.1.2.push模式push模式：控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新。 5.2.实现push模式详细步骤可以参考课前资料的《sentinel规则持久化》：","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"Sentinel","slug":"Sentinel","permalink":"https://codeofli.github.io/tags/Sentinel/"}]},{"title":"Jmeter快速入门","slug":"java-note/SpringCloud/Sentinel/Jmeter快速入门/Jmeter快速入门","date":"2021-10-23T02:40:06.000Z","updated":"2021-10-31T04:44:58.411Z","comments":true,"path":"2021/10/java-note/SpringCloud/Sentinel/Jmeter快速入门/Jmeter快速入门/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/Sentinel/Jmeter快速入门/Jmeter快速入门/","excerpt":"Jmeter快速入门1.安装JmeterJmeter依赖于JDK，所以必须确保当前计算机上已经安装了JDK，并且配置了环境变量。1.1.下载可以Apache Jmeter官网下载，地址：http://jmeter.apache.org/download_jmeter.cgi当然，我们课前资料也提供了下载好的安装包：","text":"Jmeter快速入门1.安装JmeterJmeter依赖于JDK，所以必须确保当前计算机上已经安装了JDK，并且配置了环境变量。1.1.下载可以Apache Jmeter官网下载，地址：http://jmeter.apache.org/download_jmeter.cgi当然，我们课前资料也提供了下载好的安装包： apache-jmeter-5.4.1.zip 1.2.解压因为下载的是zip包，解压缩即可使用，目录结构如下： 其中的bin目录就是执行的脚本，其中包含启动脚本： 1.3.运行双击即可运行，但是有两点注意： 启动速度比较慢，要耐心等待 启动后黑窗口不能关闭，否则Jmeter也跟着关闭了 2.快速入门2.1.设置中文语言默认Jmeter的语言是英文，需要设置： 效果： 注意：上面的配置只能保证本次运行是中文，如果要永久中文，需要修改Jmeter的配置文件 打开jmeter文件夹，在bin目录中找到 jmeter.properties，添加下面配置： 1language=zh_CN 注意：前面不要出现#，#代表注释，另外这里是下划线，不是中划线 2.2.基本用法在测试计划上点鼠标右键，选择添加 &gt; 线程（用户） &gt; 线程组： 在新增的线程组中，填写线程信息： 给线程组点鼠标右键，添加http取样器： 编写取样器内容： 添加监听报告： 添加监听结果树： 汇总报告结果： 结果树：","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"Jmeter","slug":"Jmeter","permalink":"https://codeofli.github.io/tags/Jmeter/"}]},{"title":"Sentinel规则持久化","slug":"java-note/SpringCloud/Sentinel/sentinel规则持久化/sentinel规则持久化","date":"2021-10-23T02:40:06.000Z","updated":"2021-10-31T04:41:49.069Z","comments":true,"path":"2021/10/java-note/SpringCloud/Sentinel/sentinel规则持久化/sentinel规则持久化/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/Sentinel/sentinel规则持久化/sentinel规则持久化/","excerpt":"Sentinel 规则持久化一、修改order-service服务修改OrderService，让其监听Nacos中的sentinel规则配置。具体步骤如下：1.引入依赖在order-service中引入sentinel监听nacos的依赖：1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt;","text":"Sentinel 规则持久化一、修改order-service服务修改OrderService，让其监听Nacos中的sentinel规则配置。具体步骤如下：1.引入依赖在order-service中引入sentinel监听nacos的依赖：1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt; 2.配置nacos地址在order-service中的application.yml文件配置nacos地址及监听的配置信息： 12345678910111213141516spring: cloud: sentinel: datasource: flow: nacos: server-addr: localhost:8848 # nacos地址 dataId: orderservice-flow-rules groupId: SENTINEL_GROUP rule-type: flow # 还可以是：degrade、authority、param-flow# degrade:# nacos:# server-addr: localhost:8848 # nacos地址# dataId: orderservice-degrade-rules# groupId: SENTINEL_GROUP# rule-type: degrade # 还可以是：degrade、authority、param-flow 二、修改sentinel-dashboard源码SentinelDashboard默认不支持nacos的持久化，需要修改源码。 1. 解压解压课前资料中的sentinel源码包： 然后并用IDEA打开这个项目，结构如下： 2. 修改nacos依赖在sentinel-dashboard源码的pom文件中，nacos的依赖默认的scope是test，只能在测试时使用，这里要去除： 将sentinel-datasource-nacos依赖的scope去掉： 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt; 3. 添加nacos支持在sentinel-dashboard的test包下，已经编写了对nacos的支持，我们需要将其拷贝到main下。 4. 修改nacos地址然后，还需要修改测试代码中的NacosConfig类： 修改其中的nacos地址，让其读取application.properties中的配置： 在sentinel-dashboard的application.properties中添加nacos地址配置： 1nacos.addr=localhost:8848 5. 配置nacos数据源另外，还需要修改com.alibaba.csp.sentinel.dashboard.controller.v2包下的FlowControllerV2类： 让我们添加的Nacos数据源生效： 6. 修改前端页面接下来，还要修改前端页面，添加一个支持nacos的菜单。 修改src/main/webapp/resources/app/scripts/directives/sidebar/目录下的sidebar.html文件： 将其中的这部分注释打开： 修改其中的文本： 7. 重新编译、打包项目运行IDEA中的maven插件，编译和打包修改好的Sentinel-Dashboard： 在资料中有配置好了的，sentinel-dashboard.jar，直接使用亦可 8.启动启动方式跟官方一样： 1java -jar sentinel-dashboard.jar 如果要修改nacos地址，需要添加参数： 1java -jar -Dnacos.addr=localhost:8848 sentinel-dashboard.jar 进入http://localhost:8080/发现有-NACOS就成功了 nacos页面中也有配置管理","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"Sentinel","slug":"Sentinel","permalink":"https://codeofli.github.io/tags/Sentinel/"}]},{"title":"CentOS7安装Docker","slug":"java-note/SpringCloud/docker/Centos7安装Docker/Centos7安装Docker","date":"2021-10-23T02:40:06.000Z","updated":"2021-10-31T04:54:28.420Z","comments":true,"path":"2021/10/java-note/SpringCloud/docker/Centos7安装Docker/Centos7安装Docker/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/docker/Centos7安装Docker/Centos7安装Docker/","excerpt":"0.安装DockerDocker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。Docker CE 分为 stable test 和 nightly 三个更新频道。官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。","text":"0.安装DockerDocker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。Docker CE 分为 stable test 和 nightly 三个更新频道。官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。 1.CentOS安装DockerDocker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。 1.1.卸载（可选）如果之前安装过旧版本的Docker，可以使用下面命令卸载： 1234567891011yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce 1.2.安装docker首先需要大家虚拟机联网，安装yum工具 123yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 --skip-broken 然后更新本地镜像源： 12345678# 设置docker镜像源yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sed -i 's/download.docker.com/mirrors.aliyun.com\\/docker-ce/g' /etc/yum.repos.d/docker-ce.repoyum makecache fast 然后输入命令： 1yum install -y docker-ce docker-ce为社区免费版本。稍等片刻，docker即可安装成功。 1.3.启动dockerDocker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 1234# 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld 通过命令启动docker： 12345systemctl start docker # 启动docker服务systemctl stop docker # 停止docker服务systemctl restart docker # 重启docker服务 然后输入命令，可以查看docker版本： 1docker -v 如: 12[root@VM-0-5-centos ~]# docker -vDocker version 20.10.8, build 3967b7d 1.4.配置镜像加速docker官方镜像仓库网速较差，我们需要设置国内镜像服务： 参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 2.CentOS7安装DockerCompose2.1.下载Linux下需要通过命令下载： 12# 安装curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件： 上传到/usr/local/bin/目录也可以。 2.2.修改文件权限修改文件权限： 12# 修改权限chmod +x /usr/local/bin/docker-compose 2.3.Base自动补全命令：12# 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 如果这里出现错误，需要修改自己的hosts文件： 1echo \"199.232.68.133 raw.githubusercontent.com\" &gt;&gt; /etc/hosts 3.Docker镜像仓库搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。 官网地址：https://hub.docker.com/_/registry 3.1.简化版镜像仓库Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。 搭建方式比较简单，命令如下： 123456docker run -d \\ --restart=always \\ --name registry \\ -p 5000:5000 \\ -v registry-data:/var/lib/registry \\ registry 命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。 访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像 3.2.带有图形化界面版本使用DockerCompose部署带有图象界面的DockerRegistry，命令如下： 123456789101112131415version: '3.0'services: registry: image: registry volumes: - ./registry-data:/var/lib/registry ui: image: joxit/docker-registry-ui:static ports: - 8080:80 environment: - REGISTRY_TITLE=传智教育私有仓库 - REGISTRY_URL=http://registry:5000 depends_on: - registry 1docker-compose up -d 3.3.配置Docker信任地址我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置： 12345678# 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：\"insecure-registries\":[\"http://192.168.194.128:8080\"]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker 注意是自己的ip","categories":[{"name":"Docker","slug":"Docker","permalink":"https://codeofli.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://codeofli.github.io/tags/Docker/"}]},{"title":"OnJava8-文件","slug":"java-note/OnJava8/OnJava8-17文件","date":"2021-10-21T02:40:06.000Z","updated":"2021-10-31T05:19:45.859Z","comments":true,"path":"2021/10/java-note/OnJava8/OnJava8-17文件/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/OnJava8/OnJava8-17文件/","excerpt":"第十七章 文件 在丑陋的 Java I/O 编程方式诞生多年以后，Java终于简化了文件读写的基本操作。 这种”困难方式”的全部细节都在 Appendix: I/O Streams。如果你读过这个部分，就会认同 Java 设计者毫不在意他们的使用者的体验这一观念。打开并读取文件对于大多数编程语言来是非常常用的，由于 I/O 糟糕的设计以至于很少有人能够在不依赖其他参考代码的情况下完成打开文件的操作。","text":"第十七章 文件 在丑陋的 Java I/O 编程方式诞生多年以后，Java终于简化了文件读写的基本操作。 这种”困难方式”的全部细节都在 Appendix: I/O Streams。如果你读过这个部分，就会认同 Java 设计者毫不在意他们的使用者的体验这一观念。打开并读取文件对于大多数编程语言来是非常常用的，由于 I/O 糟糕的设计以至于很少有人能够在不依赖其他参考代码的情况下完成打开文件的操作。 好像 Java 设计者终于意识到了 Java 使用者多年来的痛苦，在 Java7 中对此引入了巨大的改进。这些新元素被放在 java.nio.file 包下面，过去人们通常把 nio 中的 n 理解为 new 即新的 io，现在更应该当成是 non-blocking 非阻塞 io(io就是input/output输入/输出)。java.nio.file 库终于将 Java 文件操作带到与其他编程语言相同的水平。最重要的是 Java8 新增的 streams 与文件结合使得文件操作编程变得更加优雅。我们将看一下文件操作的两个基本组件： 文件或者目录的路径； 文件本身。 文件和目录路径一个 Path 对象表示一个文件或者目录的路径，是一个跨操作系统（OS）和文件系统的抽象，目的是在构造路径时不必关注底层操作系统，代码可以在不进行修改的情况下运行在不同的操作系统上。java.nio.file.Paths 类包含一个重载方法 static get()，该方法接受一系列 String 字符串或一个统一资源标识符(URI)作为参数，并且进行转换返回一个 Path 对象： Path对象： function useage toString() 生成完整形式的路径 getFileName() 方法 总是返回当前文件名 resolve() 使用 resolve() 添加 Path 的尾路径(不一定是“可发现”的名称)。 toAbsolutePath() 获取绝对路径 Paths类： function useage public static Path get(String first, String… more) 返回一个由first+文件分隔符+more组成的Path对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// files/PathInfo.javaimport java.nio.file.*;import java.net.URI;import java.io.File;import java.io.IOException;public class PathInfo &#123; static void show(String id, Object p) &#123; System.out.println(id + \": \" + p); &#125; static void info(Path p) &#123; show(\"toString\", p); show(\"Exists\", Files.exists(p)); show(\"RegularFile\", Files.isRegularFile(p)); show(\"Directory\", Files.isDirectory(p)); show(\"Absolute\", p.isAbsolute()); show(\"FileName\", p.getFileName()); show(\"Parent\", p.getParent()); show(\"Root\", p.getRoot()); System.out.println(\"******************\"); &#125; public static void main(String[] args) &#123; System.out.println(System.getProperty(\"os.name\")); info(Paths.get(\"C:\", \"path\", \"to\", \"nowhere\", \"NoFile.txt\")); Path p = Paths.get(\"PathInfo.java\"); info(p); Path ap = p.toAbsolutePath(); info(ap); info(ap.getParent()); try &#123; info(p.toRealPath()); &#125; catch(IOException e) &#123; System.out.println(e); &#125; URI u = p.toUri(); System.out.println(\"URI: \" + u); Path puri = Paths.get(u); System.out.println(Files.exists(puri)); File f = ap.toFile(); // Don't be fooled &#125;&#125;/* 输出:Windows 10toString: C:\\path\\to\\nowhere\\NoFile.txtExists: falseRegularFile: falseDirectory: falseAbsolute: trueFileName: NoFile.txtParent: C:\\path\\to\\nowhereRoot: C:\\******************toString: PathInfo.javaExists: trueRegularFile: trueDirectory: falseAbsolute: falseFileName: PathInfo.javaParent: nullRoot: null******************toString: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\files\\PathInfo.javaExists: trueRegularFile: trueDirectory: falseAbsolute: trueFileName: PathInfo.javaParent: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\filesRoot: C:\\******************toString: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\filesExists: trueRegularFile: falseDirectory: trueAbsolute: trueFileName: filesParent: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamplesRoot: C:\\******************toString: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\files\\PathInfo.javaExists: trueRegularFile: trueDirectory: falseAbsolute: trueFileName: PathInfo.javaParent: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\filesRoot: C:\\******************URI: file:///C:/Users/Bruce/Documents/GitHub/onjava/ExtractedExamples/files/PathInfo.javatrue*/ 我已经在这一章第一个程序的 main() 方法添加了第一行用于展示操作系统的名称，因此你可以看到不同操作系统之间存在哪些差异。理想情况下，差别会相对较小，并且使用 / 或者 \\ 路径分隔符进行分隔。你可以看到我运行在Windows 10 上的程序输出。 通过使用 Files 工具类(我们接下类将会更多地使用它)，可以测试一个文件是否存在，测试是否是一个”普通”文件还是一个目录等等。“Nofile.txt”这个示例展示我们描述的文件可能并不在指定的位置；这样可以允许你创建一个新的路径。”PathInfo.java”存在于当前目录中，最初它只是没有路径的文件名，但它仍然被检测为”存在”。一旦我们将其转换为绝对路径，我们将会得到一个从”C:”盘(因为我们是在Windows机器下进行测试)开始的完整路径，现在它也拥有一个父路径。“真实”路径的定义在文档中有点模糊，因为它取决于具体的文件系统。例如，如果文件名不区分大小写，即使路径由于大小写的缘故而不是完全相同，也可能得到肯定的匹配结果。在这样的平台上，toRealPath() 将返回实际情况下的 Path，并且还会删除任何冗余元素。 这里你会看到 URI 看起来只能用于描述文件，实际上 URI 可以用于描述更多的东西；通过 维基百科 可以了解更多细节。现在我们成功地将 URI 转为一个 Path 对象。 最后，你会在 Path 中看到一些有点欺骗的东西，这就是调用 toFile() 方法会生成一个 File 对象。听起来似乎可以得到一个类似文件的东西(毕竟被称为 File )，但是这个方法的存在仅仅是为了向后兼容。虽然看上去应该被称为”路径”，实际上却应该表示目录或者文件本身。这是个非常草率并且令人困惑的命名，但是由于 java.nio.file 的存在我们可以安全地忽略它的存在。 选取路径部分片段Path 对象可以非常容易地生成路径的某一部分： 1234567891011121314151617181920212223242526272829303132333435363738394041// files/PartsOfPaths.javaimport java.nio.file.*;public class PartsOfPaths &#123; public static void main(String[] args) &#123; System.out.println(System.getProperty(\"os.name\")); Path p = Paths.get(\"PartsOfPaths.java\").toAbsolutePath(); for(int i = 0; i &lt; p.getNameCount(); i++) System.out.println(p.getName(i)); System.out.println(\"ends with '.java': \" + p.endsWith(\".java\")); for(Path pp : p) &#123; System.out.print(pp + \": \"); System.out.print(p.startsWith(pp) + \" : \"); System.out.println(p.endsWith(pp)); &#125; System.out.println(\"Starts with \" + p.getRoot() + \" \" + p.startsWith(p.getRoot())); &#125;&#125;/* 输出:Windows 10UsersBruceDocumentsGitHubon-javaExtractedExamplesfilesPartsOfPaths.javaends with '.java': falseUsers: false : falseBruce: false : falseDocuments: false : falseGitHub: false : falseon-java: false : falseExtractedExamples: false : falsefiles: false : falsePartsOfPaths.java: false : trueStarts with C:\\ true*/ 可以通过 getName() 来索引 Path 的各个部分，直到达到上限 getNameCount()。==Path 也实现了 Iterable 接口，==因此我们也可以通过增强的 for-each 进行遍历。请注意，即使路径以 .java 结尾，使用 endsWith() 方法也会返回 false。这是因为使用 endsWith() 比较的是整个路径部分，而不会包含文件路径的后缀。通过使用 startsWith() 和 endsWith() 也可以完成路径的遍历。但是我们可以看到，遍历 Path 对象并不包含根路径，只有使用 startsWith() 检测根路径时才会返回 true。 路径分析Files 工具类包含一系列完整的方法用于获得 Path 相关的信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// files/PathAnalysis.javaimport java.nio.file.*;import java.io.IOException;public class PathAnalysis &#123; static void say(String id, Object result) &#123; System.out.print(id + \": \"); System.out.println(result); &#125; public static void main(String[] args) throws IOException &#123; System.out.println(System.getProperty(\"os.name\")); Path p = Paths.get(\"PathAnalysis.java\").toAbsolutePath(); say(\"Exists\", Files.exists(p)); say(\"Directory\", Files.isDirectory(p)); say(\"Executable\", Files.isExecutable(p)); say(\"Readable\", Files.isReadable(p)); say(\"RegularFile\", Files.isRegularFile(p)); say(\"Writable\", Files.isWritable(p)); say(\"notExists\", Files.notExists(p)); say(\"Hidden\", Files.isHidden(p)); say(\"size\", Files.size(p)); say(\"FileStore\", Files.getFileStore(p)); say(\"LastModified: \", Files.getLastModifiedTime(p)); say(\"Owner\", Files.getOwner(p)); say(\"ContentType\", Files.probeContentType(p)); say(\"SymbolicLink\", Files.isSymbolicLink(p)); if(Files.isSymbolicLink(p)) say(\"SymbolicLink\", Files.readSymbolicLink(p)); if(FileSystems.getDefault().supportedFileAttributeViews().contains(\"posix\")) say(\"PosixFilePermissions\", Files.getPosixFilePermissions(p)); &#125;&#125;/* 输出:Windows 10Exists: trueDirectory: falseExecutable: trueReadable: trueRegularFile: trueWritable: truenotExists: falseHidden: falsesize: 1631FileStore: SSD (C:)LastModified: : 2017-05-09T12:07:00.428366ZOwner: MINDVIEWTOSHIBA\\Bruce (User)ContentType: nullSymbolicLink: false*/ 在调用最后一个测试方法 getPosixFilePermissions() 之前我们需要确认一下当前文件系统是否支持 Posix 接口，否则会抛出运行时异常。 Paths的增减修改我们必须能通过对 Path 对象增加或者删除一部分来构造一个新的 Path 对象。我们使用 relativize() 移除 Path 的根路径，使用 resolve() 添加 Path 的尾路径(不一定是“可发现”的名称)。 对于下面代码中的示例，我使用 relativize() 方法从所有的输出中移除根路径，部分原因是为了示范，部分原因是为了简化输出结果，这说明你可以使用该方法将绝对路径转为相对路径。这个版本的代码中包含 id，以便于跟踪输出结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// files/AddAndSubtractPaths.javaimport java.nio.file.*;import java.io.IOException;public class AddAndSubtractPaths &#123; static Path base = Paths.get(\"..\", \"..\", \"..\").toAbsolutePath().normalize(); static void show(int id, Path result) &#123; if(result.isAbsolute()) System.out.println(\"(\" + id + \")r \" + base.relativize(result)); else System.out.println(\"(\" + id + \") \" + result); try &#123; System.out.println(\"RealPath: \" + result.toRealPath()); &#125; catch(IOException e) &#123; System.out.println(e); &#125; &#125; public static void main(String[] args) &#123; System.out.println(System.getProperty(\"os.name\")); System.out.println(base); Path p = Paths.get(\"AddAndSubtractPaths.java\").toAbsolutePath(); show(1, p); Path convoluted = p.getParent().getParent() .resolve(\"strings\").resolve(\"..\") .resolve(p.getParent().getFileName()); show(2, convoluted); show(3, convoluted.normalize()); Path p2 = Paths.get(\"..\", \"..\"); show(4, p2); show(5, p2.normalize()); show(6, p2.toAbsolutePath().normalize()); Path p3 = Paths.get(\".\").toAbsolutePath(); Path p4 = p3.resolve(p2); show(7, p4); show(8, p4.normalize()); Path p5 = Paths.get(\"\").toAbsolutePath(); show(9, p5); show(10, p5.resolveSibling(\"strings\")); show(11, Paths.get(\"nonexistent\")); &#125;&#125;/* 输出:Windows 10C:\\Users\\Bruce\\Documents\\GitHub(1)r onjava\\ExtractedExamples\\files\\AddAndSubtractPaths.javaRealPath: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\files\\AddAndSubtractPaths.java(2)r on-java\\ExtractedExamples\\strings\\..\\filesRealPath: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\files(3)r on-java\\ExtractedExamples\\filesRealPath: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\files(4) ..\\..RealPath: C:\\Users\\Bruce\\Documents\\GitHub\\on-java(5) ..\\..RealPath: C:\\Users\\Bruce\\Documents\\GitHub\\on-java(6)r on-javaRealPath: C:\\Users\\Bruce\\Documents\\GitHub\\on-java(7)r on-java\\ExtractedExamples\\files\\.\\..\\..RealPath: C:\\Users\\Bruce\\Documents\\GitHub\\on-java(8)r on-javaRealPath: C:\\Users\\Bruce\\Documents\\GitHub\\on-java(9)r on-java\\ExtractedExamples\\filesRealPath: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\files(10)r on-java\\ExtractedExamples\\stringsRealPath: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\strings(11) nonexistentjava.nio.file.NoSuchFileException:C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\files\\nonexistent*/ 我还为 toRealPath() 添加了更多的测试，这是为了扩展和规则化，防止路径不存在时抛出运行时异常。 目录Files 工具类包含大部分我们需要的目录操作和文件操作方法。出于某种原因，它们没有包含==删除目录树相==关的方法，因此我们将实现并将其添加到 onjava 库中。 123456789101112131415161718192021222324// onjava/RmDir.javapackage onjava;import java.nio.file.*;import java.nio.file.attribute.BasicFileAttributes;import java.io.IOException;public class RmDir &#123; public static void rmdir(Path dir) throws IOException &#123; Files.walkFileTree(dir, new SimpleFileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; Files.delete(file); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException &#123; Files.delete(dir); return FileVisitResult.CONTINUE; &#125; &#125;); &#125;&#125; 删除目录树的方法实现依赖于 Files.walkFileTree()，”walking” 目录树意味着遍历每个子目录和文件。Visitor 设计模式提供了一种标准机制来访问集合中的每个对象，然后你需要提供在每个对象上执行的操作。此操作的定义取决于实现的 FileVisitor 的四个抽象方法，包括： preVisitDirectory()：在访问目录中条目之前在目录上运行。 visitFile()：运行目录中的每一个文件。 visitFileFailed()：调用无法访问的文件。 postVisitDirectory()：在访问目录中条目之后在目录上运行，包括所有的子目录。 为了简化，java.nio.file.SimpleFileVisitor 提供了所有方法的默认实现。这样，在我们的匿名内部类中，我们只需要重写非标准行为的方法：visitFile() 和 postVisitDirectory() 实现删除文件和删除目录。两者都应该返回标志位决定是否继续访问(这样就可以继续访问，直到找到所需要的)。作为探索目录操作的一部分，现在我们可以有条件地删除已存在的目录。在以下例子中，makeVariant() 接受基本目录测试，并通过旋转部件列表生成不同的子目录路径。这些旋转与路径分隔符 sep 使用 String.join() 贴在一起，然后返回一个 Path 对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// files/Directories.javaimport java.util.*;import java.nio.file.*;import onjava.RmDir;public class Directories &#123; static Path test = Paths.get(\"test\"); static String sep = FileSystems.getDefault().getSeparator(); static List&lt;String&gt; parts = Arrays.asList(\"foo\", \"bar\", \"baz\", \"bag\"); static Path makeVariant() &#123; Collections.rotate(parts, 1); return Paths.get(\"test\", String.join(sep, parts)); &#125; static void refreshTestDir() throws Exception &#123; if(Files.exists(test)) RmDir.rmdir(test); if(!Files.exists(test)) Files.createDirectory(test); &#125; public static void main(String[] args) throws Exception &#123; refreshTestDir(); Files.createFile(test.resolve(\"Hello.txt\")); Path variant = makeVariant(); // Throws exception (too many levels): try &#123; Files.createDirectory(variant); &#125; catch(Exception e) &#123; System.out.println(\"Nope, that doesn't work.\"); &#125; populateTestDir(); Path tempdir = Files.createTempDirectory(test, \"DIR_\"); Files.createTempFile(tempdir, \"pre\", \".non\"); Files.newDirectoryStream(test).forEach(System.out::println); System.out.println(\"*********\"); Files.walk(test).forEach(System.out::println); &#125; static void populateTestDir() throws Exception &#123; for(int i = 0; i &lt; parts.size(); i++) &#123; Path variant = makeVariant(); if(!Files.exists(variant)) &#123; Files.createDirectories(variant); Files.copy(Paths.get(\"Directories.java\"), variant.resolve(\"File.txt\")); Files.createTempFile(variant, null, null); &#125; &#125; &#125;&#125;/* 输出:Nope, that doesn't work.test\\bagtest\\bartest\\baztest\\DIR_5142667942049986036test\\footest\\Hello.txt*********testtest\\bagtest\\bag\\footest\\bag\\foo\\bartest\\bag\\foo\\bar\\baztest\\bag\\foo\\bar\\baz\\8279660869874696036.tmptest\\bag\\foo\\bar\\baz\\File.txttest\\bartest\\bar\\baztest\\bar\\baz\\bagtest\\bar\\baz\\bag\\footest\\bar\\baz\\bag\\foo\\1274043134240426261.tmptest\\bar\\baz\\bag\\foo\\File.txttest\\baztest\\baz\\bagtest\\baz\\bag\\footest\\baz\\bag\\foo\\bartest\\baz\\bag\\foo\\bar\\6130572530014544105.tmptest\\baz\\bag\\foo\\bar\\File.txttest\\DIR_5142667942049986036test\\DIR_5142667942049986036\\pre7704286843227113253.nontest\\footest\\foo\\bartest\\foo\\bar\\baztest\\foo\\bar\\baz\\bagtest\\foo\\bar\\baz\\bag\\5412864507741775436.tmptest\\foo\\bar\\baz\\bag\\File.txttest\\Hello.txt*/ 首先，refreshTestDir() 用于检测 test 目录是否已经存在。若存在，则使用我们新工具类 rmdir() 删除其整个目录。检查是否 exists 是多余的，但我想说明一点，因为如果你对于已经存在的目录调用 createDirectory() 将会抛出异常。createFile() 使用参数 Path 创建一个空文件; resolve() 将文件名添加到 test Path 的末尾。 我们尝试使用 createDirectory() 来创建多级路径，但是这样会抛出异常，因为这个方法只能创建单级路径。我已经将 populateTestDir() 作为一个单独的方法，因为它将在后面的例子中被重用。对于每一个变量 variant，我们都能使用 createDirectories() 创建完整的目录路径，然后使用此文件的副本以不同的目标名称填充该终端目录。然后我们使用 createTempFile() 生成一个临时文件。 在调用 populateTestDir() 之后，我们在 test 目录下面下面创建一个临时目录。请注意，createTempDirectory() 只有名称的前缀选项。与 createTempFile() 不同，我们再次使用它将临时文件放入新的临时目录中。你可以从输出中看到，如果未指定后缀，它将默认使用”.tmp”作为后缀。 为了展示结果，我们首次使用看起来很有希望的 newDirectoryStream()，但事实证明这个方法只是返回 test 目录内容的 Stream 流，并没有更多的内容。要获取目录树的全部内容的流，请使用 Files.walk()。 文件系统FileSystems工具类 为了完整起见，我们需要一种方法查找文件系统相关的其他信息。在这里，我们使用静态的 FileSystems 工具类获取”默认”的文件系统，但你同样也可以在 Path 对象上调用 getFileSystem() 以获取创建该 Path 的文件系统。你可以获得给定 URI 的文件系统，还可以构建新的文件系统(对于支持它的操作系统)。 123456789101112131415161718192021222324252627282930313233343536373839// files/FileSystemDemo.javaimport java.nio.file.*;public class FileSystemDemo &#123; static void show(String id, Object o) &#123; System.out.println(id + \": \" + o); &#125; public static void main(String[] args) &#123; System.out.println(System.getProperty(\"os.name\")); FileSystem fsys = FileSystems.getDefault(); for(FileStore fs : fsys.getFileStores()) show(\"File Store\", fs); for(Path rd : fsys.getRootDirectories()) show(\"Root Directory\", rd); show(\"Separator\", fsys.getSeparator()); show(\"UserPrincipalLookupService\", fsys.getUserPrincipalLookupService()); show(\"isOpen\", fsys.isOpen()); show(\"isReadOnly\", fsys.isReadOnly()); show(\"FileSystemProvider\", fsys.provider()); show(\"File Attribute Views\", fsys.supportedFileAttributeViews()); &#125;&#125;/* 输出:Windows 10File Store: SSD (C:)Root Directory: C:\\Root Directory: D:\\Separator: \\UserPrincipalLookupService:sun.nio.fs.WindowsFileSystem$LookupService$1@15db9742isOpen: trueisReadOnly: falseFileSystemProvider:sun.nio.fs.WindowsFileSystemProvider@6d06d69cFile Attribute Views: [owner, dos, acl, basic, user]*/ 一个 FileSystem 对象也能生成 WatchService 和 PathMatcher 对象，将会在接下来两章中详细讲解。 路径监听通过 WatchService 可以设置一个进程对目录中的更改做出响应。在这个例子中，delTxtFiles() 作为一个单独的任务执行，该任务将遍历整个目录并删除以 .txt 结尾的所有文件，WatchService 会对文件删除操作做出反应： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// files/PathWatcher.java// &#123;ExcludeFromGradle&#125;import java.io.IOException;import java.nio.file.*;import static java.nio.file.StandardWatchEventKinds.*;import java.util.concurrent.*;public class PathWatcher &#123; static Path test = Paths.get(\"test\"); static void delTxtFiles() &#123; try &#123; Files.walk(test) .filter(f -&gt; f.toString() .endsWith(\".txt\")) .forEach(f -&gt; &#123; try &#123; System.out.println(\"deleting \" + f); Files.delete(f); &#125; catch(IOException e) &#123; throw new RuntimeException(e); &#125; &#125;); &#125; catch(IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) throws Exception &#123; Directories.refreshTestDir(); Directories.populateTestDir(); Files.createFile(test.resolve(\"Hello.txt\")); WatchService watcher = FileSystems.getDefault().newWatchService(); test.register(watcher, ENTRY_DELETE); Executors.newSingleThreadScheduledExecutor() .schedule(PathWatcher::delTxtFiles, 250, TimeUnit.MILLISECONDS); WatchKey key = watcher.take(); for(WatchEvent evt : key.pollEvents()) &#123; System.out.println(\"evt.context(): \" + evt.context() + \"\\nevt.count(): \" + evt.count() + \"\\nevt.kind(): \" + evt.kind()); System.exit(0); &#125; &#125;&#125;/* Output:deleting test\\bag\\foo\\bar\\baz\\File.txtdeleting test\\bar\\baz\\bag\\foo\\File.txtdeleting test\\baz\\bag\\foo\\bar\\File.txtdeleting test\\foo\\bar\\baz\\bag\\File.txtdeleting test\\Hello.txtevt.context(): Hello.txtevt.count(): 1evt.kind(): ENTRY_DELETE*/ delTxtFiles() 中的 try 代码块看起来有些多余，因为它们捕获的是同一种类型的异常，外部的 try 语句似乎已经足够了。然而出于某种原因，Java 要求两者都必须存在(这也可能是一个 bug)。还要注意的是在 filter() 中，我们必须显式地使用 f.toString() 转为字符串，否则我们调用 endsWith() 将会与整个 Path 对象进行比较，而不是路径名称字符串的一部分进行比较。 一旦我们从 FileSystem 中得到了 WatchService 对象，我们将其注册到 test 路径以及我们感兴趣的项目的变量参数列表中，可以选择 ENTRY_CREATE，ENTRY_DELETE 或 ENTRY_MODIFY(其中创建和删除不属于修改)。 因为接下来对 watcher.take() 的调用会在发生某些事情之前停止所有操作，所以我们希望 deltxtfiles() 能够并行运行以便生成我们感兴趣的事件。为了实现这个目的，我通过调用 Executors.newSingleThreadScheduledExecutor() 产生一个 ScheduledExecutorService 对象，然后调用 schedule() 方法传递所需函数的方法引用，并且设置在运行之前应该等待的时间。 此时，watcher.take() 将等待并阻塞在这里。当目标事件发生时，会返回一个包含 WatchEvent 的 Watchkey 对象。展示的这三种方法是能对 WatchEvent 执行的全部操作。 查看输出的具体内容。即使我们正在删除以 .txt 结尾的文件，在 Hello.txt 被删除之前，WatchService 也不会被触发。你可能认为，如果说”监视这个目录”，自然会包含整个目录和下面子目录，但实际上的：只会监视给定的目录，而不是下面的所有内容。如果需要监视整个树目录，必须在整个树的每个子目录上放置一个 Watchservice。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// files/TreeWatcher.java// &#123;ExcludeFromGradle&#125;import java.io.IOException;import java.nio.file.*;import static java.nio.file.StandardWatchEventKinds.*;import java.util.concurrent.*;public class TreeWatcher &#123; static void watchDir(Path dir) &#123; try &#123; WatchService watcher = FileSystems.getDefault().newWatchService(); dir.register(watcher, ENTRY_DELETE); Executors.newSingleThreadExecutor().submit(() -&gt; &#123; try &#123; WatchKey key = watcher.take(); for(WatchEvent evt : key.pollEvents()) &#123; System.out.println( \"evt.context(): \" + evt.context() + \"\\nevt.count(): \" + evt.count() + \"\\nevt.kind(): \" + evt.kind()); System.exit(0); &#125; &#125; catch(InterruptedException e) &#123; return; &#125; &#125;); &#125; catch(IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) throws Exception &#123; Directories.refreshTestDir(); Directories.populateTestDir(); Files.walk(Paths.get(\"test\")) .filter(Files::isDirectory) .forEach(TreeWatcher::watchDir); PathWatcher.delTxtFiles(); &#125;&#125;/* Output:deleting test\\bag\\foo\\bar\\baz\\File.txtdeleting test\\bar\\baz\\bag\\foo\\File.txtevt.context(): File.txtevt.count(): 1evt.kind(): ENTRY_DELETE*/ 在 watchDir() 方法中给 WatchSevice 提供参数 ENTRY_DELETE，并启动一个独立的线程来监视该Watchservice。这里我们没有使用 schedule() 进行启动，而是使用 submit() 启动线程。我们遍历整个目录树，并将 watchDir() 应用于每个子目录。现在，当我们运行 deltxtfiles() 时，其中一个 Watchservice 会检测到每一次文件删除。 文件查找到目前为止，为了找到文件，我们一直使用相当粗糙的方法，在 path 上调用 toString()，然后使用 string 操作查看结果。 事实证明，java.nio.file 有更好的解决方案：通过在 FileSystem 对象上调用 getPathMatcher() 获得一个 PathMatcher，然后传入您感兴趣的模式。模式有两个选项：glob 和 regex。glob 比较简单，实际上功能非常强大，因此您可以使用 glob 解决许多问题。如果您的问题更复杂，可以使用 regex，这将在接下来的 Strings 一章中解释。 在这里，我们使用 glob 查找以 .tmp 或 .txt 结尾的所有 Path： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// files/Find.java// &#123;ExcludeFromGradle&#125;import java.nio.file.*;public class Find &#123; public static void main(String[] args) throws Exception &#123; Path test = Paths.get(\"test\"); Directories.refreshTestDir(); Directories.populateTestDir(); // Creating a *directory*, not a file: Files.createDirectory(test.resolve(\"dir.tmp\")); PathMatcher matcher = FileSystems.getDefault() .getPathMatcher(\"glob:**/*.&#123;tmp,txt&#125;\"); Files.walk(test) .filter(matcher::matches) .forEach(System.out::println); System.out.println(\"***************\"); PathMatcher matcher2 = FileSystems.getDefault() .getPathMatcher(\"glob:*.tmp\"); Files.walk(test) .map(Path::getFileName) .filter(matcher2::matches) .forEach(System.out::println); System.out.println(\"***************\"); Files.walk(test) // Only look for files .filter(Files::isRegularFile) .map(Path::getFileName) .filter(matcher2::matches) .forEach(System.out::println); &#125;&#125;/* Output:test\\bag\\foo\\bar\\baz\\5208762845883213974.tmptest\\bag\\foo\\bar\\baz\\File.txttest\\bar\\baz\\bag\\foo\\7918367201207778677.tmptest\\bar\\baz\\bag\\foo\\File.txttest\\baz\\bag\\foo\\bar\\8016595521026696632.tmptest\\baz\\bag\\foo\\bar\\File.txttest\\dir.tmptest\\foo\\bar\\baz\\bag\\5832319279813617280.tmptest\\foo\\bar\\baz\\bag\\File.txt***************5208762845883213974.tmp7918367201207778677.tmp8016595521026696632.tmpdir.tmp5832319279813617280.tmp***************5208762845883213974.tmp7918367201207778677.tmp8016595521026696632.tmp5832319279813617280.tmp*/ 在 matcher 中，glob 表达式开头的 **/ 表示“当前目录及所有子目录”，这在当你不仅仅要匹配当前目录下特定结尾的 Path 时非常有用。单 * 表示“任何东西”，然后是一个点，然后大括号表示一系列的可能性—我们正在寻找以 .tmp 或 .txt 结尾的东西。您可以在 getPathMatcher() 文档中找到更多详细信息。 matcher2 只使用 *.tmp，通常不匹配任何内容，但是添加 map() 操作会将完整路径减少到末尾的名称。 注意，在这两种情况下，输出中都会出现 dir.tmp，即使它是一个目录而不是一个文件。要只查找文件，必须像在最后 files.walk() 中那样对其进行筛选。 文件读写现在让我们看一下操纵文件本身的内容。 Files工具类 1package java.nio.file; 如果一个文件很“小”，也就是说“它运行得足够快且占用内存小”，那么 java.nio.file.Files 类中的实用程序将帮助你轻松读写文本和二进制文件。 Files.readAllLines() 一次读取整个文件（因此，“小”文件很有必要），产生一个List&lt;String&gt;。 1public static List&lt;String&gt; readAllLines(Path path, Charset cs) 默认使用utf-8字符集重载方法 123public static List&lt;String&gt; readAllLines(Path path) &#123; return readAllLines(path, StandardCharsets.UTF_8);&#125; Files.write() 被重载以写入 byte 数组或任何 Iterable 对象（它也有 Charset 选项）： 如果文件大小有问题怎么办？ 比如说： 文件太大，如果你一次性读完整个文件，你可能会耗尽内存。 您只需要在文件的中途工作以获得所需的结果，因此读取整个文件会浪费时间。 Files.lines() 方便地将文件转换为行的 Stream 对于示例文件，我们将重用streams/Cheese.dat： 123456789101112131415// files/ListOfLines.javaimport java.util.*;import java.nio.file.*;public class ListOfLines &#123; public static void main(String[] args) throws Exception &#123; Files.readAllLines( Paths.get(\"../streams/Cheese.dat\")) .stream() .filter(line -&gt; !line.startsWith(\"//\")) .map(line -&gt; line.substring(0, line.length()/2)) .forEach(System.out::println); &#125;&#125; 跳过注释行，其余的内容每行只打印一半。 这实现起来很简单：你只需将 Path 传递给 readAllLines() （以前的 java 实现这个功能很复杂）。 Files.write() 被重载以写入 byte 数组或任何 Iterable 对象（它也有 Charset 选项）： 1234567891011121314151617181920212223242526// files/Writing.javaimport java.util.*;import java.nio.file.*;public class Writing &#123; static Random rand = new Random(47); static final int SIZE = 1000; public static void main(String[] args) throws Exception &#123; // Write bytes to a file: byte[] bytes = new byte[SIZE]; rand.nextBytes(bytes); Files.write(Paths.get(\"bytes.dat\"), bytes); System.out.println(\"bytes.dat: \" + Files.size(Paths.get(\"bytes.dat\"))); // Write an iterable to a file: List&lt;String&gt; lines = Files.readAllLines( Paths.get(\"../streams/Cheese.dat\")); Files.write(Paths.get(\"Cheese.txt\"), lines); System.out.println(\"Cheese.txt: \" + Files.size(Paths.get(\"Cheese.txt\"))); &#125;&#125;/* Output:bytes.dat: 1000Cheese.txt: 199*/ 我们使用 Random 来创建一个随机的 byte 数组; 你可以看到生成的文件大小是 1000。 一个 List 被写入文件，任何 Iterable 对象也可以这么做。 如果文件大小有问题怎么办？ 比如说： 文件太大，如果你一次性读完整个文件，你可能会耗尽内存。 您只需要在文件的中途工作以获得所需的结果，因此读取整个文件会浪费时间。 Files.lines() 方便地将文件转换为行的 Stream： 1234567891011121314// files/ReadLineStream.javaimport java.nio.file.*;public class ReadLineStream &#123; public static void main(String[] args) throws Exception &#123; Files.lines(Paths.get(\"PathInfo.java\")) .skip(13) .findFirst() .ifPresent(System.out::println); &#125;&#125;/* Output: show(\"RegularFile\", Files.isRegularFile(p));*/ 这对本章中第一个示例代码做了流式处理，跳过 13 行，然后选择下一行并将其打印出来。 Files.lines() 对于把文件处理行的传入流时非常有用，但是如果你想在 Stream 中读取，处理或写入怎么办？这就需要稍微复杂的代码： 1234567891011121314151617181920// files/StreamInAndOut.javaimport java.io.*;import java.nio.file.*;import java.util.stream.*;public class StreamInAndOut &#123; public static void main(String[] args) &#123; try( Stream&lt;String&gt; input = Files.lines(Paths.get(\"StreamInAndOut.java\")); PrintWriter output = new PrintWriter(\"StreamInAndOut.txt\") ) &#123; input.map(String::toUpperCase) .forEachOrdered(output::println); &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 因为我们在同一个块中执行所有操作，所以这两个文件都可以在相同的 try-with-resources 语句中打开。PrintWriter 是一个旧式的 java.io 类，允许你“打印”到一个文件，所以它是这个应用的理想选择。如果你看一下 StreamInAndOut.txt，你会发现它里面的内容确实是大写的。 本章小结虽然本章对文件和目录操作做了相当全面的介绍，但是仍然有没被介绍的类库中的功能——一定要研究 java.nio.file 的 Javadocs，尤其是 java.nio.file.Files 这个类。 Java 7 和 8 对于处理文件和目录的类库做了大量改进。如果您刚刚开始使用 Java，那么您很幸运。在过去，它令人非常不愉快，我确信 Java 设计者以前对于文件操作不够重视才没做简化。对于初学者来说这是一件很棒的事，对于教学者来说也一样。我不明白为什么花了这么长时间来解决这个明显的问题，但不管怎么说它被解决了，我很高兴。使用文件现在很简单，甚至很有趣，这是你以前永远想不到的。 自己总结java跨平台文件分隔符1File.separator","categories":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/tags/Java/"},{"name":"OnJava8","slug":"OnJava8","permalink":"https://codeofli.github.io/tags/OnJava8/"}]},{"title":"SpringCloud实用篇02","slug":"java-note/SpringCloud/SpringCloud实用篇02","date":"2021-10-20T02:40:06.000Z","updated":"2021-10-31T05:22:03.641Z","comments":true,"path":"2021/10/java-note/SpringCloud/SpringCloud实用篇02/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/SpringCloud实用篇02/","excerpt":"SpringCloud实用篇020.学习目标2.Feign远程调用先来看我们以前利用RestTemplate发起远程调用的代码：存在下面的问题：•代码可读性差，编程体验不统一•参数复杂URL难以维护Feign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign","text":"SpringCloud实用篇020.学习目标2.Feign远程调用先来看我们以前利用RestTemplate发起远程调用的代码：存在下面的问题：•代码可读性差，编程体验不统一•参数复杂URL难以维护Feign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign 其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。 2.1.Feign替代RestTemplateFegin的使用步骤如下： 1）引入依赖我们在order-service服务的pom文件中引入feign的依赖： 12345&lt;!--feign客户端依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 2）添加注解在order-service的启动类添加注解开启Feign的功能： 1@EnableFeignClients 3）编写Feign的客户端在order-service中新建一个接口，内容如下： 123456789101112package cn.itcast.order.client;import cn.itcast.order.pojo.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(\"userservice\")public interface UserClient &#123; @GetMapping(\"/user/&#123;id&#125;\") User findById(@PathVariable(\"id\") Long id);&#125; 这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如： 服务名称：userservice 请求方式：GET 请求路径：/user/{id} 请求参数：Long id 返回值类型：User 这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。 4）测试修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate： 是不是看起来优雅多了。 5）总结使用Feign的步骤： ① 引入依赖 ② 添加@EnableFeignClients注解 ③ 编写FeignClient接口 ④ 使用FeignClient中定义的方法代替RestTemplate 2.2.自定义配置Feign可以支持很多的自定义配置，如下表所示： 类型 作用 说明 feign.Logger.Level 修改日志级别 包含四种不同的级别：NONE、BASIC、HEADERS、FULL feign.codec.Decoder 响应结果的解析器 http远程调用的结果做解析，例如解析json字符串为java对象 feign.codec.Encoder 请求参数编码 将请求参数编码，便于通过http请求发送 feign. Contract 支持的注解格式 默认是SpringMVC的注解 feign. Retryer 失败重试机制 请求失败的重试机制，默认是没有，不过会使用Ribbon的重试 一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。 平时建议用NONE或者BASIC，记录日志会消耗一定的性能 下面以日志为例来演示如何自定义配置。 2.2.1.配置文件方式基于配置文件修改feign的日志级别可以针对单个服务： 12345feign: client: config: userservice: # 针对某个微服务的配置 loggerLevel: FULL # 日志级别 也可以针对所有服务： 12345feign: client: config: default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置 loggerLevel: FULL # 日志级别 而日志的级别分为四种： NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 2.2.2.Java代码方式也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象： 123456public class DefaultFeignConfiguration &#123; @Bean public Logger.Level feignLogLevel()&#123; return Logger.Level.BASIC; // 日志级别为BASIC &#125;&#125; 如果要全局生效，将其放到启动类的@EnableFeignClients这个注解中： 1@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class) 如果是局部生效，则把它放到对应的@FeignClient这个注解中： 1@FeignClient(value = \"userservice\", configuration = DefaultFeignConfiguration .class) 2.3.Feign使用优化Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括： •URLConnection：默认实现，不支持连接池 •Apache HttpClient ：支持连接池 •OKHttp：支持连接池 因此提高Feign的性能主要手段就是使用连接池代替默认的URLConnection。 这里我们用Apache的HttpClient来演示。 1）引入依赖 在order-service的pom文件中引入Apache的HttpClient依赖： 12345&lt;!--httpClient的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置连接池 在order-service的application.yml中添加配置： 123456789feign: client: config: default: # default全局的配置 loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息 httpclient: enabled: true # 开启feign对HttpClient的支持 max-connections: 200 # 最大的连接数 max-connections-per-route: 50 # 每个路径的最大连接数 接下来，在FeignClientFactoryBean中的loadBalance方法中打断点： Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient： 如果上面操作完成后，未更新为Apache HttpClient，查看已经下载好对应依赖，有可能是Maven未加载对应的依赖，用maven reload一下project，重新加载对应依赖或可解决 总结，Feign的优化： 1.日志级别尽量用basic 2.使用HttpClient或OKHttp代替URLConnection ① 引入feign-httpClient依赖 ② 配置文件开启httpClient功能，设置连接池参数 2.4.最佳实践所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。 自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似： feign客户端： UserController： 有没有一种办法简化这种重复的代码编写呢？ 2.4.1.继承方式抽象客服端和服务端的共同方法到一个接口中 一样的代码可以通过继承来共享： 1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。 2）Feign客户端和Controller都集成该接口 官方不推荐使用 优点： 简单 实现了代码共享 缺点： 服务提供方、服务消费方紧耦合 参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解 2.4.2.抽取方式将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。 例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。 2.4.3.实现基于抽取的最佳实践1）抽取首先创建一个module，命名为feign-api： 项目结构： 在feign-api中然后引入feign的starter依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中 2）在order-service中使用feign-api首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。 在order-service的pom文件中中引入feign-api的依赖： 123456&lt;!--引入feign的统一api--&gt;&lt;dependency&gt; &lt;groupId&gt;cn.itcast.demo&lt;/groupId&gt; &lt;artifactId&gt;feign-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包 3）重启测试重启后，发现服务报错了： 这是因为UserClient现在在cn.itcast.feign.clients包下， 而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。 4）解决扫描包问题方式一： 指定Feign应该扫描的包： 1@EnableFeignClients(basePackages = \"cn.itcast.feign.clients\") 方式二： 指定需要加载的Client接口： 1@EnableFeignClients(clients = &#123;UserClient.class&#125;) 推荐用第二种 3.Gateway服务网关Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。 3.1.为什么需要网关Gateway网关是我们服务的守门神，所有微服务的统一入口。 网关的核心功能特性： 请求路由 权限控制 限流 架构图： 权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。 路由和负载均衡：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。 限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。 在SpringCloud中网关的实现包括两种： gateway zuul Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。 3.2.gateway快速入门下面，我们就演示下网关的基本路由功能。基本步骤如下： 创建SpringBoot工程gateway，引入网关依赖 编写启动类 编写基础配置和路由规则 启动网关服务进行测试 1）创建gateway服务，引入依赖创建服务： 引入依赖： 12345678910&lt;!--网关gateway依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 2）编写启动类123456789101112package cn.itcast.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 3）编写基础配置和路由规则创建application.yml文件，内容如下： 123456789101112131415server: port: 10010 # 网关端口spring: application: name: gateway # 服务名称 cloud: nacos: server-addr: localhost:8848 # nacos地址 gateway: routes: # 网关路由配置 - id: user-service # 路由id，自定义，只要唯一即可 # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址 uri: lb://userservice # 路由的目标地址 lb（LoadBalance）就是负载均衡，后面跟服务名称 predicates: # 路由断言，也就是判断请求是否符合路由规则的条件 - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求 我们将符合Path 规则的一切请求，都代理到 uri参数指定的地址。 本例中，我们将 /user/**开头的请求，代理到lb://userservice，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。 注意：gateway中配置rui的useservice和自己声明的服务名称一致，否则可能发生网管不能访问，但单独访问一个服务（ip）是可行的 4）重启测试重启网关，访问http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果： 5）网关路由的流程图整个访问的流程如下： 总结： 网关搭建步骤： 创建项目，引入nacos服务发现和gateway依赖 配置application.yml，包括服务基本信息、nacos地址、路由 路由配置包括： 路由id：路由的唯一标示 路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡 路由断言（predicates）：判断路由的规则， 路由过滤器（filters）：对请求或响应做处理 接下来，就重点来学习路由断言和路由过滤器的详细知识 3.3.断言工厂我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件 例如Path=/user/**是按照路径匹配，这个规则是由 org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来 处理的，像这样的断言工厂在SpringCloudGateway还有十几个: 官方文档有案例 https://docs.spring.io/spring-cloud-gateway/docs/3.0.4-SNAPSHOT/reference/html/#gateway-request-predicates-factories 名称 说明 示例 After 是某个时间点后的请求 - After=2037-01-20T17:42:47.789-07:00[America/Denver] Before 是某个时间点之前的请求 - Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai] Between 是某两个时间点之前的请求 - Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver] Cookie 请求必须包含某些cookie - Cookie=chocolate, ch.p Header 请求必须包含某些header - Header=X-Request-Id, \\d+ Host 请求必须是访问某个host（域名） - Host=.somehost.org,.anotherhost.org Method 请求方式必须是指定方式 - Method=GET,POST Path 请求路径必须符合指定规则 - Path=/red/{segment},/blue/** Query 请求参数必须包含指定参数 - Query=name, Jack或者- Query=name RemoteAddr 请求者的ip必须是指定范围 - RemoteAddr=192.168.1.1/24 Weight 权重处理 我们只需要掌握Path这种路由工程就可以了。 3.4.过滤器工厂GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理： 3.4.1.路由过滤器的种类Spring提供了31种不同的路由过滤器工厂。例如： https://docs.spring.io/spring-cloud-gateway/docs/3.0.4-SNAPSHOT/reference/html/#gatewayfilter-factories 名称 说明 AddRequestHeader 给当前请求添加一个请求头 RemoveRequestHeader 移除请求中的一个请求头 AddResponseHeader 给响应结果中添加一个响应头 RemoveResponseHeader 从响应结果中移除有一个响应头 RequestRateLimiter 限制请求的流量 3.4.2.请求头过滤器下面我们以AddRequestHeader 为例来讲解。 需求：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome! 只需要修改gateway服务的application.yml文件，添加路由过滤即可： 12345678910spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** filters: # 过滤器 - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头 当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。 3.4.3.默认过滤器如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下： 12345678910spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** default-filters: # 默认过滤项 - AddRequestHeader=Truth, Itcast is freaking awesome! 3.4.4.总结过滤器的作用是什么？ ① 对路由的请求或响应做加工处理，比如添加请求头 ② 配置在路由下的过滤器只对当前路由的请求生效 defaultFilters的作用是什么？ ① 对所有路由都生效的过滤器 3.5.全局过滤器上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。 3.5.1.全局过滤器作用全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。 定义方式是实现GlobalFilter接口。 12345678910public interface GlobalFilter &#123; /** * 处理当前请求，有必要的话通过&#123;@link GatewayFilterChain&#125;将请求交给下一个过滤器处理 * * @param exchange 请求上下文，里面可以获取Request、Response等信息 * @param chain 用来把请求委托给下一个过滤器 * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束 */ Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);&#125; 在filter中编写自定义逻辑，可以实现下列功能： 登录状态判断 权限校验 请求限流等 3.5.2.自定义全局过滤器需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件： 参数中是否有authorization， authorization参数值是否为admin 如果同时满足则放行，否则拦截 实现： 在gateway中定义一个过滤器： 12345678910111213141516171819202122232425262728293031package cn.itcast.gateway.filters;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;@Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 1.获取请求参数 MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams(); // 2.获取authorization参数 String auth = params.getFirst(\"authorization\"); // 3.校验 if (\"admin\".equals(auth)) &#123; // 放行 return chain.filter(exchange); &#125; // 4.拦截 // 4.1.禁止访问，设置状态码 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); // 4.2.结束处理 return exchange.getResponse().setComplete(); &#125;&#125; 3.5.3.过滤器执行顺序请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter 请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器： 排序的规则是什么呢？ 每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。 GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定 路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。 当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。 详细内容，可以查看源码： org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。 org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链 3.6.跨域问题3.6.1.什么是跨域问题跨域：域名不一致就是跨域，主要包括： 域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com 域名相同，端口不同：localhost:8080和localhost:8081 跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题 解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看https://www.ruanyifeng.com/blog/2016/04/cors.html CORS是一个W3C标准，全称是“跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 3.6.2.模拟跨域问题找到课前资料的页面文件： 放入tomcat或者nginx这样的web服务器中，启动并访问。 可以安装npm，再安装live-server，再执行 1live-server --port 8090 live-server一款npm工具，全局npm i -g live-server后，项目目录使用live-server命令行命令便可直接在浏览器中预览（默认找index.html，其他请自行带上文件名空格后跟在后面），并且自动全局监听实时更新。 可以在浏览器控制台看到下面的错误： 从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。 3.6.3.解决跨域问题在gateway服务的application.yml文件中，添加下面的配置： 12345678910111213141516171819spring: cloud: gateway: # 。。。 globalcors: # 全局的跨域处理 add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题 corsConfigurations: '[/**]': #/**表示拦截一切请求 allowedOrigins: # 允许哪些网站的跨域请求 - \"http://localhost:8090\" allowedMethods: # 允许的跨域ajax的请求方式 - \"GET\" - \"POST\" - \"DELETE\" - \"PUT\" - \"OPTIONS\" allowedHeaders: \"*\" # 允许在请求中携带的头信息 allowCredentials: true # 是否允许携带cookie maxAge: 360000 # 这次跨域检测的有效期","categories":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/tags/Java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://codeofli.github.io/tags/SpringCloud/"}]},{"title":"SpringCloud01","slug":"java-note/SpringCloud/SpringCloud01","date":"2021-09-12T02:40:06.000Z","updated":"2021-10-31T05:20:40.375Z","comments":true,"path":"2021/09/java-note/SpringCloud/SpringCloud01/","link":"","permalink":"https://codeofli.github.io/2021/09/java-note/SpringCloud/SpringCloud01/","excerpt":"SpringCloud011.认识微服务随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？1.0.学习目标了解微服务架构的优缺点微服务技术栈1.1.单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。单体架构的优缺点如下：","text":"SpringCloud011.认识微服务随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？1.0.学习目标了解微服务架构的优缺点微服务技术栈1.1.单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。单体架构的优缺点如下： 优点： 架构简单 部署成本低 缺点： 耦合度高（维护困难、升级困难） 1.2.分布式架构分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。 分布式架构的优缺点： 优点： 降低服务耦合 有利于服务升级和拓展 缺点： 服务调用关系错综复杂 分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考： 服务拆分的粒度如何界定？ 服务之间如何调用？ 服务的调用关系如何管理？ 人们需要制定一套行之有效的标准来约束分布式架构。 1.3.微服务微服务的架构特征： 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责 自治：团队独立、技术独立、数据独立，独立部署和交付 面向服务：服务提供统一标准的接口，与语言和技术无关 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题 微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。 因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 。 但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。 其中在Java领域最引人注目的就是SpringCloud提供的方案了。 1.4.SpringCloudSpringCloud是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。 SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。 其中常见的组件包括： 另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下： 我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。 1.5.总结 单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统 分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝 微服务：一种良好的分布式架构方案 ①优点：拆分粒度更小、服务更独立、耦合度更低 ②缺点：架构非常复杂，运维、监控、部署难度提高 SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件 2.服务拆分和远程调用任何分布式架构都离不开服务的拆分，微服务也是一样。 2.1.服务拆分原则这里我总结了微服务拆分时的几个原则： 不同微服务，不要重复开发相同业务 微服务数据独立，不要访问其它微服务的数据库 微服务可以将自己的业务暴露为接口，供其它微服务调用 2.2.服务拆分示例以课前资料中的微服务cloud-demo为例，其结构如下： cloud-demo：父工程，管理依赖 order-service：订单微服务，负责订单相关业务 user-service：用户微服务，负责用户相关业务 要求： 订单微服务和用户微服务都必须有各自的数据库，相互独立 订单服务和用户服务都对外暴露Restful的接口 订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库 2.2.1.导入demo工程用IDEA导入课前资料提供的Demo： 项目结构如下： 导入后，会在IDEA右下角出现弹窗： 点击弹窗，然后按下图选择： 会出现这样的菜单： 配置下项目使用的JDK： 2.3.实现远程调用案例在order-service服务中，有一个根据id查询订单的接口： 根据id查询订单，返回值是Order对象，如图： 其中的user为null 在user-service中有一个根据id查询用户的接口： 查询的结果如图： 2.3.1.案例需求：修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。 因此，我们需要在order-service中 向user-service发起一个http的请求，调用http://localhost:8081/user/{userId}这个接口。 大概的步骤是这样的： 注册一个RestTemplate的实例到Spring容器 修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User 将查询的User填充到Order对象，一起返回 2.3.2.注册RestTemplate首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例： 123456789101112131415161718192021package cn.itcast.order;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@MapperScan(\"cn.itcast.order.mapper\")@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 2.3.3.实现远程调用修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法： 2.4.提供者与消费者在服务调用关系中，会有两个不同的角色： 服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务） 服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口） 但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。 如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？ 对于A调用B的业务而言：A是服务消费者，B是服务提供者 对于B调用C的业务而言：B是服务消费者，C是服务提供者 因此，服务B既可以是服务提供者，也可以是服务消费者。 3.Eureka注册中心假如我们的服务提供者user-service部署了多个实例，如图： 大家思考几个问题： order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？ 有多个user-service实例地址，order-service调用时该如何选择？ order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？ 3.1.Eureka的结构和作用这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下： 回答之前的各个问题。 问题1：order-service如何得知user-service实例地址？ 获取地址信息的流程如下： user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册 eureka-server保存服务名称到服务实例地址列表的映射关系 order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取 问题2：order-service如何从多个user-service实例中选择具体的实例？ order-service从实例列表中利用负载均衡算法选中一个实例地址 向该实例地址发起远程调用 问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？ user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳 当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除 order-service拉取服务时，就能将故障实例排除了 注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端 总结 因此，接下来我们动手实践的步骤包括： 3.2.搭建eureka-server首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务 3.2.1.创建eureka-server服务在cloud-demo父工程下，创建一个子模块： 填写模块信息： 然后填写服务信息：eureka-server 3.2.2.引入eureka依赖引入SpringCloud为eureka提供的starter依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 3.2.3.编写启动类给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能： 12345678910111213package cn.itcast.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 3.2.4.编写配置文件编写一个application.yml文件，内容如下： 123456789server: port: 10086spring: application: name: eureka-servereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 3.2.5.启动服务启动微服务，然后在浏览器访问：http://127.0.0.1:10086 看到下面结果应该是成功了： 3.3.服务注册下面，我们将user-service注册到eureka-server中去。 1）引入依赖在user-service的pom文件中，引入下面的eureka-client依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置文件在user-service中，修改application.yml文件，添加服务名称、eureka地址： 1234567spring: application: name: userservice # user服务的服务名称eureka: client: service-url: # eureka的地址信息 defaultZone: http://127.0.0.1:10086/eureka 3）启动多个user-service实例为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。 首先，复制原来的user-service启动配置： 然后，在弹出的窗口中，填写信息： 现在，SpringBoot窗口会出现两个user-service启动配置： 不过，第一个是8081端口，第二个是8082端口。 启动两个user-service实例： 查看eureka-server管理页面： 总结 3.4.服务发现下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。 1）引入依赖之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。 在order-service的pom文件中，引入下面的eureka-client依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置文件服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息： 在order-service中，修改application.yml文件，添加服务名称、eureka地址： 123456789server: port: 10086 # 服务端口spring: application: name: eurekaserver # eureka的服务名称eureka: client: service-url: # eureka的地址信息 defaultZone: http://127.0.0.1:10086/eureka 3）服务拉取和负载均衡最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。 不过这些动作不用我们去做，只需要添加一些注解即可。 在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解： 修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口： spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。 总结 4.Ribbon负载均衡上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？ 4.1.负载均衡原理SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。 那么我们发出的请求明明是http://userservice/user/1，怎么变成了http://localhost:8081的呢？ 4.2.源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。 我们进行源码跟踪： 1）LoadBalancerInterceptor 可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事： request.getURI()：获取请求uri，本例中就是 http://user-service/user/8 originalUri.getHost()：获取uri路径的主机名，其实就是服务id，user-service this.loadBalancer.execute()：处理服务id，和用户请求。 这里的this.loadBalancer是LoadBalancerClient类型，我们继续跟入。 2）LoadBalancerClient继续跟入execute方法： 代码是这样的： getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。 getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务 放行后，再次访问并跟踪，发现获取的是8081： 果然实现了负载均衡。 3）负载均衡策略IRule在刚才的代码中，可以看到获取服务使通过一个getServer方法来做负载均衡: 我们继续跟入： 继续跟踪源码chooseServer方法，发现这么一段代码： BaseLoadBalancer 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 RoundRobin轮询（调度） 到这里，整个负载均衡的流程我们就清楚了。 4）总结SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下： 基本流程如下： 拦截我们的RestTemplate请求http://userservice/user/1 RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表 eureka返回列表，localhost:8081、localhost:8082 IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081 RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到http://localhost:8081/user/1，发起真实请求 4.3.负载均衡策略4.3.1.负载均衡策略负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类： 不同规则的含义如下： 内置负载均衡规则类 规则描述 RoundRobinRule 简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。 AvailabilityFilteringRule 对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的..ActiveConnectionsLimit属性进行配置。 WeightedResponseTimeRule 为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。 ZoneAvoidanceRule 以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。 BestAvailableRule 忽略那些短路的服务器，并选择并发数较低的服务器。 RandomRule 随机选择一个可用的服务器。 RetryRule 重试机制的选择逻辑 默认的实现就是ZoneAvoidanceRule，是一种轮询方案 4.3.2.自定义负载均衡策略通过定义IRule实现可以修改负载均衡规则，有两种方式： 代码方式：在order-service中的OrderApplication类中，定义一个新的IRule： 1234@Beanpublic IRule randomRule()&#123; return new RandomRule();&#125; 这个针对全体服务 配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则： 123userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 这个针对某一个服务userservice 注意，一般用默认的负载均衡规则，不做修改。 4.4.饥饿加载Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。 而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载： 12345ribbon: eager-load: enabled: true # 开启饥饿加载 clients: # 指定饥饿加载的服务名称 - userservice 总结 5.Nacos注册中心国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。 5.1.认识和安装NacosNacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。 安装方式可以参考课前资料《Nacos安装指南.md》 5.2.服务注册到nacosNacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。 主要差异在于： 依赖不同 服务地址不同 1）引入依赖在cloud-demo父工程的pom文件中的&lt;dependencyManagement&gt;中引入SpringCloudAlibaba的依赖： 12345678&lt;!--nacos的管理依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 然后在user-service和order-service中的pom文件中引入nacos-discovery依赖： 12345&lt;!--nacos的配置管理依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 注意：不要忘了注释掉eureka的依赖。 2）配置nacos地址在user-service和order-service的application.yml中添加nacos地址： 1234spring: cloud: nacos: server-addr: localhost:8848 #nacos服务地址 注意：不要忘了注释掉eureka的地址 3）重启重启微服务后，登录nacos管理页面，可以看到微服务信息： 总结 5.3.服务分级存储模型一个服务可以有多个实例，例如我们的user-service，可以有: 127.0.0.1:8081 127.0.0.1:8082 127.0.0.1:8083 假如这些实例分布于全国各地的不同机房，例如： 127.0.0.1:8081，在上海机房 127.0.0.1:8082，在上海机房 127.0.0.1:8083，在杭州机房 Nacos就将同一机房内的实例 划分为一个集群。 也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图： 微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如： 杭州机房内的order-service应该优先访问同机房的user-service。 5.3.1.给user-service配置集群修改user-service的application.yml文件，添加集群配置： 123456spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ # 集群名称 重启两个user-service实例后，我们可以在nacos控制台看到下面结果： 我们再次复制一个user-service启动配置，添加属性： 1-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH 配置如图所示： 启动UserApplication3后再次查看nacos控制台： 总结 5.3.2.同集群优先的负载均衡失败https://www.bilibili.com/video/BV1LQ4y127n4?p=20默认的ZoneAvoidanceRule并不能实现根据同集群优先来实现负载均衡。 因此Nacos中提供了一个NacosRule的实现，可以优先从同集群中挑选实例。 1）给order-service配置集群信息 修改order-service的application.yml文件，添加集群配置： 123456spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ # 集群名称 2）修改负载均衡规则 修改order-service的application.yml文件，修改负载均衡规则： 123userservice: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 代码方式：在order-service中的OrderApplication类中，定义一个新的IRule： 1234@Beanpublic IRule randomRule()&#123; return new NacosRule();&#125; 这个针对全体服务 成功 5.4.权重配置实际部署中会出现这样的场景： 服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。 但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。 因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。 在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重： 在弹出的编辑窗口，修改权重： 注意：如果权重修改为0，则该实例永远不会被访问 5.5.环境隔离Nacos提供了namespace来实现环境隔离功能。 nacos中可以有多个namespace namespace下可以有group、service等 不同namespace之间相互隔离，例如不同namespace的服务互相不可见 5.5.1.创建namespace默认情况下，所有service、data、group都在同一个namespace，名为public： 我们可以点击页面新增按钮，添加一个namespace： 然后，填写表单： 就能在页面看到一个新的namespace： 5.5.2.给微服务配置namespace给微服务配置namespace只能通过修改配置来实现。 例如，修改order-service的application.yml文件： 1234567spring: cloud: nacos: server-addr: localhost:8848 #nacos服务地址 discovery: cluster-name: HZ # 集群名称 namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID 重启order-service后，访问控制台，可以看到下面的结果： 此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错： 5.6.Nacos与Eureka的区别Nacos的服务实例分为两种l类型： 临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。 非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。 配置一个服务实例为永久实例： 12345spring: cloud: nacos: discovery: ephemeral: false # 设置为非临时实例，是否是临时实例 Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异： 总结 Nacos与eureka的共同点 都支持服务注册和服务拉取 都支持服务提供者心跳方式做健康检测 Nacos与Eureka的区别 Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式 临时实例心跳不正常会被剔除，非临时实例则不会被剔除 Nacos支持服务列表变更的消息推送模式，服务列表更新更及时，eureka时效性就相对而言比较差 Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式 1.Nacos配置管理Nacos除了可以做注册中心，同样可以做配置管理来使用。 1.1.统一配置管理当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。 Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。 1.1.1.在nacos中添加配置文件如何在nacos中管理配置呢？ 然后在弹出的表单中，填写配置信息： 注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。 1.1.2.从微服务拉取配置微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。 但如果尚未读取application.yml，又如何得知nacos地址呢？ 因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下： 1）引入nacos-config依赖 首先，在user-service服务中，引入nacos-config的客户端依赖： 12345&lt;!--nacos配置管理依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 2）添加bootstrap.yaml 然后，在user-service中添加一个bootstrap.yaml文件，内容如下： 12345678910spring: application: name: userservice # 服务名称 profiles: active: dev #开发环境，这里是dev cloud: nacos: server-addr: localhost:8848 # Nacos地址 config: file-extension: yaml # 文件后缀名 这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据 ${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}作为文件id，来读取配置。 本例中，就是去读取userservice-dev.yaml： 服务名称-开发环境.文件后缀名 3）读取nacos配置 在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置： 完整代码： 1234567891011121314151617181920212223242526272829package cn.itcast.user.web;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(\"/user\")public class UserController &#123; @Autowired private UserService userService; @Value(\"$&#123;pattern.dateformat&#125;\") private String dateformat; @GetMapping(\"now\") public String now()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)); &#125; // ...略&#125; 在页面访问，可以看到效果： 1.2.配置热更新我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是配置热更新。 要实现配置热更新，可以使用两种方式： 1.2.1.方式一在@Value注入的变量所在类上添加注解@RefreshScope： 1.2.2.方式二使用@ConfigurationProperties注解代替@Value注解。 注:在使用@ConfigurationProperties时不需要@RefreshScope，推荐使用这种方式 在user-service服务中，添加一个类，读取patterrn.dateformat属性： 123456789101112package cn.itcast.user.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@Data@ConfigurationProperties(prefix = \"pattern\")public class PatternProperties &#123; private String dateformat;&#125; 在UserController中使用这个类代替@Value： 完整代码： 123456789101112131415161718192021222324252627282930313233package cn.itcast.user.web;import cn.itcast.user.config.PatternProperties;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(\"/user\")public class UserController &#123; @Autowired private UserService userService; @Autowired private PatternProperties patternProperties; @GetMapping(\"now\") public String now()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat())); &#125; // 略&#125; 1.3.配置共享其实微服务启动时，会去nacos读取多个配置文件，例如： [spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml [spring.application.name].yaml，例如：userservice.yaml 而[spring.application.name].yaml不包含环境，因此可以被多个环境共享。 下面我们通过案例来测试配置共享 1）添加一个环境共享配置我们在nacos中添加一个userservice.yaml文件： 2）在user-service中读取共享配置在user-service服务中，修改PatternProperties类，读取新添加的属性： 在user-service服务中，修改UserController，添加一个方法： 3）运行两个UserApplication，使用不同的profile修改UserApplication2这个启动项，改变其profile值： 这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。 启动UserApplication和UserApplication2 访问http://localhost:8081/user/prop，结果： 访问http://localhost:8082/user/prop，结果： 可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。 4）配置共享的优先级当nacos、服务本地同时出现相同属性时，优先级有高低之分： bug：注：如果没能读取到nacos的共享配置，重启nacos可解决 1.4.搭建Nacos集群Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档： nacos集群搭建.md https://www.bilibili.com/video/BV1LQ4y127n4?p=29","categories":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/tags/Java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://codeofli.github.io/tags/SpringCloud/"}]},{"title":"Markdown","slug":"markdown/markdown","date":"2020-10-13T14:19:09.000Z","updated":"2021-10-31T01:53:34.003Z","comments":true,"path":"2020/10/markdown/markdown/","link":"","permalink":"https://codeofli.github.io/2020/10/markdown/markdown/","excerpt":"[TOC]常用语法展示目录(table of contents)结构1[toc]链接 和html一样能使用相对路径12[对象传递和返回](./Appendix-Passing-and-Returning-Objects.md)[百度](www.baidu.com) 多级标题123456一级标题 # + space二级 ## +space 三级### + ...","text":"[TOC]常用语法展示目录(table of contents)结构1[toc]链接 和html一样能使用相对路径12[对象传递和返回](./Appendix-Passing-and-Returning-Objects.md)[百度](www.baidu.com) 多级标题123456一级标题 # + space二级 ## +space 三级### + ... 列表有序列表 你好 1.space 你好 -+space 得到 insert code 1234567```javapublic class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello &quot;); &#125;&#125;other使用notepad++增加markdown换行typora产生的markdown文件通常没有换行,及两个空格， 可以使用notepad++或者word、进行替换，将\\r\\n替换为两个空格+\\r\\n markdown如何跳转到文本内的指定位置知道用的是typora就好办了，有官方的说明： https://support.typora.io/Lin… 12345678# title.........[link](#title) jump to title 注：要按住ctrl点击那个link 也可参考Typora中实现内部跳转 pdf转markdownpdf -&gt; word -&gt; typora导入word文件，图片自己解决 三. 页面内跳转MarkDown中是通过定义链接的方式来定义跳转的，在这里，跳转也称为锚点，跳转的目标称为锚点目标； 所以，在 MarkDown 中实现页面内跳转的方法就是：定义一个 锚点目标 和 对应的 锚点 ，用户点击 锚点 便可跳转到对应的 锚点目标 位置处； 锚点 和 锚点目标 的定义格式如下： 1. 锚点的定义锚点就是一个链接，另外，由于在MarkDown中可以直接写HTML，所以在MarkDown中实现锚点有两种方式：MarkDown方式 和 HTML方式； 1.1 MarkDown锚点MarkDown锚点本质上就是一个MarkDown链接，只是链接地址的格式为： 1链接地址 = #目标内容 所以 MarkDown锚点 的定义也有两种方式 行内式语法： 1锚点 = [内容](#目标内容 \"标题\") 说明： 标题 是可选的，可以用单引号 或 双引号； 转换成HTML后，会生成如下标签： 1&lt;a href=\"#目标内容\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： 1[MarkDown方式的锚点](#MarkDown锚点) 渲染成HTML后，会生成如下标签： 1&lt;a href=\"#MarkDown锚点\" &gt;MarkDown方式的锚点&lt;/a&gt; 效果如下：点击下面的锚点 [MarkDown方式的锚点](###1.1 MarkDown锚点) 作者：科研者链接：https://www.jianshu.com/p/4898c2e9a36d","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://codeofli.github.io/tags/Markdown/"}]},{"title":"Axios","slug":"js-note/axios/axios","date":"2020-10-13T14:19:09.000Z","updated":"2021-10-31T01:14:05.066Z","comments":true,"path":"2020/10/js-note/axios/axios/","link":"","permalink":"https://codeofli.github.io/2020/10/js-note/axios/axios/","excerpt":"[TOC]axios的全局配置常见配置选项，具体可看官网封装axiosaxios使用封装接口1234567891011request(&#123; url: '/p/getProblemSet/'+index&#125;).then( res =&gt;&#123; console.log(res); &#125;).catch( err =&gt;&#123; console.log(err) &#125;)","text":"[TOC]axios的全局配置常见配置选项，具体可看官网封装axiosaxios使用封装接口1234567891011request(&#123; url: '/p/getProblemSet/'+index&#125;).then( res =&gt;&#123; console.log(res); &#125;).catch( err =&gt;&#123; console.log(err) &#125;) Parameters与Data的区别:实际上就是GET和POST区别; 我们知道GET请求的参数都是在URL上的，服务器并不会读取http body里面的数据,这样我们传递的就是Params里的请求的参数了；如果想让服务器读取http body里面的数据那就需要用POST请求了，POST请求的参数就存放在body； 以后如果是GET请求最好是在parameters里面设置，而POST请求就在Body Data里面设置. axios接收图片1234567891011121314151617181920212223242526getVerifyImage() &#123; request(&#123; url: \"/verify/image\", method: \"get\", responseType: \"arraybuffer\" &#125;) .then(response =&gt; &#123; //将从后台获取的图片流进行转换 return ( \"data:image/png;base64,\" + btoa( new Uint8Array(response.data).reduce( (data, byte) =&gt; data + String.fromCharCode(byte), \"\" ) ) ); &#125;) .then(res =&gt; &#123; console.log(res); this.verifiedImg = res; &#125;) .catch(err =&gt; &#123; console.log(err); &#125;);&#125; axios跨域需要在默认实例添加 1withCredentials: true 123456const instance = axios.create(&#123; baseURL: process.env.VUE_APP_BASE_API, timeout: 5000, // 请求的超时时间 // `withCredentials` 表示跨域请求时是否需要使用凭证，允许携带cookie withCredentials: true, // default false&#125;) https://segmentfault.com/a/1190000011811117 axios上传文件","categories":[],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://codeofli.github.io/tags/Axios/"}]},{"title":"nginx","slug":"nginx/nginx","date":"2019-11-25T14:22:09.000Z","updated":"2021-10-30T02:35:54.405Z","comments":true,"path":"2019/11/nginx/nginx/","link":"","permalink":"https://codeofli.github.io/2019/11/nginx/nginx/","excerpt":"[TOC]nginxhttp://nginx.org/en/docs/http/ngx_http_proxy_module.html#example1、 nginx 简介（1） 什么是 nginx 和可以做什么事情（2） 正向代理（3） 反向代理（4） 动静分离2、 Nginx 的安装（1） 在 linux 系统中安装 nginx 3、 Nginx 的常用命令和配置文件","text":"[TOC]nginxhttp://nginx.org/en/docs/http/ngx_http_proxy_module.html#example1、 nginx 简介（1） 什么是 nginx 和可以做什么事情（2） 正向代理（3） 反向代理（4） 动静分离2、 Nginx 的安装（1） 在 linux 系统中安装 nginx 3、 Nginx 的常用命令和配置文件 4、 Nginx 配置实例 1 反向代理 5、 Nginx 配置实例 2 负载均衡 6、 Nginx 配置实例 3 动静分离 7、 Nginx 的高可用集群 （1） nginx 配置主从模式 （2） nginx 配置双主模式 Nginx 的简介什么是 nginxNginx 是高性能的 HTTP 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。 2、正向代理Nginx不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。正向代理：如果把局域网外的Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet ，则需要通过代理服务器来访问，这种代理服务就称为正向代理。 需要在==客户端配置代理服务器==进行指定网站访问 3、反向代理暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。 代理服务器 反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。 4、负载均衡增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 5、动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 Nginx 的安装Nginx 安装配置|菜鸟教程 进入 nginx 官网，下载 https://nginx.org/en/download.html 1.安装 pcre一般放在 /usr/src中 1wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz 第二步 解压压缩文件使用命令 1tar -xvf pcre-8.37.tar.gz 3、进入安装包目录 1cd pcre-8.37 4、编译安装 12./configuremake &amp;&amp; make install 4.1make install报错 12345678910111213[cevent@hadoop213 pcre-8.37]$ make installmake install-ammake[1]: Entering directory `/opt/module/pcre-8.37'make[2]: Entering directory `/opt/module/pcre-8.37' /bin/mkdir -p '/usr/local/lib' /bin/sh ./libtool --mode=install /usr/bin/install -c libpcre.la libpcreposix.la libpcrecpp.la '/usr/local/lib'libtool: install: /usr/bin/install -c .libs/libpcre.so.1.2.5 /usr/local/lib/libpcre.so.1.2.5/usr/bin/install: cannot create regular file `/usr/local/lib/libpcre.so.1.2.5': Permission denied 没有附权make[2]: *** [install-libLTLIBRARIES] 错误 1make[2]: Leaving directory `/opt/module/pcre-8.37'make[1]: *** [install-am] 错误 2make[1]: Leaving directory `/opt/module/pcre-8.37'make: *** [install] 错误 2 【解决】 12345678910111213141516[cevent@hadoop213 pcre-8.37]$ sudo chown -R cevent:cevent /usr/local/ 修改权限，需要在usr/local下创建相关目录[cevent@hadoop213 pcre-8.37]$ make install 安装make install-ammake[1]: Entering directory `/opt/module/pcre-8.37'make[2]: Entering directory `/opt/module/pcre-8.37' /bin/mkdir -p '/usr/local/lib' /bin/sh ./libtool --mode=install /usr/bin/install -c libpcre.la libpcreposix.la libpcrecpp.la '/usr/local/lib'libtool: install: /usr/bin/install -c .libs/libpcre.so.1.2.5 /usr/local/lib/libpcre.so.1.2.5……ln -sf pcre_utf32_to_host_byte_order.3 /usr/local/share/man/man3/pcre32_utf32_to_host_byte_order.3ln -sf pcre_version.3 /usr/local/share/man/man3/pcre32_version.3make[3]: Leaving directory `/opt/module/pcre-8.37'make[2]: Leaving directory `/opt/module/pcre-8.37'make[1]: Leaving directory `/opt/module/pcre-8.37'[cevent@hadoop213 pcre-8.37]$ pcre-config --version 查看版本号8.37 5、查看pcre版本 1pcre-config --version 2 ）安装 openssl 、 zlib 、 gcc 依赖 centos 1yum -y install make zlib zlib devel gcc c++ libtool openssl openssl devel ubuntu https://blog.csdn.net/z920954494/article/details/52132125 3 ）安装 nginx 使用命令解压 1tar -xvf nginx-1.20.2.tar.gz 12./configuremake &amp;&amp; make install 进入目录 /usr/local/nginx/sbin/nginx 启动服务 12cd /usr/local/nginx/sbin/./nginx nginx默认监听80端口，直接在浏览器中访问ip地址即可 1234server &#123; listen 80; ...&#125; 在 window s 系统中访问 linu x 中 nginx ，默认不能访问的，因为防火墙问题 1 ）关闭防火墙 2 ）开放访问的端口号 80 端口 查看开放的端口号 firewall cmd list all 设置开放的端口号 firewall cmd add service=http permanentfirewall cmd add port=80/tcp permanent 重启防火墙 firewall cmd reload Nginx 的常用的命令1export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 首先要进入nginx 目录中 1cd /usr/local/nginx/sbin 注意 自己安装的 为 ./nginx 1/usr/local/nginx/sbin/nginx 命令 描述 nginx -h 查看Nginx的帮助 nginx -v 查看Nginx的版本 nginx -t 测试Nginx的配置 nginx -T 测试Nginx的配置，并打印配置信息 nginx 启动nginx nginx -s reload 重新加载配置文件，平滑启动nginx nginx -s stop 停止nginx的命令 Nginx 的配置文件nginx 配置文件位置用apt-get或者yum安装都是/etc,与源码安装的/usr/local/nginx/conf/nginx.conf不一样 配置文件中的内容包含三部分内容 1.全局块：从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。 比如worker_processes 1;处理并发数的配置 2.events 块events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。 比如worker_connections 1024; 支持的最大连接数为 1024 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。 3.http 块还包含两部分：http 全局块server 块 这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http全局块、server 块。 http 全局块http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 server 块这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 location 块。 1、全局 server 块 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。 2、location 块 一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 具体事例123456server &#123; listen 8080; root /data/up1; location / &#123; &#125;&#125; root 指令放在 server 上下文中。当响应请求的 location 区块中，没有自己的 root 指令，上述的 root 指令才会被使用。 反向代理nginx 配置实例 反向代理1代理端口 ip:80 -&gt; localhost:8080 1、实现效果 （1）打开浏览器，在浏览器地址栏输入地址 www.123.com，跳转到liunx 系统tomcat 主页 面中 2.准备工作 1）在liunx 系统安装tomcat，使用默认端口8080 tomcat 安装文件放到liunx 系统中，解压 进入tomcat 的bin 目录中，./startup.sh 启动tomcat 服务器 （2）对外开放访问的端口 3）在windows 系统中通过浏览器访问tomcat 服务器 3、访问过程的分析 4、具体配置 第一步 在windows 系统的host 文件进行域名和ip 对应关系的配置 C:\\Windows\\System32\\drivers\\etc目录下的hosts文件文末添加一行 1106.54.94.80 www.123.com 第二步 在nginx 进行请求转发的配置（反向代理配置） 在server组中的location中添加一行 1proxy_pass http://127.0.0.1:8080; 12345678server &#123; location / &#123; root html; proxy_pass http://127.0.0.1:8080; index index.html index.htm; &#125; ...&#125; Nginx 配置实例-反向代理实例 2实现效果： 使用 nginx 反向代理， 根据访问的路径跳转到不同端口的服务中 nginx 监听端口为 80 访问 http://127.0.0.1/edu/ 直接跳转到 127.0.0.1:8080 访问 http://127.0.0.1/vod/ 直接跳转到 127.0.0.1:8081 2 、准备工作 1 ）准备两个 tomcat 服务器，一个 8080 端口，一个 8081 端口 2 ）创建文件夹和测试页面 放在webapps目录下即可 3 、具体配置 1 ）找到 nginx 配置文件，进行反向代理配置 2 ）开放对外访问的端口号 9001 8080 8081 1234567891011 server &#123; listen 80; server_name localhost; location ~ /edu/ &#123; proxy_pass http://127.0.0.1:8080; &#125; location ~ /vod/ &#123; proxy_pass http://127.0.0.1:8081; &#125;&#125; location 指令说明该指令用于匹配 URL。 语法如下： 1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。 2、~：用于表示 uri 包含正则表达式，并且区分大小写。 3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。 4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。 Nginx 配置实例-负载均衡1 、实现效果 1 ）浏览器地址栏输入地址 http://192.168. 17.129/edu/a.html ，负载均衡效果，平均 8080和 8081 端口中 2 、准备工作 1 ）准备两台 tomcat 服务器，一台 8080 ，一台 8081 2 ）在两台 tomcat 里面 webapps 目录中，创建名称是 edu 文件夹，在 edu 文件夹中创建页面 a.html ，用于测试 3 、在 nginx 的配置文件中进行负载均衡的配置 12345678910111213141516171819upstream myserver&#123; server localhost:8080; server localhost:8081; &#125; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://myserver; root html; index index.html index.htm; &#125; &#125; 负载均衡随着互联网信息的爆炸性增长，负载均衡（load balance ）已经不再是一个很陌生的话题顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品，很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎，nginx 就是其中的一个，在 linux 下有 Nginx 、 LVS 、 Haproxy 等等服务可以提供负载均衡服务，而且 Nginx 提供了几种分配方式 策略 1、轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 2、weightweight代表权 重默认为 1, 权重越高被分配的客户端越多 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如： 1234upstream server_pool&#123; server 192.168.5.21 weight=10; server 192.168.5.22 weight=10; &#125; 3、ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如： 12345upstream server_pool&#123; ip_hash; server 192.168.5.21:80; server 192.168.5.22:80; &#125; 4、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 1234upstream server_pool&#123; server 192.168.5.21:80; server 192.168.5.22:80; fair; &#125; Nginx 配置实例-动静分离1 、什么是动静分离 Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx 处理静态页面，Tomcat处理动态页面。动静分离从目前实现角度来讲大致分为两种， 一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案； 另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。 通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。 2 、准备工作 1 ）在 liunx 系统中准备静态资源，用于进行访问 在根目录创建data文件件 3 、具体配置 1 ）在 nginx 配置文件中进行配置 123456789location /www/ &#123; root /data/; index index.html index.htm;&#125;location /image/ &#123; root /data/; autoindex on;&#125; Nginx 配置高可用的集群 https://www.bilibili.com/video/av68136734?p=14 myngx_http_proxy_module Nginx出现403 forbiddenhttps://blog.csdn.net/qq_35843543/article/details/81561240/ 1.2将nginx.config的user改为和启动用户一致， 1#user nobody; croshttps://blog.csdn.net/envon123/article/details/83270277 在相应后端服务url中（location）添加 1234567891011add_header 'Access-Control-Allow-Origin' $http_origin;add_header 'Access-Control-Allow-Credentials' 'true';add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';add_header 'Access-Control-Allow-Headers' 'DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range';if ($request_method = 'OPTIONS') &#123; add_header 'Access-Control-Max-Age' 1728000; add_header 'Content-Type' 'text/plain; charset=utf-8'; add_header 'Content-Length' 0; return 204;&#125; vue修改配置文件主要做两件事： 把Nginx服务器的默认路径改成我们项目所在的路径。 如果你的vue工程用的路由是history模式，需要将客户端发来的url重定向到默认的index.html，才能正常访问。否则只能看到主页。刷新或点击其他页面都会404。 在配置文件中的server里如下修改。 12345location / &#123; root /home/CRExpress/www; try_files $uri $uri/ /index.html last; index index.html;&#125; root后面的地址是项目上传的路径。try_files是添加到index的映射。 123456location / &#123; root /home/ubuntu/static; proxy_pass http://127.0.0.1:8080; try_files $uri $uri/ /index.html last; index index.html index.htm;&#125; 部署前后端分离项目https://segmentfault.com/a/1190000014972747 在前后端分离端项目里，前端的代码会被打包成为纯静态文件。使用 Nginx的目的就是让静态文件运行起服务，由于后端的接口也是分离的，直接请求可能会产生跨域问题，此时就需要Nginx转发代理后端接口。 Nginx配置如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto; #启动进程error_log /var/log/nginx/error.log; #全局错误日志pid /run/nginx.pid; #PID文件# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024; #单个后台worker process进程的最大并发链接数 &#125;http &#123; gzip on; #开启gzip压缩 gzip_min_length 1k; #设置对数据启用压缩的最少字节数 gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 6; #设置数据的压缩等级,等级为1-9，压缩比从小到大 gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; #设置需要压缩的数据格式 gzip_vary on; #虚拟主机配置 server &#123; listen 80; server_name mark.binlive.cn; root /home/spa-project/dist; #定义服务器的默认网站根目录位置 index index.html; #定义index页面 error_page 404 /index.html; #将404错误页面重定向到index.html可以解决history模式访问不到页面问题 location ^~ /api/&#123; proxy_pass http://127.0.0.1:7000; proxy_send_timeout 1800; proxy_read_timeout 1800; proxy_connect_timeout 1800; client_max_body_size 2048m; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $http_host; # required for docker client's sake proxy_set_header X-Real-IP $remote_addr; # pass on real client's IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; location ^~ /auth/&#123; proxy_pass http://127.0.0.1:7000; proxy_send_timeout 1800; proxy_read_timeout 1800; proxy_connect_timeout 1800; client_max_body_size 2048m; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $http_host; # required for docker client's sake proxy_set_header X-Real-IP $remote_addr; # pass on real client's IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; &#125; &#125; 将前端代码打包后的dist文件放入指定服务目录 将服务目录指定到spa-project/dist目录下即可代理静态服务 配置里开启了gzip压缩，可以很大程度上减小文件体积大小 将404错误页面重定向到index.html，可以解决前端history路由模式由于刷新页面访问不到服务出现404的问题 location为代理接口，可以转发代理后端的请求接口域名或者ip，即可解决接口跨域问题 Nginx 配置高可用的集群 2、配置高可用的准备工作 （1）需要两台服务器 192.168.17.129 和 192.168.17.131 在两台服务器安装 nginx 在两台服务器安装 keepalived 3、在两台服务器安装 keepalived 使用 yum 命令进行安装 yum install keepalived –y 安装之后，在 etc 里面生成目录 keepalived，有文件 keepalived.conf 4、完成高可用配置（主从配置） （1）修改/etc/keepalived/keepalivec.conf 配置文件 global_defs { notification_email { &#97;&#x63;&#97;&#x73;&#x73;&#x65;&#110;&#64;&#102;&#x69;&#114;&#x65;&#x77;&#x61;&#x6c;&#108;&#46;&#x6c;&#x6f;&#x63; &#x66;&#x61;&#105;&#x6c;&#111;&#x76;&#101;&#x72;&#64;&#102;&#x69;&#x72;&#101;&#119;&#x61;&#x6c;&#x6c;&#46;&#x6c;&#111;&#99; &#115;&#x79;&#115;&#97;&#x64;&#109;&#105;&#x6e;&#x40;&#102;&#105;&#114;&#x65;&#x77;&#97;&#108;&#x6c;&#46;&#108;&#111;&#99; } notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.17.129 smtp_connect_timeout 30 router_id LVS_DEVEL } vrrp_script chk_http_port { script “/usr/local/src/nginx_check.sh” interval 2 #（检测脚本执行的间隔） weight 2 } vrrp_instance VI_1 { state BACKUP # 备份服务器上将 MASTER 改为 BACKUP interface ens33 //网卡 virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同 priority 90 # 主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 Nginx 的原理 2、worker 如何进行工作的 3、一个 master 和多个 woker 有好处 可以使用 nginx –s reload 热部署，利用 nginx 进行热部署操作 每个 woker 是独立的进程，如果有其中的一个woker 出现问题，其他 woker 独立的， 继续进行争抢，实现请求过程，不会造成服务中断 4、设置多少个 woker 合适 安装ssl证书腾讯云安装教程 记得开放相应的端口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970server &#123; listen 443 ssl; server_name www.yestojudge.cn; #启用 SSL 功能 # ssl on; deprecated #证书文件名称 ssl_certificate 1_www.yestojudge.cn_bundle.crt; #私钥文件名称 ssl_certificate_key 2_www.yestojudge.cn.key; ssl_session_timeout 5m; #请按照以下协议配置 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; root /home/ubuntu/static; location ^~ /api/&#123; proxy_pass http://127.0.0.1:8080; &#125; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /home/ubuntu/static/; proxy_pass http://127.0.0.1:8080; try_files $uri $uri/ /index.html last; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; server &#123; listen 80; #填写绑定证书的域名 server_name www.yestojudge.cn; #把http的域名请求转成https rewrite ^(.*)$ https://www.yestojudge.cn:443$1 permanent; &#125; 开启gziphttps://blog.csdn.net/huangbaokang/article/details/79931429 加入gzip配置在nginx.conf文件的http模块中加入gzip的配置 1234567891011121314151617181920212223242526272829303132333435363738[root@localhost html]# cat ../conf/nginx.confuser root;worker_processes 4;worker_rlimit_nofile 65535;events &#123; worker_connections 65535;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; #开启gzip gzip_min_length 1k; #低于1kb的资源不压缩 gzip_comp_level 3; #压缩级别【1-9】，越大压缩率越高，同时消耗cpu资源也越多，建议设置在4左右。 gzip_types text/plain application/javascript application/x-javascript text/javascript text/xml text/css; #需要压缩哪些响应类型的资源，多个空格隔开。不建议压缩图片，下面会讲为什么。 gzip_disable \"MSIE [1-6]\\.\"; #配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持） gzip_vary on; #是否添加“Vary: Accept-Encoding”响应头 server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 可以看到相应头带上了Content-Encoding:gzip标识，说明gzip压缩起效果了。 gzip虽然好用，但是一下类型的资源不建议启用。 1、图片类型 原因：图片如jpg、png本身就会有压缩，所以就算开启gzip后，压缩前和压缩后大小没有多大区别，所以开启了反而会白白的浪费资源。（Tips：可以试试将一张jpg图片压缩为zip，观察大小并没有多大的变化。虽然zip和gzip算法不一样，但是可以看出压缩图片的价值并不大） 2、大文件 原因：会消耗大量的cpu资源，且不一定有明显的效果。 显著减少,vue只是支持gzip,开启需要服务器进行 windowshttps://blog.csdn.net/u010648555/article/details/79418779 为了方便本地的开发和验证，于是Windows上安装Nginx 注意不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程。[参考博文1]在nginx.exe目录，打开命令行工具，用命令 启动 1.进入解压的目标,我的 E:\\nginx-1.13.92.执行启动命令 ，有一个一闪而过的效果！ 1start nginx.exe 六 简单的一些启动、关闭服务命令介绍 在nginx.exe目录，打开命令行工具，用命令 启动/关闭/重启nginx command name start nginx 启动 : 关闭nginx： nginx -s quit ：完整有序的停止nginx 名称 命令启动nginx start nginx修改配置后重新加载生效 nginx -s reload重新打开日志文件 nginx -s reopen测试nginx配置文件是否正确 nnginx -t -c nginx.conf关闭nginx ：快速停止nginx nginx -s stop完整有序的停止nginx nginx -s quit","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"python","slug":"python/python/python","date":"2019-11-22T13:14:50.000Z","updated":"2021-10-23T02:19:04.269Z","comments":true,"path":"2019/11/python/python/python/","link":"","permalink":"https://codeofli.github.io/2019/11/python/python/python/","excerpt":"[TOC]关于pyhton Python语言是通用语言 Python语言是脚本语言 Python语言是开源语言 Python语言是跨平台语言 Python语言是多模型语言Python语言创立者:Guido van Rossum2002年，Python 2.x2008年，Python 3.x 注：变量命名主要采用下划线规则","text":"[TOC]关于pyhton Python语言是通用语言 Python语言是脚本语言 Python语言是开源语言 Python语言是跨平台语言 Python语言是多模型语言Python语言创立者:Guido van Rossum2002年，Python 2.x2008年，Python 3.x 注：变量命名主要采用下划线规则 python基础语法程序的格式框架代码高亮：编程的色彩辅助体系，不是语法要求 缩进一行代码开始前的空白区域，表达程序的格式框架 缩进表达程序的格式框架 严格明确：缩进是语法的一部分，缩进不正确程序运行错误 所属关系：表达代码间包含和层次关系的唯一手段 长度一致：程序内一致即可，一般用 4 个空格或 1 个 TAB 注释用于提高代码可读性的辅助性文字，不被执行 不被程序执行的辅助性说明信息 单行注释：以 开头，其后内容为注释 1#这里是单行注释 多行注释 ：以 开头和结尾 12''' 这是多行注释第一行这是多行注释第二行 ''' 命名与保留字变量程序中用于保存和表示数据的占位符号 变量采用标识符(名字) 来表示，关联标识符的过程叫命名 可以使用等号(=)向变量赋值或修改值，=被称为赋值符号 命名关联标识符的过程命名规则: 大小写字母、数字、下划线和中文等字符及组合 注意事项: 大小写敏感、首字符不能是数字、不与保留字相同 保留字被编程语言内部定义并保留使用的标识符 Python语言有35个保留字(也叫关键字) Python语言有35个保留字(也叫关键字) if 是保留字，If 是变量 分支语法条件判断用于条件组合的三个保留字 操作符及使用 描述 x and y 两个条件x和y的逻辑与 x or y 两个条件x和y的逻辑或 not x 条件x的逻辑非 操作符 数学符号 描述 &lt; &lt; 小于 &lt;= ≤ 小于等于 &gt;= ≥ 大于等于 &gt; &gt; 大于 == = 等于 ！ = ≠ 不等于 1if &lt;condition&gt;: &lt;statement&gt; special： 1if not bool: statementd 二分支紧凑形式 1&lt;statement&gt; if &lt;condition&gt; else &lt;statement&gt; 多分支 注意 是elif，不是else if 1234567if &lt;条件1&gt; :&lt;语句块1&gt;elif &lt;条件2&gt; :&lt;语句块2&gt;……else :&lt;语句块N&gt; 循环结构遍历某个结构形成的循环运行方式 从遍历结构中逐一提取元素，放在循环变量中 12for &lt;循环变量&gt; in &lt;遍历结构&gt; : &lt;语句块&gt; 由保留字for和in组成，完整遍历所有元素后结束 每次循环，所获得元素放入循环变量，并执行一次语句块 计数循环(N次) 遍历由range()函数产生的数字序列，产生循环 range(N) 产生的序列，左闭右开，即[0,N) 12for i in range(N) : &lt;语句块&gt; 字符串遍历循环 s是字符串，遍历字符串每个字符，产生循环 12for c in s : &lt;语句块&gt; 123&gt;&gt;&gt; for c in \"Python123\":print(c, end=\",\")P,y,t,h,o,n,1,2,3, ls是一个列表， 遍历其每个元素，产生循环 12345for item in ls : &lt;语句块&gt;&gt;&gt;&gt; for item in [123, \"PY\", 456] :print(item, end=\",\")123,PY,456, 文件遍历循环 fi是一个文件标识符，遍历其每行，产生循环 12for line in fi : &lt;语句块&gt; while由条件控制的循环运行方式 反复执行语句块，直到条件不满足时结束 12while &lt;条件&gt; : &lt;语句块&gt; 循环控制保留字break 和 continue break跳出并结束当前整个循环，执行循环后的语句 continue结束当次循环，继续执行后续次数循环 break和continue可以与for和while循环搭配使用 循环的扩展(else)循环与else 当循环没有被break语句退出时，执行else语句块 else语句块作为”正常”完成循环的奖励 这里else的用法与异常处理中else用法相似 123456789while &lt;条件&gt; : &lt;语句块1&gt;else : &lt;语句块2&gt;for &lt;变量&gt; in &lt;遍历结构&gt; : &lt;语句块1&gt;else : &lt;语句块2&gt; 12345678910111213141516&gt;&gt;&gt; for c in \"PYTHON\" :if c == \"T\" :continueprint(c, end=\"\")else:print(\"正常退出\")PYHON正常退出&gt;&gt;&gt; for c in \"PYTHON\" : if c == \"T\" : break print(c, end=\"\")else:print(\"正常退出\")PY import库import:使用库名调用12import &lt;libaryName&gt;import &lt;libaryName&gt; as &lt;alias&gt; form:能直接调用函数当我们使用from * 的时候，会取得模块顶层左右赋值的变量名的拷贝。 123from 库 import 函数名from 库 import *&lt;functionName&gt;(argc) 输入输出print()以字符串形式向控制台输出的函数 1print(&#123;&#125;.format()) &#123;&#125;表示槽，后续format()填入 1234title = \"a+b\"print('%s %d insert!!!!!!' % (title, 5))title = \"a+b\"print('%s insert!!!!!!' % title) input()1input([prompt]) 在一行输入多个数字 1a, b, c, d = map(int, input().split()) 函数的定义与使用函数的定义函数是一段代码的表示 函数是一段具有特定功能的、可重用的语句组 函数是一种功能的抽象，一般函数表达特定功能 两个作用：降低编程难度和代码复用 123def&lt;函数名&gt;(&lt;参数(0个或多个)&gt;): &lt;函数体&gt; return&lt;返回值&gt; 函数的调用调用是运行函数代码的方式 调用时要给出实际参数 实际参数替换定义中的参数 函数调用后得到返回值 可选参数传递函数定义时可以为某些参数指定默认值，构成可选参数 123def&lt;函数名&gt;(&lt;非可选参数&gt;,&lt;可选参数&gt;): &lt;函数体&gt; return&lt;返回值&gt; 例如： 12345def fact(n,m=1) : s = 1 foriinrange(1, n+1): s *= i return s//m 可变参数传递123def &lt;函数名&gt; (&lt;参数&gt;, *b): &lt;函数体&gt; return &lt;返回值&gt; 例如 1234567def fact(n, *b) : s = 1 for i in range(1, n+1): s *= i for item in b: s *= item return s 函数的返回值函数可以返回0个或多个结果 return保留字用来传递返回值 函数可以有返回值，也可以没有，可以有return，也可以没有 return可以传递0个返回值，也可以传递任意多个返回值 局部变量和全局变量规则1: 局部变量和全局变量是不同变量 局部变量是函数内部的占位符，与全局变量可能重名但不同 函数运算结束后，局部变量被释放 可以使用global保留字在函数内部使用全局变量 1234567n, s = 10, 100def fact(n) : global s #fact()函数中使用global保留字声明此处s是全局变量s for i in range(1, n+1): s *= i return sprint(fact(n), s) 123运行结果&gt;&gt;&gt;362880000 362880000 规则2: 局部变量为组合数据类型且未创建，等同于全局变量 123456ls = [\"F\", \"f\"] #通过使用[]真实创建了一个全局变量列表lsdef func(a) : ls.append(a) #此处ls是列表类型，未真实创建则等同于全局变量 returnfunc(\"C\") #局部变量ls被修改print(ls) 123运行结果&gt;&gt;&gt;['F', 'f'] 使用规则 基本数据类型，无论是否重名，局部变量与全局变量不同 可以通过global保留字在函数内部声明全局变量 组合数据类型，如果局部变量未真实创建，则是全局变量 lambda函数lambda函数返回函数名作为结果 lambda函数是一种匿名函数，即没有名字的函数 使用lambda保留字定义，函数名是返回结果 lambda函数用于定义简单的、能够在一行内表示的函数 1&lt;函数名&gt; = lambda&lt;参数&gt; : &lt;表达式&gt; 等价于 123def &lt;函数名&gt; (&lt;参数&gt;): &lt;函数体&gt; return &lt;返回值&gt; 定义文件编码Defining Python Source Code Encodings Defining the Encoding Python will default to ASCII as standard encoding if no other encoding hints are given. To define a source code encoding, a magic comment must be placed into the source files either as first or second line in the file, such as: 1# coding=&lt;encoding name&gt; or (using formats recognized by popular editors): 12#!/usr/bin/python# -*- coding: &lt;encoding name&gt; -*- or: 12#!/usr/bin/python# vim: set fileencoding=&lt;encoding name&gt; : 12#!/usr/bin/python# -*- coding: utf-8 -*- 基本数据类型及其操作判断变量类型12345import typesif type(text) is types.StringType: ....type(x) == types(1) # 判断是否int 类型type(x) == type('a') #是否string类型 数字类型整数类型注：python 中不支持 a++ 和 ++a 与数学中整数的概念一致 可正可负，没有取值范围限制 pow(x,y)函数：计算 xy，想算多大算多大1234pow(2,100)1267650600228229401496703205376pow(2,pow(2,15))1415461031044954789001553…… 4种进制表示形式 十进制： 1010, 99, -217 二进制，以0b或0B开头： 0b010, -0B101 八进制，以0o或0O开头： 0o123, -0O456 十六进制，以0x或0X开头： 0x9a, -0X89 浮点数类型与数学中实数的概念一致 带有小数点及小数的数字 浮点数取值范围和小数精度都存在限制，但常规计算可忽略 取值范围数量级约-10307至10308，精度数量级10-16 浮点数间运算存在不确定尾数，不是bug 12340.1 + 0.30.40.1 + 0.20.30000000000000004 #不确定尾数 round(x, d)：对x四舍五入， d是小数截取位数 浮点数间运算与比较用round()函数辅助 不确定尾数一般发生在10-16左右， round()十分有效 浮点数可以采用科学计数法表示 使用字母e或E作为幂的符号，以10为基数，格式如下：e 表示 a*10b 例如： 4.3e-3 值为0.0043 9.6E5 值为960000.0 复数类型与数学中复数的概念一致如果x2 = -1，那么x的值是什么？ 定义 j = -𝟏𝟏 ，以此为基础，构建数学体系 a+bj 被称为复数，其中， a是实部， b是虚部 复数实例z = 1.23e-4+5.6e+89j 实部是什么？ z.real 获得实部 虚部是什么？ z.imag 获得虚部 数值运算操作符操作符是完成运算的一种符号体系 操作符及使用 描述 x + y 加， x与y之和 x – y 减， x与y之差 x * y 乘， x与y之积 x / y 除， x与y之商 10/3结果是3.3333333333333335 x // y 整数除， x与y之整数商 10//3结果是3 + x x本身 - y x的负值 x % y 余数，模运算 10%3结果是1 x ** y 幂运算， x的y次幂， x^y;当y是小数时，开方运算10**0.5结果是 增强操作符及使用 描述 x op= y 即 x = x op y，其中， op为二元操作符 x op= y x += y x -= y x = y x /= y x //= y x %= y x *= y x op= y &gt;&gt;&gt; x = 3.1415 &gt;&gt;&gt; x *= 3 与 x = x *3 等价 31.006276662836743 数字类型的关系类型间可进行混合运算，生成结果为”最宽”类型 三种类型存在一种逐渐”扩展”或”变宽”的关系： 整数 -&gt; 浮点数 -&gt; 复数 例如： 123 + 4.0 = 127.0 (整数+浮点数 = 浮点数) 数值运算函数一些以函数形式提供的数值运算功能 函数及使用 描述 abs(x) 绝对值， x的绝对值 abs(-10.01) 结果为 10.01 divmod(x,y) 商余， (x//y, x%y)，同时输出商和余数 divmod(10, 3) 结果为 (3, 1) pow(x, y[, z]) 幂余， (x**y)%z， [..]表示参数z可省略 pow(3, pow(3, 99), 10000) 结果为 4587 round(x[, d]) 四舍五入， d是保留小数位数，默认值为 round(-10.123, 2) 结果为 -10.12 max(x1,x2, … ,xn) 最大值，返回x1,x2, … ,xn中的最大值， n不限 max(1, 9, 5, 4, 3) 结果为 9 min(x1,x2, … ,xn) 最小值，返回x1,x2, … ,xn中的最小值， n不限 min(1, 9, 5, 4, 3) 结果为 1 int(x) 将x变成整数，舍弃小数部分 int(123.45) 结果为123； int(“123”) 结果为123 float(x) 将x变成浮点数，增加小数部分 float(12) 结果为12.0； float(“1.23”) 结果为1.23 complex(x) 将x变成复数，增加虚数部分 complex(4) 结果为 4 + 0j 字符串由0个或多个字符组成的有序字符序列-字符串是字符的有序序列，可以对其中的字符进行索引 1\"请\"是\"请输入带有符号的温度值: \"的第0个字符 字符串有2类共4种表示方法-由一对单引号或双引号表示，仅表示单行字符串 1\"请输入带有符号的温度值: \"或者'C' -由一对三单引号或三双引号表示，可表示多行字符串 12'''Python语言''' 三引号是多行注释 字符串的序号正向递增序号和反向递减序号 字符串的使用使用[ ]获取字符串中一个或多个字符 索引：返回字符串中单个字符 &lt;字符串&gt;[M] 1\"请输入带有符号的温度值: \"[0]或者TempStr[-1] 切片：返回字符串中一段字符子串 &lt;字符串&gt;[M: N] 1\"请输入带有符号的温度值: \"[1:3]或者TempStr[0:-1] 使用[M:N: K]根据步长(K)对字符串切片 &lt;字符串&gt;[M: N]，M缺失表示至开头，N缺失表示至结尾 1\"〇一二三四五六七八九十\"[:3]结果是\"〇一二\" &lt;字符串&gt;[M: N: K]，根据步长K对字符串切片 12\"〇一二三四五六七八九十\"[1:8:2] 结果是\"一三五七\"\"〇一二三四五六七八九十\"[::-1] 结果是\"十九八七六五四三二一〇\" 字符串的特殊字符 转义符\\ 转义符表达特定字符的本意 1\"这里有个双引号(\\\")\"结果为这里有个双引号(\") 转义符形成一些组合，表达一些不可打印的含义 1\"\\b\"回退\"\\n\"换行(光标移动到下行首)\"\\r\"回车(光标移动到本行首) 字符串操作符 操作符及使用 描述 x+ y 连接两个字符串x和y n *x 或x *n 复制n次字符串x x in s 如果x是s的子串，返回True，否则返回False 字符串处理函数 函数及使用 描述 len(x) 长度，返回字符串x的长度len(“一二三456”) 结果为6 str(x) 任意类型x所对应的字符串形式str(1.23)结果为”1.23”str([1,2])结果为”[1,2]” hex(x)或oct(x) 整数x的十六进制或八进制小写形式字符串hex(425)结果为”0x1a9”oct(425)结果为”0o651” chr(u) x为Unicode编码，返回其对应的字符 ord(x) x为字符，返回其对应的Unicode编码 Unicode编码 统一字符编码，即覆盖几乎所有字符的编码方式 从0到1114111(0x10FFFF)空间，每个编码对应一个字符 Python字符串中每个字符都是Unicode编码字符 字符串处理方法 方法及使用 描述 str.lower()或str.upper() 返回字符串的副本，全部字符小写/大写“AbCdEfGh”.lower()结果为”abcdefgh” str.split(sep=None) 返回一个列表，由str根据sep被分隔的部分组成“A,B,C”.split(“,”)结果为[‘A’,’B’,’C’] str.count(sub) 返回子串sub在str中出现的次数“an apple a day”.count(“a”)结果为4 str.replace(old, new) 返回字符串str副本，所有old子串被替换为new“python”.replace(“n”,”n123.io”)结果为“python123.io” str.center(width[,fillchar]) 字符串str根据宽度width居中，fillchar可选&quot;python&quot;.center(20,&quot;=&quot;)结果为&lt;br/&gt;&#39;=======python=======&#39; str.strip(chars) 从str中去掉在其左侧和右侧chars中列出的字符 str.join(iter) 在iter变量除最后元素外每个元素后增加一个str“,”.join(“12345”)结果为“1,2,3,4,5”#主要用于字符串分隔等 字符串类型的格式化格式化是对字符串进行格式表达的方式 字符串格式化使用.format()方法，用法如下： 1&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;) format()方法的格式控制槽内部对格式化的配置方式 1&#123; &lt;参数序号&gt; ：&lt;格式控制标记&gt;&#125; ： &lt;填充&gt; &lt;对齐&gt; &lt;宽度&gt; &lt;,&gt; &lt;.精度&gt; &lt;类型&gt; 引导符号 用于填充的单个字符 &lt; 左对齐&gt; 右对齐^ 居中对齐 槽设定的输出宽度 数字的千位分隔符 浮点数小数精度或字符串最大输出长度 整数类型b, c, d, o, x, X浮点数类型e, E, f, % 123456789101112&gt;&gt;&gt;\"&#123;0:=^20&#125;\".format(\"PYTHON\")'=======PYTHON======='&gt;&gt;&gt;\"&#123;0:*&gt;20&#125;\".format(\"BIT\")'*****************BIT'&gt;&gt;&gt;\"&#123;:10&#125;\".format(\"BIT\")'BIT '&gt;&gt;&gt;\"&#123;0:,.2f&#125;\".format(12345.6789)'12,345.68'&gt;&gt;&gt;\"&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;\".format(425)'110101001,Ʃ,425,651,1a9,1A9'&gt;&gt;&gt;\"&#123;0:e&#125;,&#123;0:E&#125;,&#123;0:f&#125;,&#123;0:%&#125;\".format(3.14)'3.140000e+00,3.140000E+00,3.140000,314.000000%' 序列类型iteratorIterator Types 序列是一个基类类型 序列类型定义序列是具有先后关系的一组元素 序列是一维元素向量，元素类型可以不同 类似数学元素序列：s0, s1, … , sn-1 元素间由序号引导，通过下标访问序列的特定元素 ![1573915049023](python/Iterator Types.png) 序列处理函数及方法6个操作符 操作符及应用 描述 x in s 如果x是序列s的元素，返回True，否则返回False x not in s 如果x是序列s的元素，返回False，否则返回True s + t 连接两个序列s和t s*n 或n*s 将序列s复制n次 s[i] 索引，返回s中的第i个元素，i是序列的序号 s[i: j]或s[i: j: k] 切片，返回序列s中第i到j以k为步长的元素子序列 5个函数和方法 函数和方法 描述 len(s) 返回序列s的长度，即元素个数 min(s) 返回序列s的最小元素，s中元素需要可比较 max(s) 返回序列s的最大元素，s中元素需要可比较 s.index(x) 或s.index(x, i,j) 返回序列s从i开始到j位置中第一次出现元素x的位置 s.count(x) 返回序列s中出现x的总次数 元组类型定义元组是序列类型的一种扩展 元组是一种序列类型，一旦创建就不能被修改 使用小括号() 或tuple() 创建，元素间用逗号, 分隔 可以使用或不使用小括号 12def func(): return1,2 123456&gt;&gt;&gt;creature = \"cat\", \"dog\",\"tiger\",\"human\"&gt;&gt;&gt;creature('cat', 'dog', 'tiger', 'human')&gt;&gt;&gt;color = (0x001100, \"blue\", creature)&gt;&gt;&gt;color(4352, 'blue', ('cat', 'dog', 'tiger', 'human')) 元组类型操作 元组继承了序列类型的全部通用操作 -元组因为创建后不能修改，因此没有特殊操作 列表类型列表是序列类型的一种扩展，十分常用 列表是一种序列类型，创建后可以随意被修改 使用方括号[] 或list() 创建，元素间用逗号, 分隔 列表中各元素类型可以不同，无长度限制 列表类型操作函数和方法 函数或方法 描述 ls[i] = x 替换列表ls第i元素为x ls[i: j: k]= lt 用列表lt替换ls切片后所对应元素子列表 del ls[i] 删除列表ls中第i元素 del ls[i: j: k] 删除列表ls中第i到第j以k为步长的元素 ls += lt 更新列表ls，将列表lt元素增加到列表ls中 ls *= n 更新列表ls，其元素重复n次 ls.append(x) 在列表ls最后增加一个元素x ls.clear() 删除列表ls中所有元素 ls.copy() 生成一个新列表，赋值ls中所有元素 ls.insert(i,x) 在列表ls的第i位置增加元素x ls.pop(i) 将列表ls中第i位置元素取出并删除该元素 ls.remove(x) 将列表ls中出现的第一个元素x删除 ls.reverse() 将列表ls中的元素反转 集合类型集合是多个元素的无序组合 集合类型与数学中的集合概念一致 集合元素之间无序，每个元素唯一，不存在相同元素 集合元素不可更改，不能是可变数据类型 为什么？ 集合用大括号 {} 表示，元素间用逗号分隔 建立集合类型用 {} 或 set() 建立空集合类型，必须使用set() 123456&gt;&gt;&gt; A = &#123;\"python\", 123, (\"python\",123)&#125; #使用&#123;&#125;建立集合&#123;123, 'python', ('python', 123)&#125;&gt;&gt;&gt; B = set(\"pypy123\") #使用set()建立集合&#123;'1', 'p', '2', '3', 'y'&#125;&gt;&gt;&gt; C = &#123;\"python\", 123, \"python\",123&#125;&#123;'python', 123&#125; 集合操作符 操作符及应用 描述 S | T 并，返回一个新集合，包括在集合S和T中的所有元素 S - T 差，返回一个新集合，包括在集合S但不在T中的元素 S &amp; T 交，返回一个新集合，包括同时在集合S和T中的元素 S ^ T 补，返回一个新集合，包括集合S和T中的非相同元素 S &lt;= T 或 S &lt; T 返回True/False，判断S和T的子集关系 S &gt;= T 或 S &gt; T 返回True/False，判断S和T的包含关系 S |= T 并，更新集合S，包括在集合S和T中的所有元素 S -= T 差，更新集合S，包括在集合S但不在T中的元素 S &amp;= T 交，更新集合S，包括同时在集合S和T中的元素 S ^= T 补，更新集合S，包括集合S和T中的非相同元素 123456789101112&gt;&gt;&gt; A = &#123;\"p\", \"y\" , 123&#125;&gt;&gt;&gt; B = set(\"pypy123\")&gt;&gt;&gt; A-B&#123;123&#125;&gt;&gt;&gt; B-A&#123;'3', '1', '2'&#125;&gt;&gt;&gt; A&amp;B&#123;'p', 'y'&#125;&gt;&gt;&gt; A|B&#123;'1', 'p', '2', 'y', '3', 123&#125;&gt;&gt;&gt; A^B&#123;'2', 123, '3', '1'&#125; 集合处理方法 S.add(x) 如果x不在集合S中，将x增加到S S.discard(x) 移除S中元素x，如果x不在集合S中，不报错 S.remove(x) 移除S中元素x，如果x不在集合S中，产生KeyError异常 S.clear() 移除S中所有元素 S.pop() 随机返回S的一个元素，更新S，若S为空产生KeyError异常 S.copy() 返回集合S的一个副本 len(S) 返回集合S的元素个数 x in S 判断S中元素x， x在集合S中，返回True，否则返回False x not in S 判断S中元素x， x不在集合S中，返回True，否则返回False set(x) 将其他类型变量x转变为集合类型 1234567891011121314&gt;&gt;&gt; A = &#123;\"p\", \"y\" , 123&#125;&gt;&gt;&gt; for item in A:print(item, end=\"\")p123y&gt;&gt;&gt; A&#123;'p', 123, 'y'&#125;&gt;&gt;&gt; try:while True:print(A.pop(), end=\"\"))except:passp123y&gt;&gt;&gt; Aset() 集合类型应用场景包含关系比较 1234\"p\" in &#123;\"p\", \"y\" , 123&#125;True&#123;\"p\", \"y\"&#125; &gt;= &#123;\"p\", \"y\" , 123&#125;False 数据去重：集合类型所有元素无重复 12345&gt;&gt;&gt; ls = [\"p\", \"p\", \"y\", \"y\", 123]&gt;&gt;&gt; s = set(ls) # 利用了集合无重复元素的特点&#123;'p', 'y', 123&#125;&gt;&gt;&gt; lt = list(s) # 还可以将集合转换为列表['p', 'y', 123] 字典类型及操作字典类型定义字典类型是“映射”的体现 映射是一种键(索引)和值(数据)的对应 键值对：键是数据索引的扩展 字典是键值对的集合，键值对之间无序 采用大括号{}和dict()创建，键值对用冒号: 表示{&lt;键1&gt;:&lt;值1&gt;, &lt;键2&gt;:&lt;值2&gt;, … , &lt;键n&gt;:&lt;值n&gt;} 在字典变量中，通过键获得值&lt;字典变量&gt; = {&lt;键1&gt;:&lt;值1&gt;, … , &lt;键n&gt;:&lt;值n&gt;}&lt;值&gt; = &lt;字典变量&gt;[&lt;键&gt;][ ] 用来向字典变量中索引或增加元素 1&lt;字典变量&gt;[&lt;键&gt;] = &lt;值&gt; 123456789&gt;&gt;&gt; d = &#123;\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"&#125;&gt;&gt;&gt; d&#123;'中国': '北京', '美国': '华盛顿', '法国': '巴黎'&#125;&gt;&gt;&gt; d[\"中国\"]'北京'&gt;&gt;&gt; de = &#123;&#125; ; type(de)&lt;class 'dict'&gt;type(x)返回变量x的类型 字典类型操作函数和方法 函数或方法 描述 del d[k] 删除字典d中键k对应的数据值 k in d 判断键k是否在字典d中，如果在返回True，否则False d.keys() 返回字典d中所有的键信息 d.values() 返回字典d中所有的值信息 d.items() 返回字典d中所有的键值对信息 d.get(k, ) 键k存在，则返回相应值，不在则返回值 d.pop(k, ) 键k存在，则取出相应值，不在则返回值 d.popitem() 随机从字典d中取出一个键值对，以元组形式返回 d.clear() 删除所有的键值对 len(d) 返回字典d中元素的个数 123456789101112131415&gt;&gt;&gt; d = &#123;\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"&#125;&gt;&gt;&gt; \"中国\" in dTrue&gt;&gt;&gt; d.keys()dict_keys(['中国', '美国', '法国'])&gt;&gt;&gt; d.values()dict_values(['北京', '华盛顿', '巴黎'])&gt;&gt;&gt; d = &#123;\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"&#125;&gt;&gt;&gt; d.get(\"中国\",\"伊斯兰堡\")'北京'&gt;&gt;&gt; d.get(\"巴基斯坦\",\"伊斯兰堡\")'伊斯兰堡'&gt;&gt;&gt; d.popitem()('美国', '华盛顿') 元素遍历 12for k in d :&lt;语句块&gt; 文件处理文件的理解文件是数据的抽象和集合 文件是存储在辅助存储器上的数据序列 文件是数据存储的一种形式 文件展现形态：文本文件和二进制文件 文本文件 vs. 二进制文件 文件文件和二进制文件只是文件的展示方式 本质上，所有文件都是二进制形式存储 形式上， 所有文件采用两种方式展示 文本文件 由单一特定编码组成的文件，如UTF-8编码 由于存在编码，也被看成是存储着的长字符串 适用于例如： .txt文件、 .py文件等 二进制文件 直接由比特0和1组成， 没有统一字符编码 一般存在二进制0和1的组织结构，即文件格式 适用于例如： .png文件、 .avi文件等 文本文件vs二进制文件f.txt文件保存：“中国是一个伟大的国家！”； 文本形式打开文件12345678#tf = open(\"f.txt\", mode=\"rt\",encoding='UTF-8') 能指定编码tf = open(\"f.txt\", \"rt\",encoding='UTF-8')print(tf.readline())tf.close()============= RESTART: E:/Codes/Python/new/file.py ====================中国是一个伟大的国家！&gt;&gt;&gt; 二进制形式打开文件12345678tf = open(\"f.txt\", mode=\"rb\")#tf = open(\"f.txt\", \"rb\")print(tf.readline())tf.close()====== RESTART: E:/Codes/Python/new/file.py ====================b'\\xe4\\xb8\\xad\\xe5\\x9b\\xbd\\xe6\\x98\\xaf\\xe4\\xb8\\x80\\xe4\\xb8\\xaa\\xe4\\xbc\\x9f\\xe5\\xa4\\xa7\\xe7\\x9a\\x84\\xe5\\x9b\\xbd\\xe5\\xae\\xb6\\xef\\xbc\\x81'&gt;&gt;&gt; 文件的使用 文件的打开 1&lt;变量名(文件句柄)&gt; = open(&lt;文件名|文件路径和名称&gt;, &lt;打开模式 |文本 or 二进制|读 or 写 &gt;) 文件路径和名称源文件同目录可省路径 123\"D:/PYE/f.txt\"\"D:\\\\PYE\\\\f.txt\" \"f.txt\"\"./PYE/f.txt\" 打开模式文本形式、只读模式、默认值 文件的打开模式 描述 ‘r’ 只读模式，默认值，如果文件不存在，返回FileNotFoundError ‘w’ 覆盖写模式，文件不存在则创建，存在则完全覆盖 ‘x’ 创建写模式，文件不存在则创建，存在则返回FileExistsError ‘a’ 追加写模式，文件不存在则创建，存在则在文件最后追加内容 ‘b’ 二进制文件模式 ‘t’ 文本文件模式，默认值 ‘+’ 与r/w/x/a一同使用，在原功能基础上增加同时读写功能 1234567891011121314f = open(\"f.txt\")f = open(\"f.txt\", \"rt\")f = open(\"f.txt\", \"w\")f = open(\"f.txt\", \"a+\")f = open(\"f.txt\", \"x\")f = open(\"f.txt\", \"b\")f = open(\"f.txt\", \"wb\")- 文本形式、只读模式、默认值- 文本形式、只读模式、同默认值- 文本形式、覆盖写模式- 文本形式、追加写模式+ 读文件- 文本形式、创建写模式- 二进制形式、只读模式- 二进制形式、覆盖写模式 12345678#文本形式打开文件tf = open(\"f.txt\", \"rt\")print(tf.readline())tf.close()#二进制形式打开文件bf = open(\"f.txt\", \"rb\")print(bf.readline())bf.close() 文件内容的读取 操作方法 描述 .read(size=-1) 读入全部内容，如果给出参数，读入前size长度 &gt;&gt;&gt;s = f.read(2) 中国 .readline(size=-1) 读入一行内容，如果给出参数，读入该行前size长度 &gt;&gt;&gt;s = f.readline() 中国是一个伟大的国家！ .readlines(hint=-1) 读入文件所有行，以每行为元素形成列表 如果给出参数，读入前hint行 &gt;&gt;&gt;s = f.readlines() [‘中国是一个伟大的国家！ ‘] 文件的逐行操作 逐行遍历文件：方法一 一次读入，分行处理 12345fname = input(\"请输入要打开的文件名称:\")fo = open(fname,\"r\")for line in fo.readlines(): print(line)fo.close() 逐行遍历文件：方法二 分行读入，逐行处理 12345fname = input(\"请输入要打开的文件名称:\")fo = open(fname,\"r\")for line in fo:print(line)fo.close() 数据的文件写入 操作方法 描述 .write(s) 向文件写入一个字符串或字节流 &gt;&gt;&gt;f.write(“中国是一个伟大的国家!”) .writelines(lines) 将一个元素全为字符串的列表写入文件 &gt;&gt;&gt;ls = [“中国”, “法国”, “美国”] &gt;&gt;&gt;f.writelines(ls) 中国法国美国 .seek(offset) 改变当前文件操作指针的位置， offset含义如下： 0 – 文件开头； 1 – 当前位置； 2 – 文件结尾 &gt;&gt;&gt;f.seek(0) #回到文件开头 数据的文件写入 写入一个字符串列表(没有任何输出) 123456fo = open(\"output.txt\",\"w+\")ls = [\"中国\", \"法国\", \"美国\"]fo.writelines(ls)for line in fo: print(line)fo.close() 写入一个字符串列表 1234567fo = open(\"output.txt\",\"w+\")ls = [\"中国\", \"法国\", \"美国\"]fo.writelines(ls)fo.seek(0)for line in fo: print(line)fo.close() with open文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的： 1f.close() 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现： 123456try: f = open('/path/to/file', 'r') print(f.read())finally: if f: f.close() 但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法： 12with open('/path/to/file', 'r') as f: print(f.read()) 这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。 遍历文件夹下的所有文件12345678910111213for root, dirs, files in os.walk(file): # root 表示当前正在访问的文件夹路径 # dirs 表示该文件夹下的子目录名list # files 表示该文件夹下的文件list # 遍历文件 for f in files: print(os.path.join(root, f)) # 遍历所有的文件夹 for d in dirs: print(os.path.join(root, d)) 删除文件os.remove() 方法用于删除指定路径的文件。如果指定的路径是一个目录，将抛出OSError。 在Unix, Windows中有效 语法remove()方法语法格式如下： 1`os.remove(path)` 参数 path – 要移除的文件路径 返回值该方法没有返回值 复制目录及文件1shutil.copytree(source_dir, target_dir) python常用标准库标准库Python计算生态 = 标准库 + 第三方库 标准库：随解释器直接安装到操作系统中的功能模块 第三方库：需要经过安装才能使用的功能模块 库 Library 、包 Package 、模块 Module ，统称 模块 turtle库基本介绍turtle(海龟) 库是 turtle 绘图体系的 Python 实现 turtle 绘图体系： 1969 年诞生，主要用于程序设计入门 Python 语言的 标准库 之一 入门级的图形绘制函数库 turtle绘图窗体布局 1turtle.setup( width , height, startx , starty) setup() 设置窗体大小及位置 4 个参数中后两个可选 setup() 不是必须的 turtle空间坐标体系 1turtle.goto( x, y) turtle角度坐标体系 1turtle.seth(angle) seth()改变海龟行进方向 angle为绝对度数 seth()只改变方向但不行进 RGB色彩体系RGB色彩模式由由三种颜色构成的万物色 RGB指红蓝绿三个通道的颜色组合 覆盖视力所能感知的所有颜色 RGB每色取值范围0-255整数或0-1小数 turtle的RGB色彩模式默认采用小数值 可切换为整数值 1turtle.colormode(mode) 1.0：RGB小数值模式 255：RGB整数值模式 time库time库是Python中处理时间的标准库 计算机时间的表达 提供获取系统时间并格式化输出功能 提供系统级精确计时功能，用于程序性能分析 12import timetime.&lt;b&gt;() time库包括三类函数 时间获取：time() ctime() gmtime() 时间格式化：strftime() strptime() 程序计时：sleep(), perf_counter() 时间获取 函数 描述 time() 获取当前时间戳，即计算机内部时间值，浮点数&gt;&gt;&gt;time.time()1516939876.6022282 ctime() 获取当前时间并以易读方式表示，返回字符串&gt;&gt;time.ctime()’Fri Jan 26 12:11:16 2018’ gmtime() 获取当前时间，表示为计算机可处理的时间格式&gt;&gt;&gt;time.gmtime()time.struct_time(tm_year=2018, tm_mon=1, tm_mday=26, tm_hour=4, tm_min=11, tm_sec=16, tm_wday=4, tm_yday=26, tm_isdst=0) 时间格式化 格式化：类似字符串格式化，需要有展示模板 展示模板由特定的格式化控制符组成 strftime()方法 1strftime(tpl, ts) tpl是格式化模板字符串，用来定义输出效果ts是计算机内部时间类型变量 12&gt;&gt;&gt;t = time.gmtime()&gt;&gt;&gt;time.strftime(\"%Y-%m-%d %H:%M:%S\",t) '2018-01-26 12:55:20' 格式化控制符 格式化字符串 日期/时间说明 值范围和实例 %Y 年份 0000~9999，例如：1900 %m 月份 01~12，例如：10 %B 月份名称 January~December，例如：April %b 月份名称缩写 Jan~Dec，例如：Apr %d 日期 01~31，例如：25 %A 星期 Monday~Sunday，例如：Wednesday %a 星期缩写 Mon~Sun，例如：Wed %H 小时（24h制） 00~23，例如：12 %I 小时（12h制） 01~12，例如：7 %p 上/下午 AM, PM，例如：PM %M 分钟 00~59，例如：26 %S 秒 00~59，例如：26 12&gt;&gt;&gt;t = time.gmtime()&gt;&gt;&gt;time.strftime(\"%Y-%m-%d %H:%M:%S\",t) 12&gt;&gt;&gt;timeStr = '2018-01-26 12:55:20'&gt;&gt;&gt;time.strptime(timeStr, “%Y-%m-%d %H:%M:%S”) 程序计时程序计时应用广泛 程序计时指测量起止动作所经历时间的过程 测量时间：perf_counter() 产生时间：sleep() 1perf_counter() 返回一个CPU级别的精确时间计数值，单位为秒由于这个计数值起点不确定，连续调用差值才有意义 1234&gt;&gt;&gt;start = time.perf_counter() 318.66599499718114&gt;&gt;&gt;end = time.perf_counter() 341.3905185375658&gt;&gt;&gt;end - start&gt;&gt;&gt;22.724523540384666 sleep(s) s拟休眠的时间，单位是秒，可以是浮点数 123&gt;&gt;&gt;def wait():time.sleep(3.3)&gt;&gt;&gt;wait() #程序将等待3.3秒后再退出 random库random库是使用随机数的Python标准库 伪随机数: 采用梅森旋转算法生成的(伪)随机序列中元素 random库主要用于生成随机数 使用random库: import random 常用函数random库包括两类函数，常用共8个 基本随机数函数：seed(),random() 扩展随机数函数：randint(), getrandbits(), uniform(), randrange(), choice(), shuffle() 基本随机数函数 函数 描述 seed(a=None) 初始化给定的随机数种子，默认为当前系统时间&gt;&gt;&gt;random.seed(10) #产生种子10对应的序列 random() 生成一个[0.0, 1.0)之间的随机小数&gt;&gt;&gt;random.random()0.5714025946899135 函数 描述 randint(a, b) 生成一个[a, b]之间的整数&gt;&gt;&gt;random.randint(10, 100)64 randrange(m, n[, k]) 生成一个[m, n)之间以k为步长的随机整数&gt;&gt;&gt;random.randrange(10, 100, 10)80 getrandbits(k) 生成一个k比特长的随机整数&gt;&gt;&gt;random.getrandbits(16)37885 uniform(a,b) 生成一个[a, b]之间的随机小数&gt;&gt;&gt;random.uniform(10, 100)13.096321648808136 choice(seq) 从序列seq中随机选择一个元素&gt;&gt;&gt;random.choice([1,2,3,4,5,6,7,8,9])8 shuffle(seq) 将序列seq中元素随机排列，返回打乱后的序列&gt;&gt;&gt;s=[1,2,3,4,5,6,7,8,9];random.shuffle(s);print(s)[3, 5, 8, 9, 6, 1, 2, 7, 4] os库os库基本介绍os库提供通用的、基本的操作系统交互功能 os库是Python标准库，包含几百个函数 常用路径操作、进程管理、环境参数等几类 路径操作：os.path子库，处理文件路径及信息 进程管理：启动系统中其他程序 环境参数：获得系统软硬件信息等环境 os库之路径操作路径操作os.path子库以path为入口，用于操作和处理文件路径 123import os.path或import os.path as op 函数 描述 os.path.abspath(path) 返回path在当前系统中的绝对路径&gt;&gt;&gt;os.path.abspath(“file.txt”)‘C:\\Users\\Tian Song\\Python36-32\\file.txt’ os.path.normpath(path) 归一化path的表示形式，统一用\\分隔路径&gt;&gt;&gt;os.path.normpath(“D://PYE//file.txt”)‘D:\\PYE\\file.txt’ os.path.relpath(path) 返回当前程序与文件之间的相对路径 (relative path)&gt;&gt;&gt;os.path.relpath(“C://PYE//file.txt”)‘..\\..\\..\\..\\..\\..\\..\\PYE\\file.txt’ os.path.dirname(path) 返回path中的目录名称&gt;&gt;&gt;os.path.dirname(“D://PYE//file.txt”)‘D://PYE’ os.path.basename(path) 返回path中最后的文件名称&gt;&gt;&gt;os.path.basename(“D://PYE//file.txt”)‘file.txt’ os.path.join(path, *paths) 组合path与paths，返回一个路径字符串&gt;&gt;&gt;os.path.join(“D:/“, “PYE/file.txt”)‘D:/PYE/file.txt’ os.path.exists(path) 判断path对应文件或目录是否存在，返回True或False&gt;&gt;&gt;os.path.exists(“D://PYE//file.txt”)False os.path.isfile(path) 判断path所对应是否为已存在的文件，返回True或False&gt;&gt;&gt;os.path.isfile(“D://PYE//file.txt”)True os.path.isdir(path) 判断path所对应是否为已存在的目录，返回True或False&gt;&gt;&gt;os.path.isdir(“D://PYE//file.txt”)False os.path.getatime(path) 返回path对应文件或目录上一次的访问时间&gt;&gt;&gt;os.path.getatime(“D:/PYE/file.txt”)1518356633.7551725 os.path.getmtime(path) 返回path对应文件或目录上一次的访问时间&gt;&gt;&gt;os.path.getatime(“D:/PYE/file.txt”)1518356633.7551725 os.path.getmtime(path) 返回path对应文件或目录最近一次的修改时间&gt;&gt;&gt;os.path.getmtime(“D:/PYE/file.txt”)1518356633.7551725 os.path.getctime(path) 返回path对应文件或目录的创建时间time.ctime(os.path.getctime(“D:/PYE/file.txt”))‘Sun Feb 11 21:43:53 2018’ os.path.getsize(path) 返回path对应文件的大小，以字节为单位&gt;&gt;&gt;os.path.getsize(“D:/PYE/file.txt”)180768 获取当前文件路径123print(os.getcwd())print(os.path.abspath('.'))print(os.path.abspath(os.curdir)) os库之进程管理1os.system(command) 执行程序或命令command 在Windows系统中，返回值为cmd的调用返回信息 1234import osos.system(\"C:\\\\Windows\\\\System32\\\\calc.exe\")&gt;&gt;&gt;0 os库之环境环境获取或改变系统环境信息 函数 描述 os.chdir(path) 修改当前程序操作的路径&gt;&gt;&gt;os.chdir(“D:”) os.getcwd() 返回程序的当前路径&gt;&gt;&gt;os.getcwd()‘D:\\‘ os.getlogin() 获得当前系统登录用户名称&gt;&gt;&gt;os.getlogin() ‘Tian Song’ os.cpu_count() 获得当前系统的CPU数量&gt;&gt;&gt;os.cpu_count() 8 os.urandom(n) 获得n个字节长度的随机字符串，通常用于加解密运算&gt;&gt;&gt;os.urandom(10)b’7\\xbe\\xf2!\\xc1=\\x01gL\\xb3’ 正则表达式regular expression, regex, RE 什么是正则表达式正则表达式是对字符串串操作的一种逻辑公式，就是用事先定义好的一些特定 字符、及这些特定字符的组合，组成一个“规则字符串串”，这个“规则字符串”用 来表达对字符串的一种过滤逻辑。非Python独有，re模块实现 常见匹配模式 模式 描述 \\w 匹配字母数字及下划线 \\W 匹配非字母数字下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9] \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 * 匹配0个或多个的表达式。 + 匹配1个或多个的表达式。 ? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 {n} 精确匹配n个前面表达式。 {n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a&#124;b 匹配a或b ( ) 匹配括号内的表达式，也表示一个组 re.matchre.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 1re.match(pattern, string, flags=0) 最常规的匹配12345678import recontent = 'Hello 123 4567 World_This is a Regex Demo'print(len(content))result = re.match('^Hello\\s\\d\\d\\d\\s\\d&#123;4&#125;\\s\\w&#123;10&#125;.*Demo$', content)print(result)print(result.group())print(result.span()) out: 123441&lt;re.Match object; span=(0, 41), match='Hello 123 4567 World_This is a Regex Demo'&gt;Hello 123 4567 World_This is a Regex Demo(0, 41) 泛匹配.*来匹配任意字段 1234567import recontent = 'Hello 123 4567 World_This is a Regex Demo'result = re.match('^Hello.*Demo$', content)print(result)print(result.group())print(result.span()) out: 123&lt;re.Match object; span=(0, 41), match='Hello 123 4567 World_This is a Regex Demo'&gt;Hello 123 4567 World_This is a Regex Demo(0, 41) 匹配目标通过添加()进行分组，提取，指定数据 1234567import recontent = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^Hello\\s(\\d+)\\sWorld.*Demo$', content)print(result)print(result.group(1))print(result.span()) out: 123&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567(0, 40) 贪婪匹配Re库默认采用贪婪匹配 123456import recontent = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*(\\d+).*Demo$', content)print(result)print(result.group(1)) out: .*匹配掉了尽可能多的字符 12&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;7 非贪婪匹配只要长度输出可能不同的，都可以通过在操作符后增加?变成最小匹配 123456import recontent = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*?(\\d+).*Demo$', content)print(result)print(result.group(1)) out: 12&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567 匹配模式通过设置匹配模式，将.能匹配换行符 1234567import recontent = '''Hello 1234567 World_Thisis a Regex Demo'''result = re.match('^He.*?(\\d+).*?Demo$', content, re.S)print(result.group(1)) out: 11234567 转义12345import recontent = 'price is $5.00'result = re.match('price is $5.00', content)print(result) 1None 12345import recontent = 'price is $5.00'result = re.match('price is \\$5\\.00', content)print(result) out: 1&lt;re.Match object; span=(0, 14), match='price is $5.00'&gt; 总结：尽量使用泛匹配、使用括号得到匹配目标、尽量使用非贪婪模式、有换行符就用re.S re.searchre.search 扫描整个字符串并返回第一个成功的匹配。 12345import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'result = re.match('Hello.*?(\\d+).*?Demo', content)print(result) 1None 123456import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'result = re.search('Hello.*?(\\d+).*?Demo', content)print(result)print(result.group(1)) 12&lt;re.Match object; span=(13, 53), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567 总结：为匹配方便，能用search就不用match 匹配演练12345678910111213141516171819202122232425import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;&lt;i class=\"fa fa-user\"&gt;&lt;/i&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''result = re.search('&lt;li.*?active.*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;', html, re.S)if result: print(result.group(1), result.group(2)) import re html = ‘’’ 经典老歌 经典老歌列表 一路上有你 沧海一声笑 往事随风 光辉岁月 记事本 但愿人长久 ''' result = re.search('(.*?)', html, re.S) if result: print(result.group(1), result.group(2)) 12345678910111213141516171819202122232425import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''result = re.search('&lt;li.*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;', html)if result: print(result.group(1), result.group(2)) re.findall搜索字符串，以列表形式返回全部能匹配的子串。 12345678910111213141516171819202122232425262728import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''results = re.findall('&lt;li.*?href=\"(.*?)\".*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;', html, re.S)print(results)print(type(results))for result in results: print(result) print(result[0], result[1], result[2]) 1234567891011121314151617181920212223242526import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''results = re.findall('&lt;li.*?&gt;\\s*?(&lt;a.*?&gt;)?(\\w+)(&lt;/a&gt;)?\\s*?&lt;/li&gt;', html, re.S)print(results)for result in results: print(result[1]) re.sub替换字符串中每一个匹配的子串后返回替换后的字符串。 12345import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'content = re.sub('\\d+', 'Replacement', content)print(content) 1Extra stings Hello Replacement World_This is a Regex Demo Extra stings 12345import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'content = re.sub('(\\d+)', r'\\1 8910', content)print(content) \\1指明分组中的第一个 1Extra stings Hello 1234567 8910 World_This is a Regex Demo Extra stings 12345678910111213141516171819202122232425262728import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = re.sub('&lt;a.*?&gt;|&lt;/a&gt;', '', html)print(html)results = re.findall('&lt;li.*?&gt;(.*?)&lt;/li&gt;', html, re.S)print(results)for result in results: print(result.strip()) re.compile将正则字符串编译成正则表达式对象 将一个正则表达式串编译成正则对象，以便于复用该匹配模式 12345678import recontent = '''Hello 1234567 World_Thisis a Regex Demo'''pattern = re.compile('Hello.*Demo', re.S)result = re.match(pattern, content)#result = re.match('Hello.*Demo', content, re.S)print(result) 1&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This\\nis a Regex Demo'&gt; 豆瓣读书实战练习12345678910import requestsimport recontent = requests.get('https://book.douban.com/').textpattern = re.compile('&lt;li.*?cover.*?href=\"(.*?)\".*?title=\"(.*?)\".*?more-meta.*?author\"&gt;(.*?)&lt;/span&gt;.*?year\"&gt;(.*?)&lt;/span&gt;.*?&lt;/li&gt;', re.S)results = re.findall(pattern, content)for result in results: url, name, author, date = result author = re.sub('\\s', '', author) date = re.sub('\\s', '', date) print(url, name, author, date) 异常处理异常处理的基本使用 123456789try : &lt;语句块1&gt;except : &lt;语句块2&gt;try : &lt;语句块1&gt;except &lt;异常类型&gt; : &lt;语句块2&gt; 1234567891011try : num = eval(input(\"请输入一个整数: \")) print(num**2)except : print(\"输入不是整数\")try : num = eval(input(\"请输入一个整数: \")) print(num**2)except NameError: print(\"输入不是整数\") 示例标注异常类型后，仅响应此类异常异常类型名字等同于变量名 异常处理的高级使用 finally对应语句块4一定执行 else对应语句块3在不发生异常时执行 12345678try : &lt;语句块1&gt;except : &lt;语句块2&gt;else : &lt;语句块3&gt;finally : &lt;语句块4&gt; 12345try: ...except xxx as xx: traceback.print_exc() ... 12345try: response = urllib.request.urlopen('http://httpbin.org/get',timeout=1) except urllib.error.URLError as e: if isinstance(e.strerror,socket.timeout): print('TIME OUT') 主动抛出异常。格式：主动抛出异常终止程序 1raise 异常名称(‘异常描述’) 1raise RuntimeError('testError') 打印异常信息我们可以使用 traceback这个内置模块来获取异常更加详细的信息： 12345import traceback try: ... except Exception,e: traceback.print_exc() traceback.print_exc() 直接打印异常traceback.format_exc()返回字符串还可以将信息写入到文件 traceback.print_exc(file=open(‘error.txt’,’a+’)) python第三方库Python社区 PyPI PyPI: Python Package Index PSF维护的展示全球Python计算生态的主站 学会检索并利用PyPI，找到合适的第三方库开发程序 实例：开发与区块链相关的程序 第1步：在pypi.org搜索 blockchain 第2步：挑选适合开发目标的第三方库作为基础 第3步：完成自己需要的功能 三种方法 方法1(主要方法): 使用pip命令 方法2: 集成安装方法 方法3: 文件安装方法 pip -h 1234567891011121314151617181920E:\\Users\\11623\\Anaconda3\\Lib\\site-packages&gt;pip -hUsage: pip &lt;command&gt; [options]Commands: install Install packages. download Download packages. uninstall Uninstall packages. freeze Output installed packages in requirements format. list List installed packages. show Show information about installed packages. check Verify installed packages have compatible dependencies. config Manage local and global configuration. search Search PyPI for packages. wheel Build wheels from your requirements. hash Compute hashes of package archives. completion A helper command used for command completion. debug Show information useful for debugging. help Show help for commands. pip常用指令安装指定的第三方库 1pip install &lt;第三方库名&gt; 使用-U标签更新已安装的指定第三方库 1pip install –U &lt;第三方库名&gt; 卸载指定的第三方库 1D:\\&gt;pip uninstall &lt;第三方库名&gt; 下载但不安装指定的第三方库 1D:\\&gt;pip download &lt;第三方库名&gt; 列出某个指定第三方库的详细信息 1D:\\&gt;pip show &lt;第三方库名&gt; 根据关键词在名称和介绍中搜索第三方库 1D:\\&gt;pip search &lt;关键词&gt; 1pip search blockchain 1D:\\&gt;pip list 列出当前系统已经安装的第三方库 第三方库的集成安装方法 Anaconda集成安装：结合特定Python开发工具的批量安装 https://www.continuum.io 支持近800个第三方库 包含多个主流工具 适合数据计算领域开发 Anaconda跟换国内镜像源https://blog.csdn.net/dream_allday/article/details/80344511 文件安装方法为什么有些第三方库用pip可以下载，但无法安装？ 某些第三方库pip下载后，需要编译再安装 如果操作系统没有编译环境，则能下载但不能安装 可以直接下载编译后的版本用于安装吗？ http://www.lfd.uci.edu/~gohlke/pythonlibs/ 将pip源更换到国内镜像https://blog.csdn.net/sinat_21591675/article/details/82770360 Python命名规则https://www.jianshu.com/p/a793c0d960fe 模块名,包名,文件名模块应该使用尽可能短的、全小写命名，可以在模块命名时使用下划线以增强可读性。同样包的命名也应该是这样的，虽然其并不鼓励下划线 主要是考虑模块名是与文件夹相对应的，因此需要考虑文件系统的一些命名规则的，比如Unix系统对大小写敏感，而过长的文件名会影响其在 Windows\\Mac\\Dos 等系统中的正常使用。 通常是小写字母，单词之间用_分割 注意：文件名混合大小写仅被允许用于这种风格已经占据优势的时候，以便保持向后兼容 类名和java一样，类名都使用首字母大写开头(Pascal命名风格，驼峰)的规范。 使用 _单下划线开头的类名为内部使用 1from module_name import * 默认不被导入的情况 _InnerClass 变量全局变量名（类变量，在java中相当于static变量）大写字母，单词之间用 _分割 12NUMBERCOLOR_WRITE 普通变量小写字母，单词之间用 _分割 注意： 不论是类成员变量还是全局变量，均不使用 m 或 g 前缀(匈牙利标记法)。 私有类成员使用单一下划线前缀标识，多定义公开成员，少定义私有成员。 变量名不应带有类型信息，因为Python是动态类型语言。如 iValue、names_list、dict_obj 等都是不好的命名。 实例变量：以 _ 开头，其他和普通变量一样 私有实例变量（外部访问会报错）以 __开头（2个下划线），其他和普通变量一样 1__private_var 专有变量__开头，__结尾，一般为python的自有变量， 1不要以这种方式命名普通变量，这个是保留字，要满足防御性编程需求 12__doc____class__ 函数普通函数和普通变量一样 123get_name()count_number()ad_stat() 私有函数（外部访问会报错）以 __ 开头（2个下划线），其他和普通函数一样 1__get_name() 函数和方法的参数总使用“self”作为实例方法的第一个参数。 总使用“cls”作为类方法的第一个参数。 如果一个函数的参数名称和保留的关键字冲突，通常使用一个后缀下划线好于使用缩写或奇怪的拼写 常量常量名所有字母大写，由下划线连接各个单词如 MAX_OVERFLOW，TOTAL 异常因为异常也是一个类，所以遵守类的命名规则 此外，如果异常实际上指代一个错误的话，应该使用“Error”做后缀。 缩写命名应当尽量使用全拼写的单词，缩写的情况有如下两种： 常用的缩写，如XML、ID等，在命名时也应只大写首字母，如XmlParser 命名中含有长单词，对某个单词进行缩写。这时应使用约定成俗的缩写方式 例如： 名称 缩写 function fn text txt object obj count cnt number num 前导后缀下划线总结 一个前导下划线：表示非公有。 一个后缀下划线：避免关键字冲突。 两个前导下划线：当命名一个类属性引起名称冲突时使用。 两个前导和后缀下划线：“魔术”（有特殊用途）对象或者属性，例如init或者file。绝对不要创造这样的名字，而只是使用它们。 注意：关于下划线的使用存在一些争议 Python 用下划线作为变量前缀和后缀指定特殊变量 123456## 不能用'from module import *'导入（相当于 private）_xxx## 系统定义名字__xxx__## 类中的私有变量名(相当于protect)__xxx 下划线核心风格1避免用下划线作为变量名的开始 因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避免用下划线作为变量名的开始。 一般来讲，变量名_xxx被看作是“私有的”，在模块或类外不可以使用。当变量是私有的时候，用_xxx 来表示变量是很好的习惯。“单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；“双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据 以单下划线开头_foo的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用“from xxx import *”而导入； 以双下划线开头的__foo代表类的私有成员； 以双下划线开头和结尾的__foo__代表python里特殊方法专用的标识，如__init__（）代表类的构造函数。 特定命名方式主要是指 __xxx__ 形式的系统保留字命名法。 项目中也可以使用这种命名，它的意义在于这种形式的变量是只读的，这种形式的类成员函数尽量不要重载 如 123456class Base(object): def __init__(self, id, parent = None): self.__id__ = id self.__parent__ = parent def __message__(self, msgid): ## … 其中 __id__、__parent__ 和 __message__ 都采用了系统保留字命名法 __双下划线开头双下划线结尾__：指那些包含在用户无法控制的命名空间中的“魔术”对象或属性 如类成员的__name__、__doc__、__init__、__import__、__file__、等 推荐永远不要将这样的命名方式应用于自己的变量或函数。 单下划线结尾_：只是为了避免与python关键字的命名冲突 _单下划线开头：弱“内部使用”标识，如：from M import *，将不导入所有以下划线开头的对象，包括包、模块、成员 python 类python动态添加属性(对象属性，类属性)1234567891011121314151617181920212223242526class cltdy: #定义类，并起一个名字 n = 1000 #类属性，类内的变量 def __init__(self,name,age,profession='IT民工'): #构造函数，类接收外部传入参数全靠构造函数 self.name = name self.age = age self.profession = profession def printing_name(self): #类的方法 print('我的名字是：%s'%self.name) def printing_age(self): print(\"我的年龄：%s\"%self.age) def printing_pfsn(self): print(\"我的职业：%s\"%self.profession)test = cltdy('sober',25,'DevOps') #类的实例化，将参数传入类中，传入参数可以多但不可以少于类构造函数的参数(self参数除外，self是将实例化的变量名传入类)print(\"这是类实例化后的内存地址：%s\"%test)test.printing_name() #调用实例化后类中的方法test.name = 'moon' #可以修改构造函数中参数的值test.printing_name()test.printing_pfsn()print(test.n)test.n = 2000 #修改类属性，只针对test实例化生效print(test.n,'\\n====================')t2 = cltdy('jack',22,'student') #实例化类对象，命名t2print(t2.n)t2.printing_age() 使用pycharm导入python项目选择New environment 或者 Existing environment都可以，路径选择本地配置的python.exe路径即可； New Environment:New Environment部分是选择新建项目所依赖的python库，第一个选项会在项目中简历一个venv（virtualenv）目录，这里存放一个虚拟的python环境。这里所有的类库依赖都可以直接脱离系统安装的python独立运行。 Existing Interpreter:Existing Interpreter关联已经存在的python解释器，如果不想在项目中出现venv这个虚拟解释器就可以选择本地安装的python环境。通常选择Existing Interpreter即可 python定义类似常量const.py 12345678910class PROBLEM: MEMORY_LIMIT = \"memory_limit\" TIME_LIMIT = \"time_limit\" DESCRIPTION = 'description' SAMPLE_INPUT = \"sample_input\" SAMPLE_OUTPUT = \"sample_output\" FORMAT_INPUT = \"format_input\" FORMAT_OUTPUT = \"format_output\" HINT = \"hint\" STATE = \"state\" 使用： 12from const import *print(PROBLEM.DESCRIPTION) __init__.py文件init.py 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有init.py 文件. ######### 批量引入 init.py 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有init.py 文件。 通常init.py 文件为空，但是我们还可以为它增加其他的功能。我们在导入一个包时，实际上是导入了它的init.py文件。这样我们可以在init.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入。 packageinit.pyimport reimport urllibimport sysimport os a.pyimport packageprint(package.re, package.urllib, package.sys, package.os)init.py中还有一个重要的变量，all, 它用来将模块全部导入 init.pyall = [‘os’, ‘sys’, ‘re’, ‘urllib’] a.pyfrom package import *可以被import语句导入的对象是以下类型：模块文件（.py文件）C或C++扩展（已编译为共享库或DLL文件）包（包含多个模块）内建模块（使用C编写并已链接到Python解释器中）当导入模块时，解释器按照sys.path列表中的目录顺序来查找导入文件。 import sys print(sys.path) Linux:[‘’, ‘/usr/local/lib/python3.4’,‘/usr/local/lib/python3.4/plat-sunos5’,‘/usr/local/lib/python3.4/lib-tk’,‘/usr/local/lib/python3.4/lib-dynload’,‘/usr/local/lib/python3.4/site-packages’]其中list第一个元素空字符串代表当前目录。 关于.pyc 文件 与 .pyo 文件py文件的汇编,只有在import语句执行时进行，当.py文件第一次被导入时，它会被汇编为字节代码，并将字节码写入同名的.pyc文件中。后来每次导入操作都会直接执行.pyc 文件（当.py文件的修改时间发生改变，这样会生成新的.pyc文件），在解释器使用-O选项时，将使用同名的.pyo文件，这个文件去掉了断言（assert）、断行号以及其他调试信息，体积更小，运行更快。（使用-OO选项，生成的.pyo文件会忽略文档信息） 导入模块 模块通常为单独的.py文件，可以用import直接引用，可以作为模块的文件类型有.py、.pyo、.pyc、.pyd、.so、.dll 对象调用类中的变量和方法 init方法是一个特殊的方法,只要类名+() 产生一个对象,自动执行类中的init方法,并把类的地址传给方法里的第一个参数,约定把第一个参数定为’self’, 再给对象封装相应的属性. (1) dict 查询对象中的所有的内容 (2) 万能的点： . 123456789101112131415class Person: mind = '有思想' belif = '有信仰' animal = '高级动物' def __init__(self, name,age,hobby): self.name = name self.age = age self.hobby = hobby print(name,age,hobby) def work(self): print('会工作') return self def money(self): print('会消费') print(self) 私有方法如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 yield关键字yield 《=》生成器 包含yield语句的函数是一个生成器 生成器每次产生一个值（ yield语句），函数被冻结，被唤醒后再产生一个值生成器是一个不断产生值的函数 生成器相比一次列出所有内容的优势：1)更节省存储空间2)响应更迅速3)使用更灵活 实例： 123456def gen(n): for i in range(n): yield i ** 2 for i in gen(5): print(i, \" \", end=\"\") 生成器每调用一次在yield位置产生一个值，直到函数执行结束 一次返回所有值 12345def square(n): return [i **2 for i in range(n)] for i in square(5): print(i, \" \", end=\"\") 函数传递问题python不允许程序员选择采用传值还是传引用。python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。 如果函数收到的是一个不可变对象（数字、字符或元组）的引用，就不能直接修改原始对象–相当于通过‘值传递’来传递对象。 如果函数收到的是一个可变对象（字典、列表）的引用，就能修改对象的原始值–相当于‘传引用’来传递对象。 Python里面如何拷贝一个对象1.浅拷贝 ： 使用copy.copy,它可以进行对象的浅拷贝(shallow copy),它复制了对象,但对于对象中的元素,依然使用引用（换句话说修改拷贝对象元素，则被拷贝对象元素也被修改）2.深拷贝 ： 使用copy.deepcopy，它可以进行深拷贝，不仅拷贝了对象，同时也拷贝了对象中的元素，获得了全新的对象，与被拷贝对象完全独立，但这需要牺牲一定的时间和空间。3.特殊拷贝： 如要复制列表L,使用list(L),要复制一个字典d,使用dict(d),要复制一个集合s,使用set(s)。 总结一下的话：如果你要复制某个对象object, 它属于python内建的类型type,那么你可以使用type(object)来 获得一个拷贝。 4 举例： import copy list = [1, 2, 3, 4, [‘a’, ‘b’]] #原始对象 b = list #赋值，传对象的引用，依然指向list c = copy.copy(list) #对象拷贝，浅拷贝（元素依然是共享的引用） d = copy.deepcopy(list) #对象拷贝，深拷贝 list.append(5) #修改对象list list[4].append(‘c’) #修改对象list中的[‘a’, ‘b’]数组对象 print ‘list = ‘, list print ‘b = ‘, b print ‘c = ‘, c print ‘d = ‘, d 输出结果：list = [1, 2, 3, 4, [‘a’, ‘b’, ‘c’], 5]b = [1, 2, 3, 4, [‘a’, ‘b’, ‘c’], 5]c = [1, 2, 3, 4, [‘a’, ‘b’, ‘c’]]d = [1, 2, 3, 4, [‘a’, ‘b’]]","categories":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/tags/python/"}]},{"title":"springBoot","slug":"java-note/springBoot/springBoot","date":"2019-11-17T07:27:48.000Z","updated":"2021-10-23T02:19:04.202Z","comments":true,"path":"2019/11/java-note/springBoot/springBoot/","link":"","permalink":"https://codeofli.github.io/2019/11/java-note/springBoot/springBoot/","excerpt":"一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案； 2、微服务2014，martin fowler微服务：架构风格（服务微化）一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；","text":"一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案； 2、微服务2014，martin fowler微服务：架构风格（服务微化）一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 ##环境准备谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入注意：即使指定了对象加载的配置文件，但是如果主配置文件中存在该对象并能成功解析，那么直接使用先找到的对象，application.properties&gt;application.yml 配置文件 12345678910111213person:# lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 last-name: zhangsan javaBean： 123456789101112131415161718192021/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； *@ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;······ 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码12345678910111213#diea properties默认使用utf-8#配置person的值person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=false#对象person.maps.k1=v1 person.maps.k2=14#listperson.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件是yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 注意：即使指定了对象加载的配置文件，但是如果主配置文件中存在该对象并能成功解析，那么直接使用先找到的对象，application.properties&gt;application.yml 使用@PropertySource也需要@ConfigurationProperties(prefix = “person”)注解 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 123456789@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)//导入Spring的配置文件让其生效@SpringBootApplicationpublic class SpringBoot02ConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot02ConfigApplication.class, args); &#125;&#125; 不来编写Spring的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(\"配置类@Bean给容器中添加组件了...\"); return new HelloService(); &#125;&#125; ##4、配置文件占位符 1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值12345678910person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,c#hello默认值person.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 12#2.0以上版本java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087 --server.servlet.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports(){AutoConfigurationImportSelector类中}方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 1HttpProperties.class 新版本已更名 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = \"spring.http.encoding\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223242526272829//springboot新版本============================CONDITIONS EVALUATION REPORT=====================================================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 9、常用配置属性123#视图解析器前后缀spring.mvc.view.prefix=/WEB-INF/spring.mvc.view.suffix=.jsp 使用@ConditionalOnProperty来控制是否生成一个bean1. 简介 Spring Boot通过@ConditionalOnProperty来控制Configuration是否生效 2. 说明12345678910111213141516171819@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Documented@Conditional(OnPropertyCondition.class)public @interface ConditionalOnProperty &#123; String[] value() default &#123;&#125;; //数组，获取对应property名称的值，与name不可同时使用 String prefix() default &quot;&quot;;//property名称的前缀，可有可无 String[] name() default &#123;&#125;;//数组，property完整名称或部分名称（可与prefix组合使用，组成完整的property名称），与value不可同时使用 String havingValue() default &quot;&quot;;//可与name组合使用，比较获取到的属性值与havingValue给定的值是否相同，相同才加载配置 boolean matchIfMissing() default false;//缺少该property时是否可以加载。如果为true，没有该property也会正常加载；反之报错 boolean relaxedNames() default true;//是否可以松散匹配，至今不知道怎么使用的 &#125; &#125; 3. 使用方法 通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值。如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效。 4. code12345678910111213@Configuration//在application.properties配置\"mf.assert\"，对应的值为true@ConditionalOnProperty(prefix=\"mf\",name = \"assert\", havingValue = \"true\")public class AssertConfig &#123; @Autowired private HelloServiceProperties helloServiceProperties; @Bean public HelloService helloService()&#123; HelloService helloService = new HelloService(); helloService.setMsg(helloServiceProperties.getMsg()); return helloService; &#125;&#125; 5. 收获springboot注解丰富，我们可以利用好这些注解来实现我们自定义的starter配置，减少硬编码的校验，降低组件间的耦合性!!! 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(\"rawtypes\")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用(配置）；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%nSpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(\"/webjars/**\") .addResourceLocations( \"classpath:/META-INF/resources/webjars/\") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== java/resources都是内路径的根路径（classpath） 12345\"classpath:/META-INF/resources/\", \"classpath:/resources/\",\"classpath:/static/\", \"classpath:/public/\" \"/\"：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc http://localhost:8080/asserts/js/Chart.min.js ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 12#定义自己的静态资源文件夹spring.resources.static-locations=classpath:/hello/,classpath:/atguigu/ 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=\"$&#123;session.user&#125;： &lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*&#123;lastName&#125;\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*&#123;nationality&#125;\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType='FAST')&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=\"~&#123;commons :: main&#125;\"&gt;...&lt;/div&gt; Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path=\"/hello\" view-name=\"success\"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/hello\"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter（@deprecate）类型；不能标注@EnableWebMvc==; 实现接口WebMvcConfigurer为2支持 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = \"spring.messages\")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * \"org.mypackage\"), it will be resolved from the classpath root. */ private String basename = \"messages\"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"asserts/css/bootstrap.min.css\" th:href=\"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"asserts/css/signin.css\" th:href=\"@&#123;/asserts/css/signin.css&#125;\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\"&gt; &lt;img class=\"mb-4\" th:src=\"@&#123;/asserts/img/bootstrap-solid.svg&#125;\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#&#123;login.tip&#125;\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#&#123;login.username&#125;\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.password&#125;\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#&#123;login.password&#125;\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#&#123;login.btn&#125;\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split(\"_\"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style=\"color: red\" th:text=\"$&#123;msg&#125;\" th:if=\"$&#123;not #strings.isEmpty(msg)&#125;\"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(\"loginUser\"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute(\"msg\",\"没有权限请先登陆\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); &#125; &#125;; return adapter; &#125; ==2.0以上版本会拦截静态资源== 12345678//静态文件@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; //静态文件 registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/static/\"); //webjar文件 registry.addResourceHandler(\"/webjars/**\").addResourceLocations(\"/webjars/\");&#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE thymeleaf默认为classpath:/templates/xxx.html 123 // thymeleaf默认就会拼串// classpath:/templates/xxxx.htmlreturn \"emp/list\"; 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=\"~&#123;footer :: copy&#125;\"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class=\"col-md-2 d-none d-md-block bg-light sidebar\" id=\"sidebar\"&gt; &lt;div class=\"sidebar-sticky\"&gt; &lt;ul class=\"nav flex-column\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link active\" th:class=\"$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;\" href=\"#\" th:href=\"@&#123;/main.html&#125;\"&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\"&gt; &lt;path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"&gt;&lt;/path&gt; &lt;polyline points=\"9 22 9 12 15 12 15 22\"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace=\"commons/bar::#sidebar(activeUri='emps')\"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添加&lt;/button&gt;&lt;/form&gt; // redirect: 表示重定向到一个地址 /代表当前项目路径// forward: 表示转发到一个地址 thymeleaf的视图解析器代码 123456789101112131415161718192021222324252627282930313233public class ThymeleafViewResolver extends AbstractCachingViewResolver implements Ordered &#123;@Override protected View createView(final String viewName, final Locale locale) throws Exception &#123; // First possible call to check \"viewNames\": before processing redirects and forwards if (!this.alwaysProcessRedirectAndForward &amp;&amp; !canHandle(viewName, locale)) &#123; vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" cannot be handled by ThymeleafViewResolver. Passing on to the next resolver in the chain.\", viewName); return null; &#125; // Process redirects (HTTP redirects) if (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123; vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" is a redirect, and will not be handled directly by ThymeleafViewResolver.\", viewName); final String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length(), viewName.length()); final RedirectView view = new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible()); return (View) getApplicationContext().getAutowireCapableBeanFactory().initializeBean(view, viewName); &#125; // Process forwards (to JSP resources) if (viewName.startsWith(FORWARD_URL_PREFIX)) &#123; // The \"forward:\" prefix will actually create a Servlet/JSP view, and that's precisely its aim per the Spring // documentation. See http://docs.spring.io/spring-framework/docs/4.2.4.RELEASE/spring-framework-reference/html/mvc.html#mvc-redirecting-forward-prefix vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" is a forward, and will not be handled directly by ThymeleafViewResolver.\", viewName); final String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length(), viewName.length()); return new InternalResourceView(forwardUrl); &#125; // Second possible call to check \"viewNames\": after processing redirects and forwards if (this.alwaysProcessRedirectAndForward &amp;&amp; !canHandle(viewName, locale)) &#123; vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" cannot be handled by ThymeleafViewResolver. Passing on to the next resolver in the chain.\", viewName); return null; &#125; vrlogger.trace(\"[THYMELEAF] View &#123;&#125; will be handled by ThymeleafViewResolver and a \" + \"&#123;&#125; instance will be created for it\", viewName, getViewClass().getSimpleName()); return loadView(viewName, locale); &#125; springboot在WebMvcAutoConfiguration.java中默认配置的格式是 1234/** * Date format to use. For instance, `dd/MM/yyyy`. */private String dateFormat; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action=\"@&#123;/emp&#125;\" method=\"post\"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name=\"_method\";值就是我们指定的请求方式--&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"$&#123;emp!=null&#125;\"/&gt; &lt;input type=\"hidden\" name=\"id\" th:if=\"$&#123;emp!=null&#125;\" th:value=\"$&#123;emp.id&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.email&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;option th:selected=\"$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;\" th:value=\"$&#123;dept.id&#125;\" th:each=\"dept:$&#123;depts&#125;\" th:text=\"$&#123;dept.departmentName&#125;\"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"$&#123;emp!=null&#125;?'修改':'添加'\"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each=\"emp:$&#123;emps&#125;\"&gt; &lt;td th:text=\"$&#123;emp.id&#125;\"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text=\"$&#123;emp.email&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.gender&#125;==0?'女':'男'\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.department.departmentName&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-sm btn-primary\" th:href=\"@&#123;/emp/&#125;+$&#123;emp.id&#125;\"&gt;编辑&lt;/a&gt; &lt;button th:attr=\"del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;\" class=\"btn btn-sm btn-danger deleteBtn\"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(\".deleteBtn\").click(function()&#123; //删除当前员工的 $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(\"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;\")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = \"text/html\")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value(\"$&#123;error.path:/error&#125;\")private String path = \"/error\"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 123456789101112* Default implementation of &#123;@link ErrorAttributes&#125;. Provides the following attributes * when possible: * &lt;ul&gt; * &lt;li&gt;timestamp - The time that the errors were extracted&lt;/li&gt; * &lt;li&gt;status - The status code&lt;/li&gt; * &lt;li&gt;error - The error reason&lt;/li&gt; * &lt;li&gt;exception - The class name of the root exception (if configured)&lt;/li&gt; * &lt;li&gt;message - The exception message&lt;/li&gt; * &lt;li&gt;errors - Any &#123;@link ObjectError&#125;s from a &#123;@link BindingResult&#125; exception * &lt;li&gt;trace - The exception stack trace&lt;/li&gt; * &lt;li&gt;path - The URL path when the exception was raised&lt;/li&gt; * &lt;/ul&gt; ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 1234567891011121314@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; &#125;&#125;//1、浏览器客户端返回的都是json//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 123BasicErrorController中获取状态码的方法protected HttpStatus getStatus(HttpServletRequest request) &#123; Integer statusCode = (Integer) request.getAttribute(\"javax.servlet.error.status_code\"); 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); //转发到/error return \"forward:/error\"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、（html）页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\"company\",\"atguigu\"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 12345678910111213141516171819202122@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125;//2.0以上版本=============== @Bean //一定要将这个定制器加入到容器中public WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; aa()&#123; return new WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableServletWebServerFactory server) &#123; server.setPort(9000); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\"/myServlet\"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 2.0版本 ![](E:\\pictures\\Language\\spring boot\\images\\configurable继承.png) 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；2.0springboot的autoConfigure类： 12345678910111213141516171819202122232425262728293031@Configuration@ConditionalOnWebApplication@EnableConfigurationProperties(ServerProperties.class)public class EmbeddedWebServerFactoryCustomizerAutoConfiguration &#123; /** * Nested configuration if Tomcat is being used. */ @Configuration @ConditionalOnClass(&#123; Tomcat.class, UpgradeProtocol.class &#125;) public static class TomcatWebServerFactoryCustomizerConfiguration &#123; @Bean public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) &#123; return new TomcatWebServerFactoryCustomizer(environment, serverProperties); &#125; &#125; @Configuration@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@ConditionalOnClass(ServletRequest.class)@ConditionalOnWebApplication(type = Type.SERVLET)@EnableConfigurationProperties(ServerProperties.class)@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, ServletWebServerFactoryConfiguration.EmbeddedTomcat.class, ServletWebServerFactoryConfiguration.EmbeddedJetty.class, ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)public class ServletWebServerFactoryAutoConfiguration &#123; EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor WebServerFactoryCustomizerBeanPostProcessor（2.0版本） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器//2.0版本 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof WebServerFactory) &#123; postProcessBeforeInitialization((WebServerFactory) bean); &#125; return bean; &#125; private Collection&lt;WebServerFactoryCustomizer&lt;?&gt;&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;&gt;(getWebServerFactoryCustomizerBeans()); this.customizers.sort(AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers; &#125; 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 123456789101112131415161718192021222324public class SpringApplication &#123;protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; switch (this.webApplicationType) &#123; case SERVLET: contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); &#125; &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( \"Unable create a default ApplicationContext, \" + \"please specify an ApplicationContextClass\", ex); &#125; &#125; return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass); &#125; 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 1private void createWebServer()//2.0版本 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); 1ServletWebServerFactory factory = getWebServerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory(TomcatServletWebServerFactory)创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 1this.webServer = factory.getWebServer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 12345public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123;this.onRefresh(); // 创建servlet容器this.registerListeners();this.finishBeanFactoryInitialization(beanFactory); //创建我们自己定义的bean组件 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer ![](E:\\pictures\\Language\\spring boot\\images\\ServletContainerInitializer目录.png) 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info(\"Root context already created (using as parent).\"); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), \"No SpringApplication sources have been defined. Either override the \" + \"configure method or add an @Configuration annotation\"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 123456789//自己的SpringBootServletInitializer的子类重写了configure方法public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动Servlet容器，再启动SpringBoot应用== 五、Docker详见docker.md 六.SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 12345678910spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc url: jdbc:mysql://localhost:3306/yoj?serverTimezone=UTC driver-class-name: com.mysql.jdbc.Driver com.mysql.cj.jdbc.Drive Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； 1//class com.zaxxer.hikari.HikariDataSource 2.0版本默认使用 ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = \"spring.datasource.type\")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； 1DataSourceInitializerInvoker 2.0版本还包括了这个类 ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 12345678910111213141516171819202122schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.31.39:3307/jdbc driver-class-name: com.mysql.cj.jdbc.Driver #DDL schema: - classpath:department.sql #DML data: - classpath:insert-dept.sql #2.0需要开启 initialization-mode: always 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); initParams.put(\"allow\",\"\");//默认就是允许所有访问 initParams.put(\"deny\",\"192.168.15.21\"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; &#125;&#125; 3、整合MyBatis123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt;#2.0注释 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select(\"select * from department where id=#&#123;id&#125;\") public Department getDeptById(Integer id); @Delete(\"delete from department where id=#&#123;id&#125;\") public int deleteDeptById(Integer id);//声明自增主键，这样就能拿到自增的主键值 @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#&#123;departmentName&#125;)\") public int insertDept(Department department); @Update(\"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;\") public int updateDept(Department department);&#125; 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789//使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = \"com.atguigu.springboot.mapper\")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 1234567891011121314//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = \"tbl_user\") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；@JsonIgnoreProperties(&#123;\"handler\",\"hibernateLazyInitializer\"&#125;)//解决json报错public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = \"last_name\",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行run方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 //打印控制台图标 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println(\"ApplicationContextInitializer...initialize...\"+applicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println(\"SpringApplicationRunListener...starting...\"); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get(\"os.name\"); System.out.println(\"SpringApplicationRunListener...environmentPrepared..\"+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println(\"SpringApplicationRunListener...contextPrepared...\"); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println(\"SpringApplicationRunListener...contextLoaded...\"); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println(\"SpringApplicationRunListener...finished...\"); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(\"ApplicationRunner...run....\"); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(\"CommandLineRunner...run...\"+ Arrays.asList(args)); &#125;&#125; 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie //结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = \"atguigu.hello\")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 123456789101112131415161718package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+\"-\" +name + helloProperties.getSuffix(); &#125;&#125; 12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples Springboot 部署jar包(官方推荐)jar包方式启动，也就是使用spring boot内置的tomcat运行。服务器上面只要你配置了jdk1.8及以上，就ok。不需要外置tomcat1.打成jar包 2.将jar包放到任意目录，执行下面的命令 1234567$ nohup java -jar test.jar &gt;temp.txt &amp;nohup java -jar yoj.jar &gt;yoj.txt &amp;ubuntu@VM-0-5-ubuntu:~$ java -Dfile.encoding=utf-8 -jar yoj-0.0.1-SNAPSHOT.jar &gt; yoj.txt &amp;java -Dfile.encoding=utf-8 -jar -Dserver.port=8080 xxx.jar //这种方法会把日志文件输入到你指定的文件中，没有则会自动创建。进程会在后台运行。 nohupnohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 nohup 是 no hang up 的缩写，就是不挂断的意思。 nohup命令： 如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。 在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。 案例\\1. nohup command &gt; myout.file 2&gt;&amp;1 &amp; 在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ； 2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。 \\2. 0 22 * * * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py &gt; /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2&gt;&amp;1 这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中 服务器注意事项1.mysql字符集需要设置为utf-82.spring boot 的control==@RequestMapping字符串必须由“/”开始== 不然本地能访问，但是服务器不能访问 1@RequestMapping(\"/set/&#123;pageNumber&#125;\") return 不能加斜杆 return “problem/set”; spring boot 加密导入jar包123456&lt;!-- https://mvnrepository.com/artifact/com.github.ulisesbocchio/jasypt-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; jasypt.encryptor. password: 加密密码的字符串 123456789jasypt: encryptor: password: lmz#配置数据源spring: datasource: url: jdbc:mysql://localhost:3306/yoj?serverTimezone=UTC username: root password: 123456 编写测试类 12345678910111213141516171819202122232425262728package com.yoj;import org.jasypt.encryption.StringEncryptor;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class EncryptTest &#123; @Autowired StringEncryptor encryptor; @Test public void test()&#123; String userName = encryptor.encrypt(\"root\"); System.out.println(userName); String password = encryptor.encrypt(\"123456\"); System.out.println(password); String originUserName = encryptor.decrypt(\"2IL6K8NI+eUHYpu8AsfB7Q==\"); System.out.println(originUserName); String originPassword = encryptor.decrypt(\"+u6jN11/Ykzl5kHU0rg2Ew==\"); System.out.println(originPassword); &#125;&#125; 将得到的加密串，写到数据库配置 123456789jasypt: encryptor: password: lmz#配置数据源spring: datasource: url: jdbc:mysql://localhost:3306/yoj?serverTimezone=UTC username: ENC(&#123;2IL6K8NI+eUHYpu8AsfB7Q==&#125;) password: NEC(&#123;vojGG7u7QZ3mN1DsX1gA1g==&#125;) 常见问题test测试插入，数据并没有保存到数据库使用junit测试插入，测试显示成功，但是数据并没有保存到数据库。是因为在junit下，插入数据会自动回滚，所以测试显示成功但实际上不能插入。若要插入到数据库，只需在测试方法上添加@Rollback(false)注解即可。 自己使用文件上传、下载官方文档 自己例子：上传图片 Application.java添加@EnableConfigurationProperties(StorageProperties.class) 123456@EnableConfigurationProperties(StorageProperties.class)public class YojApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(YojApplication.class, args); &#125;&#125; 1234567891011121314151617@ConfigurationProperties(\"storage\")public class StorageProperties &#123; /** * Folder location for storing files */ private String location = \"upload-dir\"; public String getLocation() &#123; return location; &#125; public void setLocation(String location) &#123; this.location = location; &#125;&#125; 注：项目名/upload-dir/avatar目录需存在 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@Service@Slf4jpublic class StorageService &#123;// @Value(\"$&#123;spring.servlet.multipart.location&#125;\") private final Path storeRootLocation; @Autowired private UserUtil currentUserUtil; @Autowired public StorageService(StorageProperties properties) &#123; this.storeRootLocation = Paths.get(properties.getLocation()); &#125; /** * @param uploadFile * @return is or not upload successfully */ public boolean storeAvatar(MultipartFile uploadFile, HttpServletRequest req) &#123; // empty file data if (uploadFile == null || uploadFile.isEmpty()) &#123; log.info(\"not have uploadFile data\"); return false; &#125; // 组成新的文件名 String oldName = uploadFile.getOriginalFilename(); //不是图片后缀名 if (!oldName.endsWith(\".jpg\") &amp;&amp; !oldName.endsWith(\".png\") &amp;&amp; !oldName.endsWith(\".gif\")) &#123; log.info(\"not have a image suffix\"); return false; &#125; //related path : static/uploadFile // newFile is composed of saveDirectory + useId.originSuffix String newFileName = currentUserUtil.getUserDetail().getUsername() + oldName.substring(oldName.lastIndexOf(\".\"), oldName.length()); Path storePath = Paths.get(storeRootLocation.normalize().toAbsolutePath().toString(), \"avatar\", newFileName); try (InputStream inputStream = uploadFile.getInputStream()) &#123; Files.copy(inputStream, storePath, StandardCopyOption.REPLACE_EXISTING); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // judge is or not a image file File savedImage = new File(storePath.toString()); if (!isImage(savedImage)) &#123; log.info(\"is not a image file\"); savedImage.delete(); return false; &#125; return true; &#125; /** * 通过读取文件并获取其width及height的方式，来判断判断当前文件是否图片，这是一种非常简单的方式。 * 这种方式较安全！ * * @param imageFile * @return */ public static boolean isImage(File imageFile) &#123; if (!imageFile.exists()) &#123; return false; &#125; Image img = null; try &#123; img = ImageIO.read(imageFile); if (img == null || img.getWidth(null) &lt;= 0 || img.getHeight(null) &lt;= 0) &#123; return false; &#125; return true; &#125; catch (Exception e) &#123; return false; &#125; finally &#123; img = null; &#125; &#125;&#125; 123456789101112131415#文件传输配置spring.servlet.multipart.enabled=truespring.servlet.multipart.file-size-threshold=0#表示上传文件的临时保存位置，要保证其路径存在。可以省略配置#spring.servlet.multipart.location=D:\\\\OJspring.servlet.multipart.max-file-size=1MBspring.servlet.multipart.max-request-size=10MBspring.servlet.multipart.resolve-lazily=false#代码解释：#第l 行表示是否开启文件上传支持，默认为true。#第2 行表示文件写入磁盘的闽值，默认为0 。#第4 行表示上传的羊个文件的最大大小，默认为11\\侣。#第5 行表示多文件上传时文件的总大小，默认为10孔侣。#第6 行表示文件是否延迟解析，默认为false 。 通过url访问项目外的其他目录下的图片1.首先在application.properties文件中增加配置： 123456#资源绝对路径为file: D://Codes/Java/yoj/upload-dir，图片存放的真实路径#意思是springboot开放此资源路径供外部读取spring.resources.static-locations=file:D://Codes/Java/yoj/upload-dir#资源映射路径为/image/**，使用url访问的请求路径spring.mvc.static-path-pattern=/image/** vue 1&lt;img class=&quot;user-img ml-auto&quot; :src=&quot;appApi+&apos;/image/avatar/1.jpg&apos;&quot;/&gt; 2.如果项目使用了权限认证，则需要将/image/** 添加在免认证的配置中，才能直接访问。 如此便可以访问图片了：https://localhost:8050/image/avatar/1.jpg","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"springBoot","slug":"springBoot","permalink":"https://codeofli.github.io/tags/springBoot/"}]},{"title":"OnJava8","slug":"java-note/OnJava8/OnJava8","date":"2019-11-15T07:43:44.000Z","updated":"2021-10-23T02:19:02.855Z","comments":true,"path":"2019/11/java-note/OnJava8/OnJava8/","link":"","permalink":"https://codeofli.github.io/2019/11/java-note/OnJava8/OnJava8/","excerpt":"简介OnJava8，thinkingInJava源作者作，被称为thinking in java 5. “我的语言极限，即是我的世界的极限。” ——路德维希·维特根斯坦（Wittgenstein） 就我个人而言，把一切事物都抽象成对象不仅是一项不必要的负担，同时还会招致许多设计朝着不好的方向发展。尽管如此，“对象”的概念依然有其闪光点。固执地要求所有东西都是一个对象（特别是一直到最底层级别）是一种设计错误；相反，完全逃避“对象”的概念似乎同样太过苛刻。","text":"简介OnJava8，thinkingInJava源作者作，被称为thinking in java 5. “我的语言极限，即是我的世界的极限。” ——路德维希·维特根斯坦（Wittgenstein） 就我个人而言，把一切事物都抽象成对象不仅是一项不必要的负担，同时还会招致许多设计朝着不好的方向发展。尽管如此，“对象”的概念依然有其闪光点。固执地要求所有东西都是一个对象（特别是一直到最底层级别）是一种设计错误；相反，完全逃避“对象”的概念似乎同样太过苛刻。 Java 语言曾规划设计的许多功能并未按照承诺兑现。本书中，我将尝试解释这些原因，力争让读者知晓这些功能，并明白为什么这些功能最终并不适用。这无关 Java 是一种好语言或者坏语言，一旦你了解了该语言的缺陷和局限性，你就能够： 明白有些功能特性为什么会被“废弃”。 熟悉语言边界，更好地设计和编码。 编程的过程就是复杂性管理的过程：业务问题的复杂性，以及依赖的计算机的复杂性。 第一章 对象的概念 “我们没有意识到惯用语言的结构有多大的力量。可以毫不夸张地说，它通过语义反应机制奴役我们。语言表现出来并在无意识中给我们留下深刻印象的结构会自动投射到我们周围的世界。” – Alfred Korzybski (1930) 抽象面向对象编程（Object-Oriented Programming OOP）是一种编程思维方式和编码架构。 OOP 允许我们根据问题来描述问题，而不是根据运行解决方案的计算机 我们可理解“纯粹”的面向对象程序设计方法是什么样的： 万物皆对象。你可以将对象想象成一种特殊的变量。它存储数据，但可以在你对其“发出请求”时执行本身的操作。理论上讲，你总是可以从要解决的问题身上抽象出概念性的组件，然后在程序中将其表示为一个对象。 程序是一组对象，通过消息传递来告知彼此该做什么。要请求调用一个对象的方法，你需要向该对象发送消息。 每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。 每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。 同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法，大家不久便能理解。由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收发送给”形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。 对对象更简洁的描述：：一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态)、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）。 当我们进行面向对象的程序设计时，面临的最大一项挑战性就是：如何在“问题空间”（问题实际存在的地方）的元素与“方案空间”（对实际问题进行建模的地方，如计算机）的元素之间==建立理想的“一对一”的映射关系。== 接口每个对象仅能接受特定的请求。我们向对象发出的请求是通过它的“接口”（Interface）定义的 提供服务软件设计的基本原则是高内聚：每个组件的内部作用明确，功能紧密相关。然而经常有人将太多功能塞进一个对象中。在良好的面向对象设计中，每个对象功能单一且高效。这样的程序设计可以提高我们代码的复用性，同时也方便别人阅读和理解我们的代码。 封装使用访问控制的原因有以下两点： 让应用程序员不要触摸他们不应该触摸的部分。（请注意，这也是一个哲学决策。部分编程语言认为如果程序员有需要，则应该让他们访问细节部分。）； 使类库的创建者（研发程序员）在不影响后者使用的情况下完善更新工具库。例如，我们开发了一个功能简单的工具类，后来发现可以通过优化代码来提高执行速度。假如工具类的接口和实现部分明确分开并受到保护，那我们就可以轻松地完成改造。 Java 有三个显式关键字来设置类中的访问权限：public（公开），private(私有)和protected（受保护）。这些访问修饰符决定了谁能使用它们修饰的方法、变量或类。 public（公开）表示任何人都可以访问和使用该元素； private（私有）除了类本身和类内部的方法，外界无法直接访问该元素。private 是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误； protected（受保护）类似于 private，区别是子类（下一节就会引入继承的概念）可以访问 protected 的成员，但不能访问 private 成员； default（默认）如果你不使用前面的三者，默认就是 default 访问权限。default 被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。 复用代码和设计方案的复用性是面向对象程序设计的优点之一。我们可以将一个类的对象作为另一个类的成员变量使用。 这里涉及到“组合”和“聚合”的概念： 组合（Composition）经常用来表示“拥有”关系（has-a relationship）。例如，“汽车拥有引擎”。 聚合（Aggregation）动态的组合。 组合和聚合都属于关联关系的一种，只是额外具有整体-部分的意义。聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件。这个区别可以用来区分某个关联关系到底是组合还是聚合。两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。 继承inheritance基类包含派生自它的类型之间共享的所有特征和行为。 单继承结构所有的类都默认从一个基类继承,在 Java 中，这个最终基类的名字就是 Object。 由于所有对象都具有一个公共接口，因此它们最终都属于同一个基类。 单继承的结构使得垃圾收集器的实现更为容易。这也是 Java 在 C++ 基础上的根本改进之一。 由于运行期的类型信息会存在于所有对象中，所以我们永远不会遇到判断不了对象类型的情况。这对于系统级操作尤其重要，例如异常处理。同时，这也让我们的编程具有更大的灵活性。 多态面向对象语言使用后期绑定的概念。当向对象发送信息时，被调用的代码直到运行时才确定。编译器确保方法存在，并对参数和返回值执行类型检查，但是它不知道要执行的确切代码。 为了执行后期绑定，Java 使用一个特殊的代码位来代替绝对调用。这段代码使用对象中存储的信息来计算方法主体的地址（此过程在多态性章节中有详细介绍）。因此，每个对象的行为根据特定代码位的内容而不同。当你向对象发送消息时，对象知道该如何处理这条消息。在某些语言中，必须显式地授予方法后期绑定属性的灵活性。例如，C++ 使用 virtual 关键字。在这些语言中，默认情况下方法不是动态绑定的。 在 Java 中，==动态绑定是默认行为==，不需要额外的关键字来实现多态性。 把子类当成其基类来处理的过程叫做“向上转型”（upcasting）。 面向对象的程序设计语言是通过“动态绑定”的方式来实现对象的多态性的。 集合collection“集合”这种类型的对象可以存储任意类型、数量的其他对象。它能根据需要自动扩容，我们不用关心过程是如何实现的。 Java 5 版本前的集合只保存 Object,每次取出元素都要做额外的“向下转型”对程序和程序员都是一种开销。 参数化类型机制（Parameterized Type Mechanism）。 参数化类型机制可以使得编译器能够自动识别某个 class 的具体类型并正确地执行。 Java 5 版本支持了参数化类型机制，称之为“泛型”（Generic）。 对象创建与生命周期在 C++ 程序设计中，当使用完一个对象后，必须明确将其删除。 在 C++ 设计中采用的观点是效率第一，因此它将选择权交给了程序员。为了获得最大的运行时速度，程序员可以在编写程序时，通过将对象放在栈（Stack，有时称为自动变量或作用域变量）或静态存储区域（static storage area）中来确定内存占用和生存时间。这些区域的对象会被优先分配内存和释放。 第二种方法是在堆内存（Heap）中动态地创建对象。在这种方式下，直到程序运行我们才能确定需要创建的对象数量、生存时间和类型。什么时候需要，什么时候在堆内存中创建。 因为内存的占用是动态管理的，所以在运行时，在堆内存上开辟空间所需的时间可能比在栈内存上要长（但也不一定）。在栈内存开辟和释放空间通常是一条将栈指针向下移动和一条将栈指针向上移动的汇编指令。开辟堆内存空间的时间取决于内存机制的设计。 动态方法有这样一个一般性的逻辑假设：对象趋向于变得复杂，因此额外的内存查找和释放对对象的创建影响不大。（原文：The dynamic approach makes the generally logical assumption that objects tend to be complicated, so the extra overhead of finding storage and releasing that storage will not have an important impact on the creation of an object.）此外，更好的灵活性对于问题的解决至关重要。 Java 使用动态内存分配。每次创建对象时，使用 new 关键字构建该对象的动态实例。这又带来另一个问题：对象的生命周期。较之堆内存，在栈内存中创建对象，编译器能够确定该对象的生命周期并自动销毁它；然而如果你在堆内存创建对象的话，编译器是不知道它的生命周期的。在 C++ 中你必须以编程方式确定何时销毁对象，否则可能导致内存泄漏。Java 的内存管理是建立在垃圾收集器上的，它能自动发现对象不再被使用并释放内存。垃圾收集器的存在带来了极大的便利，它减少了我们之前必须要跟踪的问题和编写相关代码的数量。 异常处理异常处理机制将程序错误直接交给编程语言甚至是操作系统。“异常”（Exception）是一个从出错点“抛出”（thrown）后能被特定类型的异常处理程序捕获(catch)的一个对象。它不会干扰程序的正常运行，仅当程序出错的时候才被执行。 第二章 安装Java和本书用例Shell如果你之前没有接触过编程，那么有可能对 Shell（命令行窗口） 不太熟悉。shell 的历史可以追溯到早期的计算时代，当时在计算机上的操作是都通过输入命令进行的，计算机通过回显响应。所有的操作都是基于文本的。 尽管和现在的图形用户界面相比，Shell 操作方式很原始。但是同时 shell 也为我们提供了许多有用的功能特性。在学习本书的过程中，我们会经常使用到 Shell，包括现在这部分的安装，还有运行 Java 程序。 Mac：单击聚光灯（屏幕右上角的放大镜图标），然后键入 terminal。单击看起来像小电视屏幕的应用程序（你也可以单击“return”）。这就启动了你的用户下的 shell 窗口。 windows：首先，通过目录打开 windows 资源管理器： Windows 7: 单击屏幕左下角的“开始”图标，输入“explorer”后按回车键。 Windows 8: 按 Windows+Q，输入 “explorer” 后按回车键。 Windows 10: 按 Windows+E 打开资源管理器，导航到所需目录，单击窗口左上角的“文件“选项卡，选择“打开 Window PowerShell”启动 Shell。 Linux: 在 home 目录打开 Shell。 Debian: 按 Alt+F2， 在弹出的对话框中输入“gnome-terminal” Ubuntu: 在屏幕中鼠标右击，选择 “打开终端”，或者按住 Ctrl+Alt+T Redhat: 在屏幕中鼠标右击，选择 “打开终端” Fedora: 按 Alt+F2，在弹出的对话框中输入“gnome-terminal” 目录 目录是 Shell 的基础元素之一。目录用来保存文件和其他目录。目录就好比树的分支。如果书籍是你系统上的一个目录，并且它有两个其他目录作为分支，例如数学和艺术，那么我们就可以说你有一个书籍目录，它包含数学和艺术两个子目录。注意：Windows 使用 \\ 而不是 / 来分隔路径。 Shell基本操作 我在这展示的 Shell 操作和系统中大体相同。出于本书的原因，下面列举一些在 Shell 中的基本操作： 123456789101112131415161718192021222324252627282930313233343536373839更改目录： cd &lt;路径&gt; cd .. 移动到上级目录 pushd &lt;路径&gt; 记住来源的同时移动到其他目录，popd 返回来源目录列举： ls 列举出当前目录下所有的文件和子目录名（不包含隐藏文件）， 可以选择使用通配符 * 来缩小搜索范围。 示例(1)： 列举所有以“.java”结尾的文件，输入 ls *.java (Windows: dir *.java) 示例(2)： 列举所有以“F”开头，“.java”结尾的文件，输入ls F*.java (Windows: dir F*.java)创建目录： Mac/Linux 系统：mkdir 示例：mkdir books Windows 系统：md 示例：md books移除文件： Mac/Linux 系统：rm 示例：rm somefile.java Windows 系统：del 示例：del somefile.java移除目录： Mac/Linux 系统：rm -r 示例：rm -r books Windows 系统：deltree 示例：deltree books重复命令： !! 重复上条命令 示例：!n 重复倒数第n条命令命令历史： Mac/Linux 系统：history Windows 系统：按 F7 键文件解压： Linux/Mac 都有命令行解压程序 unzip，你可以通过互联网为 Windows 安装命令行解压程序 unzip。 图形界面下（Windows 资源管理器，Mac Finder，Linux Nautilus 或其他等效软件）右键单击该文件， 在 Mac 上选择“open”，在 Linux 上选择“extract here”，或在 Windows 上选择“extract all…”。 要了解关于 shell 的更多信息，请在维基百科中搜索 Windows shell，Mac/Linux用户可搜索 bash shell。 安装和运行代码示例当 Java 安装完毕，下一步就是安装本书的代码示例了。安装步骤所有平台一致： 从 GitHub 仓库中下载本书代码示例 解压到你所选目录里。 使用 Windows 资源管理器，Mac Finder，Linux 的 Nautilus 或其他等效工具浏览，在该目录下打开 Shell。 如果你在正确的目录中，你应该看到该目录中名为 gradlew 和 gradlew.bat 的文件，以及许多其他文件和目录。目录与书中的章节相对应。 在shell中输入下面的命令运行： 12345Windows 系统： gradlew runMac/Linux 系统： ./gradlew run 第一次安装时 Gradle 需要安装自身和其他的相关的包，请稍等片刻。安装完成后，后续的安装将会快很多。 注意： 第一次运行 gradlew 命令时必须连接互联网。 Gradle 基础任务 本书构建的大量 Gradle 任务都可以自动运行。Gradle 使用约定大于配置的方式，简单设置即可具备高可用性。本书中“一起去骑行”的某些任务不适用于此或无法执行成功。以下是你通常会使用上的 Gradle 任务列表： 123456789101112编译本书中的所有 java 文件，除了部分错误示范的gradlew compileJava编译并执行 java 文件（某些文件是库组件）gradlew run执行所有的单元测试（在本书第16章会有详细介绍）gradlew test编译并运行一个具体的示例程序gradlew &lt;本书章节&gt;:&lt;示例名称&gt;示例：gradlew objects:HelloDate 空白 final空白 final 指的是没有初始化值的 final 属性。编译器确保空白 final 在使用前必须被初始化。这样既能使一个类的每个对象的 final 属性值不同，也能保持它的不变性。 你必须在定义时或在每个构造器中执行 final 变量的赋值操作。这保证了 final 属性在使用前已经被初始化过。 final 参数在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量 如果一个方法是 private 的，它就不是基类接口的一部分。它只是隐藏在类内部的代码，且恰好有相同的命名而已。但是如果你在派生类中以相同的命名创建了 public，protected 或包访问权限的方法，这些方法与基类中的方法没有联系，你没有覆写方法，只是在创建新的方法而已。 final 和 private类中所有的 private 方法==都隐式地指定为 final。==因为不能访问 private 方法，所以不能覆写它。可以给 private 方法添加 final 修饰，但是并不能给方法带来额外的含义。 final 类当说一个类是 final （final 关键字在类定义之前），就意味着它不能被继承。之所以这么做，是因为类的设计就是永远不需要改动，或者是出于安全考虑不希望它有子类。 final 类的属性可以根据个人选择是或不是 final。这同样适用于不管类是否是 final 的内部 final 属性。然而，由于 final 类禁止继承，类中所有的方法都被隐式地指定为 final，所以没有办法覆写它们。你可以在 final 类中的方法加上 final 修饰符，但不会增加任何意义。 类初始化和加载记住每个类的编译代码都存在于它自己独立的文件中。该文件只有在使用程序代码时才会被加载。一般可以说“类的代码在首次使用时加载“。这通常是指创建类的第一个对象，或者是访问了类的 static 属性或方法。构造器也是一个 static 方法尽管它的 static 关键字是隐式的。因此，准确地说，一个类当它任意一个 static 成员被访问时，就会被加载。 首次使用时就是 static 初始化发生时。所有的 static 对象和 static 代码块在加载时按照文本的顺序（在类中定义的顺序）依次初始化。static 变量只被初始化一次。 继承和初始化了解包括继承在内的整个初始化过程是有帮助的，这样可以对所发生的一切有全局性的把握。 首先，对象中的所有基本类型变量都被置为默认值，对象引用被设为 null —— 这是通过将对象内存设为二进制零值一举生成的。接着会调用基类的构造器。本例中是自动调用的，但是你也可以使用 super 调用指定的基类构造器（在 Beetle 构造器中的第一步操作）。基类构造器和派生类构造器一样以相同的顺序经历相同的过程。当基类构造器完成后，实例变量按文本顺序初始化。最终，构造器的剩余部分被执行。 本章小结继承和组合都是从已有类型创建新类型。组合将已有类型作为新类型底层实现的一部分，继承复用的是接口。 使用继承时，派生类具有基类接口，因此可以向上转型为基类，这对于多态至关重要，在下一章你将看到。 尽管在面向对象编程时极力强调继承，但在开始设计时，优先使用组合（或委托），只有当确实需要时再使用继承。组合更具灵活性。另外，通过对成员类型使用继承的技巧，可以在运行时改变成员的类型和行为。因此，可以在运行时改变组合对象的行为。 在设计一个系统时，目标是发现或创建一系列类，每个类有特定的用途，而且既不应太大（包括太多功能难以复用），也不应太小（不添加其他功能就无法使用）。如果设计变得过于复杂，通过将现有类拆分为更小的部分而添加更多的对象，通常是有帮助的。 当开始设计一个系统时，记住程序开发是一个增量过程，正如人类学习。它依赖实验，你可以尽可能多做分析，然而在项目开始时仍然无法知道所有的答案。如果把项目视作一个有机的，进化着的生命去培养，而不是视为像摩天大楼一样快速见效，就能获得更多的成功和更迅速的反馈。继承和组合正是可以让你执行如此实验的面向对象编程中最基本的两个工具。 第三章 万物皆对象 如果我们说另外一种不同的语言，我们会发觉一个不同的世界！— Ludwig Wittgenstein (1889-1951) 对象操纵:You Manipulate Objects with References 对象创建:在 Java 中，通常我们使用new操作符来创建一个新对象。Java 语法允许我们使用带双引号的文本内容来初始化字符串。 1String s = \"asdf\"; 数据存储那么，程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有5个不同的地方可以存储数据： 寄存器（Registers）最快的存储区域，位于 CPU 内部 。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C/C++ 允许开发者向编译器建议寄存器的分配）。 栈内存（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存，这是一种快速有效的内存分配方法，速度仅次于寄存器。创建程序时，Java 系统必须准确地知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据，特别是对象引用，但 Java 对象却是保存在堆内存的。 堆内存（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用 new 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。 常量存储（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器 ROM （只读存储器，Read Only Memory）中 。 非 RAM 存储（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。Java 为轻量级持久化提供了支持。而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。 基本类型的存储有一组类型在 Java 中使用频率很高，它们需要特殊对待，这就是 Java 的基本类型。之所以这么说，是因为它们的创建并不是通过 new 关键字来产生。通常 new 出来的对象都是保存在堆内存中的，以此方式创建小而简单的变量往往是不划算的。所以对于这些基本类型的创建方法，Java 使用了和 C/C++ 一样的策略。也就是说，不是使用 new 创建变量，而是使用一个“自动”变量。 这个变量直接存储”值”，并==置于栈内存中==，因此更加高效。 Java 确定了每种基本类型的内存占用大小。 这些大小不会像其他一些语言那样随着机器环境的变化而变化。这种不变性也是 Java 更具可移植性的一个原因。 基本类型 大小 最小值 最大值 包装类型 boolean — — — Boolean char 16 bits Unicode 0 Unicode 216 -1 Character byte 8 bits -128 +127 Byte short 16 bits - 215 + 215 -1 Short int 32 bits - 231 + 231 -1 Integer long 64 bits - 263 + 263 -1 Long float 32 bits IEEE754 IEEE754 Float double 64 bits IEEE754 IEEE754 Double void — — — Void 所有的数值类型都是有正/负符号的。布尔（boolean）类型的大小没有明确的规定，通常定义为取字面值 “true” 或 “false” 。基本类型有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类。代码示例： 12char c = 'x';Character ch = new Character(c); 或者你也可以使用下面的形式，基本类型自动转换成包装类型（自动装箱）： 1Character ch = new Character('x'); 相对的，包装类型转化为基本类型（自动拆箱）： 1char c = ch; 高精度数值在 Java 中有两种类型的数据可用于高精度的计算。它们是 BigInteger 和 BigDecimal。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。 这两个类包含的方法提供的操作，与对基本类型执行的操作相似。也就是说，能对 int 或 float 做的运算，在 BigInteger 和 BigDecimal 这里也同样可以，只不过必须要通过调用它们的方法来实现而非运算符。此外，由于涉及到的计算量更多，所以运算速度会慢一些。诚然，我们牺牲了速度，但换来了精度。 BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的货币计算。 关于这两个类的详细信息，请参考 JDK 官方文档。 数组的存储在 C 和 C++ 中使用数组是危险的，因为那些数组只是内存块。如果程序访问了内存块之外的数组或在初始化之前使用该段内存（常见编程错误），则结果是不可预测的。 Java 的设计主要目标之一是安全性，因此许多困扰 C 和 C++ 程序员的问题不会在 Java 中再现。在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。（并且 Java 经常可以优化这些操作）。 当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为 null 。在使用该数组之前，我们必须为每个引用指定一个对象 。如果我们尝试使用为 null 的引用，则会在运行时报错。因此，在 Java 中就防止了数组操作的常规错误。 我们还可创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。 代码注释Java 中有两种类型的注释。第一种是传统的 C 风格的注释，以 /* 开头，可以跨越多行，到 */ 结束。注意，许多程序员在多行注释的每一行开头添加 *，所以你经常会看到： 1234/* 这是* 跨越多行的* 注释*/ 但请记住，/* 和 */ 之间的内容都是被忽略的。所以你将其改为下面这样也是没有区别的。 12/* 这是跨越多行的注释 */ 第二种注释形式来自 C++ 。它是单行注释，以 // 开头并一直持续到行结束。这种注释方便且常用，因为直观简单。所以你经常看到： 1// 这是单行注释 对象不需要清理 作用域大多数程序语言都有作用域的概念。作用域决定了在该范围内定义的变量名的可见性和生存周期。在 C、 C++ 和 Java 中，作用域是由大括号 {} 的位置决定的。例如： 12345678910&#123; int x = 12; // 仅 x 变量可用 &#123; int q = 96; // x 和 q 变量皆可用 &#125; // 仅 x 变量可用 // 变量 q 不在作用域内&#125; Java 的变量只有在其作用域内才可用。缩进使得 Java 代码更易于阅读。由于 Java 是一种自由格式的语言，额外的空格、制表符和回车并不会影响程序的执行结果。在 Java 中，你不能执行以下操作，即使这在 C 和 C++ 中是合法的： 123456&#123; int x = 12; &#123; int x = 96; // Illegal &#125;&#125; 在上例中， Java 编译器会在提示变量 x 已经被定义过了。因此，在 C/C++ 中将一个较大作用域的变量”隐藏”起来的做法，在 Java 中是不被允许的。 因为 Java 的设计者认为这样做会导致程序混乱。 对象作用域==Java 对象==与基本类型具有不同的生命周期。当我们使用 new 关键字来创建 Java 对象时，==它的生命周期将会超出作用域==。因此，下面这段代码示例： 1234&#123; String s = new String(\"a string\");&#125; // 作用域终点 上例中，引用 s 在作用域终点就结束了。但是，引用 s 指向的字符串对象依然还在占用内存。在这段代码中，我们无法在这个作用域之后访问这个对象，因为唯一对它的引用 s 已超出了作用域的范围。 只要你需要，new 出来的对象就会一直存活下去。 相比在 C++ 编码中操作内存可能会出现的诸多问题，这些困扰在 Java 中都不复存在了。在 C++ 中你不仅要确保对象的内存在你操作的范围内存在，还必须在使用完它们之后，将其销毁。 那么问题来了：我们在 Java 中并没有主动清理这些对象，那么它是如何避免 C++ 中出现的内存被填满从而阻塞程序的问题呢？答案是：Java 的垃圾收集器会检查所有 new 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。也就是说，我们不必担心内存回收的问题了。你只需简单创建对象即可。当其不再被需要时，能自行被垃圾收集器释放。垃圾回收机制有效防止了因程序员忘记释放内存而造成的“内存泄漏”问题。 类的创建当我们创建好一个类之后，我们可以往类里存放两种类型的元素：方法（method）和字段（field）。 字段基本类型默认值如果类的成员变量（字段）是基本类型，那么在类初始化时，这些类型将会被赋予一个初始值。 基本类型 初始值 boolean false char \\u0000 (null) byte (byte) 0 short (short) 0 int 0 long 0L float 0.0f double 0.0d 这些默认值仅在 Java 初始化类的时候才会被赋予。 这种默认值的赋予并不适用于局部变量 —— 那些不属于类的字段的变量。 方法在 Java 中，方法决定对象能接收哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。格式如： 123[返回类型] [方法名](/*参数列表*/)&#123; // 方法体&#125; ==方法名和参数列表==统称为方法签名（signature of the method）。签名作为方法的唯一标识。 程序编写命名可见性命名控制在任何一门编程语言中都是一个问题。如果你在两个模块中使用相同的命名，那么如何区分这两个名称，并防止两个名称发生“冲突”呢？ Java 采取了一种新的方法避免了以上这些问题：为一个类库生成一个明确的名称，Java 创建者希望我们反向使用自己的网络域名（URL)，因为域名通常是唯一的。因此我的域名是 MindviewInc.com，所以我将我的 foibles 类库命名为 com.mindviewinc.utility.foibles。反转域名后，. 用来代表子目录的划分。 在 Java 1.0 和 Java 1.1 中，域扩展名 com、 edu、 org 和 net 等按惯例大写，因此类库中会出现这样类似的名称：com.mindviewinc.utility.foibles。然而，在 Java 2 的开发过程中，他们发现这会导致问题，所以现在整个包名都是小写的。此机制意味着所有文件都自动存在于自己的命名空间中，文件中的每个类都具有唯一标识符。这样，Java 语言可以防止名称冲突。 static关键字当我们说某个事物是静态时，就意味着该字段或方法==不依赖于任何特定的对象实例== 。 即使我们从未创建过该类的对象，也可以调用其静态方法或访问其静态字段。 编译和运行编译： 移动到子目录 objects 下并键入： 1javac HelloDate.java 此命令不应产生任何响应。如果我们收到任何类型的错误消息，则表示未正确安装 JDK，那就得检查这些问题。 若执行不报错的话，此时可以键入： 运行： 1java HelloDate 第四章 运算符几乎所有运算符都只能操作基本类型（Primitives）。唯一的例外是 =、== 和 !=，它们能操作所有对象（这也是令人混淆的一个地方）。除此以外，String 类支持 + 和 +=。 赋值基本类型的赋值都是直接的，而不像对象，赋予的只是其内存的引用。举个例子，a = b ，如果 b 是基本类型，那么赋值操作会将 b 的值复制一份给变量 a， 此后若 a 的值发生改变是不会影响到 b 的。 如果是为对象赋值，那么结果就不一样了。对一个对象进行操作时，我们实际上操作的是它的引用。所以我们将右边的对象赋予给左边时，赋予的只是该对象的引用。此时，两者指向的堆中的对象还是同一个。 为了生成随机数字，程序首先创建一个 Random 对象。不带参数的 Random 对象会利用当前的时间用作随机数生成器的“种子”（seed），从而为程序的每次执行生成不同的输出。在本书的示例中，重要的是每个示例末尾的输出尽可能一致，以便可以使用外部工具进行验证。所以我们通过在创建 Random 对象时提供种子（随机数生成器的初始化值，其始终为特定种子值产生相同的序列），让程序每次执行都生成相同的随机数，如此以来输出结果就是可验证的 ^1 special 一元加减运算符一元加 + 减 - 运算符的操作和二元是相同的。编译器可自动识别使用何种方式解析运算： 1x = -a; 上例的代码表意清晰，编译器可正确识别。下面再看一个示例： 1x = a * -b; 虽然编译器可以正确的识别，但是程序员可能会迷惑。为了避免混淆，推荐下面的写法： 1x = a * (-b); 一元减号可以得到数据的负值。一元加号的作用相反，不过它唯一能影响的就是把较小的数值类型自动转换为 int 类型。 测试对象等价关系运算符 == 和 != 同样适用于所有对象之间的比较运算 因为 Integer 内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，所以 [-128, 127] 之间的值用 == 和 != 比较也能能到正确的结果，但是不推荐用关系运算符比较，具体见 JDK 中的 Integer 类源码。 比较两个对象的内容是否相同呢？你必须使用所有对象（不包括基本类型）中都存在的 equals() 方法。 短路逻辑运算符支持一种称为“短路”（short-circuiting）的现象。整个表达式会在运算到可以明确结果时就停止并返回结果，这意味着该逻辑表达式的后半部分不会被执行到。代码示例： 123456789101112131415161718192021222324252627// operators / ShortCircuit.java // 逻辑运算符的短路行为public class ShortCircuit &#123; static boolean test1(int val) &#123; System.out.println(\"test1(\" + val + \")\"); System.out.println(\"result: \" + (val &lt; 1)); return val &lt; 1; &#125; static boolean test2(int val) &#123; System.out.println(\"test2(\" + val + \")\"); System.out.println(\"result: \" + (val &lt; 2)); return val &lt; 2; &#125; static boolean test3(int val) &#123; System.out.println(\"test3(\" + val + \")\"); System.out.println(\"result: \" + (val &lt; 3)); return val &lt; 3; &#125; public static void main(String[] args) &#123; boolean b = test1(0) &amp;&amp; test2(2) &amp;&amp; test3(2); System.out.println(\"expression is \" + b); &#125;&#125; 输出结果： 12345test1(0)result: truetest2(2)result: falseexpression is false 每个测试都对参数执行比较并返回 true 或 false。同时控制台也会在方法执行时打印他们的执行状态。 下面的表达式： 1test1（0）&amp;&amp; test2（2）&amp;&amp; test3（2） 可能你的预期是程序会执行 3 个 test 方法并返回。我们来分析一下：第一个方法的结果返回 true，因此表达式会继续走下去。紧接着，第二个方法的返回结果是 false。这就代表这整个表达式的结果肯定为 false，所以就没有必要再判断剩下的表达式部分了。 所以，运用“短路”可以节省部分不必要的运算，从而提高程序潜在的性能。 Java没有sizeof在 C/C++ 中，经常需要用到 sizeof() 方法来获取数据项被分配的字节大小。C/C++ 中使用 sizeof() 最有说服力的原因是为了移植性，不同数据在不同机器上可能有不同的大小，所以在进行大小敏感的运算时，程序员必须对这些类型有多大做到心中有数。例如，一台计算机可用 32 位来保存整数，而另一台只用 16 位保存。显然，在第一台机器中，程序可保存更大的值。所以，移植是令 C/C++ 程序员颇为头痛的一个问题。 Java 不需要 sizeof() 方法来满足这种需求，因为所有类型的大小在不同平台上是相同的。我们不必考虑这个层次的移植问题 —— Java 本身就是一种“与平台无关”的语言。 字面值常量通常，当我们向程序中插入一个字面值常量（Literal）时，编译器会确切地识别它的类型。当类型不明确时，必须辅以字面值常量关联来帮助编译器识别。代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// operators/Literals.javapublic class Literals &#123; public static void main(String[] args) &#123; int i1 = 0x2f; // 16进制 (小写) System.out.println( \"i1: \" + Integer.toBinaryString(i1)); int i2 = 0X2F; // 16进制 (大写) System.out.println( \"i2: \" + Integer.toBinaryString(i2)); int i3 = 0177; // 8进制 (前导0) System.out.println( \"i3: \" + Integer.toBinaryString(i3)); char c = 0xffff; // 最大 char 型16进制值 System.out.println( \"c: \" + Integer.toBinaryString(c)); byte b = 0x7f; // 最大 byte 型16进制值 10101111; System.out.println( \"b: \" + Integer.toBinaryString(b)); short s = 0x7fff; // 最大 short 型16进制值 System.out.println( \"s: \" + Integer.toBinaryString(s)); long n1 = 200L; // long 型后缀 long n2 = 200l; // long 型后缀 (容易与数值1混淆) long n3 = 200; // Java 7 二进制字面值常量: byte blb = (byte)0b00110101; System.out.println( \"blb: \" + Integer.toBinaryString(blb)); short bls = (short)0B0010111110101111; System.out.println( \"bls: \" + Integer.toBinaryString(bls)); int bli = 0b00101111101011111010111110101111; System.out.println( \"bli: \" + Integer.toBinaryString(bli)); long bll = 0b00101111101011111010111110101111; System.out.println( \"bll: \" + Long.toBinaryString(bll)); float f1 = 1; float f2 = 1F; // float 型后缀 float f3 = 1f; // float 型后缀 double d1 = 1d; // double 型后缀 double d2 = 1D; // double 型后缀 // (long 型的字面值同样适用于十六进制和8进制 ) &#125;&#125; 输出结果: 12345678910i1: 101111i2: 101111i3: 1111111c: 1111111111111111b: 1111111s: 111111111111111blb: 110101bls: 10111110101111bli: 101111101011111010111110101111bll: 101111101011111010111110101111 在文本值的后面添加字符可以让编译器识别该文本值的类型。对于 Long 型数值，结尾使用大写 L 或小写 l 皆可（不推荐使用 l，因为容易与阿拉伯数值 1 混淆）。大写 F 或小写 f 表示 float 浮点数。大写 D 或小写 d 表示 double 双精度。 十六进制（以 16 为基数），适用于所有整型数据类型，由前导 0x 或 0X 表示，后跟 0-9 或 a-f （大写或小写）。如果我们在初始化某个类型的数值时，赋值超出其范围，那么编译器会报错（不管值的数字形式如何）。在上例的代码中，char、byte 和 short 的值已经是最大了。如果超过这些值，编译器将自动转型为 int，并且提示我们需要声明强制转换（强制转换将在本章后面定义），意味着我们已越过该类型的范围界限。 八进制（以 8 为基数）由 0~7 之间的数字和前导零 0 表示。 Java 7 引入了二进制的字面值常量，由前导 0b 或 0B 表示，它可以初始化所有的整数类型。 使用整型数值类型时，显示其二进制形式会很有用。在 Long 型和 Integer 型中这很容易实现，调用其静态的 toBinaryString() 方法即可。 但是请注意，若将较小的类型传递给 Integer.tobinarystring() 时，类型将自动转换为 int。 下划线Java 7 中有一个深思熟虑的补充：我们可以在数字字面量中包含下划线 _，以使结果更清晰。这对于大数值的分组特别有用。代码示例： 123456789101112// operators/Underscores.javapublic class Underscores &#123; public static void main(String[] args) &#123; double d = 341_435_936.445_667; System.out.println(d); int bin = 0b0010_1111_1010_1111_1010_1111_1010_1111; System.out.println(Integer.toBinaryString(bin)); System.out.printf(\"%x%n\", bin); // [1] long hex = 0x7f_e9_b7_aa; System.out.printf(\"%x%n\", hex); &#125;&#125; 输出结果: 12343.41435936445667E81011111010111110101111101011112fafafaf7fe9b7aa 下面是合理使用的规则： 仅限单 _，不能多条相连。 数值开头和结尾不允许出现 _。 F、D 和 L的前后禁止出现 _。 二进制前导 b 和 十六进制 x 前后禁止出现 _。 [1] 注意 ％n的使用。熟悉 C 风格的程序员可能习惯于看到 \\n 来表示换行符。问题在于它给你的是一个“Unix风格”的换行符。此外，如果我们使用的是 Windows，则必须指定 \\r\\n。这种差异的包袱应该由编程语言来解决。这就是 ==Java 用 ％n 实现的可以忽略平台间差异而生成适当的换行符==，但只有当你使用 System.out.printf() 或 System.out.format() 时。对于 System.out.println()，我们仍然必须使用 \\n；如果你使用 ％n，println() 只会输出 ％n 而不是换行符。 指数计数法指数总是采用一种我认为很不直观的记号方法: 12345678910111213// operators/Exponents.java// \"e\" 表示 10 的几次幂public class Exponents &#123; public static void main(String[] args) &#123; // 大写 E 和小写 e 的效果相同: float expFloat = 1.39e-43f; expFloat = 1.39E-43f; System.out.println(expFloat); double expDouble = 47e47d; // 'd' 是可选的 double expDouble2 = 47e47; // 自动转换为 double System.out.println(expDouble); &#125;&#125; 输出结果: 121.39E-434.7E48 在科学与工程学领域，e 代表自然对数的基数，约等于 2.718 （Java 里用一种更精确的 double 值 Math.E 来表示自然对数）。指数表达式 “1.39 x e-43”，意味着 “1.39 × 2.718 的 -43 次方”。然而，自 FORTRAN 语言发明后，人们自然而然地觉得e 代表 “10 的几次幂”。这种做法显得颇为古怪，因为 FORTRAN 最初是为科学与工程领域设计的。 理所当然，它的设计者应对这样的混淆概念持谨慎态度 [^2]。但不管怎样，这种特别的表达方法在 C，C++ 以及现在的 Java 中顽固地保留下来了。所以倘若习惯 e 作为自然对数的基数使用，那么在 Java 中看到类似“1.39e-43f”这样的表达式时，请转换你的思维，从程序设计的角度思考它；它真正的含义是 “1.39 × 10 的 -43 次方”。 注意如果编译器能够正确地识别类型，就不必使用后缀字符。对于下述语句： 1long n3 = 200; 它并不存在含糊不清的地方，所以 200 后面的 L 大可省去。然而，对于下述语句： 1float f4 = 1e-43f; //10 的幂数 编译器通常会将指数作为 double 类型来处理，所以假若没有这个后缀字符 f，编译器就会报错，提示我们应该将 double 型转换成 float 型。 移位运算符移位运算符面向的运算对象也是二进制的“位”。它们只能用于处理整数类型（基本类型的一种）。左移位运算符 &lt;&lt; 能将其左边的运算对象向左移动右侧指定的位数（在低位补 0）。右移位运算符 &gt;&gt; 则相反。右移位运算符有“正”、“负”值：若值为正，则在高位插入 0；若值为负，则在高位插入 1。Java 也添加了一种“不分正负”的右移位运算符（&gt;&gt;&gt;），它使用了“零扩展”（zero extension）：无论正负，都在高位插入 0。这一运算符是 C/C++ 没有的。 如果移动 char、byte 或 short，则会在移动发生之前将其提升为 int，结果为 int。仅使用右侧的 5 个低阶位。这可以防止我们移动超过 int 范围的位数。若对一个 long 值进行处理，最后得到的结果也是 long。 移位可以与等号 &lt;&lt;= 或 &gt;&gt;= 或 &gt;&gt;&gt;= 组合使用。左值被替换为其移位运算后的值。但是，问题来了，当无符号右移与赋值相结合时，若将其与 byte 或 short 一起使用的话，则结果错误。取而代之的是，它们被提升为 int 型并右移，但在重新赋值时被截断。在这种情况下，结果为 -1。 “类型转换”（Casting）的作用是“与一个模型匹配”。在适当的时候，Java 会将一种数据类型自动转换成另一种。例如，假设我们为 float 变量赋值一个整数值，计算机会将 int 自动转换成 float。我们可以在程序未自动转换时显式、强制地使此类型发生转换。 要执行强制转换，需要将所需的数据类型放在任何值左侧的括号内，如下所示： 123456789101112// operators/Casting.javapublic class Casting &#123; public static void main(String[] args) &#123; int i = 200; long lng = (long)i; lng = i; // 没有必要的类型提升 long lng2 = (long)200; lng2 = 200; // 类型收缩 i = (int)lng2; // Cast required &#125;&#125; 诚然，你可以这样地去转换一个数值类型的变量。但是上例这种做法是多余的：因为编译器会在必要时自动提升 int 型数据为 long 型。 当然，为了程序逻辑清晰或提醒自己留意，我们也可以显式地类型转换。在其他情况下，类型转换型只有在代码编译时才显出其重要性。在 C/C++ 中，类型转换有时会让人头痛。在 Java 里，类型转换则是一种比较安全的操作。但是，若将数据类型进行“向下转换”（Narrowing Conversion）的操作（将容量较大的数据类型转换成容量较小的类型），可能会发生信息丢失的危险。此时，编译器会强迫我们进行转型，好比在提醒我们：该操作可能危险，若你坚持让我这么做，那么对不起，请明确需要转换的类型。 对于“向上转换”（Widening conversion），则不必进行显式的类型转换，因为较大类型的数据肯定能容纳较小类型的数据，不会造成任何信息的丢失。 除了布尔类型的数据，Java 允许任何基本类型的数据转换为另一种基本类型的数据。此外，类是不能进行类型转换的。为了将一个类转换为另一个类型，需要使用特殊的方法（后面将会学习到如何在父子类之间进行向上/向下转型 截断和舍入在执行“向下转换”时，必须注意数据的截断和舍入问题。若从浮点值转换为整型值，Java 会做什么呢？例如：浮点数 29.7 被转换为整型值，结果会是 29 还是 30 呢？下面是代码示例： 123456789101112// operators/CastingNumbers.java// 尝试转换 float 和 double 型数据为整型数据public class CastingNumbers &#123; public static void main(String[] args) &#123; double above = 0.7, below = 0.4; float fabove = 0.7f, fbelow = 0.4f; System.out.println(\"(int)above: \" + (int)above); System.out.println(\"(int)below: \" + (int)below); System.out.println(\"(int)fabove: \" + (int)fabove); System.out.println(\"(int)fbelow: \" + (int)fbelow); &#125;&#125; 输出结果： 1234(int)above: 0(int)below: 0(int)fabove: 0(int)fbelow: 0 因此，答案是，从 float 和 double 转换为整数值时==，小数位将被截断。==若你想对结果进行四舍五入，可以使用 java.lang.Math 的 round() 方法 类型提升你会发现，如果我们对小于 int 的基本数据类型（即 char、byte 或 short）执行任何算术或按位操作，这些值会在执行操作之前类型提升为 int，并且结果值的类型为 int。若想重新使用较小的类型，必须使用强制转换（由于重新分配回一个较小的类型，结果可能会丢失精度）。通常，表达式中最大的数据类型是决定表达式结果的数据类型。float 型和 double 型相乘，结果是 double 型的；int 和 long 相加，结果是 long 型。 第五章 控制流 程序必须在执行过程中控制它的世界并做出选择。 在 Java 中，你需要执行控制语句来做出选择。 臭名昭著的 goto goto 问题中一起讨论，是由于它们使用了相同的机制：标签。 “标签”是后面跟一个冒号的标识符。代码示例： 1label1: 对 Java 来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方 —— 在标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环或者一个开关。这是由于 break 和 continue 关键字通常只中断当前循环，但若搭配标签一起使用，它们就会中断并跳转到标签所在的地方开始执行。代码示例： 12345678910111213label1:outer-iteration &#123; inner-iteration &#123; // ... break; // [1] // ... continue; // [2] // ... continue label1; // [3] // ... break label1; // [4] &#125; &#125; [1] break 中断内部循环，并在外部循环结束。[2] continue 移回内部循环的起始处。但在条件 3 中，continue label1 却同时中断内部循环以及外部循环，并移至 label1 处。[3] 随后，它实际是继续循环，但却从外部循环开始。[4] break label1 也会中断所有循环，并回到 label1 处，但并不重新进入循环。也就是说，它实际是完全中止了两个循环。 下面是 for 循环的一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142// control/LabeledFor.java// 搭配“标签 break”的 for 循环中使用 break 和 continuepublic class LabeledFor &#123; public static void main(String[] args) &#123; int i = 0; outer: // 此处不允许存在执行语句 for(; true ;) &#123; // 无限循环 inner: // 此处不允许存在执行语句 for(; i &lt; 10; i++) &#123; System.out.println(\"i = \" + i); if(i == 2) &#123; System.out.println(\"continue\"); continue; &#125; if(i == 3) &#123; System.out.println(\"break\"); i++; // 否则 i 永远无法获得自增 // 获得自增 break; &#125; if(i == 7) &#123; System.out.println(\"continue outer\"); i++; // 否则 i 永远无法获得自增 // 获得自增 continue outer; &#125; if(i == 8) &#123; System.out.println(\"break outer\"); break outer; &#125; for(int k = 0; k &lt; 5; k++) &#123; if(k == 3) &#123; System.out.println(\"continue inner\"); continue inner; &#125; &#125; &#125; &#125; // 在此处无法 break 或 continue 标签 &#125;&#125; 输出结果： 123456789101112131415161718i = 0continue inneri = 1continue inneri = 2continuei = 3breaki = 4continue inneri = 5continue inneri = 6continue inneri = 7continue outeri = 8break outer 注意 break 会中断 for 循环，而且在抵达 for 循环的末尾之前，递增表达式不会执行。由于 break 跳过了递增表达式，所以递增会在 i==3 的情况下直接执行。在 i==7 的情况下，continue outer 语句也会到达循环顶部，而且也会跳过递增，所以它也是直接递增的。 如果没有 break outer 语句，就没有办法在一个内部循环里找到出外部循环的路径。这是由于 break 本身只能中断最内层的循环（对于 continue 同样如此）。 当然，若想在中断循环的同时退出方法，简单地用一个 return 即可。 同样的规则亦适用于 while： 简单的一个 continue 会退回最内层循环的开头（顶部），并继续执行。 带有标签的 continue 会到达标签的位置，并重新进入紧接在那个标签后面的循环。 break 会中断当前循环，并移离当前标签的末尾。 带标签的 break 会中断当前循环，并移离由那个标签指示的循环的末尾。 大家要记住的重点是：在 Java 里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中 break 或 continue。 break 和 continue 标签在编码中的使用频率相对较低 (此前的语言中很少使用或没有先例)，所以我们很少在代码里看到它们。 switch 字符串Java 7 增加了在字符串上 switch 的用法。 第六章 初始化和清理区分重载方法有一条简单的规则：每个被重载的方法必须有独一无二的参数列表。你甚至可以根据参数列表中的参数顺序来区分不同的方法，尽管这会造成代码难以维护。 垃圾回收器程序员都了解初始化的重要性，但通常会忽略清理的重要性。毕竟，谁会去清理一个 int 呢？但是使用完一个对象就不管它并非总是安全的。Java 中有垃圾回收器回收无用对象占用的内存。但现在考虑一种特殊情况：你创建的对象不是通过 new 来分配内存的，而垃圾回收器只知道如何释放用 new 创建的对象的内存，所以它不知道如何回收不是 new 分配的内存。为了处理这种情况，Java 允许在类中定义一个名为 finalize() 的方法。 它的工作原理”假定”是这样的：当垃圾回收器准备回收对象的内存时，首先会调用其 finalize() 方法，并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的内存。所以如果你打算使用 finalize() ，就能在垃圾回收时做一些重要的清理工作。finalize() 是一个潜在的编程陷阱，因为一些程序员（尤其是 C++ 程序员）会一开始把它误认为是 C++ 中的析构函数（C++ 在销毁对象时会调用这个函数）。所以有必要明确区分一下：在 C++ 中，对象总是被销毁的（在一个 bug-free 的程序中），而在 Java 中，对象并非总是被垃圾回收，或者换句话说： 对象可能不被垃圾回收。 垃圾回收不等同于析构。 这意味着在你不再需要某个对象之前，如果必须执行某些动作，你得自己去做。Java 没有析构器或类似的概念，所以你必须得自己创建一个普通的方法完成这项清理工作。例如，对象在创建的过程中会将自己绘制到屏幕上。如果不是明确地从屏幕上将其擦除，它可能永远得不到清理。如果在 finalize() 方法中加入某种擦除功能，那么当垃圾回收发生时，finalize() 方法被调用（不保证一定会发生），图像就会被擦除，要是”垃圾回收”没有发生，图像则仍会保留下来。 也许你会发现，只要程序没有濒临内存用完的那一刻，对象占用的空间就总也得不到释放。如果程序执行结束，而垃圾回收器一直没有释放你创建的任何对象的内存，则当程序退出时，那些资源会全部交还给操作系统。这个策略是恰当的，因为垃圾回收本身也有开销，要是不使用它，那就不用支付这部分开销了。 finalize() 的用途如果你不能将 finalize() 作为通用的清理方法，那么这个方法有什么用呢？ 这引入了要记住的第3点： 垃圾回收只与内存有关。 也就是说，使用垃圾回收的唯一原因就是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是 finalize() 方法），它们也必须同内存及其回收有关。 但这是否意味着如果对象中包括其他对象，finalize() 方法就应该明确释放那些对象呢？不是，无论对象是如何创建的，垃圾回收器都会负责释放对象所占用的所有内存。这就将对 finalize() 的需求限制到一种特殊情况，即通过某种创建对象方式之外的方式为对象分配了存储空间。不过，你可能会想，Java 中万物皆对象，这种情况怎么可能发生？ 看起来之所以有 finalize() 方法，是因为在分配内存时可能采用了类似 C 语言中的做法，而非 Java 中的通常做法。这种情况主要发生在使用”本地方法”的情况下，本地方法是一种用 Java 语言调用非 Java 语言代码的形式（关于本地方法的讨论，见本书电子版第2版的附录B）。本地方法目前只支持 C 和 C++，但是它们可以调用其他语言写的代码，所以实际上可以调用任何代码。在非 Java 代码中，也许会调用 C 的 malloc() 函数系列来分配存储空间，而且除非调用 free() 函数，不然存储空间永远得不到释放，造成内存泄露。但是，free() 是 C 和 C++ 中的函数，所以你需要在 finalize() 方法里用本地方法调用它。 读到这里，你可能明白了不会过多使用 finalize() 方法。对，它确实不是进行普通的清理工作的合适场所。那么，普通的清理工作在哪里执行呢？ 你必须实施清理要清理一个对象，用户必须在需要清理的时候调用执行清理动作的方法。这听上去相当直接，但却与 C++ 中的”析构函数”的概念稍有抵触。在 C++ 中，所有对象都会被销毁，或者说应该被销毁。如果在 C++ 中创建了一个局部对象（在栈上创建，在 Java 中不行），此时的销毁动作发生在以”右花括号”为边界的、此对象作用域的末尾处。如果对象是用 new 创建的（类似于 Java 中），那么当程序员调用 C++ 的 delete 操作符时（Java 中不存在），就会调用相应的析构函数。如果程序员忘记调用 delete，那么永远不会调用析构函数，这样就会导致内存泄露，对象的其他部分也不会得到清理。这种 bug 很难跟踪，也是让 C++ 程序员转向 Java 的一个主要因素。相反，在 Java 中，没有用于释放对象的 delete，因为垃圾回收器会帮助你释放存储空间。甚至可以肤浅地认为，正是由于垃圾回收的存在，使得 Java 没有析构函数。然而，随着学习的深入，你会明白垃圾回收器的存在并不能完全替代析构函数（而且绝对不能直接调用 finalize()，所以这也不是一种解决方案）。如果希望进行除释放存储空间之外的清理工作，还是得明确调用某个恰当的 Java 方法：这就等同于使用析构函数了，只是没有它方便。 记住，无论是”垃圾回收”还是”终结”，都不保证一定会发生。如果 Java 虚拟机（JVM）并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。 终结条件通常，不能指望 finalize() ，你必须创建其他的”清理”方法，并明确地调用它们。所以看起来，finalize() 只对大部分程序员很难用到的一些晦涩内存清理里有用了。但是，finalize() 还有一个有趣的用法，它不依赖于每次都要对 finalize() 进行调用，这就是对象终结条件的验证。 当对某个对象不感兴趣时——也就是它将被清理了，这个对象应该处于某种状态，这种状态下它占用的内存可以被安全地释放掉。例如，如果对象代表了一个打开的文件，在对象被垃圾回收之前程序员应该关闭这个文件。只要对象中存在没有被适当清理的部分，程序就存在很隐晦的 bug。finalize() 可以用来最终发现这个情况，尽管它并不总是被调用。如果某次 finalize() 的动作使得 bug 被发现，那么就可以据此找出问题所在——这才是人们真正关心的。以下是个简单的例子，示范了 finalize() 的可能使用方式： 1234567891011121314151617181920212223242526272829303132333435363738394041// housekeeping/TerminationCondition.java// Using finalize() to detect a object that// hasn't been properly cleaned upimport onjava.*;class Book &#123; boolean checkedOut = false; Book(boolean checkOut) &#123; checkedOut = checkOut; &#125; void checkIn() &#123; checkedOut = false; &#125; @Override protected void finalize() throws Throwable &#123; if (checkedOut) &#123; System.out.println(\"Error: checked out\"); &#125; // Normally, you'll also do this: // super.finalize(); // Call the base-class version &#125;&#125;public class TerminationCondition &#123; public static void main(String[] args) &#123; Book novel = new Book(true); // Proper cleanup: novel.checkIn(); // Drop the reference, forget to clean up: new Book(true); // Force garbage collection &amp; finalization: System.gc(); new Nap(1); // One second delay &#125;&#125; 输出： 1Error: checked out 本例的终结条件是：所有的 Book 对象在被垃圾回收之前必须被登记。但在 main() 方法中，有一本书没有登记。要是没有 finalize() 方法来验证终结条件，将会很难发现这个 bug。 你可能注意到使用了 @Override。@ 意味着这是一个注解，注解是关于代码的额外信息。在这里，该注解告诉编译器这不是偶然地重定义在每个对象中都存在的 finalize() 方法——程序员知道自己在做什么。编译器确保你没有拼错方法名，而且确保那个方法存在于基类中。注解也是对读者的提醒，@Override 在 Java 5 引入，在 Java 7 中改善，本书通篇会出现。 注意，System.gc() 用于强制进行终结动作。但是即使不这么做，只要重复地执行程序（假设程序将分配大量的存储空间而导致垃圾回收动作的执行），最终也能找出错误的 Book 对象。 你应该总是假设基类版本的 finalize() 也要做一些重要的事情，使用 super 调用它，就像在 Book.finalize() 中看到的那样。本例中，它被注释掉了，因为它需要进行异常处理，而我们到现在还没有涉及到。 垃圾回收器如何工作如果你以前用过的语言，在堆上分配对象的代价十分高昂，你可能自然会觉得 Java 中所有对象（基本类型除外）在堆上分配的方式也十分高昂。然而，垃圾回收器能很明显地提高对象的创建速度。这听起来很奇怪——存储空间的释放影响了存储空间的分配，但这确实是某些 Java 虚拟机的工作方式。这也意味着，Java 从堆空间分配的速度可以和其他语言在栈上分配空间的速度相媲美。 例如，你可以把 C++ 里的堆想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间后，对象可能被销毁，但地盘必须复用。在某些 Java 虚拟机中，堆的实现截然不同：它更像一个传送带，每分配一个新对象，它就向前移动一格。这意味着对象存储空间的分配速度特别快。Java 的”堆指针”只是简单地移动到尚未分配的区域，所以它的效率与 C++ 在栈上分配空间的效率相当。当然实际过程中，在簿记工作方面还有少量额外开销，但是这部分开销比不上查找可用空间开销大。 你可能意识到了，Java 中的堆并非完全像传送带那样工作。要是那样的话，势必会导致频繁的内存页面调度——将其移进移出硬盘，因此会显得需要拥有比实际需要更多的内存。页面调度会显著影响性能。最终，在创建了足够多的对象后，内存资源被耗尽。其中的秘密在于垃圾回收器的介入。当它工作时，一边回收内存，一边使堆中的对象紧凑排列，这样”堆指针”就可以很容易地移动到更靠近传送带的开始处，也就尽量避免了页面错误。垃圾回收器通过重新排列对象，实现了一种高速的、有无限空间可分配的堆模型。 要想理解 Java 中的垃圾回收，先了解其他系统中的垃圾回收机制将会很有帮助。一种简单但速度很慢的垃圾回收机制叫做引用计数。每个对象中含有一个引用计数器，每当有引用指向该对象时，引用计数加 1。当引用离开作用域或被置为 null 时，引用计数减 1。因此，管理引用计数是一个开销不大但是在程序的整个生命周期频繁发生的负担。垃圾回收器会遍历含有全部对象的列表，当发现某个对象的引用计数为 0 时，就释放其占用的空间（但是，引用计数模式经常会在计数为 0 时立即释放对象）。这个机制存在一个缺点：如果对象之间存在循环引用，那么它们的引用计数都不为 0，就会出现应该被回收但无法被回收的情况。对垃圾回收器而言，定位这样的循环引用所需的工作量极大。引用计数常用来说明垃圾回收的工作方式，但似乎从未被应用于任何一种 Java 虚拟机实现中。 在更快的策略中，垃圾回收器并非基于引用计数。它们依据的是：对于任意”活”的对象，一定能最终追溯到其存活在栈或静态存储区中的引用。这个引用链条可能会穿过数个对象层次，由此，如果从栈或静态存储区出发，遍历所有的引用，你将会发现所有”活”的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是该对象包含的所有引用，如此反复进行，直到访问完”根源于栈或静态存储区的引用”所形成的整个网络。你所访问过的对象一定是”活”的。注意，这解决了对象间循环引用的问题，这些对象不会被发现，因此也就被自动回收了。 在这种方式下，Java 虚拟机采用了一种自适应的垃圾回收技术。至于如何处理找到的存活对象，取决于不同的 Java 虚拟机实现。其中有一种做法叫做停止-复制（stop-and-copy）。顾名思义，这需要先暂停程序的运行（不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有复制的就是需要被垃圾回收的。另外，当对象被复制到新堆时，它们是一个挨着一个紧凑排列，然后就可以按照前面描述的那样简单、直接地分配新空间了。 当对象从一处复制到另一处，所有指向它的引用都必须修正。位于栈或静态存储区的引用可以直接被修正，但可能还有其他指向这些对象的引用，它们在遍历的过程中才能被找到（可以想象成一个表格，将旧地址映射到新地址）。 这种所谓的”复制回收器”效率低下主要因为两个原因。其一：得有两个堆，然后在这两个分离的堆之间来回折腾，得维护比实际需要多一倍的空间。某些 Java 虚拟机对此问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。 其二在于复制本身。一旦程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。尽管如此，复制回收器仍然会将所有内存从一处复制到另一处，这很浪费。为了避免这种状况，一些 Java 虚拟机会进行检查：要是没有新垃圾产生，就会转换到另一种模式（即”自适应”）。这种模式称为标记-清扫（mark-and-sweep），Sun 公司早期版本的 Java 虚拟机一直使用这种技术。对一般用途而言，”标记-清扫”方式速度相当慢，但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。 “标记-清扫”所依据的思路仍然是从栈和静态存储区出发，遍历所有的引用，找出所有存活的对象。但是，每当找到一个存活对象，就给对象设一个标记，并不回收它。只有当标记过程完成后，清理动作才开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。”标记-清扫”后剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就需要重新整理剩下的对象。 “停止-复制”指的是这种垃圾回收动作不是在后台进行的；相反，垃圾回收动作发生的同时，程序将会暂停。在 Oracle 公司的文档中会发现，许多参考文献将垃圾回收视为低优先级的后台进程，但是早期版本的 Java 虚拟机并不是这么实现垃圾回收器的。当可用内存较低时，垃圾回收器会暂停程序。同样，”标记-清扫”工作也必须在程序暂停的情况下才能进行。 如前文所述，这里讨论的 Java 虚拟机中，内存分配以较大的”块”为单位。如果对象较大，它会占用单独的块。严格来说，”停止-复制”要求在释放旧对象之前，必须先将所有存活对象从旧堆复制到新堆，这导致了大量的内存复制行为。有了块，垃圾回收器就可以把对象复制到废弃的块。每个块都有年代数来记录自己是否存活。通常，如果块在某处被引用，其年代数加 1，垃圾回收器会对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作——大型对象仍然不会复制（只是年代数会增加），含有小型对象的那些块则被复制并整理。Java 虚拟机会监视，如果所有对象都很稳定，垃圾回收的效率降低的话，就切换到”标记-清扫”方式。同样，Java 虚拟机会跟踪”标记-清扫”的效果，如果堆空间出现很多碎片，就会切换回”停止-复制”方式。这就是”自适应”的由来，你可以给它个啰嗦的称呼：”自适应的、分代的、停止-复制、标记-清扫”式的垃圾回收器。 Java 虚拟机中有许多附加技术用来提升速度。尤其是与加载器操作有关的，被称为”即时”（Just-In-Time, JIT）编译器的技术。这种技术可以把程序全部或部分翻译成本地机器码，所以不需要 JVM 来进行翻译，因此运行得更快。当需要装载某个类（通常是创建该类的第一个对象）时，编译器会先找到其 .class 文件，然后将该类的字节码装入内存。你可以让即时编译器编译所有代码，但这种做法有两个缺点：一是这种加载动作贯穿整个程序生命周期内，累加起来需要花更多时间；二是会增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），这会导致页面调度，从而一定降低程序速度。另一种做法称为惰性评估，意味着即时编译器只有在必要的时候才编译代码。这样，从未被执行的代码也许就压根不会被 JIT 编译。新版 JDK 中的 Java HotSpot 技术就采用了类似的做法，代码每被执行一次就优化一些，所以执行的次数越多，它的速度就越快。 构造器初始化初始化的顺序在类中变量定义的顺序决定了它们初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。 静态数据的初始化无论创建多少个对象，静态数据都只占用一份存储区域。static 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。如果一个字段是静态的基本类型，你没有初始化它，那么它就会获得基本类型的标准初值。 如果在定义时进行初始化，那么静态变量看起来就跟非静态变量一样。 初始化的顺序先是静态对象（如果它们之前没有被初始化的话），然后是非静态对象。要执行 main() 方法，必须加载 类，它的静态属性随后被初始化. 概括一下创建对象的过程，假设有个名为 Dog 的类： 即使没有显式地使用 static 关键字，构造器实际上也是静态方法。所以，当首次创建 Dog 类型的对象或是首次访问 Dog 类的静态方法或属性时，Java 解释器必须在类路径中查找，以定位 Dog.class。 当加载完 Dog.class 后（后面会学到，这将创建一个 Class 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 Class 对象时初始化一次。 当用 new Dog() 创建对象时，首先会在堆上为 Dog 对象分配足够的存储空间。 分配的存储空间首先会被清零，即会将 Dog 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 null。 执行所有出现在字段定义处的初始化动作。 执行构造器。你将会在”复用”这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。 显式的静态初始化(静态代码块)你可以将一组静态初始化动作放在类里面一个特殊的”静态子句”（有时叫做静态块）中。像下面这样： 123456789// housekeeping/Spoon.javapublic class Spoon &#123; static int i; static &#123; i = 47; &#125;&#125; 这看起来像个方法，但实际上它只是一段跟在 static 关键字后面的代码块。与其他静态初始化动作一样，这段代码仅执行一次：当首次创建这个类的对象或首次访问这个类的静态成员（甚至不需要创建该类的对象）时。 非静态实例初始化(实例代码块)实例初始化子句是在两个构造器之前执行的。 123456789public class Mugs &#123; Mug mug1; Mug mug2; &#123; // [1] mug1 = new Mug(1); mug2 = new Mug(2); System.out.println(\"mug1 &amp; mug2 initialized\"); &#125;&#125; Java 提供了被称为实例初始化的类似语法，用来初始化每个对象的非静态变量，例如： 12345678910111213141516171819202122232425262728293031323334// housekeeping/Mugs.java// Instance initializationclass Mug &#123; Mug(int marker) &#123; System.out.println(\"Mug(\" + marker + \")\"); &#125;&#125;public class Mugs &#123; Mug mug1; Mug mug2; &#123; // [1] mug1 = new Mug(1); mug2 = new Mug(2); System.out.println(\"mug1 &amp; mug2 initialized\"); &#125; Mugs() &#123; System.out.println(\"Mugs()\"); &#125; Mugs(int i) &#123; System.out.println(\"Mugs(int)\"); &#125; public static void main(String[] args) &#123; System.out.println(\"Inside main()\"); new Mugs(); System.out.println(\"new Mugs() completed\"); new Mugs(1); System.out.println(\"new Mugs(1) completed\"); &#125;&#125; 输出： 1234567891011Inside mainMug(1)Mug(2)mug1 &amp; mug2 initializedMugs()new Mugs() completedMug(1)Mug(2)mug1 &amp; mug2 initializedMugs(int)new Mugs(1) completed 看起来它很像静态代码块，只不过少了 static 关键字。这种语法对于支持”匿名内部类”（参见”内部类”一章）的初始化是必须的，但是你也可以使用它保证某些操作一定会发生，而不管哪个构造器被调用。从输出看出，实例初始化子句是在两个构造器之前执行的。 数组初始化数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。数组是通过方括号下标操作符 [] 来定义和使用的。要定义一个数组引用，只需要在类型名加上方括号： 1int[] a1; 方括号也可放在标识符的后面，两者的含义是一样的： 1int a1[]; 这种格式符合 C 和 C++ 程序员的习惯。不过前一种格式或许更合理，毕竟它表明类型是”一个 int 型数组”。本书中采用这种格式。 编译器不允许指定数组的大小。这又把我们带回有关”引用”的问题上。你所拥有的只是对数组的一个引用（你已经为该引用分配了足够的存储空间），但是还没有给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式。对于数组，初始化动作可以出现在代码的任何地方，但是也可以使用一种特殊的初始化表达式，它必须在创建数组的地方出现。这种特殊的初始化是由一对花括号括起来的值组成。这种情况下，存储空间的分配（相当于使用 new） 将由编译器负责。例如： 1int[] a1 = &#123;1, 2, 3, 4, 5&#125;; 那么为什么在还没有数组的时候定义一个数组引用呢？ 1int[] a2; 在 Java 中可以将一个数组赋值给另一个数组，所以可以这样： 1a2 = a1; 其实真正做的只是复制了一个引用 所有的数组（无论是对象数组还是基本类型数组）都有一个固定成员 length，告诉你这个数组有多少个元素，你不能对其修改。与 C 和 C++ 类似，Java 数组计数也是从 0 开始的，所能使用的最大下标数是 length - 1。超过这个边界，C 和 C++ 会默认接受，允许你访问所有内存，许多声名狼藉的 bug 都是由此而生。但是 Java 在你访问超出这个边界时，会报运行时错误（异常），从而避免此类问题。 动态数组创建你可以直接使用 new 在数组中创建元素。数组元素中的基本数据类型值会自动初始化为空值（对于数字和字符是 0；对于布尔型是 false）。Arrays.toString() 是 java.util 标准类库中的方法，会产生一维数组的可打印版本。 也可以用花括号括起来的列表来初始化数组，有两种形式： 12345678Integer[] a = &#123; 1, 2, 3, // Autoboxing&#125;;Integer[] b = new Integer[] &#123; 1, 2, 3, // Autoboxing&#125;; 在这两种形式中，初始化列表的最后一个逗号是可选的（这一特性使维护长列表变得更容易）。 尽管第一种形式很有用，但是它更加受限，因为它只能用于数组定义处。第二种和第三种形式可以用在任何地方，甚至用在方法的内部。例如，你创建了一个 String 数组，将其传递给另一个类的 main() 方法，如下： 12345678910111213141516// housekeeping/DynamicArray.java// Array initializationpublic class DynamicArray &#123; public static void main(String[] args) &#123; Other.main(new String[] &#123;\"fiddle\", \"de\", \"dum\"&#125;); &#125;&#125;class Other &#123; public static void main(String[] args) &#123; for (String s: args) &#123; System.out.print(s + \" \"); &#125; &#125;&#125; 输出： 1fiddle de dum Other.main() 的参数是在调用处创建的，因此你甚至可以在方法调用处提供可替换的参数。 可变参数列表你可以以一种类似 C 语言中的可变参数列表（C 通常把它称为”varargs”）来创建和调用方法。这可以应用在参数个数或类型未知的场合。在 Java 5 中， 12345678910111213141516171819202122// housekeeping/NewVarArgs.java// Using array syntax to create variable argument listspublic class NewVarArgs &#123; static void printArray(Object... args) &#123; for (Object obj: args) &#123; System.out.print(obj + \" \"); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; // Can take individual elements: printArray(47, (float) 3.14, 11.11); printArray(47, 3.14F, 11.11); printArray(\"one\", \"two\", \"three\"); printArray(new A(), new A(), new A()); // Or an array: printArray((Object[]) new Integer[] &#123;1, 2, 3, 4&#125;); printArray(); // Empty list is OK &#125;&#125; 输出： 1234547 3.14 11.11 47 3.14 11.11 one two three A@15db9742 A@6d06d69c A@7852e922 1 2 3 4 有了可变参数，你就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你填充数组。你获取的仍然是一个数组，这就是为什么 printArray() 可以使用 for-in 迭代数组的原因。但是，这不仅仅只是从元素列表到数组的自动转换。注意程序的倒数第二行，一个 Integer 数组（通过自动装箱创建）被转型为一个 Object 数组（为了移除编译器的警告），并且传递给了 printArray()。显然，编译器会发现这是一个数组，不会执行转换。因此，如果你有一组事物，可以把它们当作列表传递，而如果你已经有了一个数组，该方法会把它们当作可变参数列表来接受。 程序的最后一行表明，可变参数的个数可以为 0。当具有可选的尾随参数时，这一特性会有帮助： 1234567891011121314151617// housekeeping/OptionalTrailingArguments.javapublic class OptionalTrailingArguments &#123; static void f(int required, String... trailing) &#123; System.out.print(\"required: \" + required + \" \"); for (String s: trailing) &#123; System.out.print(s + \" \"); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; f(1, \"one\"); f(2, \"two\", \"three\"); f(0); &#125;&#125; 输出： 123required: 1 one required: 2 two three required: 0 这段程序展示了如何使用除了 Object 类之外类型的可变参数列表。这里，所有的可变参数都是 String 对象。可变参数列表中可以使用任何类型的参数，包括基本类型。下面例子展示了可变参数列表变为数组的情形，并且如果列表中没有任何元素，那么转变为大小为 0 的数组： 123456789101112131415161718192021// housekeeping/VarargType.javapublic class VarargType &#123; static void f(Character... args) &#123; System.out.print(args.getClass()); System.out.println(\" length \" + args.length); &#125; static void g(int... args) &#123; System.out.print(args.getClass()); System.out.println(\" length \" + args.length) &#125; public static void main(String[] args) &#123; f('a'); f(); g(1); g(); System.out.println(\"int[]: \"+ new int[0].getClass()); &#125;&#125; 输出： 12345class [Ljava.lang.Character; length 1class [Ljava.lang.Character; length 0class [I length 1class [I length 0int[]: class [I getClass() 方法属于 Object 类，将在”类型信息”一章中全面介绍。它会产生对象的类，并在打印该类时，看到表示该类类型的编码字符串。前导的 [ 代表这是一个后面紧随的类型的数组，I 表示基本类型 int；为了进行双重检查，我在最后一行创建了一个 int 数组，打印了其类型。这样也验证了使用可变参数列表不依赖于自动装箱，而使用的是基本类型。 然而，可变参数列表与自动装箱可以和谐共处，如下： 1234567891011121314151617// housekeeping/AutoboxingVarargs.javapublic class AutoboxingVarargs &#123; public static void f(Integer... args) &#123; for (Integer i: args) &#123; System.out.print(i + \" \"); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; f(1, 2); f(4, 5, 6, 7, 8, 9); f(10, 11, 12); &#125;&#125; 输出： 1231 24 5 6 7 8 910 11 12 注意吗，你可以在单个参数列表中将类型混合在一起，自动装箱机制会有选择地把 int 类型的参数提升为 Integer。 可变参数列表使得方法重载更加复杂了，尽管乍看之下似乎足够安全： 1234567891011121314151617181920212223242526272829303132// housekeeping/OverloadingVarargs.javapublic class OverloadingVarargs &#123; static void f(Character... args) &#123; System.out.print(\"first\"); for (Character c: args) &#123; System.out.print(\" \" + c); &#125; System.out.println(); &#125; static void f(Integer... args) &#123; System.out.print(\"second\"); for (Integer i: args) &#123; System.out.print(\" \" + i); &#125; System.out.println(); &#125; static void f(Long... args) &#123; System.out.println(\"third\"); &#125; public static void main(String[] args) &#123; f('a', 'b', 'c'); f(1); f(2, 1); f(0); f(0L); //- f(); // Won's compile -- ambiguous &#125;&#125; 输出： 12345first a b csecond 1second 2 1second 0third 在每种情况下，编译器都会使用自动装箱来匹配重载的方法，然后调用最明确匹配的方法。 但是如果调用不含参数的 f()，编译器就无法知道应该调用哪个方法了。尽管这个错误可以弄清楚，但是它可能会使客户端程序员感到意外。 你可能会通过在某个方法中增加一个非可变参数解决这个问题： 1234567891011121314151617// housekeeping/OverloadingVarargs2.java// &#123;WillNotCompile&#125;public class OverloadingVarargs2 &#123; static void f(float i, Character... args) &#123; System.out.println(\"first\"); &#125; static void f(Character... args) &#123; System.out.println(\"second\"); &#125; public static void main(String[] args) &#123; f(1, 'a'); f('a', 'b'); &#125;&#125; {WillNotCompile} 注释把该文件排除在了本书的 Gradle 构建之外。如果你手动编译它，会得到下面的错误信息： 123OverloadingVarargs2.java:14:error:reference to f is ambiguous f('a', 'b');\\^both method f(float, Character...) in OverloadingVarargs2 and method f(Character...) in OverloadingVarargs2 match 1 error 如果你给这两个方法都添加一个非可变参数，就可以解决问题了： 12345678910111213141516// housekeeping/OverloadingVarargs3public class OverloadingVarargs3 &#123; static void f(float i, Character... args) &#123; System.out.println(\"first\"); &#125; static void f(char c, Character... args) &#123; System.out.println(\"second\"); &#125; public static void main(String[] args) &#123; f(1, 'a'); f('a', 'b'); &#125;&#125; 输出： 12firstsecond 你应该总是在重载方法的一个版本上使用可变参数列表，或者压根不用它。 枚举类型Java 5 中添加了一个看似很小的特性 enum 关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便地处理。以前，你需要创建一个整数常量集，但是这些值并不会将自身限制在这个常量集的范围内，因此使用它们更有风险，而且更难使用。枚举类型属于非常普遍的需求，C、C++ 和其他许多语言都已经拥有它了。现在 Java 也有了 enum，并且它的功能比 C/C++ 中的完备得多。下面是个简单的例子： 12345// housekeeping/Spiciness.javapublic enum Spiciness &#123; NOT, MILD, MEDIUM, HOT, FLAMING&#125; 这里创建了一个名为 Spiciness 的枚举类型，它有5个值。由于枚举类型的实例是常量，因此按照命名惯例，它们都用大写字母表示（如果名称中含有多个单词，使用下划线分隔）。 要使用 enum，需要创建一个该类型的引用，然后将其赋值给某个实例： 12345678// housekeeping/SimpleEnumUse.javapublic class SimpleEnumUse &#123; public static void main(String[] args) &#123; Spiciness howHot = Spiciness.MEDIUM; System.out.println(howHot); &#125;&#125; 输出： 1MEDIUM 在你创建 enum 时，编译器会自动添加一些有用的特性。例如，它会创建 toString() 方法，以便你方便地显示某个 enum 实例的名称，这从上面例子中的输出可以看出。编译器还会创建 ordinal() 方法表示某个特定 enum 常量的声明顺序，static values() 方法按照 enum 常量的声明顺序，生成这些常量值构成的数组： 123456789// housekeeping/EnumOrder.javapublic class EnumOrder &#123; public static void main(String[] args) &#123; for (Spiciness s: Spiciness.values()) &#123; System.out.println(s + \", ordinal \" + s.ordinal()); &#125; &#125;&#125; 输出： 12345NOT, ordinal 0MILD, ordinal 1MEDIUM, ordinal 2HOT, ordinal 3FLAMING, ordinal 4 尽管 enum 看起来像是一种新的数据类型，但是这个关键字只是在生成 enum 的类时，产生了某些编译器行为，因此在很大程度上你可以将 enum 当作其他任何类。事实上，enum 确实是类，并且具有自己的方法。 enum 有一个很实用的特性，就是在 switch 语句中使用： 1234567891011121314151617181920212223242526272829303132333435// housekeeping/Burrito.javapublic class Burrito &#123; Spiciness degree; public Burrito(Spiciness degree) &#123; this.degree = degree; &#125; public void describe() &#123; System.out.print(\"This burrito is \"); switch(degree) &#123; case NOT: System.out.println(\"not spicy at all.\"); break; case MILD: case MEDIUM: System.out.println(\"a little hot.\"); break; case HOT: case FLAMING: default: System.out.println(\"maybe too hot\"); &#125; &#125; public static void main(String[] args) &#123; Burrito plain = new Burrito(Spiciness.NOT), greenChile = new Burrito(Spiciness.MEDIUM), jalapeno = new Burrito(Spiciness.HOT); plain.describe(); greenChile.describe(); jalapeno.describe(); &#125;&#125; 输出： 123This burrito is not spicy at all.This burrito is a little hot.This burrito is maybe too hot. 由于 switch 是在有限的可能值集合中选择，因此它与 enum 是绝佳的组合。注意，enum 的名称是如何能够倍加清楚地表明程序的目的的。 通常，你可以将 enum 用作另一种创建数据类型的方式，然后使用所得到的类型。这正是关键所在，所以你不用过多地考虑它们。在 enum 被引入之前，你必须花费大量的精力去创建一个等同的枚举类型，并是安全可用的。 第七章 封装重构就是重写可工作的代码，使之更加可读，易懂，因而更易维护。 通常，客户端程序员希望你的代码在某些方面保持不变。所以你想修改代码，但他们希望代码保持不变。由此引出了面向对象设计中的一个基本问题：”如何区分变动的事物和不变的事物”。 Java 提供了访问修饰符供类库开发者指明哪些对于客户端程序员是可用的，哪些是不可用的。访问控制权限的等级，从”最大权限”到”最小权限”依次是：public，protected，包访问权限（没有关键字）和 private。 包的概念包内包含一组类，它们被组织在一个单独的命名空间下。 一个 Java 源代码文件称为一个编译单元（有时也称翻译单元）。每个编译单元的文件名后缀必须是 .java。在编译单元中可以有一个 public 类，它的类名必须与文件名相同（包括大小写，但不包括后缀名 .java）。每个编译单元中只能有一个 public 类，否则编译器不接受。如果这个编译单元中还有其他类，那么在包之外是无法访问到这些类的，因为它们不是 public 类，此时它们支持主 public 类。 类访问权限注意，类既不能是 private 的（这样除了该类自身，任何类都不能访问它），也不能是 protected 的。所以对于类的访问权限只有两种选择：==包访问权限或者 public。==为了防止类被外界访问，可以将所有的构造器声明为 private，这样只有你自己能创建对象（在类的 static 成员中） 本章小结控制成员访问权限有两个原因。第一个原因是使用户不要接触他们不该接触的部分，这部分对于类内部来说是必要的，但是不属于客户端程序员所需接口的一部分。因此将方法和属性声明为 private 对于客户端程序员来说是一种服务，可以让他们清楚地看到什么是重要的，什么可以忽略。这可以简化他们对类的理解。 第二个也是最重要的原因是为了让类库设计者更改类内部的工作方式，而不用担心会影响到客户端程序员。 第八章 复用 代码复用是面向对象编程（OOP）最具魅力的原因之一。 在本章里，你将学习到两种方式来达到这个目的： 第一种方式直接了当。在新类中创建现有类的对象。这种方式叫做“组合”（Composition），通过这种方式复用代码的功能，而非其形式。 第二种方式更为微妙。创建现有类类型的新类。照字面理解：采用现有类形式，又无需在编码时改动其代码，这种方式就叫做“继承”（Inheritance），编译器会做大部分的工作。继承是面向对象编程（OOP）的重要基础之一。更多功能相关将在多态（Polymorphism）章节中介绍。 组合语法你仅需要把对象的引用（object references）放置在一个新的类里，这就使用了组合。例如，假设你需要一个对象，其中内置了几个 String 对象，两个基本类型（primitives）的属性字段，一个其他类的对象。对于非基本类型对象，将引用直接放置在新类中，对于基本类型属性字段则仅进行声明。 编译器不会为每个引用创建一个默认对象，这是有意义的，因为在许多情况下，这会导致不必要的开销。初始化引用有四种方法: 当对象被定义时。这意味着它们总是在调用构造函数之前初始化。 在该类的构造函数中。 在实际使用对象之前。这通常称为延迟初始化。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销。 使用实例初始化。 继承对基类构造函数的调用必须是派生类构造函数中的第一个操作。(如果你写错了，编译器会提醒你。) 委托Java不直接支持的第三种重用关系称为委托。这介于继承和组合之间，因为你将一个成员对象放在正在构建的类中(比如组合)，但同时又在新类中公开来自成员对象的所有方法(比如继承)。例如，宇宙飞船需要一个控制模块: 1234567891011121314// reuse/SpaceShipControls.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.public class SpaceShipControls &#123; void up(int velocity) &#123;&#125; void down(int velocity) &#123;&#125; void left(int velocity) &#123;&#125; void right(int velocity) &#123;&#125; void forward(int velocity) &#123;&#125; void back(int velocity) &#123;&#125; void turboBoost() &#123;&#125;&#125; 建造宇宙飞船的一种方法是使用继承: 12345678910111213141516171819// reuse/DerivedSpaceShip.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.public classDerivedSpaceShip extends SpaceShipControls &#123; private String name; public DerivedSpaceShip(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return name; &#125; public static void main(String[] args) &#123; DerivedSpaceShip protector = new DerivedSpaceShip(\"NSEA Protector\"); protector.forward(100); &#125;&#125; 然而， DerivedSpaceShip 并不是真正的“一种” SpaceShipControls ，即使你“告诉” DerivedSpaceShip 调用 forward()。更准确地说，一艘宇宙飞船包含了 SpaceShipControls *，同时 *SpaceShipControls 中的所有方法都暴露在宇宙飞船中。委托解决了这个难题: 12345678910111213141516171819202122232425262728293031323334353637383940// reuse/SpaceShipDelegation.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.public class SpaceShipDelegation &#123; private String name; private SpaceShipControls controls = new SpaceShipControls(); public SpaceShipDelegation(String name) &#123; this.name = name; &#125; // Delegated methods: public void back(int velocity) &#123; controls.back(velocity); &#125; public void down(int velocity) &#123; controls.down(velocity); &#125; public void forward(int velocity) &#123; controls.forward(velocity); &#125; public void left(int velocity) &#123; controls.left(velocity); &#125; public void right(int velocity) &#123; controls.right(velocity); &#125; public void turboBoost() &#123; controls.turboBoost(); &#125; public void up(int velocity) &#123; controls.up(velocity); &#125; public static void main(String[] args) &#123; SpaceShipDelegation protector = new SpaceShipDelegation(\"NSEA Protector\"); protector.forward(100); &#125;&#125; 方法被转发到底层 control 对象，因此接口与继承的接口是相同的。但是，你对委托有更多的控制，因为你可以选择只在成员对象中提供方法的子集。 虽然Java语言不支持委托，但是开发工具常常支持。例如，上面的例子是使用 JetBrains Idea IDE 自动生成的。 组合与继承的选择当你想在新类中包含一个已有类的功能时，使用组合，而非继承。 “是一个”的关系是用继承来表达的，而“有一个“的关系则用组合来表达。 向上转型继承最重要的方面不是为新类提供方法。它是新类与基类的一种关系。简而言之，这种关系可以表述为“新类是已有类的一种类型”。 继承图中派生类转型为基类是向上的，所以通常称作向上转型。因为是从一个更具体的类转化为一个更一般的类，所以向上转型永远是安全的。也就是说，派生类是基类的一个超集。它可能比基类包含更多的方法，但它必须至少具有与基类一样的方法。在向上转型期间，类接口只可能失去方法，不会增加方法。这就是为什么编译器在没有任何明确转型或其他特殊标记的情况下，仍然允许向上转型的原因。 再论组合和继承在面向对象编程中，创建和使用代码最有可能的方法是将数据和方法一起打包到类中，然后使用该类的对象。也可以使用已有的类通过组合来创建新类。继承其实不太常用。因此尽管在教授 OOP 的过程中我们多次强调继承，但这并不意味着要尽可能使用它。恰恰相反，尽量少使用它，除非确实使用继承是有帮助的。一种判断使用组合还是继承的最清晰的方法是问一问自己是否需要把新类向上转型为基类。如果必须向上转型，那么继承就是必要的，但如果不需要，则要进一步考虑是否该采用继承。“多态”一章提出了一个使用向上转型的最有力的理由，但是只要记住问一问“我需要向上转型吗？”，就能在这两者中作出较好的选择。 final关键字根据上下文环境，Java 的关键字 final 的含义有些微的不同，但通常它指的是“这是不能被改变的”。防止改变有两个原因：设计或效率。因为这两个原因相差很远，所以有可能误用关键字 final。 可能使用 final 的三个地方：数据、方法和类。 final 数据许多编程语言都有某种方法告诉编译器有一块数据是恒定不变的。恒定是有用的，如： 一个永不改变的编译时常量。 一个在运行时初始化就不会改变的值。 对于编译时常量这种情况，编译器可以把常量带入计算中；也就是说，可以在编译时计算，减少了一些运行时的负担。在 Java 中，这类常量必须是基本类型，而且用关键字 final 修饰。你必须在定义常量的时候进行赋值。 一个被 static 和 final 同时修饰的属性只会占用一段不能改变的存储空间。 对于基本类型，final 使数值恒定不变，而对于对象引用，final 使引用恒定不变。一旦引用被初始化指向了某个对象，它就不能改为指向其他对象。但是，对象本身是可以修改的，Java 没有提供将任意对象设为常量的方法。（你可以自己编写类达到使对象恒定不变的效果）这一限制同样适用数组，数组也是对象。 按照惯例，带有恒定初始值的 final static 基本变量（即编译时常量）命名全部使用大写，单词之间用下划线分隔。（源于 C 语言中定义常量的方式。） 第九章 多态 曾经有人请教我 “ Babbage 先生，如果输入错误的数字到机器中，会得出正确结果吗？” 我无法理解产生如此问题的概念上的困惑。 —— Charles Babbage (1791 - 1871) 多态是面向对象编程语言中，继数据抽象和继承之外的第三个重要特性。 多态（也称为动态绑定或后期绑定或运行时绑定） 转机方法调用绑定将一个方法调用和一个方法主体关联起来称作绑定。若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做前期绑定。你可能从来没有听说这个术语，因为它是面向过程语言不需选择默认的绑定方式，例如在 C 语言中就只有前期绑定这一种方法调用。 解决方法就是后期绑定，意味着在运行时根据对象的类型进行绑定。后期绑定也称为动态绑定或运行时绑定。当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器仍然不知道对象的类型，但是方法调用机制能找到正确的方法体并调用。每种语言的后期绑定机制都不同，但是可以想到，对象中一定存在某种类型信息。 Java 中除了 static 和 final 方法（private 方法也是隐式的 final）外，其他所有方法都是后期绑定。这意味着通常情况下，我们不需要判断后期绑定是否会发生——它自动发生。 为什么将一个对象指明为 final ？正如前一章所述，它可以防止方法被重写。但更重要的一点可能是，它有效地”关闭了“动态绑定，或者说告诉编译器不需要对其进行动态绑定。这可以让编译器为 final 方法生成更高效的代码。然而，大部分情况下这样做不会对程序的整体性能带来什么改变，因此最好是为了设计使用 final，而不是为了提升性能而使用。 可扩展性只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类派生出新的数据类型，从而添加新的功能。那些操纵基类接口的方法不需要改动就可以应用于新类。 这正是我们期待多态能提供的特性。代码中的修改不会破坏程序中其他不应受到影响的部分。换句话说，多态是一项“将改变的事物与不变的事物分离”的重要技术。 构造器和多态通常，构造器不同于其他类型的方法。在涉及多态时也是如此。尽管构造器不具有多态性（它们实际上是静态方法，但是隐式声明的），但是理解构造器在复杂层次结构中运作多态还是非常重要的。这个理解可以帮助你避免一些不愉快的困扰。 继承和清理在使用组合和继承创建新类时，大部分时候你无需关心清理。子对象通常会留给垃==圾收集器处理。如果你存在清理问题，那么必须用心地为新类创建一个== dispose() 方法（这里用的是我选择的名称，你可以使用更好的名称）。由于继承，如果有其他特殊的清理工作的话，就必须在派生类中重写 dispose() 方法。当重写 dispose() 方法时，记得调用基类的 dispose() 方法，否则基类的清理工作不会发生： 构造器内部多态方法的行为编写构造器有一条良好规范：做尽量少的事让对象进入良好状态。如果有可能的话，==尽量不要调用类中的任何方法==。在构造器中唯一能安全调用的只有基类的 final 方法（包括 private 方法，它们自动属于 final）。这些方法不能被重写，因此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。 协变返回类型Java 5 中引入了协变返回类型，这表示派生类的被重写方法可以返回基类方法返回类型的派生类型： 123456789101112class Mill &#123; Grain process() &#123; return new Grain(); &#125;&#125;class WheatMill extends Mill &#123; @Override Wheat process() &#123; return new Wheat(); &#125;&#125; 关键区别在于 Java 5 之前的版本强制要求被重写的 process() 方法必须返回 Grain 而不是 Wheat，即使 Wheat 派生自 Grain，因而也应该是一种合法的返回类型。协变返回类型允许返回更具体的 Wheat 类型。 使用继承设计有一条通用准则：使用继承表达行为的差异，使用属性表达状态的变化。 向下转型与运行时类型信息在某些语言中（如 C++），必须执行一个特殊的操作来获得安全的向下转型，但是在 Java 中，每次转型都会被检查！所以即使只是进行一次普通的加括号形式的类型转换，在运行时这个转换仍会被检查，以确保它的确是希望的那种类型。如果不是，就会得到 ClassCastException （类转型异常）。这种在运行时检查类型的行为称作运行时类型信息。 本章小结为了在程序中有效地使用多态乃至面向对象的技术，就必须扩展自己的编程视野，不能只看到单一类中的成员和消息，而要看到类之间的共同特性和它们之间的关系。尽管这需要很大的努力，但是这么做是值得的。它能带来更快的程序开发、更好的代码组织、扩展性更好的程序和更易维护的代码。 第十章 接口接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。 抽象类和方法抽象类，一种介于普通类和接口之间的折中手段。尽管你的第一想法是创建接口，但是对于构建具有属性和未实现方法的类来说，抽象类也是重要且必要的工具。你不可能总是使用纯粹的接口。 Java 提供了一个叫做抽象方法的机制，这个方法是不完整的：它只有声明没有方法体。下面是抽象方法的声明语法： 1abstract void f(); 包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的，否则，编译器会报错。 1234// interface/Basic.javaabstract class Basic &#123; abstract void unimplemented();&#125; 事实上，接口只允许 public 方法，如果不加访问修饰符的话，接口的方法不是 friendly 而是 public。 接口创建描述 Java 8 之前的接口更加容易，因为它们只允许抽象方法。像下面这样： 1234567// interfaces/PureInterface.java// Interface only looked like this before Java 8public interface PureInterface &#123; int m1(); void m2(); double m3();&#125; 我们甚至不用为方法加上 abstract 关键字，因为方法在接口中。Java 知道这些方法不能有方法体（仍然可以为方法加上 abstract 关键字，但是看起来像是不明白接口，徒增难堪罢了）。 Java 8之前我们可以这么说：interface 关键字产生一个完全抽象的类，没有提供任何实现。我们只能描述类应该像什么，做什么，但不能描述怎么做，即只能决定方法名、参数列表和返回类型，但是无法确定方法体。接口只提供形式，通常来说没有实现，尽管在某些受限制的情况下可以有实现。 一个接口表示：所有实现了该接口的类看起来都像这样。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。所以，接口被用来建立==类之间的协议==。（一些面向对象编程语言中，使用 protocol 关键字完成相同的功能。） Java 8 中接口稍微有些变化，因为 Java 8 允许接口包含默认方法和静态方法——基于某些重要原因，看到后面你会理解。接口的基本概念仍然没变，介于类型之上、实现之下。接口与抽象类最明显的区别可能就是使用上的惯用方式。 接口同样可以包含属性，这些属性被隐式指明为 static 和 final。 默认方法Java 8 为关键字 default 增加了一个新的用途（之前只用于 switch 语句和注解中）。当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用 default 创建的方法体。默认方法比抽象类中的方法受到更多的限制，但是非常有用。 123456789// interfaces/InterfaceWithDefault.javainterface InterfaceWithDefault &#123; void firstMethod(); void secondMethod(); default void newMethod() &#123; System.out.println(\"newMethod\"); &#125;&#125; 增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下，在接口中增加新的方法。默认方法有时也被称为守卫方法或虚拟扩展方法。 多继承多继承意味着一个类可能从多个父类型中继承特征和特性。 Java 在设计之初，C++ 的多继承机制饱受诟病。Java 过去是一种严格要求单继承的语言：只能继承自一个类（或抽象类），但可以实现任意多个接口。在 Java 8 之前，接口没有包袱——它只是方法外貌的描述。 多年后的现在，Java 通过默认方法具有了某种多继承的特性。结合带有默认方法的接口意味着结合了多个基类中的行为。因为接口中仍然不允许存在属性（只有静态属性，不适用），所以属性仍然只会来自单个基类或抽象类，也就是说，不会存在状态的多继承。 接口中的静态方法Java 8 允许在接口中添加静态方法。这么做能恰当地把工具功能置于接口中，从而操作接口，或者成为通用的工具。 1234567891011121314151617// onjava/Operations.javapackage onjava;import java.util.*;public interface Operations &#123; void execute(); static void runOps(Operations... ops) &#123; for (Operations op: ops) &#123; op.execute(); &#125; &#125; static void show(String msg) &#123; System.out.println(msg); &#125;&#125; 抽象类和接口尤其是在 Java 8 引入 default 方法之后，选择用抽象类还是用接口变得更加令人困惑。下表做了明确的区分： 特性 接口 抽象类 组合 新类可以组合多个接口 只能继承单一抽象类 状态 不能包含属性（除了静态属性，不支持对象状态） 可以包含属性，非抽象方法可能引用这些属性 默认方法 和 抽象方法 不需要在子类中实现默认方法。默认方法可以引用其他接口的方法 必须在子类中实现抽象方法 构造器 没有构造器 可以有构造器 可见性 隐式 public 可以是 protected 或友元 抽象类仍然是一个类，在创建新类时只能继承它一个。而创建类的过程中可以实现多个接口。 有一条实际经验：尽可能地抽象。因此，更倾向使用接口而不是抽象类。只有当必要时才使用抽象类。除非必须使用，否则不要用接口和抽象类。大多数时候，普通类已经做得很好，如果不行的话，再移动到接口或抽象类中。 完全解耦创建一个能根据传入的参数类型从而具备不同行为的方法称为策略设计模式。方法包含算法中不变的部分，策略包含变化的部分。策略就是传入的对象，它包含要执行的代码。 可以在接口中定义 main() 方法。 多接口结合结合具体类和接口时，需要将具体类放在前面，后面跟着接口（否则编译器会报错）。 使用接口的核心原因之一：为了能够向上转型为多个基类型（以及由此带来的灵活性）。然而，使用接口的第二个原因与使用抽象基类相同：防止客户端程序员创建这个类的对象，确保这仅仅只是一个接口。这带来了一个问题：应该使用接口还是抽象类呢？如果创建不带任何方法定义或成员变量的基类，就选择接口而不是抽象类。事实上，如果知道某事物是一个基类，可以考虑用接口实现它（这个主题在本章总结会再次讨论）。 使用继承扩展接口通过继承，可以很容易在接口中增加方法声明，还可以在新接口中结合多个接口。 123interface DangerousMonster extends Monster &#123; void destroy();&#125; 接口适配接口的一种常见用法是前面提到的策略设计模式。编写一个方法执行某些操作并接受一个指定的接口作为参数。可以说：“只要对象遵循接口，就可以调用方法” ，这使得方法更加灵活，通用，并更具可复用性。 在已有类中增加新接口，所以这就意味着一个接受接口类型的方法提供了一种让任何类都可以与该方法进行适配的方式。这就是使用接口而不是类的强大之处。 接口字段因为接口中的字段都自动是 static 和 final 的，所以接口就成为了创建一组常量的方便的工具。在 Java 5 之前，这是产生与 C 或 C++ 中的 enum (枚举类型) 具有相同效果的唯一方式。所以你可能在 Java 5 之前的代码中看到： 123456789// interfaces/Months.java// Using interfaces to create groups of constantspublic interface Months &#123; int JANUARY = 1, FEBRUARY = 2, MARCH = 3, APRIL = 4, MAY = 5, JUNE = 6, JULY = 7, AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10, NOVEMBER = 11, DECEMBER = 12;&#125; 注意 Java 中使用大写字母的风格定义具有初始化值的 static final 变量。接口中的字段自动是 public 的，所以没有显式指明这点。 自 Java 5 开始，我们有了更加强大和灵活的关键字 enum，那么在接口中定义常量组就显得没什么意义了。 初始化接口中的字段接口中定义的字段不能是“空 final“，但是可以用非常量表达式初始化。 这些字段不是接口的一部分，它们的值被存储在接口的静态存储区域中。 接口和工厂方法模式接口是多实现的途径，而生成符合某个接口的对象的典型方式是工厂方法设计模式。不同于直接调用构造器，只需调用工厂对象中的创建方法就能生成对象的实现——理论上，通过这种方式可以将接口与实现的代码完全分离，使得可以透明地将某个实现替换为另一个实现。 本章小结认为接口是好的选择，从而使用接口不用具体类，这具有诱惑性。几乎任何时候，创建类都可以替代为创建一个接口和工厂。 很多人都掉进了这个陷阱，只要有可能就创建接口和工厂。这种逻辑看起来像是可能会使用不同的实现，所以总是添加这种抽象性。这变成了一种过早的设计优化。 任何抽象性都应该是由真正的需求驱动的。当有必要时才应该使用接口进行重构，而不是到处添加额外的间接层，从而带来额外的复杂性。这种复杂性非常显著，如果你让某人去处理这种复杂性，只是因为你意识到“以防万一”而添加新接口，而没有其他具有说服力的原因——好吧，如果我碰上了这种设计，就会质疑此人所作的所有其他设计了。 恰当的原则是优先使用类而不是接口。从类开始，如果使用接口的必要性变得很明确，那么就重构。==接口是一个伟大的工具，但它们容易被滥用。== 第十一章 内部类 一个定义在另一个类中的类，叫作内部类。 内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可见性。 创建内部类如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像在 main() 方法中那样，具体地指明这个对象的类型：OuterClassName.InnerClassName。(译者注：在外部类的静态方法中也可以直接指明类型 InnerClassName，在其他类中需要指明 OuterClassName.InnerClassName。) 链接外部类内部类似乎还只是一种名字隐藏和组织代码的模式。这些是很有用，但还不是最引人注目的，它还有其他的用途。当生成一个内部类的对象时，此对象与制造它的外围对象（enclosing object）之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。 使用 .this 和 .new如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。下面的示例展示了如何使用 .this： 12345678public class DotThis &#123; public class Inner &#123; public DotThis outer() &#123; return DotThis.this; // A plain \"this\" would be Inner's \"this\" &#125; &#125;&#125; 有时你可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在 new 表达式中提供对其他外部类对象的引用，这是需要使用 .new 语法，就像下面这样： 123456789// innerclasses/DotNew.java// Creating an inner class directly using .new syntaxpublic class DotNew &#123; public class Inner &#123;&#125; public static void main(String[] args) &#123; DotNew dn = new DotNew(); DotNew.Inner dni = dn.new Inner(); &#125;&#125; 在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。 内部类与向上转型普通（非内部）类的访问权限不能被设为 private 或者 protected；他们只能设置为 public 或 package 访问权限。 private 内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。此外，从客户端程序员的角度来看，由于不能访问任何新增加的、原本不属于公共接口的方法，所以扩展接口是没有价值的。这也给 Java 编译器提供了生成高效代码的机会。 内部类方法和作用域可以在一个方法里面或者在任意的作用域内定义内部类。 这么做有两个理由： 如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。 在后面的例子中，先前的代码将被修改，以用来实现： 一个定义在方法中的类。 一个定义在作用域内的类，此作用域在方法的内部。 一个实现了接口的匿名类。 一个匿名类，它扩展了没有默认构造器的类。 一个匿名类，它执行字段初始化。 一个匿名类，它通过实例初始化实现构造（匿名内部类不可能有构造器）。 第一个例子展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类。这被称作局部内部类： 123456789101112131415public class Parcel5 &#123; public Destination destination(String s) &#123; final class PDestination implements Destination &#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; @Override public String readLabel() &#123; return label; &#125; &#125; return new PDestination(s); &#125;&#125; 匿名内部类这种奇怪的语法指的是：“创建一个继承自 Contents 的匿名类的对象。”通过 new 表达式返回的引用被自动向上转型为对 Contents 的引用。 12345678910public class Parcel7 &#123; public Contents contents() &#123; return new Contents() &#123; // Insert class definition private int i = 11; @Override public int value() &#123; return i; &#125; &#125;; // Semicolon required &#125;&#125; 嵌套类如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为 static，这通常称为嵌套类。想要理解 static 应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是 static 的时，就不是这样了。嵌套类意味着： 要创建嵌套类的对象，并不需要其外围类的对象。 不能从嵌套类的对象中访问非静态的外围类对象。 嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有 static 数据和 static 字段，也不能包含嵌套类。 接口内部的类嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是 public 和 static 的。因为类是 static 的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。你甚至可以在内部类中实现其外围接口 我曾在本书中建议过，在每个类中都写一个 main() 方法，用来测试这个类。这样做有一个缺点，那就是必须带着那些已编译过的额外代码。如果这对你是个麻烦，那就可以使用嵌套类来放置测试代码。 123456789101112// innerclasses/TestBed.java// Putting test code in a nested class// &#123;java TestBed$Tester&#125;public class TestBed &#123; public void f() &#123; System.out.println(\"f()\"); &#125; public static class Tester &#123; public static void main(String[] args) &#123; TestBed t = new TestBed(); t.f(); &#125; &#125;&#125; 输出为： 1f() 这生成了一个独立的类 TestBed$Tester（要运行这个程序，执行 java TestBed$Tester，在 Unix/Linux 系统中需要转义 $）。你可以使用这个类测试，但是不必在发布的产品中包含它，可以在打包产品前删除 TestBed$Tester.class。 为什么需要内部类一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。 内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢？答案是：“如果这能满足需求，那么就应该这样做。”那么内部类实现一个接口与外围类实现这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是： 每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类）。 使用内部类，还可以获得其他一些特性： 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。稍后就会展示一个这样的例子。 创建内部类对象的时刻并不依赖于外围类对象的创建 内部类并没有令人迷惑的”is-a”关系，它就是一个独立的实体。 闭包与回调闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 private 成员。 在 Java 8 之前，生成闭包行为的唯一方式就是内部类。在 Java 8 之后，我们可以使用 lambda 表达式来生成闭包行为，并且语法更加精细和简洁；你将会在 函数式编程 这一章节中学习相关细节。即使应该优先使用 lambda 表达式用于内部类闭包，你依旧会看到那些 Java 8 以前的代码，即使用内部类来表示闭包的方式，所以非常有必要来理解这种形式。 Java 最引人争议的问题之一就是，人们认为 Java 应该包含某种类似指针的机制，以允许回调（callback）。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。稍后将会看到这是一个非常有用的概念。如果回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。然而，读者应该已经了解到，Java 更小心仔细，所以没有在语言中包括指针。 通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。 12345678910111213141516171819202122// If your class must implement increment() in// some other way, you must use an inner class:class Callee2 extends MyIncrement &#123; private int i = 0; @Override public void increment() &#123; super.increment(); i++; System.out.println(i); &#125; private class Closure implements Incrementable &#123; @Override public void increment() &#123; // Specify outer-class method, otherwise // you'll get an infinite recursion: Callee2.this.increment(); &#125; &#125; Incrementable getCallbackReference() &#123; return new Closure(); &#125;&#125; 回调的价值在于它的灵活性-可以在运行时动态地决定需要调用什么方法。 内部类与控制框架应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题。这是设计模式中模板方法的一个例子，模板方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，以完成算法的动作。设计模式总是将==变化的事物与保持不变的事物==分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物。 控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统被称作事件驱动系统。应用程序设计中常见的问题之一是图形用户接口（GUI），它几乎完全是事件驱动的系统。 继承内部类因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外围类对象的“秘密的”引用必须被初始化，而在派生类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联： 123456789101112131415// innerclasses/InheritInner.java// Inheriting an inner classclass WithInner &#123; class Inner &#123;&#125;&#125;public class InheritInner extends WithInner.Inner &#123; //- InheritInner() &#123;&#125; // Won't compile InheritInner(WithInner wi) &#123; wi.super(); &#125; public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner ii = new InheritInner(wi); &#125;&#125; 可以看到，InheritInner 只继承自内部类，而不是外围类。但是当要生成一个构造器时，默认的构造器并不算好，而且不能只是传递一个指向外围类对象的引用。此外，必须在构造器内使用如下语法： 1enclosingClassReference.super(); 这样才提供了必要的引用，然后程序才能编译通过。 内部类可以被覆盖么？如果创建了一个内部类，然后继承其外围类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被覆盖吗？这看起来似乎是个很有用的思想，但是“覆盖”内部类就好像它是外围类的一个方法，其实并不起什么作用. 局部内部类前面提到过，可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外围类的一部分；但是它可以访问当前代码块内的常量，以及此外围类的所有成员。下面的例子对局部内部类与匿名内部类的创建进行了比较。 Anonymous inner class cannot have a named constructor, only an instance initializer 局部内部类的名字在方法外是不可见的，那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。 所以使用局部内部类而不使用匿名内部类的另一个理由就是，需要不止一个该内部类的对象。 内部类标识符由于编译后每个类都会产生一个.class 文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个”meta-class”，叫做 Class 对象）。 你可能猜到了，内部类也必须生成一个.class 文件以包含它们的 Class 对象信息。这些类文件的命名有严格的规则：外围类的名字，加上“$“，再加上内部类的名字。例如，LocalInnerClass.java 生成的 .class 文件包括： 1234Counter.classLocalInnerClass$1.classLocalInnerClass$1LocalCounter.classLocalInnerClass.class 如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外围类标识符与“$”的后面。 虽然这种命名格式简单而直接，但它还是很健壮的，足以应对绝大多数情况。因为这是 java 的标准命名方式，所以产生的文件自动都是平台无关的。（注意，为了保证你的内部类能起作用，Java 编译器会尽可能地转换它们。） 本章小结虽然这些特性本身是相当直观的，但是就像多态机制一样，这些特性的使用应该是设计阶段考虑的问题。随着时间的推移，读者将能够更好地识别什么情况下应该使用接口，什么情况使用内部类，或者两者同时使用。 第十二章 集合 如果一个程序只包含固定数量的对象且对象的生命周期都是已知的，那么这是一个非常简单的程序。 为了解决这个普遍的编程问题，需要在任意时刻和任意位置创建任意数量的对象。因此，不能依靠创建命名的引用来持有每一个对象： 1MyType aReference; 因为从来不会知道实际需要多少个这样的引用。 Java有多种方式保存对象（确切地说，是对象的引用）。例如前边曾经学习过的数组，它是编译器支持的类型。数组是保存一组对象的最有效的方式，如果想要保存一组基本类型数据，也推荐使用数组。但是数组具有固定的大小尺寸，而且在更一般的情况下，在写程序的时候并不知道将需要多少个对象，或者是否需要更复杂的方式来存储对象，因此数组尺寸固定这一限制就显得太过受限了。 java.util 库提供了一套相当完整的集合类（collection classes）来解决这个问题，其中基本的类型有 List 、 Set 、 Queue 和 Map。这些类型也被称作容器类（container classes），但我将使用Java类库使用的术语。集合提供了完善的方法来保存对象，可以使用这些工具来解决大量的问题。 泛型和类型安全的集合 new ArrayList&lt;&gt;() 。这有时被称为“菱形语法”（diamond syntax）。在 Java 7 之前，必须要在两端都进行类型声明，如下所示： 1ArrayList&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;(); 随着类型变得越来越复杂，这种重复产生的代码非常混乱且难以阅读。程序员发现所有类型信息都可以从左侧获得，因此，编译器没有理由强迫右侧再重复这些。虽然类型推断（type inference）只是个很小的请求，Java 语言团队仍然欣然接受并进行了改进。 使用泛型，从 List 中获取元素不需要强制类型转换。因为 List 知道它持有什么类型，因此当调用 get() 时，它会替你执行转型。因此，使用泛型，你不仅知道编译器将检查放入集合的对象类型，而且在使用集合中的对象时也可以获得更清晰的语法。 Object 默认的 toString() 方法产生的，该方法打印类名，后边跟着对象的散列码的无符号十六进制表示（这个散列码是通过 hashCode() 方法产生的）。将在附录：理解equals和hashCode方法中了解有关散列码的内容。 基本概念Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口： 集合（Collection） ：一个独立元素的序列，这些元素都服从一条或多条规则。List 必须以插入的顺序保存元素， Set 不能包含重复元素， Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。 映射（Map） ： 一组成对的“键值对”对象，允许使用键来查找值。 ArrayList 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 map 允许我们使用一个对象来查找另一个对象，它也被称作关联数组（associative array），因为它将对象和其它对象关联在一起；或者称作字典（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 Map 是强大的编程工具。 尽管并非总是可行，但在理想情况下，你编写的大部分代码都在与这些接口打交道，并且唯一需要指定所使用的精确类型的地方就是在创建的时候。因此，可以像下面这样创建一个 List ： 1List&lt;Apple&gt; apples = new ArrayList&lt;&gt;(); 请注意， ArrayList 已经被向上转型为了 List ，这与之前示例中的处理方式正好相反。使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了，就像下面这样： 1List&lt;Apple&gt; apples = new LinkedList&lt;&gt;(); 因此，应该创建一个具体类的对象，将其向上转型为对应的接口，然后在其余代码中都是用这个接口。 这种方式并非总是有效的，因为某些具体类有额外的功能。例如， LinkedList 具有 List 接口中未包含的额外方法，而 TreeMap 也具有在 Map 接口中未包含的方法。如果需要使用这些方法，就不能将它们向上转型为更通用的接口。 Collection 接口概括了序列的概念——一种存放一组对象的方式。 添加元素组在 java.util 包中的 Arrays 和 Collections 类中都有很多实用的方法，可以在一个 Collection 中添加一组元素。 Arrays.asList() 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 List 对象。 Collections.addAll() 方法接受一个 Collection 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 Collection 中。下边的示例展示了这两个方法，以及更通用的 addAll() 方法，所有 Collection 类型都包含该方法： 123456789101112131415161718192021// collections/AddingGroups.java// Adding groups of elements to Collection objectsimport java.util.*;public class AddingGroups &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; collection = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5)); Integer[] moreInts = &#123; 6, 7, 8, 9, 10 &#125;; collection.addAll(Arrays.asList(moreInts)); // Runs significantly faster, but you can't // construct a Collection this way: Collections.addAll(collection, 11, 12, 13, 14, 15); Collections.addAll(collection, moreInts); // Produces a list \"backed by\" an array: List&lt;Integer&gt; list = Arrays.asList(16,17,18,19,20); list.set(1, 99); // OK -- modify an element // list.add(21); // Runtime error; the underlying // array cannot be resized. &#125;&#125; Collection 的构造器可以接受另一个 Collection，用它来将自身初始化。因此，可以使用 Arrays.asList() 来为这个构造器产生输入。但是，=== Collections.addAll() 运行得更快，而且很容易构建一个不包含元素的 Collection ，然后调用 Collections.addAll() ，因此这是首选方式。== Collection.addAll() 方法只能接受另一个 Collection 作为参数，因此它没有 Arrays.asList() 或 Collections.addAll() 灵活。这两个方法都使用可变参数列表。 也可以直接使用 Arrays.asList() 的输出作为一个 List ，但是这里的底层实现是数组，没法调整大小。如果尝试在这个 List 上调用 add() 或 remove()，由于这两个方法会尝试修改数组大小，所以会在运行时得到“Unsupported Operation（不支持的操作）”错误： 12345678910111213141516171819202122232425262728293031// collections/AsListInference.javaimport java.util.*;class Snow &#123;&#125;class Powder extends Snow &#123;&#125;class Light extends Powder &#123;&#125;class Heavy extends Powder &#123;&#125;class Crusty extends Snow &#123;&#125;class Slush extends Snow &#123;&#125;public class AsListInference &#123; public static void main(String[] args) &#123; List&lt;Snow&gt; snow1 = Arrays.asList( new Crusty(), new Slush(), new Powder()); //- snow1.add(new Heavy()); // Exception List&lt;Snow&gt; snow2 = Arrays.asList( new Light(), new Heavy()); //- snow2.add(new Slush()); // Exception List&lt;Snow&gt; snow3 = new ArrayList&lt;&gt;(); Collections.addAll(snow3, new Light(), new Heavy(), new Powder()); snow3.add(new Crusty()); // Hint with explicit type argument specification: List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList( new Light(), new Heavy(), new Slush()); //- snow4.add(new Powder()); // Exception &#125;&#125; 在 snow4 中，注意 Arrays.asList() 中间的“暗示”（即 &lt;Snow&gt; ），告诉编译器 Arrays.asList() 生成的结果 List 类型的实际目标类型是什么。这称为显式类型参数说明（explicit type argument specification）。 集合的打印必须使用 Arrays.toString() 来生成数组的可打印形式。但是打印集合无需任何帮助。 集合的分类Java集合库中的两个主要类型。它们的区别在于集合中的每个“槽”（slot）保存的元素个数。 Collection 类型在每个槽中只能保存一个元素。此类集合包括： List ，它以特定的顺序保存一组元素； Set ，其中元素不允许重复； Queue ，只能在集合一端插入对象，并从另一端移除对象（就本例而言，这只是查看序列的另一种方式，因此并没有显示它）。 Map 在每个槽中存放了两个元素，即键和与之关联的值。 默认的打印行为，使用集合提供的 toString() 方法即可生成可读性很好的结果。 Collection 打印出的内容用方括号括住，每个元素由逗号分隔。 Map 则由大括号括住，每个键和值用等号连接（键在左侧，值在右侧）。 ArrayList 和 LinkedList 都是 List 的类型，从输出中可以看出，它们都按插入顺序保存元素。两者之间的区别不仅在于执行某些类型的操作时的性能，而且 LinkedList 包含的操作多于 ArrayList 。本章后面将对这些内容进行更全面的探讨。 HashSet ， TreeSet 和 LinkedHashSet 是 Set 的类型。从输出中可以看到， Set 仅保存每个相同项中的一个，并且不同的 Set 实现存储元素的方式也不同。 HashSet 使用相当复杂的方法存储元素，这在附录：集合主题中进行了探讨。现在只需要知道，这种技术是检索元素的最快方法，因此，存储顺序看上去没有什么意义（通常只关心某事物是否是 Set 的成员，而存储顺序并不重要）。如果存储顺序很重要，则可以使用 TreeSet ，它将按比较结果的升序保存对象）或 LinkedHashSet ，它按照被添加的先后顺序保存对象。 Map （也称为关联数组）使用键来查找对象，就像一个简单的数据库。所关联的对象称为值。 假设有一个 Map 将美国州名与它们的首府联系在一起，如果想要俄亥俄州（Ohio）的首府，可以用“Ohio”作为键来查找，几乎就像使用数组下标一样。正是由于这种行为，对于每个键， Map 只存储一次。 Map.put(key, value) 添加一个所想要添加的值并将它与一个键（用来查找值）相关联。 Map.get(key) 生成与该键相关联的值。上面的示例仅添加键值对，并没有执行查找。这将在稍后展示。 请注意，这里没有指定（或考虑） Map 的大小，因为它会自动调整大小。 此外， Map 还知道如何打印自己，它会显示相关联的键和值。 Map 的三种基本风格： HashMap ， TreeMap 和 LinkedHashMap 。 键和值保存在 HashMap 中的顺序不是插入顺序，因为 HashMap 实现使用了非常快速的算法来控制顺序。 TreeMap 通过比较结果的升序来保存键， LinkedHashMap 在保持 HashMap 查找速度的同时按键的插入顺序保存键。 列表ListLists承诺将元素保存在特定的序列中。 List 接口在 Collection 的基础上添加了许多方法，允许在 List 的中间插入和删除元素。 有两种类型的 List ： 基本的 ArrayList ，擅长随机访问元素，但在 List 中间插入和删除元素时速度较慢。 LinkedList ，它通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问。 LinkedList 对于随机访问来说相对较慢，但它具有比 ArrayList 更大的特征集。 可以使用 contains() 方法确定对象是否在列表中。如果要删除一个对象，可以将该对象的引用传递给 remove() 方法。同样，如果有一个对象的引用，可以使用 indexOf() 在 List 中找到该对象所在位置的下标号 当确定元素是否是属于某个 List ，寻找某个元素的索引，以及通过引用从 List 中删除元素时，都会用到 equals() 方法（根类 Object 的一个方法）。 name description usage 与数组不同， List 可以在创建后添加或删除元素，并自行调整大小。这正是它的重要价值：一种可修改的序列。 可以使用 contains() 方法确定对象是否在列表中。如果要删除一个对象，可以将该对象的引用传递给 remove() 方法。同样，如果有一个对象的引用，可以使用 indexOf() 在 List 中找到该对象所在位置的下标号，如第 4 行输出所示中所示。 当确定元素是否是属于某个 List ，寻找某个元素的索引，以及通过引用从 List 中删除元素时，都会用到 equals() 方法（根类 Object 的一个方法）。每个 Pet 被定义为一个唯一的对象，所以即使列表中已经有两个 Cymrics ，如果再创建一个新的 Cymric 对象并将其传递给 indexOf() 方法，结果仍为 -1 （表示未找到），并且尝试调用 remove() 方法来删除这个对象将返回 false 。对于其他类， equals() 的定义可能有所不同。例如，如果两个 String 的内容相同，则这两个 String 相等。因此，为了防止出现意外，请务必注意 List 行为会根据 equals() 行为而发生变化。 第 7、8 行输出展示了删除与 List 中的对象完全匹配的对象是成功的。 可以在 List 的中间插入一个元素，就像在第 9 行输出和它之前的代码那样。但这会带来一个问题：对于 LinkedList ，在列表中间插入和删除都是廉价操作（在本例中，除了对列表中间进行的真正的随机访问），但对于 ArrayList ，这可是代价高昂的操作。这是否意味着永远不应该在 ArrayList 的中间插入元素，并最好是转换为 LinkedList ？不，它只是意味着你应该意识到这个问题，如果你开始在某个 ArrayList 中间执行很多插入操作，并且程序开始变慢，那么你应该看看你的 List 实现有可能就是罪魁祸首（发现此类瓶颈的最佳方式是使用分析器 profiler）。优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）。 subList() 方法可以轻松地从更大的列表中创建切片，当将切片结果传递给原来这个较大的列表的 containsAll() 方法时，很自然地会得到 true。请注意，顺序并不重要，在第 11、12 行输出中可以看到，在 sub 上调用直观命名的 Collections.sort() 和 Collections.shuffle() 方法，不会影响 containsAll() 的结果。 subList() 所产生的列表的幕后支持就是原始列表。因此，对所返回列表的更改都将会反映在原始列表中，反之亦然。 retainAll() 方法实际上是一个“集合交集”操作，在本例中，它保留了同时在 copy 和 sub 中的所有元素。请再次注意，所产生的结果行为依赖于 equals() 方法。 第 14 行输出展示了使用索引号来删除元素的结果，与通过对象引用来删除元素相比，它显得更加直观，因为在使用索引时，不必担心 equals() 的行为。 removeAll() 方法也是基于 equals() 方法运行的。 顾名思义，它会从 List 中删除在参数 List 中的所有元素。 set() 方法的命名显得很不合时宜，因为它与 Set 类存在潜在的冲突。在这里使用“replace”可能更适合，因为它的功能是用第二个参数替换索引处的元素（第一个参数）。 第 17 行输出表明，对于 List ，有一个重载的 addAll() 方法可以将新列表插入到原始列表的中间位置，而不是仅能用 Collection 的 addAll() 方法将其追加到列表的末尾。 第 18 - 20 行输出展示了 isEmpty() 和 clear() 方法的效果。 第 22、23 行输出展示了如何使用 toArray() 方法将任意的 Collection 转换为数组。这是一个重载方法，其无参版本返回一个 Object 数组，但是如果将目标类型的数组传递给这个重载版本，那么它会生成一个指定类型的数组（假设它通过了类型检查）。如果参数数组太小而无法容纳 List 中的所有元素（就像本例一样），则 toArray() 会创建一个具有合适尺寸的新数组。 迭代器Iterators迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为轻量级对象（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 Iterator 只能单向移动。这个 Iterator 只能用来： 使用 iterator() 方法要求集合返回一个 Iterator。 Iterator 将准备好返回序列中的第一个元素。 使用 next() 方法获得序列中的下一个元素。 使用 hasNext() 方法检查序列中是否还有元素。 使用 remove() 方法将迭代器最近返回的那个元素删除。 有了 Iterator ，就不必再为集合中元素的数量操心了。这是由 hasNext() 和 next() 关心的事情。 如果只是想向前遍历 List ，并不打算修改 List 对象本身，那么使用 for-in 语法更加简洁。 ==Iterator 还可以删除由 next() 生成的最后一个元素，这意味着在调用 remove() 之前必须先调用 next() 。==[^4] [^4]: remove() 是一个所谓的“可选”方法（还有一些其它的这种方法），这意味着并非所有的 Iterator 实现都必须实现该方法。这个问题将在附录：集合主题中介绍。但是，标准 Java 库集合实现了 remove() ，因此在附录：集合主题章节之前，都不必担心这个问题。 display() 方法不包含任何有关它所遍历的序列的类型信息。这也展示了 Iterator 的真正威力：能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有时会说：迭代器统一了对集合的访问方式。 我们可以使用 Iterable 接口生成上一个示例的更简洁版本，该接口描述了“可以产生 Iterator 的任何东西”： 12345678910111213141516171819202122232425262728293031323334// collections/CrossCollectionIteration2.javaimport typeinfo.pets.*;import java.util.*;public class CrossCollectionIteration2 &#123; public static void display(Iterable&lt;Pet&gt; ip) &#123; Iterator&lt;Pet&gt; it = ip.iterator(); while(it.hasNext()) &#123; Pet p = it.next(); System.out.print(p.id() + \":\" + p + \" \"); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; List&lt;Pet&gt; pets = Pets.list(8); LinkedList&lt;Pet&gt; petsLL = new LinkedList&lt;&gt;(pets); HashSet&lt;Pet&gt; petsHS = new HashSet&lt;&gt;(pets); TreeSet&lt;Pet&gt; petsTS = new TreeSet&lt;&gt;(pets); display(pets); display(petsLL); display(petsHS); display(petsTS); &#125;&#125;/* Output:0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug7:Manx0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug7:Manx0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug7:Manx5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug0:Rat*/ 这里所有的类都是 Iterable ，所以现在对 display() 的调用显然更简单。 ListIteratorListIterator 是一个更强大的 Iterator 子类型，它只能由各种 List 类生成。 Iterator 只能向前移动，而 ==ListIterator 可以双向移动==。它还可以生成相对于迭代器在列表中指向的当前位置的后一个和前一个元素的索引，并且可以使用 set() 方法替换它访问过的最近一个元素。可以通过调用 listIterator() 方法来生成指向 List 开头处的 ListIterator ，还==可以通过调用 listIterator(n) 创建一个一开始就指向列表索引号为 n 的元素处的 ListIterator 。== 下面的示例演示了所有这些能力： 12345678910111213141516171819202122232425262728293031323334// collections/ListIteration.javaimport typeinfo.pets.*;import java.util.*;public class ListIteration &#123; public static void main(String[] args) &#123; List&lt;Pet&gt; pets = Pets.list(8); ListIterator&lt;Pet&gt; it = pets.listIterator(); while(it.hasNext()) System.out.print(it.next() + \", \" + it.nextIndex() + \", \" + it.previousIndex() + \"; \"); System.out.println(); // Backwards: while(it.hasPrevious()) System.out.print(it.previous().id() + \" \"); System.out.println(); System.out.println(pets); it = pets.listIterator(3); while(it.hasNext()) &#123; it.next(); it.set(Pets.get()); &#125; System.out.println(pets); &#125;&#125;/* Output:Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug,5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;7 6 5 4 3 2 1 0[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx][Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster,EgyptianMau]*/ Pets.get() 方法用来从位置 3 开始替换 List 中的所有 Pet 对象。 链表LinkedListLinkedList 也像 ArrayList 一样实现了基本的 List 接口，但它在 List 中间执行插入和删除操作时比 ArrayList 更高效。然而,它在随机访问操作效率方面却要逊色一些。 LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque） 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 Queue 中）。例如： getFirst() 和 element() 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 List 为空，则抛出 NoSuchElementException 异常。 peek() 方法与这两个方法只是稍有差异，它在列表为空时返回 null 。 removeFirst() 和 remove() 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 NoSuchElementException 异常。 poll() 稍有差异，它在列表为空时返回 null 。 addFirst() 在列表的开头插入一个元素。 offer() 与 add() 和 addLast() 相同。 它们都在列表的尾部（末尾）添加一个元素。 removeLast() 删除并返回列表的最后一个元素。 堆栈Stack堆栈是“后进先出”（LIFO）集合。它有时被称为叠加栈（pushdown stack），因为最后“压入”（push）栈的元素，第一个被“弹出”（pop）栈。 Java 1.0 中附带了一个 Stack 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 ArrayDeque ，其中包含直接实现堆栈功能的方法： 基于 Vector 实现的栈 Stack。底层实际上还是数组，所以还是存在需要扩容。Vector 是由数组实现的集合类，他包含了大量集合处理的方法。而 Stack 之所以继承 Vector，是为了复用 Vector 中的方法，来实现进栈（push）、出栈(pop)等操作。这里就是 Stack 设计不好的地方，既然只是为了实现栈，不用链表来单独实现，而是为了复用简单的方法而迫使它继承 Vector，Stack 和 Vector 本来是毫无关系的。这使得 Stack 在基于数组实现上效率受影响，另外因为继承 Vector 类，Stack 可以复用 Vector 大量方法，这使得 Stack 在设计上不严谨。 当数组默认的容量发生改变时，pop、push的性能会有较大降低；第二个：这个类是java.util.Vector的子类，由于是继承，stack就会将父类的方法继承过来如：add(int index,E element)等（具体见Vector的API说明）。这个破坏了stack约定的规则（只能从栈顶进，栈顶出）。所以SUN公司自己也给出的解释就是不要轻易用这个类。 12publicclass Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; 集合SetSet 不保存重复的元素。 Set 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 Set 中。因此，查找通常是 Set 最重要的操作，因此通常会选择 HashSet 实现，该实现针对快速查找进行了优化。 早期 Java 版本中的 HashSet 产生的输出没有可辨别的顺序。这是因为出于对速度的追求， HashSet 使用了散列，请参阅附录：集合主题一章。由 HashSet 维护的顺序与 TreeSet 或 LinkedHashSet 不同，因为它们的实现具有不同的元素存储方式。 TreeSet 将元素存储在红-黑树数据结构中，而 HashSet 使用散列函数。 LinkedHashSet 因为查询速度的原因也使用了散列，但是看起来使用了链表来维护元素的插入顺序。 因为它是 TreeSet ，所以对结果进行排序。这里，排序是按字典顺序（lexicographically）完成的，因此大写和小写字母位于不同的组中。如果想按字母顺序（alphabetically）对其进行排序，可以向 TreeSet 构造器传入 String.CASE_INSENSITIVE_ORDER 比较器（比较器是一个建立排序顺序的对象）： 映射Map将对象映射到其他对象的能力是解决编程问题的有效方法。 通过使用 containsKey() 和 containsValue() 方法去测试一个 Map ，以查看它是否包含某个键或某个值： Map 可以返回由其键组成的 Set ，由其值组成的 Collection ，或者其键值对的 Set 。 它在 for-in 语句中被用来遍历该 Map 。 队列Queue队列是一个典型的“先进先出”（FIFO）集合。 即从集合的一端放入事物，再从另一端去获取它们，事物放入集合的顺序和被取出的顺序是相同的。队列通常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在并发编程中尤为重要，因为它们可以安全地将对象从一个任务传输到另一个任务。 LinkedList 实现了 Queue 接口，并且提供了一些方法以支持队列行为，因此 LinkedList 可以用作 Queue 的一种实现。 offer() 是与 Queue 相关的方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 false 。 peek() 和 element() 都返回队头元素而不删除它，但是如果队列为空，则 element() 抛出 NoSuchElementException ，而 peek() 返回 null 。 poll() 和 remove()都删除并返回队头元素，但如果队列为空，poll() 返回 null ，而 remove() 抛出 NoSuchElementException 。 优先级队列PriorityQueue先进先出（FIFO）描述了最典型的队列规则（queuing discipline）。队列规则是指在给定队列中的一组元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个弹出的元素应该是等待时间最长的元素。 优先级队列声明下一个弹出的元素是最需要的元素（具有最高的优先级）。 当在 PriorityQueue 上调用 offer() 方法来插入一个对象时，该对象会在队列中被排序。[^5]默认的排序使用队列中对象的自然顺序（natural order），但是可以通过提供自己的 Comparator 来修改这个顺序。 PriorityQueue 确保在调用 peek() ， poll() 或 remove() 方法时，获得的元素将是队列中优先级最高的元素。 PriorityQueue 是允许重复的，最小的值具有最高的优先级（如果是 String ，空格也可以算作值，并且比字母的优先级高）。 由 Collections.reverseOrder() （Java 5 中新添加的）产生的反序的 Comparator 。 12priorityQueue = new PriorityQueue&lt;&gt;( ints.size(), Collections.reverseOrder()); Integer ， String 和 Character 可以与 PriorityQueue 一起使用，因为这些类已经内置了自然排序。如果想在 PriorityQueue 中使用自己的类，则必须包含额外的功能以产生自然排序，或者必须提供自己的 Comparator 。在附录：集合主题中有一个更复杂的示例来演示这种情况。 [^5]: 这实际上依赖于具体实现。优先级队列算法通常会按插入顺序排序（维护一个堆），但它们也可以在删除时选择最重要的元素。 如果对象的优先级在它在队列中等待时可以修改，那么算法的选择就显得很重要了。 集合与迭代器Collection 是所有序列集合共有的根接口。它可能会被认为是一种“附属接口”（incidental interface），即因为要表示其他若干个接口的共性而出现的接口。此外，java.util.AbstractCollection 类提供了 Collection 的默认实现，使得你可以创建 AbstractCollection 的子类型，而其中没有不必要的代码重复。 使用接口描述的一个理由是它可以使我们创建更通用的代码。通过针对接口而非具体实现来编写代码，我们的代码可以应用于更多类型的对象。[^6] [^6]: 有些人提倡这样一种自动创建机制，即对一个类中所有可能的方法组合都自动创建一个接口，有时候对于单个的类都是如此。 我相信接口的意义不应该仅限于方法组合的机械地复制，因此我在创建接口之前，总是要先看到增加接口带来的价值。 Collection 要更方便一点，因为它是 Iterable 类型，因此在 display(Collection) 的实现中可以使用 for-in 构造，这使得代码更加清晰。 12345678public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; 虽然这可以通过继承 AbstractCollection 而很容易地实现，但是无论如何还是要被强制去实现 iterator() 和 size() 方法，这些方法 AbstractCollection 没有实现，但是 AbstractCollection 中的其它方法会用到： remove() 方法是一个“可选操作”，在附录：集合主题中详细介绍。 这里可以不必实现它，如果你调用它，它将抛出异常。 for-in和迭代器到目前为止，for-in 语法主要用于数组，但它也适用于任何 Collection 对象。 Java 5 引入了一个名为 Iterable 的接口，该接口包含一个能够生成 Iterator 的 iterator() 方法。for-in 使用此 Iterable 接口来遍历序列。因此，如果创建了任何实现了 Iterable 的类，都可以将它用于 for-in 语句中. 在 Java 5 中，许多类都是 Iterable ，主要包括所有的 Collection 类（但不包括各种 Maps ）。 例如，下面的代码可以显示所有的操作系统环境变量： 123456789101112// collections/EnvironmentVariables.java// &#123;VisuallyInspectOutput&#125;import java.util.*;public class EnvironmentVariables &#123; public static void main(String[] args) &#123; for(Map.Entry entry: System.getenv().entrySet()) &#123; System.out.println(entry.getKey() + \": \" + entry.getValue()); &#125; &#125;&#125; System.getenv() [^7]返回一个 Map ， entrySet() 产生一个由 Map.Entry 的元素构成的 Set ，并且这个 Set 是一个 Iterable ，因此它可以用于 for-in 循环。 for-in 语句适用于数组或其它任何 Iterable ，但这并不意味着数组肯定也是个 Iterable ，也不会发生任何自动装箱： 1234567891011121314151617181920// collections/ArrayIsNotIterable.javaimport java.util.*;public class ArrayIsNotIterable &#123; static &lt;T&gt; void test(Iterable&lt;T&gt; ib) &#123; for(T t : ib) System.out.print(t + \" \"); &#125; public static void main(String[] args) &#123; test(Arrays.asList(1, 2, 3)); String[] strings = &#123; \"A\", \"B\", \"C\" &#125;; // An array works in for-in, but it's not Iterable: //- test(strings); // You must explicitly convert it to an Iterable: test(Arrays.asList(strings)); &#125;&#125;/* Output:1 2 3 A B C*/ 尝试将数组作为一个 Iterable 参数传递会导致失败。这说明不存在任何从数组到 Iterable 的自动转换; 必须手工执行这种转换。 适配器方法惯用法如果现在有一个 Iterable 类，你想要添加一种或多种在 for-in 语句中使用这个类的方法，应该怎么做呢？例如，你希望可以选择正向还是反向遍历一个单词列表。如果直接继承这个类，并覆盖 iterator() 方法，则只能替换现有的方法，而不能实现遍历顺序的选择。 一种解决方案是所谓适配器方法*（Adapter Method）的惯用法。“适配器”部分来自于设计模式，因为必须要提供特定的接口来满足 *for-in 语句。如果已经有一个接口并且需要另一个接口时，则编写适配器就可以解决这个问题。在这里，若希望在默认的正向迭代器的基础上，添加产生反向迭代器的能力，因此不能使用覆盖，相反，而是添加了一个能够生成 Iterable 对象的方法，该对象可以用于 for-in 语句。这使得我们可以提供多种使用 for-in 语句的方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// collections/AdapterMethodIdiom.java// The \"Adapter Method\" idiom uses for-in// with additional kinds of Iterablesimport java.util.*;class ReversibleArrayList&lt;T&gt; extends ArrayList&lt;T&gt; &#123; ReversibleArrayList(Collection&lt;T&gt; c) &#123; super(c); &#125; public Iterable&lt;T&gt; reversed() &#123; return new Iterable&lt;T&gt;() &#123; public Iterator&lt;T&gt; iterator() &#123; return new Iterator&lt;T&gt;() &#123; int current = size() - 1; public boolean hasNext() &#123; return current &gt; -1; &#125; public T next() &#123; return get(current--); &#125; public void remove() &#123; // Not implemented throw new UnsupportedOperationException(); &#125; &#125;; &#125; &#125;; &#125;&#125;public class AdapterMethodIdiom &#123; public static void main(String[] args) &#123; ReversibleArrayList&lt;String&gt; ral = new ReversibleArrayList&lt;String&gt;( Arrays.asList(\"To be or not to be\".split(\" \"))); // Grabs the ordinary iterator via iterator(): for(String s : ral) System.out.print(s + \" \"); System.out.println(); // Hand it the Iterable of your choice for(String s : ral.reversed()) System.out.print(s + \" \"); &#125;&#125;/* Output:To be or not to bebe to not or be To*/ 重要的是要注意 Arrays.asList() 生成一个 List 对象，该对象使用底层数组作为其物理实现。如果执行的操作会修改这个 List ，并且不希望修改原始数组，那么就应该在另一个集合中创建一个副本。 本章小结Java 提供了许多保存对象的方法： 数组将数字索引与对象相关联。它保存类型明确的对象，因此在查找对象时不必对结果做类型转换。它可以是多维的，可以保存基本类型的数据。虽然可以在运行时创建数组，但是一旦创建数组，就无法更改数组的大小。 Collection 保存单一的元素，而 Map 包含相关联的键值对。使用 Java 泛型，可以指定集合中保存的对象的类型，因此不能将错误类型的对象放入集合中，并且在从集合中获取元素时，不必进行类型转换。各种 Collection 和各种 Map 都可以在你向其中添加更多的元素时，自动调整其尺寸大小。集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。 像数组一样， List 也将数字索引与对象相关联，因此，数组和 List 都是有序集合。 如果要执行大量的随机访问，则使用 ArrayList ，如果要经常从表中间插入或删除元素，则应该使用 LinkedList 。 队列和堆栈的行为是通过 LinkedList 提供的。 Map 是一种将对象（而非数字）与对象相关联的设计。 HashMap 专为快速访问而设计，而 TreeMap 保持键始终处于排序状态，所以没有 HashMap 快。 LinkedHashMap 按插入顺序保存其元素，但使用散列提供快速访问的能力。 Set 不接受重复元素。 HashSet 提供最快的查询速度，而 TreeSet 保持元素处于排序状态。 LinkedHashSet 按插入顺序保存其元素，但使用散列提供快速访问的能力。 ==不要在新代码中使用遗留类 Vector ，Hashtable 和 Stack 。== 浏览一下Java集合的简图（不包含抽象类或遗留组件）会很有帮助。这里仅包括在一般情况下会碰到的接口和类。（译者注：下图为原著PDF中的截图，可能由于未知原因存在问题。这里可参考译者绘制版[^8]） [^8]: 下面是译者绘制的 Java 集合框架简图，黄色为接口，绿色为抽象类，蓝色为具体类。虚线箭头表示实现关系，实线箭头表示继承关系。 简单集合分类可以看到，实际上只有四个基本的集合组件： Map ， List ， Set 和 Queue ，它们各有两到三个实现版本（Queue 的 java.util.concurrent 实现未包含在此图中）。最常使用的集合用黑色粗线线框表示。 虚线框表示接口，实线框表示普通的（具体的）类。带有空心箭头的虚线表示特定的类实现了一个接口。实心箭头表示某个类可以生成箭头指向的类的对象。例如，任何 Collection 都可以生成 Iterator ， List 可以生成 ListIterator （也能生成普通的 Iterator ，因为 List 继承自 Collection ）。 下面的示例展示了各种不同的类在方法上的差异。实际代码来自泛型章节，在这里只是调用它来产生输出。程序的输出还展示了在每个类或接口中所实现的接口： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// collections/CollectionDifferences.javaimport onjava.*;public class CollectionDifferences &#123; public static void main(String[] args) &#123; CollectionMethodDifferences.main(args); &#125;&#125;/* Output:Collection: [add, addAll, clear, contains, containsAll,equals, forEach, hashCode, isEmpty, iterator,parallelStream, remove, removeAll, removeIf, retainAll,size, spliterator, stream, toArray]Interfaces in Collection: [Iterable]Set extends Collection, adds: []Interfaces in Set: [Collection]HashSet extends Set, adds: []Interfaces in HashSet: [Set, Cloneable, Serializable]LinkedHashSet extends HashSet, adds: []Interfaces in LinkedHashSet: [Set, Cloneable,Serializable]TreeSet extends Set, adds: [headSet,descendingIterator, descendingSet, pollLast, subSet,floor, tailSet, ceiling, last, lower, comparator,pollFirst, first, higher]Interfaces in TreeSet: [NavigableSet, Cloneable,Serializable]List extends Collection, adds: [replaceAll, get,indexOf, subList, set, sort, lastIndexOf, listIterator]Interfaces in List: [Collection]ArrayList extends List, adds: [trimToSize,ensureCapacity]Interfaces in ArrayList: [List, RandomAccess,Cloneable, Serializable]LinkedList extends List, adds: [offerFirst, poll,getLast, offer, getFirst, removeFirst, element,removeLastOccurrence, peekFirst, peekLast, push,pollFirst, removeFirstOccurrence, descendingIterator,pollLast, removeLast, pop, addLast, peek, offerLast,addFirst]Interfaces in LinkedList: [List, Deque, Cloneable,Serializable]Queue extends Collection, adds: [poll, peek, offer,element]Interfaces in Queue: [Collection]PriorityQueue extends Queue, adds: [comparator]Interfaces in PriorityQueue: [Serializable]Map: [clear, compute, computeIfAbsent,computeIfPresent, containsKey, containsValue, entrySet,equals, forEach, get, getOrDefault, hashCode, isEmpty,keySet, merge, put, putAll, putIfAbsent, remove,replace, replaceAll, size, values]HashMap extends Map, adds: []Interfaces in HashMap: [Map, Cloneable, Serializable]LinkedHashMap extends HashMap, adds: []Interfaces in LinkedHashMap: [Map]SortedMap extends Map, adds: [lastKey, subMap,comparator, firstKey, headMap, tailMap]Interfaces in SortedMap: [Map]TreeMap extends Map, adds: [descendingKeySet,navigableKeySet, higherEntry, higherKey, floorKey,subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,headMap, tailMap, lowerEntry, ceilingEntry,descendingMap, pollFirstEntry, lastKey, firstEntry,floorEntry, comparator, lastEntry]Interfaces in TreeMap: [NavigableMap, Cloneable,Serializable]*/ 除 TreeSet 之外的所有 Set 都具有与 Collection 完全相同的接口。List 和 Collection 存在着明显的不同，尽管 List 所要求的方法都在 Collection 中。另一方面，在 Queue 接口中的方法是独立的，在创建具有 Queue 功能的实现时，不需要使用 Collection 方法。最后， Map 和 Collection 之间唯一的交集是 Map 可以使用 entrySet() 和 values() 方法来产生 Collection 。 请注意，标记接口 java.util.RandomAccess 附加到了 ArrayList 上，但不附加到 LinkedList 上。这为根据特定 List 动态改变其行为的算法提供了信息。 从面向对象的继承层次结构来看，这种组织结构确实有些奇怪。但是，当了解了 java.util 中更多的有关集合的内容后（特别是在附录：集合主题中的内容），就会发现出了继承结构有点奇怪外，还有更多的问题。集合类库一直以来都是设计难题——解决这些问题涉及到要去满足经常彼此之间互为牵制的各方面需求。所以要做好准备，在各处做出妥协。 尽管存在这些问题，但 Java 集合仍是在日常工作中使用的基本工具，它可以使程序更简洁、更强大、更有效。你可能需要一段时间才能熟悉集合类库的某些方面，但我想你很快就会找到自己的路子，来获得和使用这个类库中的类。 8 下面是译者绘制的 Java 集合框架简图，黄色为接口，绿色为抽象类，蓝色为具体类。虚线箭头表示实现关系，实线箭头表示继承关系。 第十三章 函数式编程 函数式编程语言操纵代码片段就像操作数据一样容易。 虽然 Java 不是函数式语言，但 Java 8 Lambda 表达式和方法引用 (Method References) 允许你以函数式编程。 函数式编程（FP）的意义所在。通过合并现有代码来生成新功能而不是从头开始编写所有内容，我们可以更快地获得更可靠的代码。至少在某些情况下，这套理论似乎很有用。在这一过程中，一些非函数式语言已经习惯了使用函数式编程产生的优雅的语法。 你也可以这样想： OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。 纯粹的函数式语言在安全性方面更进一步。它强加了额外的约束，即所有数据必须是不可变的：设置一次，永不改变。将值传递给函数，该函数然后生成新值但从不修改自身外部的任何东西（包括其参数或该函数范围之外的元素）。当强制执行此操作时，你知道任何错误都不是由所谓的副作用引起的，因为该函数仅创建并返回结果，而不是其他任何错误。 更好的是，“不可变对象和无副作用”范式解决了并发编程中最基本和最棘手的问题之一（当程序的某些部分同时在多个处理器上运行时）。这是可变共享状态的问题，这意味着代码的不同部分（在不同的处理器上运行）可以尝试同时修改同一块内存（谁赢了？没人知道）。如果函数永远不会修改现有值但只生成新值，则不会对内存产生争用，这是纯函数式语言的定义。 因此，经常提出纯函数式语言作为并行编程的解决方案（还有其他可行的解决方案）。 需要提醒大家的是，函数式语言背后有很多动机，这意味着描述它们可能会有些混淆。它通常取决于各种观点：为“并行编程”，“代码可靠性”和“代码创建和库复用”。 FP 思想值得融入非 FP 语言，如 Python。Java 8 也从中吸收并支持了 FP。 Java 8 的 Lambda 表达式。由箭头 -&gt; 分隔开参数和函数体，箭头左边是参数，箭头右侧是从 Lambda 返回的表达式，即函数体。 Java 8 的方法引用，由 :: 区分。在 :: 的左边是类或对象的名称，在 :: 的右边是方法的名称，但没有参数列表。 方法引用和 Lambda 表达式的出现让我们可以在需要时传递功能，而不是仅在必要才这么做。 Lambda表达式Lambda 表达式是使用最小可能语法编写的函数定义： Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。 Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。 我们在 Strategize.java 中看到了一个 Lambda 表达式，但还有其他语法变体： 12345678910111213141516171819202122232425262728293031323334353637// functional/LambdaExpressions.javainterface Description &#123; String brief();&#125;interface Body &#123; String detailed(String head);&#125;interface Multi &#123; String twoArg(String head, Double d);&#125;public class LambdaExpressions &#123; static Body bod = h -&gt; h + \" No Parens!\"; // [1] static Body bod2 = (h) -&gt; h + \" More details\"; // [2] static Description desc = () -&gt; \"Short info\"; // [3] static Multi mult = (h, n) -&gt; h + n; // [4] static Description moreLines = () -&gt; &#123; // [5] System.out.println(\"moreLines()\"); return \"from moreLines()\"; &#125;; public static void main(String[] args) &#123; System.out.println(bod.detailed(\"Oh!\")); System.out.println(bod2.detailed(\"Hi!\")); System.out.println(desc.brief()); System.out.println(mult.twoArg(\"Pi! \", 3.14159)); System.out.println(moreLines.brief()); &#125;&#125; 输出结果： 123456Oh! No Parens!Hi! More detailsShort infoPi! 3.14159moreLines()from moreLines() 我们从三个接口开始，每个接口都有一个单独的方法（很快就会理解它的重要性）。但是，每个方法都有不同数量的参数，以便演示 Lambda 表达式语法。 任何 Lambda 表达式的基本语法是： 参数。 接着 -&gt;，可视为“产出”。 -&gt; 之后的内容都是方法体。 [1] 当只用一个参数，可以不需要括号 ()。 然而，这是一个特例。 [2] 正常情况使用括号 () 包裹参数。 为了保持一致性，也可以使用括号 () 包裹单个参数，虽然这种情况并不常见。 [3] 如果没有参数，则必须使用括号 () 表示空参数列表。 [4] 对于多个参数，将参数列表放在括号 () 中。 到目前为止，所有 Lambda 表达式方法体都是单行。 该表达式的结果自动成为 Lambda 表达式的返回值，在此处使用 return 关键字是非法的。 这是 Lambda 表达式缩写用于描述功能的语法的另一种方式。 [5] 如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 return。 Lambda 表达式通常比匿名内部类产生更易读的代码，因此我们将在本书中尽可能使用它们。 use-me==Lambda表达式常与单一方法接口(函数式接口)使用==,即常用来产生匿名内部类（因为java中一切皆是对象，没有JavaScript中的function），但是必须要声明类型。 接口 123interface Body &#123; String detailed(String head);&#125; 123456public class LambdaExpressions &#123; public static void main(String[] args) &#123; Body bod = h -&gt; h + \" No Parens!\"; // [1] &#125;&#125; Lambda传送匿名类参数使用==强制类型转换==表明Lambda产生的类型。 123456789public class LambdaExpressions &#123; public static void useBody(Body body)&#123; &#125; public static void main(String[] args) &#123; useBody( (Body)str -&gt;&#123; return str &#125;) &#125;&#125; 递归递归函数是一个自我调用的函数。可以编写递归的 Lambda 表达式，但需要注意：递归方法必须是实例变量或静态变量，否则会出现编译时错误。 我们将为每个案例创建一个示例。 这两个示例都需要一个接受 int 型参数并生成 int 的接口： 12345// functional/IntCall.javainterface IntCall &#123; int call(int arg);&#125; 整数 n 的阶乘将所有小于或等于 n 的正整数相乘。 阶乘函数是一个常见的递归示例： 12345678910// functional/RecursiveFactorial.javapublic class RecursiveFactorial &#123; static IntCall fact; public static void main(String[] args) &#123; fact = n -&gt; n == 0 ? 1 : n * fact.call(n - 1); for(int i = 0; i &lt;= 10; i++) System.out.println(fact.call(i)); &#125;&#125; 输出结果： 12345678910111126241207205040403203628803628800 这里，fact 是一个静态变量。 注意使用三元 if-else。 递归函数将一直调用自己，直到 i == 0。所有递归函数都有“停止条件”，否则将无限递归并产生异常。 我们可以将 Fibonacci 序列改为使用递归 Lambda 表达式来实现，这次使用实例变量： 12345678910111213141516171819// functional/RecursiveFibonacci.javapublic class RecursiveFibonacci &#123; IntCall fib; RecursiveFibonacci() &#123; fib = n -&gt; n == 0 ? 0 : n == 1 ? 1 : fib.call(n - 1) + fib.call(n - 2); &#125; int fibonacci(int n) &#123; return fib.call(n); &#125; public static void main(String[] args) &#123; RecursiveFibonacci rf = new RecursiveFibonacci(); for(int i = 0; i &lt;= 10; i++) System.out.println(rf.fibonacci(i)); &#125;&#125; 输出结果： 1234567891011011235813213455 将 Fibonacci 序列中的最后两个元素求和来产生下一个元素。 方法引用Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 :: [^4]，然后跟方法名称。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// functional/MethodReferences.javaimport java.util.*;interface Callable &#123; // [1] void call(String s);&#125;class Describe &#123; void show(String msg) &#123; // [2] System.out.println(msg); &#125;&#125;public class MethodReferences &#123; static void hello(String name) &#123; // [3] System.out.println(\"Hello, \" + name); &#125; static class Description &#123; String about; Description(String desc) &#123; about = desc; &#125; void help(String msg) &#123; // [4] System.out.println(about + \" \" + msg); &#125; &#125; static class Helper &#123; static void assist(String msg) &#123; // [5] System.out.println(msg); &#125; &#125; public static void main(String[] args) &#123; Describe d = new Describe(); Callable c = d::show; // [6] c.call(\"call()\"); // [7] c = MethodReferences::hello; // [8] c.call(\"Bob\"); c = new Description(\"valuable\")::help; // [9] c.call(\"information\"); c = Helper::assist; // [10] c.call(\"Help!\"); &#125;&#125; 输出结果： 1234call()Hello, Bobvaluable informationHelp! [1] 我们从单一方法接口开始（同样，你很快就会了解到这一点的重要性）。 [2] show() 的签名（参数类型和返回类型）符合 Callable 的 call() 的签名。 [3] hello() 也符合 call() 的签名。 [4] help() 也符合，它是静态内部类中的非静态方法。 [5] assist() 是静态内部类中的静态方法。 [6] 我们将 Describe 对象的方法引用赋值给 Callable ，它没有 show() 方法，而是 call() 方法。 但是，Java 似乎接受用这个看似奇怪的赋值，因为方法引用符合 Callable 的 call() 方法的签名。 [7] 我们现在可以通过调用 call() 来调用 show()，因为 Java 将 call() 映射到 show()。 [8] 这是一个静态方法引用。 [9] 这是 [6] 的另一个版本：对已实例化对象的方法的引用，有时称为绑定方法引用。 [10] 最后，获取静态内部类的方法引用的操作与 [8] 中外部类方式一样。 上例只是简短的介绍，我们很快就能看到方法引用的全部变化。 Runnable接口Runnable 接口自 1.0 版以来一直在 Java 中，因此不需要导入。它也符合特殊的单方法接口格式：它的方法 run() 不带参数，也没有返回值。因此，我们可以使用 Lambda 表达式和方法引用作为 Runnable： 1234567891011121314151617181920212223242526// functional/RunnableMethodReference.java// 方法引用与 Runnable 接口的结合使用class Go &#123; static void go() &#123; System.out.println(\"Go::go()\"); &#125;&#125;public class RunnableMethodReference &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(\"Anonymous\"); &#125; &#125;).start(); new Thread( () -&gt; System.out.println(\"lambda\") ).start(); new Thread(Go::go).start(); &#125;&#125; 输出结果： 123AnonymouslambdaGo::go() Thread 对象将 Runnable 作为其构造函数参数，并具有会调用 run() 的方法 start()。 注意，只有匿名内部类才需要具有名为 run() 的方法。 未绑定的方法引用未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用之前，我们必须先提供对象： 12345678910111213141516171819202122232425// functional/UnboundMethodReference.java// 没有方法引用的对象class X &#123; String f() &#123; return \"X::f()\"; &#125;&#125;interface MakeString &#123; String make();&#125;interface TransformX &#123; String transform(X x);&#125;public class UnboundMethodReference &#123; public static void main(String[] args) &#123; // MakeString ms = X::f; // [1] TransformX sp = X::f; X x = new X(); System.out.println(sp.transform(x)); // [2] System.out.println(x.f()); // 同等效果 &#125;&#125; 输出结果： 12X::f()X::f() 截止目前，我们已经知道了与接口方法同名的方法引用。 在 [1]，我们尝试把 X 的 f() 方法引用赋值给 MakeString。结果：即使 make() 与 f() 具有相同的签名，编译也会报“invalid method reference”（无效方法引用）错误。 这是因为实际上还有另一个隐藏的参数：我们的老朋友 this。 你不能在没有 X 对象的前提下调用 f()。 因此，X :: f 表示未绑定的方法引用，因为它尚未“绑定”到对象。 要解决这个问题，我们需要一个 X 对象，所以我们的接口实际上需要一个额外的参数的接口，如上例中的 TransformX。 如果将 X :: f 赋值给 TransformX，这在 Java 中是允许的。这次我们需要调整下心里预期——使用未绑定的引用时，函数方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配。 理由是：你需要一个对象来调用方法。 [2] 的结果有点像脑筋急转弯。 我接受未绑定的引用并对其调用 transform()，将其传递给 X，并以某种方式导致对 x.f() 的调用。 Java 知道它必须采用第一个参数，这实际上就是 this，并在其上调用方法。 12345678910111213141516171819202122232425262728293031323334// functional/MultiUnbound.java// 未绑定的方法与多参数的结合运用class This &#123; void two(int i, double d) &#123;&#125; void three(int i, double d, String s) &#123;&#125; void four(int i, double d, String s, char c) &#123;&#125;&#125;interface TwoArgs &#123; void call2(This athis, int i, double d);&#125;interface ThreeArgs &#123; void call3(This athis, int i, double d, String s);&#125;interface FourArgs &#123; void call4( This athis, int i, double d, String s, char c);&#125;public class MultiUnbound &#123; public static void main(String[] args) &#123; TwoArgs twoargs = This::two; ThreeArgs threeargs = This::three; FourArgs fourargs = This::four; This athis = new This(); twoargs.call2(athis, 11, 3.14); threeargs.call3(athis, 11, 3.14, \"Three\"); fourargs.call4(athis, 11, 3.14, \"Four\", 'Z'); &#125;&#125; 为了说明这一点，我将类命名为 This ，函数方法的第一个参数则是 athis，但是你应该选择其他名称以防止生产代码混淆。 构造函数引用你还可以捕获构造函数的引用，然后通过引用调用该构造函数。 123456789101112131415161718192021222324252627282930313233// functional/CtorReference.javaclass Dog &#123; String name; int age = -1; // For \"unknown\" Dog() &#123; name = \"stray\"; &#125; Dog(String nm) &#123; name = nm; &#125; Dog(String nm, int yrs) &#123; name = nm; age = yrs; &#125;&#125;interface MakeNoArgs &#123; Dog make();&#125;interface Make1Arg &#123; Dog make(String nm);&#125;interface Make2Args &#123; Dog make(String nm, int age);&#125;public class CtorReference &#123; public static void main(String[] args) &#123; MakeNoArgs mna = Dog::new; // [1] Make1Arg m1a = Dog::new; // [2] Make2Args m2a = Dog::new; // [3] Dog dn = mna.make(); Dog d1 = m1a.make(\"Comet\"); Dog d2 = m2a.make(\"Ralph\", 4); &#125;&#125; Dog 有三个构造函数，函数接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。 注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这 3 个构造函数只有一个相同名称：:: new，但在每种情况下都赋值给不同的接口。编译器可以检测并知道从哪个构造函数引用。 编译器能识别并调用你的构造函数（ 在本例中为 make()）。 函数式接口方法引用和 Lambda 表达式必须被赋值，同时编译器需要识别类型信息以确保类型正确。 Lambda 表达式特别引入了新的要求。 代码示例： 1x -&gt; x.toString() 我们清楚这里返回类型必须是 String，但 x 是什么类型呢？ Lambda 表达式包含类型推导（编译器会自动推导出类型信息，避免了程序员显式地声明）。编译器必须能够以某种方式推导出 x 的类型。 下面是第 2 个代码示例： 1(x, y) -&gt; x + y 现在 x 和 y 可以是任何支持 + 运算符连接的数据类型，可以是两个不同的数值类型或者是 1 个 String 加任意一种可自动转换为 String 的数据类型（这包括了大多数类型）。 但是，当 Lambda 表达式被赋值时，编译器必须确定 x 和 y 的确切类型以生成正确的代码。 该问题也适用于方法引用。 假设你要传递 System.out :: println 到你正在编写的方法 ，你怎么知道传递给方法的参数的类型？ 为了解决这个问题，Java 8 引入了 java.util.function 包。它包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为函数式方法。 在编写接口时，可以使用 @FunctionalInterface 注解强制执行此“函数式方法”模式： 12345678910111213141516171819202122232425262728293031323334353637// functional/FunctionalAnnotation.java@FunctionalInterfaceinterface Functional &#123; String goodbye(String arg);&#125;interface FunctionalNoAnn &#123; String goodbye(String arg);&#125;/*@FunctionalInterfaceinterface NotFunctional &#123; String goodbye(String arg); String hello(String arg);&#125;产生错误信息:NotFunctional is not a functional interfacemultiple non-overriding abstract methodsfound in interface NotFunctional*/public class FunctionalAnnotation &#123; public String goodbye(String arg) &#123; return \"Goodbye, \" + arg; &#125; public static void main(String[] args) &#123; FunctionalAnnotation fa = new FunctionalAnnotation(); Functional f = fa::goodbye; FunctionalNoAnn fna = fa::goodbye; // Functional fac = fa; // Incompatible Functional fl = a -&gt; \"Goodbye, \" + a; FunctionalNoAnn fnal = a -&gt; \"Goodbye, \" + a; &#125;&#125; @FunctionalInterface 注解是可选的; Java 在 main() 中把 Functional 和 FunctionalNoAnn 都当作函数式接口。 @FunctionalInterface 的值在 NotFunctional 的定义中可见：接口中如果有多个方法则会产生编译时错误消息。 仔细观察在定义 f 和 fna 时发生了什么。 Functional 和 FunctionalNoAnn 定义接口，然而被赋值的只是方法 goodbye()。首先，这只是一个方法而不是类；其次，它甚至都不是实现了该接口的类中的方法。Java 8 在这里添加了一点小魔法：如果将方法引用或 Lambda 表达式赋值给函数式接口（类型需要匹配），Java 会适配你的赋值到目标接口。 编译器会自动包装方法引用或 Lambda 表达式到实现目标接口的类的实例中。 Java 8 允许我们以简便的语法为接口赋值函数。 java.util.function 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。这主要是因为基本类型会产生一小部分接口。 如果你了解命名模式，顾名思义就能知道特定接口的作用。 以下是基本命名准则： 如果只处理对象而非基本类型，名称则为 Function，Consumer，Predicate 等。参数类型通过泛型添加。 如果接收的参数是基本类型，则由名称的第一部分表示，如 LongConsumer，DoubleFunction，IntPredicate 等，但基本 Supplier 类型例外。 如果返回值为基本类型，则用 To 表示，如 ToLongFunction &lt;T&gt; 和 IntToLongFunction。 如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 UnaryOperator，两个参数使用 BinaryOperator。 如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。 如果接收的两个参数类型不同，则名称中有一个 Bi。 下表描述了 java.util.function 中的目标类型（包括例外情况）： 特征 函数式方法名 示例 无参数； 无返回值 Runnable (java.lang) run() Runnable 无参数； 返回类型任意 Supplier get() getAs类型() Supplier&lt;T&gt; BooleanSupplier IntSupplier LongSupplier DoubleSupplier 无参数； 返回类型任意 Callable (java.util.concurrent) call() Callable&lt;V&gt; 1 参数； 无返回值 Consumer accept() Consumer&lt;T&gt; IntConsumer LongConsumer DoubleConsumer 2 参数 Consumer BiConsumer accept() BiConsumer&lt;T,U&gt; 2 参数 Consumer； 1 引用； 1 基本类型 Obj类型Consumer accept() ObjIntConsumer&lt;T&gt; ObjLongConsumer&lt;T&gt; ObjDoubleConsumer&lt;T&gt; 1 参数； 返回类型不同 Function apply() To类型 和 类型To类型 applyAs类型() Function&lt;T,R&gt; IntFunction&lt;R&gt; LongFunction&lt;R&gt; DoubleFunction&lt;R&gt; ToIntFunction&lt;T&gt; ToLongFunction&lt;T&gt; ToDoubleFunction&lt;T&gt; IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 1 参数； 返回类型相同 UnaryOperator apply() UnaryOperator&lt;T&gt; IntUnaryOperator LongUnaryOperator DoubleUnaryOperator 2 参数类型相同； 返回类型相同 BinaryOperator apply() BinaryOperator&lt;T&gt; IntBinaryOperator LongBinaryOperator DoubleBinaryOperator 2 参数类型相同; 返回整型 Comparator (java.util) compare() Comparator&lt;T&gt; 2 参数； 返回布尔型 Predicate test() Predicate&lt;T&gt; BiPredicate&lt;T,U&gt; IntPredicate LongPredicate DoublePredicate 参数基本类型； 返回基本类型 类型To类型Function applyAs类型() IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 2 参数类型不同 Bi操作 (不同方法名) BiFunction&lt;T,U,R&gt; BiConsumer&lt;T,U&gt; BiPredicate&lt;T,U&gt; ToIntBiFunction&lt;T,U&gt; ToLongBiFunction&lt;T,U&gt; ToDoubleBiFunction&lt;T&gt; 此表仅提供些常规方案。通过上表，你应该或多或少能自行推导出更多行的函数式接口。 可以看出，在创建 java.util.function 时，设计者们做出了一些选择。 例如，为什么没有 IntComparator，LongComparator 和 DoubleComparator 呢？有 BooleanSupplier 却没有其他表示 Boolean 的接口；有通用的 BiConsumer 却没有用于 int，long 和 double 的 BiConsumers 变体（我对他们放弃的原因表示同情）。这些选择是疏忽还是有人认为其他组合的使用情况出现得很少（他们是如何得出这个结论的）？ 多参数函数式接口java.util.functional 中的接口是有限的。比如有了 BiFunction，但它不能变化。 如果需要三参数函数的接口怎么办？ 其实这些接口非常简单，很容易查看 Java 库源代码并自行创建。代码示例： 123456// functional/TriFunction.java@FunctionalInterfacepublic interface TriFunction&lt;T, U, V, R&gt; &#123; R apply(T t, U u, V v);&#125; 高阶函数这个名字可能听起来令人生畏，但是：高阶函数（Higher-order Function）只是一个消费或产生函数的函数。 我们先来看看如何产生一个函数： 12345678910111213141516// functional/ProduceFunction.javaimport java.util.function.*;interfaceFuncSS extends Function&lt;String, String&gt; &#123;&#125; // [1]public class ProduceFunction &#123; static FuncSS produce() &#123; return s -&gt; s.toLowerCase(); // [2] &#125; public static void main(String[] args) &#123; FuncSS f = produce(); System.out.println(f.apply(\"YELLING\")); &#125;&#125; 输出结果： 1yelling 这里，produce() 是高阶函数。 [1] 使用继承，可以轻松地为专用接口创建别名。 [2] 使用 Lambda 表达式，可以轻松地在方法中创建和返回一个函数。 要消费一个函数，消费函数需要在参数列表正确地描述函数类型。代码示例： 123456789101112131415// functional/ConsumeFunction.javaimport java.util.function.*;class One &#123;&#125;class Two &#123;&#125;public class ConsumeFunction &#123; static Two consume(Function&lt;One,Two&gt; onetwo) &#123; return onetwo.apply(new One()); &#125; public static void main(String[] args) &#123; Two two = consume(one -&gt; new Two()); &#125;&#125; 当基于消费函数生成新函数时，事情就变得相当有趣了。代码示例如下： 1234567891011121314151617181920212223242526272829// functional/TransformFunction.javaimport java.util.function.*;class I &#123; @Override public String toString() &#123; return \"I\"; &#125;&#125;class O &#123; @Override public String toString() &#123; return \"O\"; &#125;&#125;public class TransformFunction &#123; static Function&lt;I,O&gt; transform(Function&lt;I,O&gt; in) &#123; return in.andThen(o -&gt; &#123; System.out.println(o); return o; &#125;); &#125; public static void main(String[] args) &#123; Function&lt;I,O&gt; f2 = transform(i -&gt; &#123; System.out.println(i); return new O(); &#125;); O o = f2.apply(new I()); &#125;&#125; 输出结果： 12IO 在这里，transform() 生成一个与传入的函数具有相同签名的函数，但是你可以生成任何你想要的类型。 这里使用到了 Function 接口中名为 andThen() 的默认方法，该方法专门用于操作函数。 顾名思义，在调用 in 函数之后调用 toThen()（还有个 compose() 方法，它在 in 函数之前应用新函数）。 要附加一个 andThen() 函数，我们只需将该函数作为参数传递。 transform() 产生的是一个新函数，它将 in 的动作与 andThen() 参数的动作结合起来。 闭包闭包（Closure）一词总结了这些问题。 它非常重要，利用闭包可以轻松生成函数。 考虑一个更复杂的 Lambda，它使用函数作用域之外的变量。 返回该函数会发生什么？ 也就是说，当你调用函数时，它对那些 “外部 ”变量引用了什么? 如果语言不能自动解决这个问题，那将变得非常具有挑战性。 能够解决这个问题的语言被称为支持闭包，或者叫作在词法上限定范围( 也使用术语变量捕获 )。Java 8 提供了有限但合理的闭包支持，我们将用一些简单的例子来研究它。 从 Lambda 表达式引用的局部变量必须是 final 或者是等同 final 效果的。 首先，下例函数中，方法返回访问对象字段和方法参数。代码示例： 12345678910// functional/Closure1.javaimport java.util.function.*;public class Closure1 &#123; int i; IntSupplier makeFun(int x) &#123; return () -&gt; x + i++; &#125;&#125; 但是，仔细考虑一下，i 的这种用法并非是个大难题，因为对象很可能在你调用 makeFun() 之后就存在了——实际上，垃圾收集器几乎肯定会保留一个对象，并将现有的函数以这种方式绑定到该对象上[^5]。当然，如果你对同一个对象多次调用 makeFun() ，你最终会得到多个函数，它们共享 i 的存储空间 如果使用 final 修饰 x和 i，就不能再递增它们的值了。代码示例： 12345678910// functional/Closure4.javaimport java.util.function.*;public class Closure4 &#123; IntSupplier makeFun(final int x) &#123; final int i = 0; return () -&gt; x + i; &#125;&#125; 那么为什么在 Closure2.java 中， x 和 i 非 final 却可以运行呢？ 这就叫做等同 final 效果（Effectively Final）。这个术语是在 Java 8 才开始出现的，表示虽然没有明确地声明变量是 final 的，但是因变量值没被改变过而实际有了 final 同等的效果。 如果局部变量的初始值永远不会改变，那么它实际上就是 final 的。 通过在闭包中使用 final 关键字提前修饰变量 x 和 i ， 我们解决了 Closure5.java 中的问题。代码示例： 1234567891011121314// functional/Closure6.javaimport java.util.function.*;public class Closure6 &#123; IntSupplier makeFun(int x) &#123; int i = 0; i++; x++; final int iFinal = i; final int xFinal = x; return () -&gt; xFinal + iFinal; &#125;&#125; 上例中 iFinal 和 xFinal 的值在赋值后并没有改变过，因此在这里使用 final 是多余的。 如果这里是引用的话，需要把 int 型更改为 Integer 型。代码示例： 123456789101112// functional/Closure7.java// &#123;无法编译成功&#125;import java.util.function.*;public class Closure7 &#123; IntSupplier makeFun(int x) &#123; Integer i = 0; i = i + 1; return () -&gt; x + i; &#125;&#125; 编译器非常智能，它能识别变量 i 的值被更改过了。 对于包装类型的处理可能比较特殊，因此我们尝试下 List： 123456789101112131415161718192021222324// functional/Closure8.javaimport java.util.*;import java.util.function.*;public class Closure8 &#123; Supplier&lt;List&lt;Integer&gt;&gt; makeFun() &#123; final List&lt;Integer&gt; ai = new ArrayList&lt;&gt;(); ai.add(1); return () -&gt; ai; &#125; public static void main(String[] args) &#123; Closure8 c7 = new Closure8(); List&lt;Integer&gt; l1 = c7.makeFun().get(), l2 = c7.makeFun().get(); System.out.println(l1); System.out.println(l2); l1.add(42); l2.add(96); System.out.println(l1); System.out.println(l2); &#125;&#125; 输出结果： 1234[1][1][1, 42][1, 96] 可以看到，这次一切正常。我们改变了 List 的值却没产生编译时错误。通过观察本例的输出结果，我们发现这看起来非常安全。这是因为每次调用 makeFun() 时，其实都会创建并返回一个全新的 ArrayList。 也就是说，每个闭包都有自己独立的 ArrayList， 它们之间互不干扰。 请注意我已经声明 ai 是 final 的了。尽管在这个例子中你可以去掉 final 并得到相同的结果（试试吧！）。 应用于对象引用的 final 关键字==仅表示不会重新赋值引用。 它并不代表你不能修改对象本身。== 作为闭包的内部类我们可以使用匿名内部类重写之前的例子: 123456789101112131415// functional/AnonymousClosure.javaimport java.util.function.*;public class AnonymousClosure &#123; IntSupplier makeFun(int x) &#123; int i = 0; // 同样规则的应用: // i++; // 非等同 final 效果 // x++; // 同上 return new IntSupplier() &#123; public int getAsInt() &#123; return x + i; &#125; &#125;; &#125;&#125; 实际上只要有内部类，就会有闭包（Java 8 只是简化了闭包操作）。在 Java 8 之前，变量 x 和 i 必须被明确声明为 final。在 Java 8 中，内部类的规则放宽，包括等同 final 效果。 函数组合函数组合（Function Composition）意为“多个函数组合成新函数”。它通常是函数式编程的基本组成部分。在前面的 TransformFunction.java 类中，有一个使用 andThen() 的函数组合示例。一些 java.util.function 接口中包含支持函数组合的方法 [^7]。 组合方法 支持接口 andThen(argument) 根据参数执行原始操作 Function BiFunction Consumer BiConsumer IntConsumer LongConsumer DoubleConsumer UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator BinaryOperator compose(argument) 根据参数执行原始操作 Function UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator and(argument) 短路逻辑与原始断言和参数断言 Predicate BiPredicate IntPredicate LongPredicate DoublePredicate or(argument) 短路逻辑或原始断言和参数断言 Predicate BiPredicate IntPredicate LongPredicate DoublePredicate negate() 该断言的逻辑否断言 Predicate BiPredicate IntPredicate LongPredicate DoublePredicate 下例使用了 Function 里的 compose()和 andThen()。代码示例： 123456789101112131415161718// functional/FunctionComposition.javaimport java.util.function.*;public class FunctionComposition &#123; static Function&lt;String, String&gt; f1 = s -&gt; &#123; System.out.println(s); return s.replace('A', '_'); &#125;, f2 = s -&gt; s.substring(3), f3 = s -&gt; s.toLowerCase(), f4 = f1.compose(f2).andThen(f3); public static void main(String[] args) &#123; System.out.println( f4.apply(\"GO AFTER ALL AMBULANCES\")); &#125;&#125; 输出结果： 12AFTER ALL AMBULANCES_fter _ll _mbul_nces 这里我们重点看正在创建的新函数 f4。它调用 apply() 的方式与常规几乎无异[^8]。 当 f1 获得字符串时，它已经被f2 剥离了前三个字符。这是因为 compose（f2） 表示 f2 的调用发生在 f1 之前。 下例是 Predicate 的逻辑运算演示.代码示例： 1234567891011121314151617// functional/PredicateComposition.javaimport java.util.function.*;import java.util.stream.*;public class PredicateComposition &#123; static Predicate&lt;String&gt; p1 = s -&gt; s.contains(\"bar\"), p2 = s -&gt; s.length() &lt; 5, p3 = s -&gt; s.contains(\"foo\"), p4 = p1.negate().and(p2).or(p3); public static void main(String[] args) &#123; Stream.of(\"bar\", \"foobar\", \"foobaz\", \"fongopuckey\") .filter(p4) .forEach(System.out::println); &#125;&#125; 输出结果： 12foobarfoobaz p4 获取到了所有断言并组合成一个更复杂的断言。解读：如果字符串中不包含 bar 且长度小于 5，或者它包含 foo ，则结果为 true。 正因它产生如此清晰的语法，我在主方法中采用了一些小技巧，并借用了下一章的内容。首先，我创建了一个字符串对象的流，然后将每个对象传递给 filter() 操作。 filter() 使用 p4 的断言来确定对象的去留。最后我们使用 forEach() 将 println 方法引用应用在每个留存的对象上。 从输出结果我们可以看到 p4 的工作流程：任何带有 foo 的东西都会留下，即使它的长度大于 5。 fongopuckey 因长度超出和不包含 bar 而被丢弃。 柯里化和部分求值柯里化（Currying）的名称来自于其发明者之一 Haskell Curry。他可能是计算机领域唯一名字被命名重要概念的人（另外就是 Haskell 编程语言）。 柯里化意为：将一个多参数的函数，转换为一系列单参数函数。 123456789101112131415161718192021222324252627// functional/CurryingAndPartials.javaimport java.util.function.*;public class CurryingAndPartials &#123; // 未柯里化: static String uncurried(String a, String b) &#123; return a + b; &#125; public static void main(String[] args) &#123; // 柯里化的函数: Function&lt;String, Function&lt;String, String&gt;&gt; sum = a -&gt; b -&gt; a + b; // [1] System.out.println(uncurried(\"Hi \", \"Ho\")); Function&lt;String, String&gt; hi = sum.apply(\"Hi \"); // [2] System.out.println(hi.apply(\"Ho\")); // 部分应用: Function&lt;String, String&gt; sumHi = sum.apply(\"Hup \"); System.out.println(sumHi.apply(\"Ho\")); System.out.println(sumHi.apply(\"Hey\")); &#125;&#125; 输出结果： 1234Hi HoHi HoHup HoHup Hey [1] 这一连串的箭头很巧妙。注意，在函数接口声明中，第二个参数是另一个函数。 [2] 柯里化的目的是能够通过提供一个参数来创建一个新函数，所以现在有了一个“带参函数”和剩下的 “无参函数” 。实际上，你从一个双参数函数开始，最后得到一个单参数函数。 我们可以通过添加级别来柯里化一个三参数函数： 123456789101112131415161718// functional/Curry3Args.javaimport java.util.function.*;public class Curry3Args &#123; public static void main(String[] args) &#123; Function&lt;String, Function&lt;String, Function&lt;String, String&gt;&gt;&gt; sum = a -&gt; b -&gt; c -&gt; a + b + c; Function&lt;String, Function&lt;String, String&gt;&gt; hi = sum.apply(\"Hi \"); Function&lt;String, String&gt; ho = hi.apply(\"Ho \"); System.out.println(ho.apply(\"Hup\")); &#125;&#125; 输出结果： 1Hi Ho Hup 对于每个级别的箭头级联（Arrow-cascading），你在类型声明中包裹了另一个 Function。 处理基本类型和装箱时，请使用适当的 Function 接口： 123456789101112// functional/CurriedIntAdd.javaimport java.util.function.*;public class CurriedIntAdd &#123; public static void main(String[] args) &#123; IntFunction&lt;IntUnaryOperator&gt; curriedIntAdd = a -&gt; b -&gt; a + b; IntUnaryOperator add4 = curriedIntAdd.apply(4); System.out.println(add4.applyAsInt(5)); &#125;&#125; 输出结果： 19 可以在互联网上找到更多的柯里化示例。通常它们是用 Java 之外的语言实现的，但如果理解了柯里化的基本概念，你可以很轻松地用 Java 实现它们。 纯函数式编程即使没有函数式支持，像 C 这样的基础语言，也可以按照一定的原则编写纯函数式程序。Java 8 让函数式编程更简单，不过我们要确保一切是 final 的，同时你的所有方法和函数没有副作用。因为 Java 在本质上并非是不可变语言，我们无法通过编译器查错。 这种情况下，我们可以借助第三方工具[^9]，但使用 Scala 或 Clojure 这样的语言可能更简单。因为它们从一开始就是为保持不变性而设计的。你可以采用这些语言来编写你的 Java 项目的一部分。如果必须要用纯函数式编写，则可以用 Scala（需要一些规则） 或 Clojure （需要的规则更少）。虽然 Java 支持并发编程，但如果这是你项目的核心部分，你应该考虑在项目部分功能中使用 Scala 或 Clojure 之类的语言。 本章小结Lambda 表达式和方法引用并没有将 Java 转换成函数式语言，而是提供了对函数式编程的支持。这对 Java 来说是一个巨大的改进。因为这允许你编写更简洁明了，易于理解的代码。在下一章中，你会看到它们在流式编程中的应用。相信你会像我一样，喜欢上流式编程。 这些特性满足大部分 Java 程序员的需求。他们开始羡慕嫉妒 Clojure、Scala 这类新语言的功能，并试图阻止 Java 程序员流失到其他阵营 （就算不能阻止，起码提供了更好的选择）。 但是，Lambdas 和方法引用远非完美，我们永远要为 Java 设计者早期的草率决定付出代价。特别是没有泛型 Lambda，所以 Lambda 在 Java 中并非一等公民。虽然我不否认 Java 8 的巨大改进，但这意味着和许多 Java 特性一样，它的使用还是会让人感觉沮丧和鸡肋。 第十四章 流式编程 集合优化了对象的存储，而流和对象的处理有关。 流是一系列与特定存储机制无关的元素——实际上，流并没有“存储”之说。 利用流，我们无需迭代集合中的元素，就可以提取和操作它们。这些管道通常被组合在一起，在流上形成一条操作管道。 在大多数情况下，将对象存储在集合中是为了处理他们，因此你将会发现你将把编程的主要焦点从集合转移到了流上。流的一个核心好处是，它使得程序更加短小并且更易理解。当 Lambda 表达式和方法引用（method references）和流一起使用的时候会让人感觉自成一体。流使得 Java 8 更具吸引力。 举个例子，假如你要随机展示 5 至 20 之间不重复的整数并进行排序。实际上，你的关注点首先是创建一个有序集合。围绕这个集合进行后续的操作。但是使用流式编程，你就可以简单陈述你想做什么： 123456789101112// streams/Randoms.javaimport java.util.*;public class Randoms &#123; public static void main(String[] args) &#123; new Random(47) .ints(5, 20) .distinct() .limit(7) .sorted() .forEach(System.out::println); &#125;&#125; 首先，我们给 Random 对象一个种子（以便程序再次运行时产生相同的输出）。ints() 方法产生一个流并且 ints() 方法有多种方式的重载 — 两个参数限定了数值产生的边界。这将生成一个整数流。我们可以使用中间流操作（intermediate stream operation） distinct() 来获取它们的非重复值，然后使用 limit() 方法获取前 7 个元素。接下来，我们使用 sorted() 方法排序。最终使用 forEach() 方法遍历输出，它根据传递给它的函数对每个流对象执行操作。在这里，我们传递了一个可以在控制台显示每个元素的方法引用。System.out::println 。 声明式编程（Declarative programming）是一种：声明要做什么，而非怎么做的编程风格。正如我们在函数式编程中所看到的。注意，命令式编程的形式更难以理解。代码示例： 1234567891011121314// streams/ImperativeRandoms.javaimport java.util.*;public class ImperativeRandoms &#123; public static void main(String[] args) &#123; Random rand = new Random(47); SortedSet&lt;Integer&gt; rints = new TreeSet&lt;&gt;(); while(rints.size() &lt; 7) &#123; int r = rand.nextint(20); if(r &lt; 5) continue; rints.add(r); &#125; System.out.println(rints); &#125;&#125; 在 Randoms.java 中，我们无需定义任何变量，但在这里我们定义了 3 个变量： rand，rints 和 r。由于 nextInt() 方法没有下限的原因（其内置的下限永远为 0），这段代码实现起来更复杂。所以我们要生成额外的值来过滤小于 5 的结果。 注意，你必须要研究程序的真正意图，而在 Randoms.java 中，代码只是告诉了你它正在做什么。这种语义清晰性也是 Java 8 的流式编程更受推崇的重要原因。 流支持Java 设计者面临着这样一个难题：现存的大量类库不仅为 Java 所用，同时也被应用在整个 Java 生态圈数百万行的代码中。如何将一个全新的流的概念融入到现有类库中呢？ 问题是，接口部分怎么改造呢？特别是涉及集合类接口的部分。如果你想把一个集合转换为流，直接向接口添加新方法会破坏所有老的接口实现类。 Java 8 采用的解决方案是：在接口中添加被 default（默认）修饰的方法。通过这种方案，设计者们可以将流式（stream）方法平滑地嵌入到现有类中。流方法预置的操作几乎已满足了我们平常所有的需求。 流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是到集合中）。 流创建你可以通过 Stream.of() 很容易地将一组元素转化成为流 123456public class StreamOf &#123; public static void main(String[] args) &#123; Stream.of(\"It's \", \"a \", \"wonderful \", \"day \", \"for \", \"pie!\") .forEach(System.out::print); &#125;&#125; 除此之外，每个集合都可以通过调用 stream() 方法来产生一个流。 1234Set&lt;String&gt; w = new HashSet&lt;&gt;(Arrays.asList(\"It's a wonderful day for pie!\".split(\" \"))); w.stream() .map(x -&gt; x + \" \") .forEach(System.out::print); 随机数流Random 类被一组生成流的方法增强了。 123456789101112131415161718192021222324// streams/RandomGenerators.javaimport java.util.*;import java.util.stream.*;public class RandomGenerators &#123; public static &lt;T&gt; void show(Stream&lt;T&gt; stream) &#123; stream .limit(4) .forEach(System.out::println); System.out.println(\"++++++++\"); &#125; public static void main(String[] args) &#123; Random rand = new Random(47); show(rand.ints().boxed()); show(rand.longs().boxed()); show(rand.doubles().boxed()); // 控制上限和下限： show(rand.ints(10, 20).boxed()); // 控制流大小： show(rand.ints(2).boxed()); // 控制流的大小和界限 show(rand.ints(3, 3, 9).boxed()); &#125;&#125; boxed() 流操作将会自动地把基本类型包装成为对应的装箱类型，从而使得 show() 能够接受流。 Stream.generate() 的用法，它可以把任意 Supplier&lt;T&gt; 用于生成 T 类型的流。 我们可以使用 Random 为任意对象集合创建 Supplier。如下是一个文本文件提供字符串对象的例子。 Cheese.dat 文件内容： 123456// streams/Cheese.datNot much of a cheese shop really, is it?Finest in the district, sir.And what leads you to that conclusion?Well, it's so clean.It's certainly uncontaminated by cheese. 我们通过 File 类将 Cheese.dat 文件的所有行读取到 List&lt;String&gt; 中。代码示例： 1234567891011121314151617181920212223242526272829303132// streams/RandomWords.javaimport java.util.*;import java.util.stream.*;import java.util.function.*;import java.io.*;import java.nio.file.*;public class RandomWords implements Supplier&lt;String&gt; &#123; List&lt;String&gt; words = new ArrayList&lt;&gt;(); Random rand = new Random(47); RandomWords(String fname) throws IOException &#123; List&lt;String&gt; lines = Files.readAllLines(Paths.get(fname)); // 略过第一行 for (String line : lines.subList(1, lines.size())) &#123; for (String word : line.split(\"[ .?,]+\")) words.add(word.toLowerCase()); &#125; &#125; public String get() &#123; return words.get(rand.nextInt(words.size())); &#125; @Override public String toString() &#123; return words.stream() .collect(Collectors.joining(\" \")); &#125; public static void main(String[] args) throws Exception &#123; System.out.println( Stream.generate(new RandomWords(\"Cheese.dat\")) .limit(10) .collect(Collectors.joining(\" \"))); &#125;&#125; 在这里你可以看到更为复杂的 split() 运用。在构造器中，每一行都被 split() 通过空格或者被方括号包裹的任意标点符号进行分割。在结束方括号后面的 + 代表 + 前面的东西可以出现一次或者多次。 我们注意到在构造函数中循环体使用命令式编程（外部迭代）。在以后的例子中，你甚至会看到我们如何消除这一点。这种旧的形式虽不是特别糟糕，但使用流会让人感觉更好。 collect() 收集操作，它根据参数来组合所有流中的元素。 当你使用 Collectors.joining()，你将会得到一个 String 类型的结果，每个元素都根据 joining() 的参数来进行分割。还有许多不同的 Collectors 用于产生不同的结果。 int 类型的范围IntStream 类提供了 range() 方法用于生成整型序列的流。编写循环时，这个方法会更加便利： 123456789101112131415161718// streams/Ranges.javaimport static java.util.stream.IntStream.*;public class Ranges &#123; public static void main(String[] args) &#123; // 传统方法: int result = 0; for (int i = 10; i &lt; 20; i++) result += i; System.out.println(result); // for-in 循环: result = 0; for (int i : range(10, 20).toArray()) result += i; System.out.println(result); // 使用流: System.out.println(range(10, 20).sum()); &#125;&#125; 输出结果： 123145145145 在主方法中的第一种方式是我们传统编写 for 循环的方式；第二种方式，我们使用 range() 创建了流并将其转化为数组，然后在 for-in 代码块中使用。但是，如果你能像第三种方法那样全程使用流是更好的。我们对范围中的数字进行求和。在流中可以很方便的使用 sum() 操作求和。 注意 IntStream.range() 相比 onjava.Range.range() 拥有更多的限制。这是由于其可选的第三个参数，后者允许步长大于 1，并且可以从大到小来生成。 实用小功能 repeat() 可以用来替换简单的 for 循环。代码示例： 12345678// onjava/Repeat.javapackage onjava;import static java.util.stream.IntStream.*;public class Repeat &#123; public static void repeat(int n, Runnable action) &#123; range(0, n).forEach(i -&gt; action.run()); &#125;&#125; 其产生的循环更加清晰： 1234567891011// streams/Looping.javaimport static onjava.Repeat.*;public class Looping &#123; static void hi() &#123; System.out.println(\"Hi!\"); &#125; public static void main(String[] args) &#123; repeat(3, () -&gt; System.out.println(\"Looping!\")); repeat(2, Looping::hi); &#125;&#125; 输出结果： 12345Looping!Looping!Looping!Hi!Hi! 原则上，在代码中包含并解释 repeat() 并不值得。诚然它是一个相当透明的工具，但结果取决于你的团队和公司的运作方式。 generate()12345public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) &#123; Objects.requireNonNull(s); return StreamSupport.stream( new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), false);&#125; 123456789@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; 参照 RandomWords.java 中 Stream.generate() 搭配 Supplier&lt;T&gt; 使用的例子。代码示例： 1234567891011121314151617181920// streams/Generator.javaimport java.util.*;import java.util.function.*;import java.util.stream.*;public class Generator implements Supplier&lt;String&gt; &#123; Random rand = new Random(47); char[] letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray(); public String get() &#123; return \"\" + letters[rand.nextInt(letters.length)]; &#125; public static void main(String[] args) &#123; String word = Stream.generate(new Generator()) .limit(30) .collect(Collectors.joining()); System.out.println(word); &#125;&#125; 输出结果： 1YNZBRNYGCFOWZNTCQRGSEGZMMJMROE 使用 Random.nextInt() 方法来挑选字母表中的大写字母。Random.nextInt() 的参数代表可以接受的最大的随机数范围，所以使用数组边界是经过深思熟虑的。 如果要创建包含相同对象的流，只需要传递一个生成那些对象的 lambda 到 generate() 中： 123456789// streams/Duplicator.javaimport java.util.stream.*;public class Duplicator &#123; public static void main(String[] args) &#123; Stream.generate(() -&gt; \"duplicate\") .limit(3) .forEach(System.out::println); &#125;&#125; 输出结果： 123duplicateduplicateduplicate 如下是在本章之前例子中使用过的 Bubble 类。注意它包含了自己的静态生成器（Static generator）方法。 12345678910111213141516171819// streams/Bubble.javaimport java.util.function.*;public class Bubble &#123; public final int i; public Bubble(int n) &#123; i = n; &#125; @Override public String toString() &#123; return \"Bubble(\" + i + \")\"; &#125; private static int count = 0; public static Bubble bubbler() &#123; return new Bubble(count++); &#125;&#125; 由于 bubbler() 与 Supplier&lt;Bubble&gt; 是接口兼容的，我们可以将其方法引用直接传递给 Stream.generate()： 123456789// streams/Bubbles.javaimport java.util.stream.*;public class Bubbles &#123; public static void main(String[] args) &#123; Stream.generate(Bubble::bubbler) .limit(5) .forEach(System.out::println); &#125;&#125; 输出结果： 12345Bubble(0)Bubble(1)Bubble(2)Bubble(3)Bubble(4) 这是创建单独工厂类（Separate Factory class）的另一种方式。在很多方面它更加整洁，但是这是一个对于代码组织和品味的问题——你总是可以创建一个完全不同的工厂类。 iterate()1234567891011121314151617181920public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) &#123; Objects.requireNonNull(f); final Iterator&lt;T&gt; iterator = new Iterator&lt;T&gt;() &#123; @SuppressWarnings(\"unchecked\") T t = (T) Streams.NONE; @Override public boolean hasNext() &#123; return true; &#125; @Override public T next() &#123; return t = (t == Streams.NONE) ? seed : f.apply(t); &#125; &#125;; return StreamSupport.stream(Spliterators.spliteratorUnknownSize( iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE), false);&#125; Stream.iterate() 以种子（第一个参数）开头，并将其传给方法（第二个参数）。方法的结果将添加到流，并存储作为第一个参数用于下次调用 iterate()，依次类推。我们可以利用 iterate() 生成一个斐波那契数列。代码示例： 1234567891011121314151617181920// streams/Fibonacci.javaimport java.util.stream.*;public class Fibonacci &#123; int x = 1; Stream&lt;Integer&gt; numbers() &#123; return Stream.iterate(0, i -&gt; &#123; int result = x + i; x = i; return result; &#125;); &#125; public static void main(String[] args) &#123; new Fibonacci().numbers() .skip(20) // 过滤前 20 个 .limit(10) // 然后取 10 个 .forEach(System.out::println); &#125;&#125; 输出结果： 1234567891067651094617711286574636875025121393196418317811514229 斐波那契数列将数列中最后两个元素进行求和以产生下一个元素。iterate() 只能记忆结果，因此我们需要利用一个变量 x 追踪另外一个元素。 在主方法中，我们使用了一个之前没有见过的 skip() 操作。它根据参数丢弃指定数量的流元素。在这里，我们丢弃了前 20 个元素。 流的建造者模式在建造者设计模式（也称构造器模式）中，首先创建一个 builder 对象，传递给它多个构造器信息，最后执行“构造”。Stream 库提供了这样的 Builder。在这里，我们重新审视文件读取并将其转换成为单词流的过程。代码示例： 1234567891011121314151617181920212223242526272829// streams/FileToWordsBuilder.javaimport java.io.*;import java.nio.file.*;import java.util.stream.*;public class FileToWordsBuilder &#123; Stream.Builder&lt;String&gt; builder = Stream.builder(); public FileToWordsBuilder(String filePath) throws Exception &#123; Files.lines(Paths.get(filePath)) .skip(1) // 略过开头的注释行 .forEach(line -&gt; &#123; for (String w : line.split(\"[ .?,]+\")) builder.add(w); &#125;); &#125; Stream&lt;String&gt; stream() &#123; return builder.build(); &#125; public static void main(String[] args) throws Exception &#123; new FileToWordsBuilder(\"Cheese.dat\") .stream() .limit(7) .map(w -&gt; w + \" \") .forEach(System.out::print); &#125;&#125; 输出结果： 1Not much of a cheese shop really 注意，构造器会添加文件中的所有单词（除了第一行，它是包含文件路径信息的注释），但是其并没有调用 build()。只要你不调用 stream() 方法，就可以继续向 builder 对象中添加单词。 在该类的更完整形式中，你可以添加一个标志位用于查看 build() 是否被调用，并且可能的话增加一个可以添加更多单词的方法。在 Stream.Builder 调用 build() 方法后继续尝试添加单词会产生一个异常。 ArraysArrays 类中含有一个名为 stream() 的静态方法用于把数组转换成为流。我们可以重写 interfaces/Machine.java 中的主方法用于创建一个流，并将 execute() 应用于每一个元素。代码示例： 12345678910111213// streams/Machine2.javaimport java.util.*;import onjava.Operations;public class Machine2 &#123; public static void main(String[] args) &#123; Arrays.stream(new Operations[] &#123; () -&gt; Operations.show(\"Bing\"), () -&gt; Operations.show(\"Crack\"), () -&gt; Operations.show(\"Twist\"), () -&gt; Operations.show(\"Pop\") &#125;).forEach(Operations::execute); &#125;&#125; 输出结果： 1234BingCrackTwistPop new Operations[] 表达式动态创建了 Operations 对象的数组。 stream() 同样可以产生 IntStream，LongStream 和 DoubleStream。 1234567891011121314151617181920212223// streams/ArrayStreams.javaimport java.util.*;import java.util.stream.*;public class ArrayStreams &#123; public static void main(String[] args) &#123; Arrays.stream(new double[] &#123; 3.14159, 2.718, 1.618 &#125;) .forEach(n -&gt; System.out.format(\"%f \", n)); System.out.println(); Arrays.stream(new int[] &#123; 1, 3, 5 &#125;) .forEach(n -&gt; System.out.format(\"%d \", n)); System.out.println(); Arrays.stream(new long[] &#123; 11, 22, 44, 66 &#125;) .forEach(n -&gt; System.out.format(\"%d \", n)); System.out.println(); // 选择一个子域: Arrays.stream(new int[] &#123; 1, 3, 5, 7, 15, 28, 37 &#125;, 3, 6) .forEach(n -&gt; System.out.format(\"%d \", n)); &#125;&#125; 输出结果： 12343.141590 2.718000 1.6180001 3 511 22 44 667 15 28 最后一次 stream() 的调用有两个额外的参数。第一个参数告诉 stream() 从数组的哪个位置开始选择元素，第二个参数用于告知在哪里停止。每种不同类型的 stream() 都有类似的操作。 正则表达式Java 的正则表达式将在字符串这一章节详细介绍。Java 8 在 java.util.regex.Pattern 中增加了一个新的方法 splitAsStream()。这个方法可以根据传入的公式将字符序列转化为流。但是有一个限制，输入只能是 CharSequence，因此不能将流作为 splitAsStream() 的参数。 我们再一次查看将文件处理为单词流的过程。这一次，我们使用流将文件分割为单独的字符串，接着使用正则表达式将字符串转化为单词流。 123456789101112131415161718192021222324252627282930// streams/FileToWordsRegexp.javaimport java.io.*;import java.nio.file.*;import java.util.stream.*;import java.util.regex.Pattern;public class FileToWordsRegexp &#123; private String all; public FileToWordsRegexp(String filePath) throws Exception &#123; all = Files.lines(Paths.get(filePath)) .skip(1) // First (comment) line .collect(Collectors.joining(\" \")); &#125; public Stream&lt;String&gt; stream() &#123; return Pattern .compile(\"[ .,?]+\").splitAsStream(all); &#125; public static void main(String[] args) throws Exception &#123; FileToWordsRegexp fw = new FileToWordsRegexp(\"Cheese.dat\"); fw.stream() .limit(7) .map(w -&gt; w + \" \") .forEach(System.out::print); fw.stream() .skip(7) .limit(2) .map(w -&gt; w + \" \") .forEach(System.out::print); &#125;&#125; 输出结果： 1Not much of a cheese shop really is it 在构造器中我们读取了文件中的所有内容（跳过第一行注释，并将其转化成为单行字符串）。现在，当你调用 stream() 的时候，可以像往常一样获取一个流，但这次你可以多次调用 stream() 在已存储的字符串中创建一个新的流。这里有个限制，整个文件必须存储在内存中；在大多数情况下这并不是什么问题，但是这损失了流操作非常重要的优势： 流“不需要存储”。当然它们需要一些内部存储，但是这只是序列的一小部分，和持有整个序列并不相同。 它们是懒加载计算的。 幸运的是，我们稍后就会知道如何解决这个问题。 中间操作中间操作用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接到其他操作。 跟踪和调试1Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action); peek() 操作的目的是帮助调试。它允许你无修改地查看流中的元素。代码示例： 1234567891011121314// streams/Peeking.javaclass Peeking &#123; public static void main(String[] args) throws Exception &#123; FileToWords.stream(\"Cheese.dat\") .skip(21) .limit(4) .map(w -&gt; w + \" \") .peek(System.out::print) .map(String::toUpperCase) .peek(System.out::print) .map(String::toLowerCase) .forEach(System.out::print); &#125;&#125; 输出结果： 1Well WELL well it IT it s S s so SO so FileToWords 稍后定义，但它的功能实现貌似和之前我们看到的差不多：产生字符串对象的流。之后在其通过管道时调用 peek() 进行处理。 因为 peek() 符合无返回值的 Consumer 函数式接口，所以我们只能观察，无法使用不同的元素来替换流中的对象。 流元素排序 sorted() 的默认比较器实现。其实它还有另一种形式的实现：传入一个 Comparator 参数。 1Stream.sorted(Comparator.reverseOrder()) sorted() 预设了一些默认的比较器。这里我们使用的是反转“自然排序”。当然你也可以把 Lambda 函数作为参数传递给 sorted()。 移除元素 distinct()：在 Randoms.java 类中的 distinct() 可用于消除流中的重复元素。相比创建一个 Set 集合，该方法的工作量要少得多。 filter(Predicate)：过滤操作会保留与传递进去的过滤器函数计算结果为 true 元素。 在下例中，isPrime() 作为过滤器函数，用于检测质数。 1234567891011121314151617181920212223// streams/Prime.javaimport java.util.stream.*;import static java.util.stream.LongStream.*;public class Prime &#123; public static Boolean isPrime(long n) &#123; return rangeClosed(2, (long)Math.sqrt(n)) .noneMatch(i -&gt; n % i == 0); &#125; public LongStream numbers() &#123; return iterate(2, i -&gt; i + 1) .filter(Prime::isPrime); &#125; public static void main(String[] args) &#123; new Prime().numbers() .limit(10) .forEach(n -&gt; System.out.format(\"%d \", n)); System.out.println(); new Prime().numbers() .skip(90) .limit(10) .forEach(n -&gt; System.out.format(\"%d \", n)); &#125;&#125; 输出结果： 122 3 5 7 11 13 17 19 23 29467 479 487 491 499 503 509 521 523 541 rangeClosed() 包含了上限值。如果不能整除，即余数不等于 0，则 noneMatch() 操作返回 true，如果出现任何等于 0 的结果则返回 false。 noneMatch() 操作一旦有失败就会退出。 应用函数到元素 map(Function)：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。 mapToInt(ToIntFunction)：操作同上，但结果是 IntStream。 mapToLong(ToLongFunction)：操作同上，但结果是 LongStream。 mapToDouble(ToDoubleFunction)：操作同上，但结果是 DoubleStream。 在这里，我们使用 map() 映射多种函数到一个字符串流中。代码示例： 1234567891011121314151617181920212223242526272829303132// streams/FunctionMap.javaimport java.util.*;import java.util.stream.*;import java.util.function.*;class FunctionMap &#123; static String[] elements = &#123; \"12\", \"\", \"23\", \"45\" &#125;; static Stream&lt;String&gt; testStream() &#123; return Arrays.stream(elements); &#125; static void test(String descr, Function&lt;String, String&gt; func) &#123; System.out.println(\" ---( \" + descr + \" )---\"); testStream() .map(func) .forEach(System.out::println); &#125; public static void main(String[] args) &#123; test(\"add brackets\", s -&gt; \"[\" + s + \"]\"); test(\"Increment\", s -&gt; &#123; try &#123; return Integer.parseInt(s) + 1 + \"\"; &#125; catch(NumberFormatException e) &#123; return s; &#125; &#125; ); test(\"Replace\", s -&gt; s.replace(\"2\", \"9\")); test(\"Take last digit\", s -&gt; s.length() &gt; 0 ? s.charAt(s.length() - 1) + \"\" : s); &#125;&#125; 输出结果： 1234567891011121314151617---( add brackets )---[12][][23][45]---( Increment )---132446---( Replace )---199345---( Take last digit )---235 在上面的自增示例中，我们使用 Integer.parseInt() 尝试将一个字符串转化为整数。如果字符串不能转化成为整数就会抛出 NumberFormatException 异常，我们只须回过头来将原始字符串放回到输出流中。 在以上例子中，map() 将一个字符串映射为另一个字符串，但是我们完全可以产生和接收类型完全不同的类型，从而改变流的数据类型。下面代码示例： 123456789101112131415161718192021// streams/FunctionMap2.java// Different input and output types （不同的输入输出类型）import java.util.*;import java.util.stream.*;class Numbered &#123; final int n; Numbered(int n) &#123; this.n = n; &#125; @Override public String toString() &#123; return \"Numbered(\" + n + \")\"; &#125;&#125;class FunctionMap2 &#123; public static void main(String[] args) &#123; Stream.of(1, 5, 7, 9, 11, 13) .map(Numbered::new) .forEach(System.out::println); &#125;&#125; 输出结果： 123456Numbered(1)Numbered(5)Numbered(7)Numbered(9)Numbered(11)Numbered(13) 我们将获取到的整数通过构造器 Numbered::new 转化成为 Numbered 类型。 如果使用 Function 返回的结果是数值类型的一种，我们必须使用合适的 mapTo数值类型 进行替代。代码示例： 12345678910111213141516171819// streams/FunctionMap3.java// Producing numeric output streams（ 产生数值输出流）import java.util.*;import java.util.stream.*;class FunctionMap3 &#123; public static void main(String[] args) &#123; Stream.of(\"5\", \"7\", \"9\") .mapToInt(Integer::parseInt) .forEach(n -&gt; System.out.format(\"%d \", n)); System.out.println(); Stream.of(\"17\", \"19\", \"23\") .mapToLong(Long::parseLong) .forEach(n -&gt; System.out.format(\"%d \", n)); System.out.println(); Stream.of(\"17\", \"1.9\", \".23\") .mapToDouble(Double::parseDouble) .forEach(n -&gt; System.out.format(\"%f \", n)); &#125;&#125; 输出结果： 1235 7 917 19 2317.000000 1.900000 0.230000 遗憾的是，Java 设计者并没有尽最大努力去消除基本类型。 在 map() 中组合流假设我们现在有了一个传入的元素流，并且打算对流元素使用 map() 函数。现在你已经找到了一些可爱并独一无二的函数功能，但是问题来了：这个函数功能是产生一个流。我们想要产生一个元素流，而实际却产生了一个元素流的流。 flatMap() 做了两件事：将产生流的函数应用在每个元素上（与 map() 所做的相同），然后将每个流都扁平化为元素，因而最终产生的仅仅是元素。 flatMap(Function)：当 Function 产生流时使用。 flatMapToInt(Function)：当 Function 产生 IntStream 时使用。 flatMapToLong(Function)：当 Function 产生 LongStream 时使用。 flatMapToDouble(Function)：当 Function 产生 DoubleStream 时使用。 为了弄清它的工作原理，我们从传入一个刻意设计的函数给 map() 开始。该函数接受一个整数并产生一个字符串流： 12345678910// streams/StreamOfStreams.javaimport java.util.stream.*;public class StreamOfStreams &#123; public static void main(String[] args) &#123; Stream.of(1, 2, 3) .map(i -&gt; Stream.of(\"Gonzo\", \"Kermit\", \"Beaker\")) .map(e-&gt; e.getClass().getName()) .forEach(System.out::println); &#125;&#125; 输出结果： 123java.util.stream.ReferencePipeline$Headjava.util.stream.ReferencePipeline$Headjava.util.stream.ReferencePipeline$Head 我们天真地希望能够得到字符串流，但实际得到的却是“Head”流的流。我们可以使用 flatMap() 解决这个问题： 123456789// streams/FlatMap.javaimport java.util.stream.*;public class FlatMap &#123; public static void main(String[] args) &#123; Stream.of(1, 2, 3) .flatMap(i -&gt; Stream.of(\"Gonzo\", \"Fozzie\", \"Beaker\")) .forEach(System.out::println); &#125;&#125; 输出结果： 123456789GonzoFozzieBeakerGonzoFozzieBeakerGonzoFozzieBeaker 从映射返回的每个流都会自动扁平为组成它的字符串。 下面是另一个演示，我们从一个整数流开始，然后使用每一个整数去创建更多的随机数。 123456789101112// streams/StreamOfRandoms.javaimport java.util.*;import java.util.stream.*;public class StreamOfRandoms &#123; static Random rand = new Random(47); public static void main(String[] args) &#123; Stream.of(1, 2, 3, 4, 5) .flatMapToInt(i -&gt; IntStream.concat( rand.ints(0, 100).limit(i), IntStream.of(-1))) .forEach(n -&gt; System.out.format(\"%d \", n)); &#125;&#125; 输出结果： 158 -1 55 93 -1 61 61 29 -1 68 0 22 7 -1 88 28 51 89 9 -1 在这里我们引入了 concat()，它以参数顺序组合两个流。 如此，我们在每个随机 Integer 流的末尾添加一个 -1 作为标记。你可以看到最终流确实是从一组扁平流中创建的。 因为 rand.ints() 产生的是一个 IntStream，所以我必须使用 flatMap()、concat() 和 of() 的特定整数形式。 让我们再看一下将文件划分为单词流的任务。我们最后使用到的是 FileToWordsRegexp.java，它的问题是需要将整个文件读入行列表中 —— 显然需要存储该列表。而我们真正想要的是创建一个不需要中间存储层的单词流。 下面，我们再使用 flatMap() 来解决这个问题： 123456789101112// streams/FileToWords.javaimport java.nio.file.*;import java.util.stream.*;import java.util.regex.Pattern;public class FileToWords &#123; public static Stream&lt;String&gt; stream(String filePath) throws Exception &#123; return Files.lines(Paths.get(filePath)) .skip(1) // First (comment) line .flatMap(line -&gt; Pattern.compile(\"\\\\W+\").splitAsStream(line)); &#125;&#125; stream() 现在是一个静态方法，因为它可以自己完成整个流创建过程。 注意：\\\\W+ 是一个正则表达式。他表示“非单词字符”，+ 表示“可以出现一次或者多次”。小写形式的 \\\\w 表示“单词字符”。 我们之前遇到的问题是 Pattern.compile().splitAsStream() 产生的结果为流，这意味着当我们只是想要一个简单的单词流时，在传入的行流（stream of lines）上调用 map() 会产生一个单词流的流。幸运的是，flatMap() 可以将元素流的流扁平化为一个简单的元素流。或者，我们可以使用 String.split() 生成一个数组，其可以被 Arrays.stream() 转化成为流： 1.flatMap(line -&gt; Arrays.stream(line.split(\"\\\\W+\")))) 有了真正的、而非 FileToWordsRegexp.java 中基于集合存储的流，我们每次使用都必须从头创建，因为流并不能被复用： 1234567891011121314// streams/FileToWordsTest.javaimport java.util.stream.*;public class FileToWordsTest &#123; public static void main(String[] args) throws Exception &#123; FileToWords.stream(\"Cheese.dat\") .limit(7) .forEach(s -&gt; System.out.format(\"%s \", s)); System.out.println(); FileToWords.stream(\"Cheese.dat\") .skip(7) .limit(2) .forEach(s -&gt; System.out.format(\"%s \", s)); &#125;&#125; 输出结果： 1Not much of a cheese shop really 在 System.out.format() 中的 %s 表明参数为 String 类型。 Optional类在流中放置 null 是很好的中断方法。那么是否有某种对象，可作为流元素的持有者，即使查看的元素不存在也能友好地提示我们（也就是说，不会发生异常）？ Optional 可以实现这样的功能。一些标准流操作返回 Optional 对象，因为它们并不能保证预期结果一定存在。包括： findFirst() 返回一个包含第一个元素的 Optional 对象，如果流为空则返回 Optional.empty findAny() 返回包含任意元素的 Optional 对象，如果流为空则返回 Optional.empty max() 和 min() 返回一个包含最大值或者最小值的 Optional 对象，如果流为空则返回 Optional.empty reduce() 不再以 identity 形式开头，而是将其返回值包装在 Optional 中。（identity 对象成为其他形式的 reduce() 的默认结果，因此不存在空结果的风险） 对于数字流 IntStream、LongStream 和 DoubleStream，average() 会将结果包装在 Optional 以防止流为空。 当流为空的时候你会获得一个 Optional.empty 对象，而不是抛出异常。Optional 拥有 toString() 方法可以用于展示有用信息。 注意，空流是通过 Stream.&lt;String&gt;empty() 创建的。 这个示例展示了 Optional 的两个基本用法： 123456789101112131415// streams/OptionalBasics.javaimport java.util.*;import java.util.stream.*;class OptionalBasics &#123; static void test(Optional&lt;String&gt; optString) &#123; if(optString.isPresent()) System.out.println(optString.get()); else System.out.println(\"Nothing inside!\"); &#125; public static void main(String[] args) &#123; test(Stream.of(\"Epithets\").findFirst()); test(Stream.&lt;String&gt;empty().findFirst()); &#125;&#125; 输出结果： 12EpithetsNothing inside! 当你接收到 Optional 对象时，应首先调用 isPresent() 检查其中是否包含元素。如果存在，可使用 get() 获取。 便利函数有许多便利函数可以解包 Optional ，这简化了上述“对所包含的对象的检查和执行操作”的过程： ifPresent(Consumer)：当值存在时调用 Consumer，否则什么也不做。 orElse(otherObject)：如果值存在则直接返回，否则生成 otherObject。 orElseGet(Supplier)：如果值存在则直接返回，否则使用 Supplier 函数生成一个可替代对象。 orElseThrow(Supplier)：如果值存在直接返回，否则使用 Supplier 函数生成一个异常。 创建 Optional当我们在自己的代码中加入 Optional 时，可以使用下面 3 个静态方法： empty()：生成一个空 Optional。 of(value)：将一个非空值包装到 Optional 里。 ofNullable(value)：针对一个可能为空的值，为空时自动生成 Optional.empty，否则将值包装在 Optional 中。 我们不能通过传递 null 到 of() 来创建 Optional 对象。最安全的方法是， 使用 ofNullable() 来优雅地处理 null。 Optional 对象操作当我们的流管道生成了 Optional 对象，下面 3 个方法可使得 Optional 的后续能做更多的操作： filter(Predicate)：将 Predicate 应用于 Optional 中的内容并返回结果。当 Optional 不满足 Predicate 时返回空。如果 Optional 为空，则直接返回。 map(Function)：如果 Optional 不为空，应用 Function 于 Optional 中的内容，并返回结果。否则直接返回 Optional.empty。 flatMap(Function)：同 map()，但是提供的映射函数将结果包装在 Optional 对象中，因此 flatMap() 不会在最后进行任何包装。 以上方法都不适用于数值型 Optional。一般来说，流的 filter() 会在 Predicate 返回 false 时移除流元素。而 Optional.filter() 在失败时不会删除 Optional，而是将其保留下来，并转化为空。 同 map() 一样 ， Optional.map() 应用于函数。它仅在 Optional 不为空时才应用映射函数，并将 Optional 的内容提取到映射函数。 Optional 的 flatMap() 应用于已生成 Optional 的映射函数，所以 flatMap() 不会像 map() 那样将结果封装在 Optional 中。 Optional 流假设你的生成器可能产生 null 值，那么当用它来创建流时，你会自然地想到用 Optional 来包装元素。 12345678910111213class Signal&#123; public static Signal morse() &#123; switch(rand.nextInt(4)) &#123; case 1: return new Signal(\"dot\"); case 2: return new Signal(\"dash\"); default: return null; &#125; &#125; public static Stream&lt;Optional&lt;Signal&gt;&gt; stream() &#123; return Stream.generate(Signal::morse) .map(signal -&gt; Optional.ofNullable(signal)); &#125;&#125; 12345678910111213141516// streams/StreamOfOptionals.javaimport java.util.*;import java.util.stream.*;public class StreamOfOptionals &#123; public static void main(String[] args) &#123; Signal.stream() .limit(10) .forEach(System.out::println); System.out.println(\" ---\"); Signal.stream() .limit(10) .filter(Optional::isPresent) .map(Optional::get) .forEach(System.out::println); &#125;&#125; 在这里，我们使用 filter() 来保留那些非空 Optional，然后在 map() 中使用 get() 获取元素。由于每种情况都需要定义“空值”的含义，所以通常我们要为每个应用程序采用不同的方法。 终端操作这些操作接收一个流并产生一个最终结果；它们不会向后端流提供任何东西。因此，终端操作总是你在管道中做的最后一件事情。 转化为数组 toArray()：将流转换成适当类型的数组。 toArray(generator)：在特殊情况下，生成器用于分配自定义的数组存储。 1private static int[] rints = new Random(47).ints(0, 1000).limit(100).toArray(); 应用最终操作 forEach(Consumer)：你已经看到过很多次 System.out::println 作为 Consumer 函数。 forEachOrdered(Consumer)： 保证 forEach 按照原始流顺序操作。 第一种形式：显式设计为任意顺序操作元素，仅在引入 parallel() 操作时才有意义。在 并发编程 章节之前我们不会深入研究这个问题。这里简单介绍下 parallel()：可实现多处理器并行操作。实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。因为我们采用的是内部迭代，而不是外部迭代，所以这是可能实现的。 parallel() 看似简单，实则棘手。更多内容将在稍后的 并发编程 章节中学习。 下例引入了 parallel() 来帮助理解 forEachOrdered(Consumer) 的作用和使用场景。代码示例： 12345678910111213141516171819// streams/ForEach.javaimport java.util.*;import java.util.stream.*;import static streams.RandInts.*;public class ForEach &#123; static final int SZ = 14; public static void main(String[] args) &#123; rands().limit(SZ) .forEach(n -&gt; System.out.format(\"%d \", n)); System.out.println(); rands().limit(SZ) .parallel() .forEach(n -&gt; System.out.format(\"%d \", n)); System.out.println(); rands().limit(SZ) .parallel() .forEachOrdered(n -&gt; System.out.format(\"%d \", n)); &#125;&#125; 输出结果： 123258 555 693 861 961 429 868 200 522 207 288 128 551 589551 861 429 589 200 522 555 693 258 128 868 288 961 207258 555 693 861 961 429 868 200 522 207 288 128 551 589 为了方便测试不同大小的数组，我们抽离出了 SZ 变量。结果很有趣：在第一个流中，未使用 parallel() ，所以 rands() 按照元素迭代出现的顺序显示结果；在第二个流中，引入parallel() ，即便流很小，输出的结果顺序也和前面不一样。这是由于多处理器并行操作的原因。多次运行测试，结果均不同。多处理器并行操作带来的非确定性因素造成了这样的结果。 在最后一个流中，同时使用了 parallel() 和 forEachOrdered() 来强制保持原始流顺序。因此，对非并行流使用 forEachOrdered() 是没有任何影响的。 收集 collect(Collector)：使用 Collector 收集流元素到结果集合中。 collect(Supplier, BiConsumer, BiConsumer)：同上，第一个参数 Supplier 创建了一个新结果集合，第二个参数 BiConsumer 将下一个元素包含到结果中，第三个参数 BiConsumer 用于将两个值组合起来。 在这里我们只是简单介绍了几个 Collectors 的运用示例。实际上，它还有一些非常复杂的操作实现，可通过查看 java.util.stream.Collectors 的 API 文档了解。 12345678Set&lt;String&gt; words2 = Files.lines(Paths.get(\"TreeSetOfWords.java\")) .flatMap(s -&gt; Arrays.stream(s.split(\"\\\\W+\"))) .filter(s -&gt; !s.matches(\"\\\\d+\")) // No numbers .map(String::trim) .filter(s -&gt; s.length() &gt; 2) .limit(100) .collect(Collectors.toCollection(TreeSet::new)); 我们也可以在流中生成 Map。代码示例： 1234567891011121314151617181920212223242526272829303132333435363738// streams/MapCollector.javaimport java.util.*;import java.util.stream.*;class Pair &#123; public final Character c; public final Integer i; Pair(Character c, Integer i) &#123; this.c = c; this.i = i; &#125; public Character getC() &#123; return c; &#125; public Integer getI() &#123; return i; &#125; @Override public String toString() &#123; return \"Pair(\" + c + \", \" + i + \")\"; &#125;&#125;class RandomPair &#123; Random rand = new Random(47); // An infinite iterator of random capital letters: Iterator&lt;Character&gt; capChars = rand.ints(65,91) .mapToObj(i -&gt; (char)i) .iterator(); public Stream&lt;Pair&gt; stream() &#123; return rand.ints(100, 1000).distinct() .mapToObj(i -&gt; new Pair(capChars.next(), i)); &#125;&#125;public class MapCollector &#123; public static void main(String[] args) &#123; Map&lt;Integer, Character&gt; map = new RandomPair().stream() .limit(8) .collect( Collectors.toMap(Pair::getI, Pair::getC)); System.out.println(map); &#125;&#125; 输出结果： 1&#123;688=W, 309=C, 293=B, 761=N, 858=N, 668=G, 622=F, 751=N&#125; Pair 只是一个基础的数据对象。RandomPair 创建了随机生成的 Pair 对象流。在 Java 中，我们不能直接以某种方式组合两个流。所以这里创建了一个整数流，并且使用 mapToObj() 将其转化成为 Pair 流。 capChars 随机生成的大写字母迭代器从流开始，然后 iterator() 允许我们在 stream() 中使用它。就我所知，这是组合多个流以生成新的对象流的唯一方法。 在这里，我们只使用最简单形式的 Collectors.toMap()，这个方法值需要一个可以从流中获取键值对的函数。还有其他重载形式，其中一种形式是在遇到键值冲突时，需要一个函数来处理这种情况。 在大多数情况下，你可以在 java.util.stream.Collectors寻找到你想要的预先定义好的 Collector。在少数情况下当你找不到想要的时候，你可以使用第二种形式的 collect()。 我基本上把它留作更高级的练习，但是这里有一个例子给出了基本想法： 123456789101112131415// streams/SpecialCollector.javaimport java.util.*;import java.util.stream.*;public class SpecialCollector &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;String&gt; words = FileToWords.stream(\"Cheese.dat\") .collect(ArrayList::new, ArrayList::add, ArrayList::addAll); words.stream() .filter(s -&gt; s.equals(\"cheese\")) .forEach(System.out::println); &#125;&#125; 输出结果： 12cheesecheese 在这里， ArrayList 的方法已经执行了你所需要的操作，但是似乎更有可能的是，如果你必须使用这种形式的 collect()，则必须自己创建特殊的定义。 组合所有流元素 reduce(BinaryOperator)：使用 BinaryOperator 来组合所有流中的元素。因为流可能为空，其返回值为 Optional。 reduce(identity, BinaryOperator)：功能同上，但是使用 identity 作为其组合的初始值。因此如果流为空，identity 就是结果。 reduce(identity, BiFunction, BinaryOperator)：这个形式更为复杂（所以我们不会介绍它），在这里被提到是因为它使用起来会更有效。通常，你可以显式地组合 map() 和 reduce() 来更简单的表达它。 如下是一个用于演示 reduce() 的示例： 1234567891011121314151617181920212223242526// streams/Reduce.javaimport java.util.*;import java.util.stream.*;class Frobnitz &#123; int size; Frobnitz(int sz) &#123; size = sz; &#125; @Override public String toString() &#123; return \"Frobnitz(\" + size + \")\"; &#125; // Generator: static Random rand = new Random(47); static final int BOUND = 100; static Frobnitz supply() &#123; return new Frobnitz(rand.nextInt(BOUND)); &#125;&#125;public class Reduce &#123; public static void main(String[] args) &#123; Stream.generate(Frobnitz::supply) .limit(10) .peek(System.out::println) .reduce((fr0, fr1) -&gt; fr0.size &lt; 50 ? fr0 : fr1) .ifPresent(System.out::println); &#125;&#125; 输出结果： 1234567891011Frobnitz(58)Frobnitz(55)Frobnitz(93)Frobnitz(61)Frobnitz(61)Frobnitz(29)Frobnitz(68)Frobnitz(0)Frobnitz(22)Frobnitz(7)Frobnitz(29) Frobnitz 包含了一个名为 supply() 的生成器；因为这个方法对于 Supplier&lt;Frobnitz&gt; 是签名兼容的，我们可以将其方法引用传递给 Stream.generate()（这种签名兼容性被称作结构一致性）。我们使用没有给“起始值”的 reduce()方法，这意味着它的返回值是 Optional 类型的。Optional.ifPresent() 只有在结果非空的时候才会调用 Consumer&lt;Frobnitz&gt; （println 方法可以被调用是因为 Frobnitz 可以通过 toString() 方法转换成 String）。 Lambda 表达式中的第一个参数 fr0 是上一次调用 reduce() 的结果。而第二个参数 fr1 是从流传递过来的值。 reduce() 中的 Lambda 表达式使用了三元表达式来获取结果，当其 size 小于 50 的时候获取 fr0 否则获取序列中的下一个值 fr1。因此你会取得第一个 size 小于 50 的 Frobnitz，只要找到了就这个结果就会紧紧地攥住它，即使有其他候选者出现。虽然这是一个非常奇怪的约束，但是它确实让你对 reduce() 有了更多的了解。 匹配 allMatch(Predicate) ：如果流的每个元素根据提供的 Predicate 都返回 true 时，结果返回为 true。这个操作将会在第一个 false 之后短路；也就是不会在发生 false 之后继续执行计算。 anyMatch(Predicate)：如果流中的任意一个元素根据提供的 Predicate 返回 true 时，结果返回为 true。这个操作将会在第一个 true 之后短路；也就是不会在发生 true 之后继续执行计算。 noneMatch(Predicate)：如果流的每个元素根据提供的 Predicate 都返回 false 时，结果返回为 true。这个操作将会在第一个 true 之后短路；也就是不会在发生 true 之后继续执行计算。 1boolean allMatch(Predicate&lt;? super T&gt; predicate); 元素查找 findFirst()：返回一个含有第一个流元素的 Optional，如果流为空返回 Optional.empty。 1Optional&lt;T&gt; findFirst(); findAny()：返回含有任意流元素的 Optional，如果流为空返回 Optional.empty。 1234567891011121314// streams/SelectElement.javaimport java.util.*;import java.util.stream.*;import static streams.RandInts.*;public class SelectElement &#123; public static void main(String[] args) &#123; System.out.println(rands().findFirst().getAsInt()); System.out.println( rands().parallel().findFirst().getAsInt()); System.out.println(rands().findAny().getAsInt()); System.out.println( rands().parallel().findAny().getAsInt()); &#125;&#125; 输出结果： 1234258258258242 findFirst() 无论流是否为并行化的，总是会选择流中的第一个元素。对于非并行流，findAny()会选择流中的第一个元素（即使从定义上来看是选择任意元素）。在这个例子中，我们使用 parallel() 来并行流从而引入 findAny() 选择非第一个流元素的可能性。 如果必须选择流中最后一个元素，那就使用 reduce()： 12345678910111213141516// streams/LastElement.javaimport java.util.*;import java.util.stream.*;public class LastElement &#123; public static void main(String[] args) &#123; OptionalInt last = IntStream.range(10, 20) .reduce((n1, n2) -&gt; n2); System.out.println(last.orElse(-1)); // Non-numeric object: Optional&lt;String&gt; lastobj = Stream.of(\"one\", \"two\", \"three\") .reduce((n1, n2) -&gt; n2); System.out.println( lastobj.orElse(\"Nothing there!\")); &#125;&#125; 输出结果： 1219three reduce() 的参数只是用最后一个元素替换了最后两个元素，最终只生成最后一个元素。如果为数字流，你必须使用相近的数字 Optional 类型（ numeric optional type），否则使用 Optional 类型，就像上例中的 Optional&lt;String&gt;。 信息 count()：流中的元素个数。 max(Comparator)：根据所传入的 Comparator 所决定的“最大”元素。 min(Comparator)：根据所传入的 Comparator 所决定的“最小”元素。 字符串类型有预先定义好的 Comparator，这简化了我们的示例： 123456789101112131415161718// streams/Informational.javaimport java.util.stream.*;import java.util.function.*;public class Informational &#123; public static void main(String[] args) throws Exception &#123; System.out.println( FileToWords.stream(\"Cheese.dat\").count()); System.out.println( FileToWords.stream(\"Cheese.dat\") .min(String.CASE_INSENSITIVE_ORDER) .orElse(\"NONE\")); System.out.println( FileToWords.stream(\"Cheese.dat\") .max(String.CASE_INSENSITIVE_ORDER) .orElse(\"NONE\")); &#125;&#125; 输出结果： 12332ayou min() 和 max() 的返回类型为 Optional，这需要我们使用 orElse()来解包。 数字流信息 average() ：求取流元素平均值。 max() 和 min()：因为这些操作在数字流上面，所以不需要 Comparator。 sum()：对所有流元素进行求和。 summaryStatistics()：生成可能有用的数据。目前还不太清楚他们为什么觉得有必要这样做，因为你可以使用直接的方法产生所有的数据。 123456789101112// streams/NumericStreamInfo.javaimport java.util.stream.*;import static streams.RandInts.*;public class NumericStreamInfo &#123; public static void main(String[] args) &#123; System.out.println(rands().average().getAsDouble()); System.out.println(rands().max().getAsInt()); System.out.println(rands().min().getAsInt()); System.out.println(rands().sum()); System.out.println(rands().summaryStatistics()); &#125;&#125; 输出结果： 12345507.94998850794IntSummaryStatistics&#123;count=100, sum=50794, min=8, average=507.940000, max=998&#125; 这些操作对于 LongStream 和 DoubleStream 也同样适用。 本章小结流改变并极大地提升了 Java 编程的性质，并可能极大地阻止了 Java 编程人员向诸如 Scala 这种函数式语言的流动。在本书的剩余部分，我们将尽可能地使用流。 第十五章 异常 Java 的基本理念是“结构不佳的代码不能运行”。 改进的错误恢复机制是提高代码健壮性的最强有力的方式。错误恢复在我们所编写的每一个程序中都是基本的要素，但是在 Java 中它显得格外重要，因为 Java 的主要目标之一就是创建供他人使用的程序构件。 发现错误的理想时机是在编译阶段，也就是在你试图运行程序之前。然而，编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。这就需要错误源能通过某种方式，把适当的信息传递给某个接收者——该接收者将知道如何正确处理这个问题。 要想创建健壮的系统，它的每一个构件都必须是健壮的。 Java 使用异常来提供一致的错误报告模型，使得构件能够与客户端代码可靠地沟通问题。 Java 中的异常处理的目的在于通过使用少于目前数量的代码来简化大型、可靠的程序的生成，并且通过这种方式可以使你更加确信：你的应用中没有未处理的错误。异常的相关知识学起来并非艰涩难懂，并且它属于那种可以使你的项目受益明显、立竿见影的特性之一。 基本异常可以创建一个代表错误信息的对象，并且将它从当前环境中“抛出”，这样就把错误信息传播到了“更大”的环境中。这被称为抛出一个异常，看起来像这样： 12if(t == null) throw new NullPointerException(); 异常参数与使用 Java 中的其他对象一样，我们总是用 new 在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用。所有标准异常类都有两个构造器：一个是无参构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器： 1throw new NullPointerException(\"t = null\"); 关键字 throw 将产生许多有趣的结果。在使用 new 创建了异常对象之后，此对象的引用将传给 throw。 能够抛出任意类型的 Throwable 对象，它是异常类型的根类。 异常捕获要明白异常是如何被捕获的，必须首先理解监控区域（guarded region）的概念。它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。 try 语句块如果在方法内部抛出了异常（或者在方法内部调用的其他方法抛出了异常），这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。因为在这个块里“尝试”各种（可能产生异常的）方法调用，所以称为 try 块。它是跟在 try 关键字之后的普通程序块： 123try &#123; // Code that might generate exceptions&#125; 对于不支持异常处理的程序语言，要想仔细检查错误，就得在每个方法调用的前后加上设置和错误检查的代码，甚至在每次调用同一方法时也得这么做。有了异常处理机制，可以把所有动作都放在 try 块里，然后只需在一个地方就可以捕获所有异常。这意味着你的代码将更容易编写和阅读，因为代码的意图和错误检查不是混淆在一起的。 异常处理程序异常处理程序紧跟在 try 块之后，以关键字 catch 表示： 12345678910try &#123; // Code that might generate exceptions&#125; catch(Type1 id1) &#123; // Handle exceptions of Type1&#125; catch(Type2 id2) &#123; // Handle exceptions of Type2&#125; catch(Type3 id3) &#123; // Handle exceptions of Type3&#125;// etc. 当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入 catch 子句执行，此时认为异常得到了处理。一旦 catch 子句结束，则处理程序的查找过程结束。注意，只有匹配的 catch 子句才能得到执行；这与 switch 语句不同，switch 语句需要在每一个 case 后面跟一个 break，以避免执行后续的 case 子句。 终止与恢复异常处理理论上有两种基本模型。Java 支持终止模型（它是 Java 和 C++所支持的模型）。在这种模型中，将假设错误非常严重，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。 另一种称为恢复模型。意思是异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。对于恢复模型，通常希望异常被处理之后能继续执行程序。如果想要用 Java 实现类似恢复的行为，那么在遇见错误时就不能抛出异常，而是调用方法来修正该错误。或者，把 try 块放在 while 循环里，这样就不断地进入 try 块，直到得到满意的结果。 在过去，使用支持恢复模型异常处理的操作系统的程序员们最终还是转向使用类似“终止模型”的代码，并且忽略恢复行为。所以虽然恢复模型开始显得很吸引人，但不是很实用。其中的主要原因可能是它所导致的耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码。这增加了代码编写和维护的困难，对于异常可能会从许多地方抛出的大型程序来说，更是如此。 自定义异常要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承（不过这样的异常并不容易找）。对异常来说，最重要的部分就是类名 你也许想通过写入 System.err 而将错误发送给标准错误流。通常这比把错误信息输出到 System.out 要好，因为 System.out 也许会被重定向。如果把结果送到 System.err，它就不会随 System.out 一起被重定向，这样更容易被用户注意。 既然异常也是对象的一种，所以可以继续修改这个异常类，以得到更强的功能。但要记住，使用程序包的客户端程序员可能仅仅只是查看一下抛出的异常类型，其他的就不管了（大多数 Java 库里的异常都是这么用的），所以对异常所添加的其他功能也许根本用不上。 异常声明Java 鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员。这是种优雅的做法，它使得调用者能确切知道写什么样的代码可以捕获所有潜在的异常。当然，如果提供了源代码，客户端程序员可以在源代码中查找 throw 语句来获知相关信息，然而程序库通常并不与源代码一起发布。 异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后。 异常说明使用了附加的关键字 throws，后面接一个所有潜在异常类型的列表，所以方法定义可能看起来像这样： 1void f() throws TooBig, TooSmall, DivZero &#123; // ... 但是，要是这样写： 1void f() &#123; // ... 就表示此方法不会抛出任何异常（除了从 RuntimeException 继承的异常，它们可以在没有异常说明的情况下被抛出，这些将在后面进行讨论）。 这种在编译时被强制检查的异常称为被检查的异常。 捕获所有异常可以只写一个异常处理程序来捕获所有类型的异常。通过捕获异常类型的基类 Exception，就可以做到这一点（事实上还有其他的基类，但 Exception 是所有编程行为相关的基类）： 123catch(Exception e) &#123; System.out.println(\"Caught an exception\");&#125; 这将捕获所有异常，所以最好把它放在处理程序列表的末尾，以防它抢在其他处理程序之前先把异常捕获了。 因为 Exception 是与编程有关的所有异常类的基类，所以它不会含有太多具体的信息，不过可以调用它从其基类 Throwable 继承的方法： 12String getMessage()String getLocalizedMessage() 用来获取详细信息，或用本地语言表示的详细信息。 1String toString() 返回对 Throwable 的简单描述，要是有详细信息的话，也会把它包含在内。 123void printStackTrace()void printStackTrace(PrintStream)void printStackTrace(java.io.PrintWriter) 打印 Throwable 和 Throwable 的调用栈轨迹。调用栈显示了“把你带到异常抛出地点”的方法调用序列。其中第一个版本输出到标准错误，后两个版本允许选择要输出的流（在附录 I/O 流 中，你将会理解为什么有两种不同的流）。 1Throwable fillInStackTrace() 用于在 Throwable 对象的内部记录栈帧的当前状态。这在程序重新抛出错误或异常（很快就会讲到）时很有用。 此外，也可以使用 Throwable 从其基类 Object（也是所有类的基类）继承的方法。对于异常来说，getClass）也许是个很好用的方法，它将返回一个表示此对象类型的对象。然后可以使用 getName）方法查询这个 Class 对象包含包信息的名称，或者使用只产生类名称的 getSimpleName() 方法。 下面的例子演示了如何使用 Exception 类型的方法： 123456789101112131415161718// exceptions/ExceptionMethods.java// Demonstrating the Exception Methodspublic class ExceptionMethods &#123; public static void main(String[] args) &#123; try &#123; throw new Exception(\"My Exception\"); &#125; catch(Exception e) &#123; System.out.println(\"Caught Exception\"); System.out.println( \"getMessage():\" + e.getMessage()); System.out.println(\"getLocalizedMessage():\" + e.getLocalizedMessage()); System.out.println(\"toString():\" + e); System.out.println(\"printStackTrace():\"); e.printStackTrace(System.out); &#125; &#125;&#125; 输出为： 12345678Caught ExceptiongetMessage():My ExceptiongetLocalizedMessage():My ExceptiontoString():java.lang.Exception: My ExceptionprintStackTrace():java.lang.Exception: My ExceptionatExceptionMethods.main(ExceptionMethods.java:7) 可以发现每个方法都比前一个提供了更多的信息一一实际上它们每一个都是前一个的超集。 多重捕获如果有一组具有相同基类的异常，你想使用同一方式进行捕获，那你直接 catch 它们的基类型。但是，如果这些异常没有共同的基类型，在 Java 7 之前，你必须为每一个类型编写一个 catch： 123456789101112131415161718192021222324252627// exceptions/SameHandler.javaclass EBase1 extends Exception &#123;&#125;class Except1 extends EBase1 &#123;&#125;class EBase2 extends Exception &#123;&#125;class Except2 extends EBase2 &#123;&#125;class EBase3 extends Exception &#123;&#125;class Except3 extends EBase3 &#123;&#125;class EBase4 extends Exception &#123;&#125;class Except4 extends EBase4 &#123;&#125;public class SameHandler &#123; void x() throws Except1, Except2, Except3, Except4 &#123;&#125; void process() &#123;&#125; void f() &#123; try &#123; x(); &#125; catch(Except1 e) &#123; process(); &#125; catch(Except2 e) &#123; process(); &#125; catch(Except3 e) &#123; process(); &#125; catch(Except4 e) &#123; process(); &#125; &#125;&#125; 通过 Java 7 的多重捕获机制，你可以使用“或”将不同类型的异常组合起来，只需要一行 catch 语句： 123456789101112// exceptions/MultiCatch.javapublic class MultiCatch &#123; void x() throws Except1, Except2, Except3, Except4 &#123;&#125; void f() &#123; try &#123; x(); &#125; catch(Except1 | Except2 | Except3 | Except4 e) &#123; process(); &#125; &#125;&#125; 或者以其他的组合方式： 12345678910111213// exceptions/MultiCatch2.javapublic class MultiCatch2 &#123; void x() throws Except1, Except2, Except3, Except4 &#123;&#125; void f() &#123; try &#123; x(); &#125; catch(Except1 | Except2 e) &#123; process1(); &#125; catch(Except3 | Except4 e) &#123; process2(); &#125; &#125;&#125; 这对书写更整洁的代码很有帮助。 重新抛出异常有时希望把刚捕获的异常重新抛出，尤其是在使用 Exception 捕获所有异常的时候。既然已经得到了对当前异常对象的引用，可以直接把它重新抛出： 1234catch(Exception e) &#123; System.out.println(\"An exception was thrown\"); throw e;&#125; 重抛异常会把异常抛给上一级环境中的异常处理程序，同一个 try 块的后续 catch 子句将被忽略。此外，异常对象的所有信息都得以保持，所以高一级环境中捕获此异常的处理程序可以从这个异常对象中得到所有信息。 如果只是把当前异常对象重新抛出，那么 printStackTrace() 方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息。要想更新这个信息，可以调用 filInStackTrace() 方法，这将返回一个 Throwable 对象，它是通过把当前调用栈信息填入原来那个异常对象而建立的 调用 fillInStackTrace() 的那一行就成了异常的新发生地了。 精准的重新抛出异常在 Java 7 之前，如果遇到异常，则只能重新抛出该类型的异常。这导致在 Java 7 中修复的代码不精确。所以在 Java 7 之前，这无法编译： 123456789101112class BaseException extends Exception &#123;&#125;class DerivedException extends BaseException &#123;&#125;public class PreciseRethrow &#123; void catcher() throws DerivedException &#123; try &#123; throw new DerivedException(); &#125; catch(BaseException e) &#123; throw e; &#125; &#125;&#125; 因为 catch 捕获了一个 BaseException，编译器强迫你声明 catcher() 抛出 BaseException，即使它实际上抛出了更具体的 DerivedException。从 Java 7 开始，这段代码就可以编译，这是一个很小但很有用的修复。 异常链常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。在 JDK1.4 以前，程序员必须自己编写代码来保存原始异常的信息。现在所有 Throwable 的子类在构造器中都可以接受一个 cause（因由）对象作为参数。这个 cause 就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。 有趣的是，在 Throwable 的子类中，只有三种基本的异常类提供了带 cause 参数的构造器。它们是 Error（用于 Java 虚拟机报告系统错误）、Exception 以及 RuntimeException。如果要把其他类型的异常链接起来，应该使用 initCause()方法而不是构造器。 Java 标准异常Throwable 这个 Java 类被用来表示任何可以作为异常被抛出的类。Throwable 对象可分为两种类型（指从 Throwable 继承而得到的类型）：Error 用来表示编译时和系统错误（除特殊情况外，一般不用你关心）；Exception 是可以被抛出的基本类型，在 Java 类库、用户方法以及运行时故障中都可能抛出 Exception 型异常。所以 Java 程序员关心的基类型通常是 Exception。要想对异常有全面的了解，最好去浏览一下 HTML 格式的 Java 文档（可以从 java.sun.com 下载）。为了对不同的异常有个感性的认识，这么做是值得的。但很快你就会发现，这些异常除了名称外其实都差不多。 异常的基本的概念是用名称代表发生的问题，并且异常的名称应该可以望文知意。 特例：RuntimeException在本章的第一个例子中： 12if(t == null) throw new NullPointerException(); 如果必须对传递给方法的每个引用都检查其是否为 null（因为无法确定调用者是否传入了非法引用），这听起来着实吓人。幸运的是，这不必由你亲自来做，它属于 Java 的标准运行时检测的一部分。如果对 null 引用进行调用，Java 会自动抛出 NullPointerException 异常，所以上述代码是多余的，尽管你也许想要执行其他的检查以确保 NullPointerException 不会出现。 属于运行时异常的类型有很多，它们会自动被 java 虚拟机抛出，所以不必在异常说明中把它们列出来。这些异常都是从 RuntimeException 类继承而来，所以既体现了继承的优点，使用起来也很方便。这构成了一组具有相同特征和行为的异常类型。并且，也不再需要在异常说明中声明方法将抛出 RuntimeException 类型的异常（或者任何从 RuntimeException 继承的异常），它们也被称为“不受检查异常”。这种异常属于错误，将被自动捕获，就不用你亲自动手了。要是自己去检查 RuntimeException 的话，代码就显得太混乱了。不过尽管通常不用捕获 RuntimeException 异常，但还是可以在代码中抛出 RuntimeException 类型的异常。 RuntimeException 代表的是编程错误： 无法预料的错误。比如从你控制范围之外传递进来的 null 引用。 作为程序员，应该在代码中进行检查的错误。（比如对于 ArrayIndexOutOfBoundsException，就得注意一下数组的大小了。）在一个地方发生的异常，常常会在另一个地方导致错误。 在这些情况下使用异常很有好处，它们能给调试带来便利。 使用 finally 进行清理有一些代码片段，可能会希望无论 try 块中的异常是否抛出，它们都能得到执行。这通常适用于内存回收之外的情况（因为回收由垃圾回收器完成），为了达到这个效果，可以在异常处理程序后面加上 finally 子句。完整的异常处理程序看起来像这样： 123456789101112try &#123;// The guarded region: Dangerous activities// that might throw A, B, or C&#125; catch(A a1) &#123;// Handler for situation A&#125; catch(B b1) &#123;// Handler for situation B&#125; catch(C c1) &#123;// Handler for situation C&#125; finally &#123;// Activities that happen every time&#125; 为了证明 finally 子句总能运行，可以试试下面这个程序： 123456789101112131415161718192021// exceptions/FinallyWorks.java// The finally clause is always executedclass ThreeException extends Exception &#123;&#125;public class FinallyWorks &#123; static int count = 0; public static void main(String[] args) &#123; while(true) &#123; try &#123; // Post-increment is zero first time: if(count++ == 0) throw new ThreeException(); System.out.println(\"No exception\"); &#125; catch(ThreeException e) &#123; System.out.println(\"ThreeException\"); &#125; finally &#123; System.out.println(\"In finally clause\"); if(count == 2) break; // out of \"while\" &#125; &#125; &#125;&#125; 输出为： 1234ThreeExceptionIn finally clauseNo exceptionIn finally clause 可以从输出中发现，无论异常是否被抛出，finally 子句总能被执行。这个程序也给了我们一些思路，当 Java 中的异常不允许我们回到异常抛出的地点时，那么该如何应对呢？如果把 try 块放在循环里，就建立了一个“程序继续执行之前必须要达到”的条件。还可以加入一个 static 类型的计数器或者别的装置，使循环在放弃以前能尝试一定的次数。这将使程序的健壮性更上一个台阶。 finally 用来做什么？对于没有垃圾回收和析构函数自动调用机制的语言来说，finally 非常重要。它能使程序员保证：无论 try 块里发生了什么，内存总能得到释放。但 Java 有垃圾回收机制，所以内存释放不再是问题。而且，Java 也没有析构函数可供调用。那么，Java 在什么情况下才能用到 finally 呢？ 当要把除内存之外的资源恢复到它们的初始状态时，就要用到 finally 子句。这种需要清理的资源包括：已经打开的文件或网络连接，在屏幕上画的图形，甚至可以是外部世界的某个开关 涉及 break 和 continue 语句的时候，finally 子句也会得到执行。请注意，如果把 finally 子句和带标签的 break 及 continue 配合使用，在 Java 里就没必要使用 goto 语句了。 在 return 中使用 finally因为 finally 子句总是会执行，所以可以从一个方法内的多个点返回，仍然能保证重要的清理工作会执行： 1234567891011121314151617181920212223// exceptions/MultipleReturns.javapublic class MultipleReturns &#123; public static void f(int i) &#123; System.out.println( \"Initialization that requires cleanup\"); try &#123; System.out.println(\"Point 1\"); if(i == 1) return; System.out.println(\"Point 2\"); if(i == 2) return; System.out.println(\"Point 3\"); if(i == 3) return; System.out.println(\"End\"); return; &#125; finally &#123; System.out.println(\"Performing cleanup\"); &#125; &#125; public static void main(String[] args) &#123; for(int i = 1; i &lt;= 4; i++) f(i); &#125;&#125; 输出为： 123456789101112131415161718Initialization that requires cleanupPoint 1Performing cleanupInitialization that requires cleanupPoint 1Point 2Performing cleanupInitialization that requires cleanupPoint 1Point 2Point 3Performing cleanupInitialization that requires cleanupPoint 1Point 2Point 3EndPerforming cleanup 从输出中可以看出，从何处返回无关紧要，finally 子句永远会执行。 缺憾：异常丢失遗憾的是，Java 的异常实现也有瑕疵。异常作为程序出错的标志，决不应该被忽略，但它还是有可能被轻易地忽略。用某些特殊的方式使用 finally 子句，就会发生这种情况： 12345678910111213141516171819202122232425262728293031323334// exceptions/LostMessage.java// How an exception can be lostclass VeryImportantException extends Exception &#123; @Override public String toString() &#123; return \"A very important exception!\"; &#125;&#125;class HoHumException extends Exception &#123; @Override public String toString() &#123; return \"A trivial exception\"; &#125;&#125;public class LostMessage &#123; void f() throws VeryImportantException &#123; throw new VeryImportantException(); &#125; void dispose() throws HoHumException &#123; throw new HoHumException(); &#125; public static void main(String[] args) &#123; try &#123; LostMessage lm = new LostMessage(); try &#123; lm.f(); &#125; finally &#123; lm.dispose(); &#125; &#125; catch(VeryImportantException | HoHumException e) &#123; System.out.println(e); &#125; &#125;&#125; 输出为： 1A trivial exception 从输出中可以看到，VeryImportantException 不见了，它被 finally 子句里的 HoHumException 所取代。这是相当严重的缺陷，因为异常可能会以一种比前面例子所示更微妙和难以察党的方式完全丢失。相比之下，C++把“前一个异常还没处理就抛出下一个异常”的情形看成是糟糕的编程错误。也许在 Java 的未来版本中会修正这个问题（另一方面，要把所有抛出异常的方法，如上例中的 dispose() 方法，全部打包放到 try-catch 子句里面）。 一种更加简单的丢失异常的方式是从 finally 子句中返回： 123456789101112// exceptions/ExceptionSilencer.javapublic class ExceptionSilencer &#123; public static void main(String[] args) &#123; try &#123; throw new RuntimeException(); &#125; finally &#123; // Using 'return' inside the finally block // will silence any thrown exception. return; &#125; &#125;&#125; 如果运行这个程序，就会看到即使方法里抛出了异常，它也不会产生任何输出。 异常限制当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。（&lt;= 基类） 派生类构造器不能捕获基类构造器抛出的异常。 尽管在继承过程中，编译器会对异常说明做强制要求，但异常说明本身并不属于方法类型的一部分，方法类型是由方法的名字与参数的类型组成的。因此，不能基于异常说明来重载方法。此外，一个出现在基类方法的异常说明中的异常，不一定会出现在派生类方法的异常说明里。这点同继承的规则明显不同，在继承中，基类的方法必须出现在派生类里，换句话说，在继承和覆盖的过程中，某个特定方法的“异常说明的接口”不是变大了而是变小了——这恰好和类接口在继承时的情形相反。 构造器构造器会把对象设置成安全的初始状态，但还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能得以清理。如果在构造器内抛出了异常，这些清理行为也许就不能正常工作了。这意味着在编写构造器时要格外细心。 你也许会认为使用 finally 就可以解决问题。但问题并非如此简单，因为 finally 会每次都执行清理代码。如果构造器在其执行过程中半途而废，也许该对象的某些部分还没有被成功创建，而这些部分在 finaly 子句中却是要被清理的。 Java 的缺陷：除了内存的清理之外，所有的清理都不会自动发生。所以必须告诉客户端程序员，这是他们的责任。 Try-With-Resources 用法1234It is a compile-time error if final appears more than once as a modifier for each variable declared in a resource specification.A variable declared in a resource specification is implicitly declared final (§4.12.4) if it is not explicitly declared final. 意思就是，try-with-resource中声明的变量会隐式的加上final 关键字，所以无法再进行赋值。但是至于为什么这么设计，我暂时没找到答案。 Java 7 引入了 try-with-resources 语法 123456789101112131415// exceptions/TryWithResources.javaimport java.io.*;public class TryWithResources &#123; public static void main(String[] args) &#123; try( InputStream in = new FileInputStream( new File(\"TryWithResources.java\")) ) &#123; int contents = in.read(); // Process contents &#125; catch(IOException e) &#123; // Handle the error &#125; &#125;&#125; 在 Java 7 之前，try 总是后面跟着一个 {，但是现在可以跟一个带括号的定义 - 这里是我们创建的 FileInputStream 对象。括号内的部分称为资源规范头（resource specification header）。现在可用于整个 try 块的其余部分。更重要的是，无论你如何退出 try 块（正常或异常），都会执行前一个 finally 子句的等价物，但不会编写那些杂乱而棘手的代码。 它是如何工作的？在 try-with-resources 定义子句中创建的对象（在括号内）必须实现 java.lang.AutoCloseable 接口，这个接口有一个方法：close()。当在 Java 7 中引入 AutoCloseable 时，许多接口和类被修改以实现它；查看 Javadocs 中的 AutoCloseable，可以找到所有实现该接口的类列表，其中包括 Stream 对象： 1234567891011121314151617181920// exceptions/StreamsAreAutoCloseable.javaimport java.io.*;import java.nio.file.*;import java.util.stream.*;public class StreamsAreAutoCloseable &#123; public static void main(String[] args) throws IOException&#123; try( Stream&lt;String&gt; in = Files.lines( Paths.get(\"StreamsAreAutoCloseable.java\")); PrintWriter outfile = new PrintWriter( \"Results.txt\"); // [1] ) &#123; in.skip(5) .limit(1) .map(String::toLowerCase) .forEachOrdered(outfile::println); &#125; // [2] &#125;&#125; [1] 你在这里可以看到其他的特性：资源规范头中可以包含多个定义，并且通过分号进行分割（最后一个分号是可选的）。规范头中定义的每个对象都会在 try 语句块运行结束之后调用 close() 方法。 [2] try-with-resources 里面的 try 语句块可以不包含 catch 或者 finally 语句而独立存在。在这里，IOException 被 main() 方法抛出，所以这里并不需要在 try 后面跟着一个 catch 语句块。 Java 5 中的 Closeable 已经被修改，修改之后的接口继承了 AutoCloseable 接口。所以所有实现了 Closeable 接口的对象，都支持了 try-with-resources 特性。 异常匹配抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。 查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序 其他可选方式异常处理的一个重要原则是“只有在你知道如何处理的情况下才捕获异常”。实际上，异常处理的一个重要目标就是把错误处理的代码同错误发生的地点相分离。 “被检查的异常”使这个问题变得有些复杂，因为它们强制你在可能还没准备好处理错误的时候被迫加上 catch 子句，这就导致了吞食则有害（harmful if swallowed）的问题： 123try &#123; // ... to do something useful&#125; catch(ObligatoryException e) &#123;&#125; // Gulp! 程序员们只做最简单的事情，常常是无意中”吞食”了异常，然而一旦这么做，虽然能通过编译，但除非你记得复查并改正代码，否则异常将会丢失。异常确实发生了，但“吞食”后它却完全消失了。因为编译器强迫你立刻写代码来处理异常，所以这种看起来最简单的方法，却可能是最糟糕的做法。 是因为我们使用的工具已经不是 ANS1 标准出台前的像 C 那样的弱类型语言，而是像 C++ 和 Java 这样的“强静态类型语言”（也就是编译时就做类型检查的语言），这是前者所无法比拟的。当刚开始这种转变的时候（就像我一样），会觉得它带来的好处是那样明显，好像类型检查总能解决所有的问题。在此，我想结合我自己的认识过程，告诉读者我是怎样从对类型检查的绝对迷信变成持怀疑态度的，当然，很多时候它还是非常有用的，但是当它挡住我们的去路并成为障碍的时候，我们就得跨过去。只是这条界限往往并不是很清晰（我最喜欢的一句格言是：所有模型都是错误的，但有些是能用的）。 观点首先，Java 无谓地发明了“被检查的异常”（很明显是受 C++ 异常说明的启发，以及受 C++ 程序员们一般对此无动于衷的事实的影响），但是，这还只是一次尝试，目前为止还没有别的语言采用这种做法。 过去，我曾坚定地认为“被检查的异常”和强静态类型检查对开发健壮的程序是非常必要的。但是，我看到的以及我使用一些动态（类型检查）语言的亲身经历告诉我，这些好处实际上是来自于： 不在于编译器是否会强制程序员去处理错误，而是要有一致的、使用异常来报告错误的模型。 不在于什么时候进行检查，而是一定要有类型检查。也就是说，必须强制程序使用正确的类型，至于这种强制施加于编译时还是运行时，那倒没关系。 此外，减少编译时施加的约束能显著提高程序员的编程效率。事实上，反射和泛型就是用来补偿静态类型检查所带来的过多限制，在本书很多例子中都会见到这种情形。 把异常传递给控制台对于简单的程序，比如本书中的许多例子，最简单而又不用写多少代码就能保护异常信息的方法，就是把它们从 main() 传递到控制台。例如，为了读取信息而打开一个文件（在第 12 章将详细介绍），必须对 FilelnputStream 进行打开和关闭操作，这就可能会产生异常。对于简单的程序，可以像这样做（本书中很多地方采用了这种方法）： 123456789101112// exceptions/MainException.javaimport java.util.*;import java.nio.file.*;public class MainException &#123; // Pass exceptions to the console: public static void main(String[] args) throws Exception &#123; // Open the file: List&lt;String&gt; lines = Files.readAllLines( Paths.get(\"MainException.java\")); // Use the file ... &#125;&#125; 注意，main() 作为一个方法也可以有异常说明，这里异常的类型是 Exception，它也是所有“被检查的异常”的基类。通过把它传递到控制台，就不必在 main() 里写 try-catch 子句了。 把“被检查的异常”转换为“不检查的异常”在编写你自己使用的简单程序时，从主方法中抛出异常是很方便的，但这不是通用的方法。 问题的实质是，当在一个普通方法里调用别的方法时，要考虑到“我不知道该这样处理这个异常，但是也不想把它‘吞’了，或若打印一些无用的消息”。异常链提供了一种新的思路来解决这个问题。可以直接把“被检查的异常”包装进 RuntimeException 里面，就像这样： 12345try &#123; // ... to do something useful&#125; catch(IDontKnowWhatToDoWithThisCheckedException e) &#123; throw new RuntimeException(e);&#125; 如果想把“被检查的异常”这种功能“屏蔽”掉的话，这看上去像是一个好办法。不用“吞下”异常，也不必把它放到方法的异常说明里面，而异常链还能保证你不会丢失任何原始异常的信息。 这种技巧给了你一种选择，你可以不写 try-catch 子句和/或异常说明，直接忽路异常，让它自己沿着调用栈往上“冒泡”，同时，还可以用 getCause() 捕获并处理特定的异常，就像这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// exceptions/TurnOffChecking.java// \"Turning off\" Checked exceptionsimport java.io.*;class WrapCheckedException &#123; void throwRuntimeException(int type) &#123; try &#123; switch(type) &#123; case 0: throw new FileNotFoundException(); case 1: throw new IOException(); case 2: throw new RuntimeException(\"Where am I?\"); default: return; &#125; &#125; catch(IOException | RuntimeException e) &#123; // Adapt to unchecked: throw new RuntimeException(e); &#125; &#125;&#125;class SomeOtherException extends Exception &#123;&#125;public class TurnOffChecking &#123; public static void main(String[] args) &#123; WrapCheckedException wce = new WrapCheckedException(); // You can call throwRuntimeException() without // a try block, and let RuntimeExceptions // leave the method: wce.throwRuntimeException(3); // Or you can choose to catch exceptions: for(int i = 0; i &lt; 4; i++) try &#123; if(i &lt; 3) wce.throwRuntimeException(i); else throw new SomeOtherException(); &#125; catch(SomeOtherException e) &#123; System.out.println( \"SomeOtherException: \" + e); &#125; catch(RuntimeException re) &#123; try &#123; throw re.getCause(); &#125; catch(FileNotFoundException e) &#123; System.out.println( \"FileNotFoundException: \" + e); &#125; catch(IOException e) &#123; System.out.println(\"IOException: \" + e); &#125; catch(Throwable e) &#123; System.out.println(\"Throwable: \" + e); &#125; &#125; &#125;&#125; 输出为： 1234FileNotFoundException: java.io.FileNotFoundExceptionIOException: java.io.IOExceptionThrowable: java.lang.RuntimeException: Where am I?SomeOtherException: SomeOtherException WrapCheckedException.throwRuntimeException() 的代码可以生成不同类型的异常。这些异常被捕获并包装进了 RuntimeException 对象，所以它们成了这些运行时异常的”cause”了。 在 TurnOfChecking 里，可以不用 try 块就调用 throwRuntimeException()，因为它没有抛出“被检查的异常”。但是，当你准备好去捕获异常的时候，还是可以用 try 块来捕获任何你想捕获的异常的。应该捕获 try 块肯定会抛出的异常，这里就是 SomeOtherException，RuntimeException 要放到最后去捕获。然后把 getCause() 的结果（也就是被包装的那个原始异常）抛出来。这样就把原先的那个异常给提取出来了，然后就可以用它们自己的 catch 子句进行处理。 本书余下部分将会在合适的时候使用这种“用 RuntimeException 来包装，被检查的异常”的技术。另一种解决方案是创建自己的 RuntimeException 的子类。在这种方式中，不必捕获它，但是希望得到它的其他代码都可以捕获它。 异常指南应该在下列情况下使用异常： 尽可能使用 try-with-resource。 在恰当的级别处理问题。（在知道该如何处理的情况下才捕获异常。） 解决问题并且重新调用产生异常的方法。 进行少许修补，然后绕过异常发生的地方继续执行。 用别的数据进行计算，以代替方法预计会返回的值。 把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。 终止程序。 进行简化。（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人。） 让类库和程序更安全。（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资。） 本章小结异常是 Java 程序设计不可分割的一部分，如果不了解如何使用它们，那你只能完成很有限的工作。正因为如此，本书专门在此介绍了异常——对于许多类库（例如提到过的 I/O 库），如果不处理异常，你就无法使用它们。 异常处理的优点之一就是它使得你可以在某处集中精力处理你要解决的问题，而在另一处处理你编写的这段代码中产生的错误。尽管异常通常被认为是一种工具，使得你可以在运行时报告错误并从错误中恢复，但是我一直怀疑到底有多少时候“恢复”真正得以实现了，或者能够得以实现。我认为这种情况少于 10%，并且即便是这 10%，也只是将栈展开到某个已知的稳定状态，而并没有实际执行任何种类的恢复性行为。无论这是否正确，我一直相信“报告”功能是异常的精髓所在. Java 坚定地强调将所有的错误都以异常形式报告的这一事实，正是它远远超过语如 C++ 这类语言的长处之一，因为在 C++ 这类语言中，需要以大量不同的方式来报告错误，或者根本就没有提供错误报告功能。一致的错误报告系统意味着，你再也不必对所写的每一段代码，都质问自己“错误是否正在成为漏网之鱼？”（只要你没有“吞咽”异常，这是关键所在！）。","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"}]},{"title":"pythonMongoDb","slug":"python/PythonMongoDb","date":"2019-11-14T14:19:09.000Z","updated":"2021-10-23T02:19:04.267Z","comments":true,"path":"2019/11/python/PythonMongoDb/","link":"","permalink":"https://codeofli.github.io/2019/11/python/PythonMongoDb/","excerpt":"[TOC]python操作mongodb菜鸟教程官方中文文档连接mongodb12345678#!/usr/bin/env python# -*- coding:utf-8 -*-from pymongo import MongoClientconn = MongoClient('192.168.0.113', 27017)db = conn.mydb #连接mydb数据库，没有则自动创建my_set = db.test_set #使用test_set集合，没有则自动创建","text":"[TOC]python操作mongodb菜鸟教程官方中文文档连接mongodb12345678#!/usr/bin/env python# -*- coding:utf-8 -*-from pymongo import MongoClientconn = MongoClient('192.168.0.113', 27017)db = conn.mydb #连接mydb数据库，没有则自动创建my_set = db.test_set #使用test_set集合，没有则自动创建 插入数据查询数据https://www.runoob.com/python3/python-mongodb-query-document.html 查询一条数据我们可以使用 find_one() 方法来查询集合中的一条数据。 1234567891011#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] x = mycol.find_one() print(x) 查询集合中所有数据find() 方法可以查询集合中的所有数据，类似 SQL 中的 SELECT * 操作。 以下实例查找 sites 集合中的所有数据： 12345678910#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] for x in mycol.find(): print(x) $exists查找字段是否存在判断字段是否存在 1db.users.find(&#123;age: &#123;\"$exists\": True&#125;&#125;); $or1&#123; $or: [ &#123; &lt;expression1&gt; &#125;, &#123; &lt;expression2&gt; &#125;, ... , &#123; &lt;expressionN&gt; &#125; ] &#125; 1db.inventory.find( &#123; $or: [ &#123; quantity: &#123; $lt: 20 &#125; &#125;, &#123; price: 10 &#125; ] &#125; ) $ne不等于查询x 的值不等于3 的数据 12query = &#123;Problem.DATA_STATUS: &#123;\"$ne\": StateValue.FILE_SUCCESS&#125;&#125;mongo_util.problem_collection.find(query) 举例如下: C1 表的数据如下: 1234&gt; db.c1.find()&#123; \"_id\" : ObjectId(\"4fb4af85afa87dc1bed94330\"), \"age\" : 7, \"length_1\" : 30 &#125;&#123; \"_id\" : ObjectId(\"4fb4af89afa87dc1bed94331\"), \"age\" : 8, \"length_1\" : 30 &#125;&#123; \"_id\" : ObjectId(\"4fb4af8cafa87dc1bed94332\"), \"age\" : 6, \"length_1\" : 30 &#125; 查询age 的值不等于7 的数据 123&gt; db.c1.find( &#123; age : &#123; $ne : 7 &#125; &#125; );&#123; \"_id\" : ObjectId(\"4fb4af89afa87dc1bed94331\"), \"age\" : 8, \"length_1\" : 30 &#125;&#123; \"_id\" : ObjectId(\"4fb4af8cafa87dc1bed94332\"), \"age\" : 6, \"length_1\" : 30 &#125; 可以看出只显示出了age 不等于7 的数据，其它不符合规则的数据并没有显示出来 在users文档中查询”age”不等于20的记录： 1db.users.find(&#123;age:&#123;$ne:20&#125;&#125;); 高级查询查询的条件语句中，我们还可以使用修饰符。 以下实例用于读取 name 字段中第一个字母 ASCII 值大于 “H” 的数据，大于的修饰符条件为 {“$gt”: “H”} : 1234567891011121314#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] myquery = &#123; \"name\": \"RUNOOB\" &#125; mydoc = mycol.find(myquery) for x in mydoc: print(x) 使用正则表达式查询我们还可以使用正则表达式作为修饰符。 正则表达式修饰符只用于搜索字符串的字段。 以下实例用于读取 name 字段中第一个字母为 “R” 的数据，正则表达式修饰符条件为 {“$regex”: “^R”} : 1234567891011121314#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] myquery = &#123; \"name\": &#123; \"$regex\": \"^R\" &#125; &#125; mydoc = mycol.find(myquery) for x in mydoc: print(x) 返回指定条数记录如果我们要对查询结果设置指定条数的记录可以使用 limit() 方法，该方法只接受一个数字参数。 计数count1problem_table.count_documents(query) 123query = &#123;\"id\": &#123;\"$regex\": \"^\" + tag_dict[name]&#125;&#125;print(query)query_cnt = problem_table.count_documents(query) 查询值为Null或不存在的字段The { name : null } query matches documents that either contain the name field whose value is null or that do not contain the name field. 给出如下查询: 1db.users.find( &#123; name: null &#125; ) 更新数据https://www.runoob.com/python3/python-mongodb-update-document.html 1234567891011121314import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] myquery = &#123; \"alexa\": \"10000\" &#125;newvalues = &#123; \"$set\": &#123; \"alexa\": \"12345\" &#125; &#125; mycol.find_one_update(myquery, newvalues) # 输出修改后的 \"sites\" 集合for x in mycol.find(): print(x) 删除字段1db.yourcollection.update_one(&#123;&#125;, &#123;\"$unset\": &#123;\"name\": \"\"&#125;&#125;) 1db.yourcollection.update_many(&#123;&#125;, &#123;\"$unset\": &#123;\"name\": \"\"&#125;&#125;) 添加字段直接使用update即可 1test_collection.update_one(&#123;\"id\":\"test1\"&#125;, &#123;\"$set\": &#123;\"new_field\": \"xxx\"&#125;&#125;) 删除数据排序sort() 方法可以指定升序或降序排序。 sort() 方法第一个参数为要排序的字段，第二个字段指定排序规则，1 为升序，-1 为降序，默认为升序。 对字段 alexa 按升序排序： 1234567891011#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] mydoc = mycol.find().sort(\"alexa\")for x in mydoc: print(x)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/tags/python/"}]},{"title":"docker","slug":"docker/docker","date":"2019-11-12T07:39:56.000Z","updated":"2021-10-29T11:14:13.096Z","comments":true,"path":"2019/11/docker/docker/","link":"","permalink":"https://codeofli.github.io/2019/11/docker/docker/","excerpt":"[TOC]1.简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术；Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；运行中的这个镜像称为容器，容器启动是非常快速的。2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；","text":"[TOC]1.简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术；Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；运行中的这个镜像称为容器，容器启动是非常快速的。2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(docker)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤：(安装不成功可以到菜鸟教程安装) 1、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker 1sudo apt install docker.io 3、输入y确认安装4、启动docker 123[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.6 5、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 操作 命令 说明 运行 docker run –name container-name -d image-nameeg:docker run –name myredis –d redis– –name：自定义容器名-d：后台运行image-name:指定镜像模板 列表 docker ps（查看运行中的容器）； 加上-a；可以查看所有容器 启动 docker start container-name/container-id 启动容器 停止 docker stop container-name/container-id 停止当前你运行的容器 删除 docker rm container-id 删除指定容器 端口映射 -p 6379:6379eg:docker run -d -p 6379:6379 –name myredisdocker.io/redis -p:主机端口(映射到)容器内部的端口 容器日志 docker logs container-name/container-id 更多命令 https://docs.docker.com/engine/reference/commandline/docker/ 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 使用进入容器Bash1docker exec -it containerID bash 将本地sql文件导入容器1sudo docker cp /home/ubuntu/yoj.sql(文件路径) mysql(容器名):/home/tmp/yoj.txt(容器文件保存路径+文件名) docker cp 第一个参数指定本地文件或者文件夹，第二个参数指定容器及容器内的目标文件夹 1sudo docker cp /home/ubuntu/yoj.sql mysql:/home Docker-Mysql安装MySQL示例123docker pull mysql#mysql 版本最好在5.7左右，不然navicat连不上[root@MiWiFi-R3A-srv ~]# docker pull mysql:5.7.27 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql \"docker-entrypoint.sh\" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 123456[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlnicolas@iZuf6i77uwsb2oiszspgvkZ:/home/admin$ sudo docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.27b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 1234567[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlnicolas@iZuf6i77uwsb2oiszspgvkZ:/home/admin$ sudo docker run -p 3306:3306 --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.27ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 1234567891011docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数#创建mysql容器+character-setdocker run -p 3306:3306 --name mysql03 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.27 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_cidocker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=db123456 --name mysql -e TZ=Asia/Shanghai mysql:5.7 1234567891011-e TZ=Asia/Shanghai 时区修改为中国时区-p 3306：3306：将容器的3306端口映射到主机的3306端口-v $ PWD / conf / my.cnf：/etc/mysql/my.cnf：将主机当前目录下的conf / my.cnf挂载到容器的/etc/mysql/my.cnf-v $ PWD / logs：/ logs：将主机当前目录下的日志目录挂载到容器的/ logs-v $ PWD / data：/ mysql_data：将主机当前目录下的数据目录挂载到容器的/ mysql_data-e MYSQL_ROOT_PASSWORD = 123456：初始化 root用户的密码 修改时区和字符集 1docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -e TZ=Asia/Shanghai -d mysql:5.7.27 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 安装mysql之后进行操作3.进入容器bash并进入mysql命令行： 1ubuntu@VM-0-5-ubuntu:/etc/apt$ sudo docker exec -it mysql02 bash Docker容器启动的时候，如果要挂载宿主机的一个目录，可以用-v参数指定。 譬如我要启动一个centos容器，宿主机的/test目录挂载到容器的/soft目录，可通过以下方式指定： 12docker run -it -v /test:/soft centos /bin/bashdocker run -it -v /hmoe/ubuntu:/tmp mysql02 /bin/bash mysql使用12sudo docker run -p 3306:3306 --name mysql8 -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0.23 --character-set-server=utf8 --collation-server=utf8_unicode_ci –name: 容器名 MySql 导入 *.sql文件1.将本地sql文件导入容器1sudo docker cp /home/ubuntu/yoj.sql(文件路径) mysql(容器名):/home/tmp/yoj.txt(容器文件保存路径+文件名) docker cp 第一个参数指定本地文件或者文件夹，第二个参数指定容器及容器内的目标文件夹 1sudo docker cp /home/ubuntu/yoj.sql mysql8:/home 登入容器内MYSQL执行sqlcommand format 1docker exec -it (mysql-container-name)[xxx] (in mysql command)[mysql -uroot -p123456] 12docker exec -it bteye-mysql mysql -uroot -p123456docker exec -it mysql8 mysql -uroot -p 执行sql文件 1source /home/yoj.sql 2.进入数据库容器1docker exec -it containerID bash 数据库导入 12345678910mysql -h localhost -u root -p（进入mysql下面）create database abc;(创建数据库)show databases;(就可看到所有已经存在的数据库，以及刚刚创建的数据库abc)use abc;(进入abc数据库下面)show tables;(产看abc数据库下面的所有表,空的)source /var/test.sql（导入数据库表）show tables;(查看abc数据库下面的所有表,就可以看到表了)desc pollution;(查看表结构设计)select * from pollution;exit(或者ctrl + c)退出mysql 修改 Docker 中 MySQL 容器的编码https://blog.csdn.net/m0_37639542/article/details/72852875 1.查看字符集 1SHOW VARIABLES LIKE &apos;character_set_%&apos;;//查看数据库字符集 更新之后记得重启mysql服务 1service mysql restart 1. 进入MySQL容器1docker exec -it my-space-mysql /bin/bash 2. 备份当前 my.cnf 文件1mv /etc/mysql/my.cnf /etc/mysql/my.cnf.bak 3. 退出容器1exit 4. 在服务器创建配置文件(my.cnf)12345[client]default-character-set=utf8[mysqld]character-set-server=utf8collation-server=utf8_general_ci 5. 查看容器长ID1docker inspect -f '&#123;&#123;.ID&#125;&#125;' my-space-mysql my-space-mysql是容器的名称 6. 上传文件到容器1docker cp my.cnf &lt;容器长ID&gt;:/etc/mysql 7. 自行登录容器查看并提出容器8. 重启docker12docker stop my-space-mysqldocker start my-space-mysql 9. 查看数据库编码 进入数据库执行 1status 备份数据库1sudo docker exec -it mysql mysqldump -uroot -p123456 yoj &gt; /home/ubuntu/sql_bak/yoj_db.sql mysql使用mysqldump定时备份数据库https://www.jianshu.com/p/be1e581acb8e 3、数据库备份脚本功能：mysql 每天定时备份， 并删除7天以前的备份mysql_dumps.sh： 12345678910#!/bin/bashdocker_name = mysql57data_dir=\"/path/to/save/data/\"sudo docker exec -it $&#123;docker_name&#125; mysqldump -uroot -ppasswd --all-databases &gt; \"$data_dir/data_`date +%Y%m%d`.sql\"#if [ $? -ne 0 ];then # 任务失败，发送邮件# echo -e \"邮件正文\" | mail -s '标题' 123456@gmail.com# exit -1#fifind $data_dir -mtime +7 -name 'data_[1-9].sql' -exec rm -rf &#123;&#125; \\; my_version 1234#!/bin/bashdata_dir=\"/path/to/save/data/\"sudo docker exec mysql mysqldump -uroot -ppasswd --all-databases &gt; \"$data_dir/data_`date +%Y%m%d`.sql\"find $data_dir -mtime +7 -name 'data_[1-9].sql' -exec rm -rf &#123;&#125; \\; 4、通过linux cron设置定时任务crontab -e： 10 2 * * * sh /home/ubuntu/sql_bak/mysql_dumps.sh &gt; /home/ubuntu/sql_bak/mysql_dumps.log 2&gt;&amp;1 设置每分钟测试 1* * * * * sh /home/ubuntu/sql_bak/mysql_dumps.sh &gt; /home/ubuntu/sql_bak/mysql_dumps.log 2&gt;&amp;1 安装redis1runoob@runoob:~$ mkdir -p ~/redis ~/redis/data 1sudo docker run -p 6379:6379 -v $PWD/data:/data -d redis redis-server --appendonly yes 命令说明： -p 6379:6379 : 将容器的6379端口映射到主机的6379端口 -v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data redis-server –appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 连接、查看容器使用redis镜像执行redis-cli命令连接到刚启动的容器,主机IP为172.17.0.1 123456789101112runoob@runoob:~/redis$ docker exec -it 43f7a65ec7f8 redis-cli172.17.0.1:6379&gt; info# Serverredis_version:3.2.0redis_git_sha1:00000000redis_git_dirty:0redis_build_id:f449541256e7d446redis_mode:standaloneos:Linux 4.2.0-16-generic x86_64arch_bits:64multiplexing_api:epoll... 1docker exec -it 239fadb88042 redis-cli 官方文档配置文件映射Alternatively, you can specify something along the same lines with docker run options. 1$ docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name myredis redis redis-server /usr/local/etc/redis/redis.conf Where /myredis/conf/ is a local directory containing your redis.conffile. Using this method means that there is no need for you to have a Dockerfile for your redis container. 其他1docker run -d --privileged=true -p 6379:6379 --restart always -v /root/docker/redis/conf/redis.conf:/etc/redis/redis.conf -v /root/docker/redis/data:/data --name myredis redis redis-server /etc/redis/redis.conf --appendonly yes 12345678-d -&gt; 以守护进程的方式启动容器-p 6379:6379 -&gt; 绑定宿主机端口--name myredis -&gt; 指定容器名称--restart always -&gt; 开机启动--privileged=true -&gt; 提升容器内权限-v /root/docker/redis/conf:/etc/redis/redis.conf -&gt; 映射配置文件-v /root/docker/redis/data:/data -&gt; 映射数据目录--appendonly yes -&gt; 开启数据持久化","categories":[{"name":"note","slug":"note","permalink":"https://codeofli.github.io/categories/note/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://codeofli.github.io/tags/docker/"}]},{"title":"linux","slug":"linux/linux","date":"2019-11-12T06:20:26.000Z","updated":"2021-10-30T02:45:20.322Z","comments":true,"path":"2019/11/linux/linux/","link":"","permalink":"https://codeofli.github.io/2019/11/linux/linux/","excerpt":"[TOC]linux入门VM和Linux系统(CentOS)安装3.1安装vm和Centos学习Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习。1)先安装virtualmachine,vm122)再安装Linux(CentOS6.8)3)原理示意图，这里我们画图说明一下VM和CentOS的关系。","text":"[TOC]linux入门VM和Linux系统(CentOS)安装3.1安装vm和Centos学习Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习。1)先安装virtualmachine,vm122)再安装Linux(CentOS6.8)3)原理示意图，这里我们画图说明一下VM和CentOS的关系。 3.3VM安装的步骤 1)去BIOS里修改设置开启虚拟化设备支持（f2,f10） 2)安装虚拟机软件（vm12）看老师的具体演示：因为老师的电脑上已经安装了VM12，因此我先卸载然后再安装。 3.4CentOS安装的步骤 1)创建虚拟机(空间)这里在配置网络连接时，有三种形式，需要大家伙注意： CentOS的终端使用和联网1)终端的使用，点击鼠标右键，即可选择打开终端 2)配置网络，可以上网。点击上面右侧的；两个计算机图片，选择启用eth0,即可成功连接到网络，就可以上网。 vmtools的安装和使用3.7.1安装vmtools的步骤说明 1.进入centos 2.点击vm菜单的-&gt;installvmwaretools 3.centos会出现一个vm的安装包 4.点击右键解压,得到一个安装文件 5.进入该vm解压的目录，该文件在/root/桌面/vmware-tools-distrib/下 6.安装./vmware-install.pl 7.全部使用默认设置即可8.需要reboot重新启动即可生效 3.7.2使用vmtools来设置windows和linux的共享文件夹 1)菜单-&gt;vm-&gt;setting,如图设置即可注意:设置选项为alwaysenable,这样可以读写了 2)windows和centos可共享d:/share目录可以读写文件了 3)在centos的/mnt/hgfs/下 Linux的目录结构4.1基本介绍 linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。深刻理解linux树状文件目录是非常重要的，这里我给大家说明一下。 记住一句经典的话：==在Linux世界里，一切皆文件。== 具体的目录结构: /bin [重点] (/usr/bin、/usr/local/bin) •是Binary的缩写, 这个目录存放着最经常使用的命令 /home [重点] •存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /root [重点] •该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin(/usr/sbin、/usr/local/sbin) •s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /lib •系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found •这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /etc [重点](etcetera,等等) •所有的系统管理所需要的配置文件和子目录my.conf /usr [重点] •这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。 /boot [重点] •存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 /srv •service缩写，该目录存放一些服务启动之后需要提取的数据。 /sys •这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs /tmp •这个目录是用来存放一些临时文件的。 /dev •类似于windows的设备管理器，把所有的硬件用文件的形式存储。 /media [重点] •linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt [重点] •系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。d:/myshare /var [重点] •这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。 /opt •这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。 /usr/local [重点] •这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序 /selinux [security-enhanced linux] 360 •SELinux是一种安全子系统,它能控制程序只能访问特定文件。 Linux目录总结1)linux的目录中有且只要一个根目录/2)linux的各个目录存放的内容是规划好，不用乱放文件。3)linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。 4)linux的各个文件目录下存放什么内容，大家必须有一个认识。5)学习后，你脑海中应该有一颗linux目录树 远程登录Linux系统5.1为什么需要远程登录Linux 5.1.1示意图 为什么需要远程登录Linux说明: 公司开发时候，具体的情况是这样的 1) linux服务器是开发小组共享的.2) 正式上线的项目是运行在公网的.3) 因此程序员需要远程登录到centos进行项目管理或者开发.4) 画出简单的网络拓扑示意图(帮助理解)5) 远程登录客户端有Xshell5，Xftp5 , 我们学习使用Xshell5 和Xftp , 其它的远程工具大同小异. 远程登录Linux-Xshell5介绍: 说明:Xshell 是目前最好的远程登录到Linux操作的软件，流畅的速度并且完美解决了中文乱码的问题，是目前程序员首选的软件。Xshell[1]是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。 特别说明：如果希望安装好XShell5就可以远程访问Linux系统的话，需要有一个前提，就是Linux启用了SSHD服务，该服务会监听22号端口。 ==终端setup指令查看系统服务中ssh是否开启== 如果都有，还是不行，就重新建立连接 5.3安装XShell5并使用5.3.2XShell5的关键配置 5.3.3XShel5远程登录到Linux后，就可以使用指令来操作Linux系统 5.4远程上传下载文件Xftp55.4.1XFtp5软件介绍 是一个基于windows平台的功能强大的SFTP、FTP文件传输软件。使用了Xftp以后，windows用户能安全地在UNIX/Linux和WindowsPC之间传输文件。 5.4.2XFtp5软件的安装这个看老师的演示即可.5.4.3Xftp5的配置和使用 linux基本vi和vim编辑器6.1vi和vim的基本介绍所有的Linux系统都会内建vi文本编辑器。Vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 vi和vim的三种常见模式正常模式 在正常模式下，我们可以使用快捷键。以vim打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、贴上』来处理你的文件数据。 6.2.2插入模式/编辑模式 在模式下，程序员可以输入内容。按下i,I,o,O,a,A,r,R等任何一个字母之后才会进入编辑模式,一般来说按i即可 命令行模式 在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等的动作则是在此模式中达成的！ 命令行模式下，有:符号使用相关快捷键，如退出命令： 1:q vi和vim三种模式的相互转化图 快捷键使用练习:1) 拷贝当前行yy , 拷贝当前行向下的5行5yy，并粘贴。 2) 删除当前行dd , 删除当前行向下的5行 5+dd 3) 在文件中查找某个单词[命令行下/关键字，回车查找, 输入n 就是查找下一个] 如查找bind 1/bind 4) 设置文件的行号，取消文件的行号. [命令行下: set nu 和:set nonu] 5) 编辑/etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg] 6) 在一个文件中输入”hello” ,然后又撤销这个动作u7) 编辑/etc/profile 文件，并将光标移动到20行shift+g8) 更多的看整理的文档 7)编辑/etc/profile文件，并将光标移动到第20行shift+g 第一步：显示行号:setnu 第二步：输入20这个数 第三步:输入（G）shift+g， ：20在按gg uu回退 vim和vi的快捷键键盘一览图 开机、重启和用户登录注销7.1关机&amp;重启命令 7.1.1基本介绍 shutdown shutdown-hnow:表示立即关机 shutdown-h1:表示1分钟后关机 shutdown-rnow:立即重启 halt 就是直接使用，效果等价于关机 reboot就是重启系统。 sync：把内存的数据同步到磁盘 7.1.2注意细节 当我们关机或者重启时，都应该先执行以下sync指令，把内存的数据写入磁盘，防止数据丢失。 7.2用户登录和注销 7.2.1基本介绍 1)登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用”su-用户名’命令来切换成系统管理员身份. 2)在提示符下输入logout即可注销用户 7.2.2使用细节 1)logout注销指令在图形运行级别无效，在运行级别3下有效. 2)运行级别这个概念，后面给大家介绍 用户管理8.1基本介绍 给大家画一个示意图，帮助大家理解用户管理的规则。 说明 1)Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 2)Linux的用户需要至少要属于一个组。 查看所有用户名1234567891011121314151617181920212223242526272829303132333435[root@hapdoop1 ~]## more /etc/passwd[root@hapdoop1 ~]## more /etc/passwd | cut -f 1 -d :rootbindaemonadmlpsyncshutdownhaltmailuucpoperatorgamesgopherftpnobodydbususbmuxdrtkitavahi-autoipdvcsaabrthaldaemonntpapachesaslauthpostfixgdmpulsesshdtcpdumpxmfoxtom 8.2添加用户 8.2.1基本语法 useradd [选项] 用户名 8.2.2实际案例 特别说明：==cd表示changedirectory==,切换目录. 8.2.3细节说明 1)当创建用户成功后，(加上-m参数)会自动的创建和用户同名的家目录 ==没有-m参数不会有缺省目录== 1root@iZuf6i77uwsb2oiszspgvkZ:~## useradd -m nicolas 2)也可以通过useradd-d指定目录新的用户名，给新创建的用户指定家目录 1[root@hapdoop1 home]## useradd -d /home/dog xh 指定/修改密码基本语法 passwd 用户名 删除用户基本语法userdel 用户名 应用案例1)删除用户xiaoming，但是要保留家目录 1[root@hapdoop1 ~]## userdel xm 2)删除用户以及用户主目录 1[root@hapdoop1 home]## userdel -r xh 8.4.3思考题在删除用户时，我们一般不会将家目录删除。 8.5查询用户信息 8.5.1基本语法 id 用户名 应用实例案例1：请查询root信息8.5.3 ![1565783310913](linux/id username.png) 细节说明 1)当用户不存在时，返回”无此用户” 8.6切换用户8.6.1介绍(substitute user) 在操作Linux中，如果当前用户的权限不够，可以通过su-指令，切换到高权限用户，比如root 8.6.2基本语法(run a shell with substitute user and group IDs) su– 切换用户名 8.6.3应用实例 1)创建一个用户zf,，指定密码，然后切换到zf. 细节说明 1)从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。 2)当需要返回到原来用户时，使用exit指令 12[root@hapdoop1 ~]## whoamiroot 8.7用户组 8.7.1介绍类似于角色，系统可以对有共性的多个用户进行统一的管理。 8.7.2增加组 groupadd 组名 案例演示 1[root@hapdoop1 ~]## groupadd wudang 8.7.4删除组指令 (基本语法)groupdel 组名 8.7.5案例演示 1[root@hapdoop1 ~]## groupdel wudang 8.8增加用户时直接加上组8.8.1指令(基本语法) useradd -g 用户组 用户名 8.8.2案例演示 增加一个用户zwj,直接将他指定到wudang步骤看演示： ![1565786129905](linux/useradd -g) 8.9修改用户的组 8.9.1指令(基本语法) usermod -g 用户组 用户名 8.9.2案例演示创建一个shaolin组，让将zwj用户修改到shaolin ![1565786180228](linux/usermod -g.png) 8.10/etc/passwd文件 用户（user）的配置文件，记录用户的各种信息 每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 8.11/etc/shadow文件 口令的配置文件 每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 8.12/etc/group文件 组(group)的配置文件，记录Linux包含的组的信息 每行含义：组名:口令:组标识号:组内用户列表 9实用指令9.1指定运行级别运行级别说明： 0：关机 1：单用户【找回丢失密码】 2：多用户状态没有网络服务 3：多用户状态有网络服务4：系统未使用保留给用户 5：图形界面 6：系统重启 常用运行级别是3和5，要修改默认的运行级别可改文件/etc/inittab的id:5:initdefault:这一行中的数字运行级别的示意图： 9.2切换到指定运行级别的指令 9.2.1基本语法 init[012356] 9.2.2应用实例案例 1：通过init来切换不同的运行级别，比如动5-&gt;3，然后关机 12345init3init5init0 9.2.3面试题 如何找回root密码，如果我们不小心，忘记root密码，怎么找回。 思路：进入到单用户模式，然后修改root密码。 因为进入单用户模式，root不需要密码就可以登录。演示一把（注意观察）： 总结:开机-&gt;在引导时输入回车键-&gt;看到一个界面输入e-&gt;看到一个新的界面，选中第二行（编辑内核）在输入e-&gt;在这行最后输入1,再输入回车键-&gt;再次输入b,这时就会进入到单用户模式。这时，我们就进入到单用户模式，使用passwd指令来修改root密码。 2)请设置我们的运行级别，linux运行后，直接进入到命令行界面，即进入到3 运行级别vim/etc/inittab将id:5:initdefault:这一行中的数字,5这个数字改成对应的运行级别即可。 9.3帮助指令9.3.1介绍 当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。 9.3.2man(manual) 获得帮助信息 基本语法 man [命令或配置文件]（功能描述：获得帮助信息） 应用实例案例：查看ls命令的帮助信息 1[root@hapdoop1 ~]## man ls 9.3.3help指令 基本语法 help命令（功能描述：获得shell内置命令的帮助信息） 应用实例案例：查看cd命令的帮助信息 1[root@hapdoop1 ~]## help cd 4文件目录类9.4.1pwd 指令(print name of current/working directory) •基本语法 pwd (功能描述：显示当前工作目录的绝对路径) •应用实例案例：显示当前工作目录的绝对路径 12[root@hapdoop1 ~]## pwd/root 9.4.2ls指令 (list directory contents) •基本语法 ls [选项] [目录或是文件] •常用选项 -a：显示当前目录所有的文件和目录，包括隐藏的。 -l：以列表的方式显示信息 •应用实例案例:查看当前目录的所有内容信息 9.4.3cd指令•基本语法 cd [参数] (功能描述：切换到指定目录) •常用参数 绝对路径和相对路径 如何理解绝对路径和相对路径： cd~ 或者 cd：回到自己的家目录 cd.. : 回到当前目录的上一级目录 •应用实例 案例1：使用绝对路径切换到root目录 cd/root 案例2: 使用相对路径到/root目录 这里我们需要知道该用户目录在哪个目录下，才能写出这个指令，假设在/usr/lib 1cd../../root 案例3：表示回到当前目录的上一级目录cd..案例4：回到家目录 cd cd~ 9.4.4 mkdir指令mkdir指令用于创建目录(makedirectory) 基本语法 mkdir [选项] 要创建的目录 •常用选项 -p(–parents)：创建多级目录 •应用实例案例1:创建一个目录/home/dog 案例2:创建多级目录/home/animal/tiger 9.4.5rmdir指令介绍 rmdir指令删除空目录 基本语法 rmdir [选项] 要删除的空目录 应用实例案例1:删除一个目录/home/dog 使用细节 rmdir删除的是空目录，如果目录下有内容时无法删除的。 提示：如果需要删除非空目录，需要使用rm-rf要删除的目录 9.4.6touch指令touch指令 创建空文件 •基本语法 touch 文件名称 •应用实例案例 1:创建一个空文件hello.txt 123[root@hapdoop1 home]## touch ok1.txt ok2.txt[root@hapdoop1 home]## lsok1.txt ok2.txt xm 9.4.7cp指令[重要]cp指令 拷贝文件到指定目录 •基本语法 1cp [选项] source dest •常用选项-r：递归复制整个文件夹 •应用实例案例 1:将/home/aaa.txt拷贝到/home/bbb目录下[拷贝单个文件 案例2:递归复制整个文件夹，举例将/home/test整个目录拷贝到/home/zwj目录 •使用细节 强制覆盖不提示的方法：\\cp 9.4.8rm指令 rm 指令移除 【删除】文件或目录 •基本语法rm[选项]要删除的文件或目录 •常用选项 -r：递归删除整个文件夹 -f：强制删除不提示 •应用实例案例1:将/home/aaa.txt删除 案例2:递归删除整个文件夹/bb 12[root@hapdoop1 /]## rm -r bb/rm：是否删除目录 \"bb\"？y 使用细节 强制删除不提示的方法：带上-f参数即可 mv指令mv 移动文件与目录或重命名 •基本语法 1mv oldNameFile newNameFile (功能描述：重命名) 1mv /temp/movefile /targetFolder (功能描述：移动文件) •应用实例 案例1:将/home/aaa.txt文件重新命名为pig.txt 123[root@hapdoop1 home]## mv aaa.txt pig.txt[root@hapdoop1 home]## lsok1.txt ok2.txt pig.txt xm 案例2:将/home/pig.txt文件移动到/root目录下 123456[root@hapdoop1 home]## mv pig.txt /root[root@hapdoop1 home]## cd ~[root@hapdoop1 ~]## lsanaconda-ks.cfg install.log.syslog 公共的 视频 下载hello.java ok.txt 红1.jpg 图片 音乐install.log pig.txt 模板 文档 桌面 查看文件1.tail用于查看文件末尾内容答： tail -n 10 文件名 : n=行数 10=查看多少行 tail -n 10 -f 文件名 : -f 每当有新的内容 实时展示出来。 10 cat指令(concatenate)cat查看文件内容，是以只读的方式打开。 •基本语法 cat [选项] 要查看的文件 •常用选项-n：显示行号 •应用实例 案例1:/etc/profile文件内容，并显示行号 1[root@hapdoop1 ~]## cat -n /etc/profile | more •使用细节 cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令|more cat文件名|more[分页浏览] 11more指令more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。 more指令中内置了若干快捷键，详见操作说明 •基本语法 more 要查看的文件 •操作说明 •应用实例案例: 采用more查看文件/etc/profile 1[root@hapdoop1 ~]## more /etc/profile 12less指令 less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。 •基本语法 less 要查看的文件 •操作说明 •应用实例 案例:采用less查看一个大文件文件/opt/金庸-射雕英雄传txt精校版.txt 1[root@hapdoop1 opt]## less 金庸-射雕英雄传txt精校版.txt 9.4.13&gt;指令和&gt;&gt;指令介绍 指令和&gt;&gt;指令 &gt; 输出重定向:会将原来的文件的内容覆盖 &gt;&gt;追加：不会覆盖原来文件的内容，而是追加到文件的尾部。• 基本语法 1)ls-l&gt;文件（功能描述：列表的内容写入文件a.txt中（覆盖写）） 1[root@hapdoop1 home]## ls -l &gt; a.txt 说明：ls-l&gt;a.txt,将ls-l的显示的内容覆盖写入到a.txt文件，如果该文件不存在，就创建该文件。 2)ls-al&gt;&gt;文件（功能描述：列表的内容追加到文件aa.txt的末尾） 1[root@hapdoop1 home]## ls -al &gt;&gt; a.txt 3)cat文件1&gt;文件2（功能描述：将文件1的内容覆盖到文件2）相当于复制文件 1[root@hapdoop1 home]## cat /etc/profile &gt; c.txt 9.4.14echo指令 echo输出内容到控制台。 •基本语法echo[选项] [输出内容] •应用实例 案例:使用echo指令输出环境变量,输出当前的环境路径。 123[root@hapdoop1 ~]## echo $PATH[root@hapdoop1 ~]## echo \"hello\" 9.4.15head指令 head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容 •基本语法 head 文件(功能描述：查看文件头10行内容) head -n 5 文件 (功能描述：查看文件头5行内容，5可以是任意行数) •应用实例 案例:查看/etc/profile的前面5行代码 1[root@hapdoop1 ~]## head -n 5 /etc/profile 9.4.16tail指令 tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。 •基本语法 1)tail 文件（功能描述：查看文件后10行内容） 2)tail -n 5 文件（功能描述：查看文件后5行内容，5可以是任意行数）3)tail -f 文件（功能描述：实时追踪该文档的所有更新，工作经常使用） •应用实例 案例1:查看/etc/profile最后5行的代码 1[root@hapdoop1 ~]## tail -n 5 /etc/profile 案例2:实时监控mydate.txt,看看到文件有变化时，是否看到，实时的追加日期 1[root@hapdoop1 home]## tail -f mydate.txt 9.4.17ln指令 软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径 •基本语法 ln -s [原文件或目录] [软链接名]（功能描述：给原文件创建一个软链接） •应用实例 案例1:在/home目录下创建一个软连接linkToRoot，连接到/root目录 1[root@hapdoop1 home]## ln -s /root linkToRoot 案例2:删除软连接linkToRoot 1[root@hapdoop1 home]## rm linkToRoot •细节说明 当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录。 1234567[root@hapdoop1 home]## cd linkToRoot/[root@hapdoop1 linkToRoot]## pwd/home/linkToRoot[root@hapdoop1 linkToRoot]## lsanaconda-ks.cfg install.log.syslog 公共的 视频 下载hello.java ok.txt 红1.jpg 图片 音乐install.log pig.txt 模板 文档 9.4.18history指令查看已经执行过历史命令,也可以执行历史指令 •基本语法history（功能描述：查看已经执行过历史命令） •应用实例案例1:显示所有的历史命令 1[root@hapdoop1 home]## history 案例2:显示最近使用过的10个指令。 1[root@hapdoop1 home]## history 10 案例3：执行历史编号为5的指令 1[root@hapdoop1 home]## !111 9.5时间日期类9.5.1date指令-显示当前日期 •基本语法 1)date（功能描述：显示当前时间） 2)date+%Y（功能描述：显示当前年份） 3)date+%m（功能描述：显示当前月份） 4)date+%d（功能描述：显示当前是哪一天） 5)date”+%Y-%m-%d%H:%M:%S”（功能描述：显示年月日时分秒） •应用实例案例1:显示当前时间信息 12[root@hapdoop1 home]## date2019年 08月 15日 星期四 17:57:34 CST 案例2:显示当前时间年月日 12[root@hapdoop1 home]## date \"+%Y %m %d\"2019 08 15 案例3:显示当前时间年月日时分秒 12[root@hapdoop1 home]## date \"+%Y %m %d %H:%M:%S\"2019 08 15 18:04:05 9.5.2date指令 -设置日期 •基本语法 date -s 字符串时间 •应用实例 案例1:设置系统当前时间，比如设置成2018-10-1011:22:22 12[root@hapdoop1 home]## date -s \"2019-9-9 11:11:11\"2019年 09月 09日 星期一 11:11:11 CST 9.5.3cal指令(calendar) 查看日历指令 •基本语法cal[选项]（功能描述：不加选项，显示本月日历） •应用实例案例1:显示当前日历 1[root@hapdoop1 home]## cal 案例2:显示2020年日历 1[root@hapdoop1 ~]## cal 2020 9.6搜索查找类9.6.1find指令 find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。 •基本语法 find [搜索范围] [选项] •选项说明 •应用实例 案例1:按文件名：根据名称查找/home目录下的hello.txt文件 1[root@hapdoop1 ~]## find /home -name hello.txt 案例2：按拥有者：查找/opt目录下，用户名称为root的文件 1[root@hapdoop1 ~]## find /opt -user root 案例3：查找整个linux系统下大于20m的文件（+n大于-n小于n等于） 1[root@hapdoop1 ~]## find /opt -size +20M 查询/目录下，所有.txt的文件 1[root@hapdoop1 ~]## find / -name \\*.txt 9.6.2locate指令 locaate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。 •基本语法 locate 搜索文件 •特别说明由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库。 •应用实例 案例1:请使用locate指令快速定位hello.txt文件所在目录 9.6.3grep指令和管道符号|grep过滤查找，管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。 •基本语法 grep [选项] 查找内容源文件 •常用选项 •应用实例 案例1:请在hello.txt文件中，查找”yes”所在行，并且显示行号 123[root@hapdoop1 home]## cat hello.txt | grep -n yes#不区分大小写[root@hapdoop1 home]## cat hello.txt | grep -ni yes 压缩和解压类9.7.1gzip/gunzip指令 gzip用于压缩文件，gunzip用于解压的 •基本语法 gzip 文件（功能描述：压缩文件，只能将文件压缩为*.gz文件） gunzip 文件.gz（功能描述：解压缩文件命令） •应用实例 案例1:gzip压缩，将/home下的hello.txt文件进行压缩 1[root@hapdoop1 home]## gzip hello.txt 案例2:gunzip压缩，将/home下的hello.txt.gz文件进行解压缩 1[root@hapdoop1 home]## gunzip hello.txt.gz 细节说明 当我们使用gzip对文件进行压缩后，不会保留原来的文件。 9.7.2 zip/unzip指令 zip用于压缩文件，unzip用于解压的，这个在项目打包发布中很有用的 •基本语法 zip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）unzip [选项] XXX.zip（功能描述：解压缩文件） •zip常用选项 -r：递归压缩，即压缩目录 unzip的常用选项 -d &lt;目录&gt;：指定解压后文件的存放目录 •应用实例 案例1:将/home下的所有文件进行压缩成mypackage.zip 1[root@hapdoop1 home]## zip -r mypackge.zip /home/ 案例2:将mypackge.zip解压到/opt/tmp目录下 1[root@hapdoop1 home]## unzip -d /opt/tmp/ mypackge.zip tar指令tar指令是打包指令，最后打包后的文件是.tar.gz的文件。 •基本语法 1tar [选项] XXX.tar.gz(打包的内容) (功能描述：打包目录，压缩后的文件格式.tar.gz) •选项说明 选项 功能 -c(–create) 产生.tar打包文件 -v(verbose，adj. 冗长的；啰嗦的) 显示详细信息 -f(file) 指定压缩后的文件名 -z(gzip) 打包同时压缩 x(extract) 解包.tar文件 •应用实例 案例1:压缩多个文件，将/home/a1.txt和/home/a2.txt压缩成a.tar.gz 1[root@hapdoop1 home]## tar -zcvf a.tar.gz ok1.txt ok2.txt 案例3:将a.tar.gz解压到当前目录 1[root@hapdoop1 home]## tar -zxvf a.tar.gz 案例4:将myhome.tar.gz解压到/opt/目录下 1[root@hapdoop1 home]## tar -zxvf a.tar.gz -C /opt 10组管理和权限管理10.1Linux组 基本介绍 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。 1)所有者 2)所在组 3)其它组 4)改变用户所在的组 10.2文件/目录所有者 一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者。10.2.1查看文件的所有者 1)指令：ls -ahl 2)应用实例：创建一个组police,再创建一个用户tom,将tom放在police组,然后使用tom来创建一个文件ok.txt，看看情况如何 10.3组的创建10.3.1基本指令 groupadd 组名 10.3.2应用实例: 创建一个组,monster 创建一个用户fox，并放入到monster组中 12[root@hapdoop1 ~]## groupadd monster[root@hapdoop1 ~]## useradd -g monster fox 10.4文件/目录所在组当某个用户创建了一个文件后，默认这个文件的所在组就是该用户所在的组。#### 10.4.1查看文件/目录所在组 •基本指令 ls –ahl 10.4.2修改文件所在的组•基本指令 chgrp 组名 文件名 •应用实例 使用root用户创建文件orange.txt,看看当前这个文件属于哪个组，然后将这个文件所在组，修改到police组。 123[root@hapdoop1 ~]## chgrp police orange.txt [root@hapdoop1 ~]## ls -ahl-rw-r--r--. 1 root police 12 9月 16 02:17 orange.txt 10.5其它组 除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组. 10.6改变用户所在组 在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组。 10.6.1改变用户所在组 1)usermod –g 组名 用户名 2)usermod –d 目录名 用户名 改变该用户登陆的初始目录。 1[root@hapdoop1 ~]## usermod -g bandit fox 10.7权限的基本介绍ls -l中显示的内容如下： -rwxrw-r–1rootroot1213Feb209:39abc 0-9位说明 1)第0位确定文件类型(d,-,l,c,b) 2)第1-3位确定所有者（该文件的所有者）拥有该文件的权限。—User 3)第4-6位确定所属组（同用户组的）拥有该文件的权限，—Group 4)第7-9位确定其他用户拥有该文件的权限—Other 10.8rwx权限详解10.8.1rwx作用到文件 1)[r]代表可读(read):可以读取,查看 ： 数字4 2)[w]代表可写(write):可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件. ：数字2 3)[x]代表可执行(execute):可以被执行 ：数字1 10.8.2rwx作用到目录 1)[r]代表可读(read):可以读取，ls查看目录内容 2)[w]代表可写(write):可以修改,目录内创建+删除+重命名目录 3)[x]代表可执行(execute):可以进入该目录10.9文件及目录权限实际案例ls-l中显示的内容如下：(记住)-rwxrw-r–1rootroot1213Feb209:39abc 10个字符确定不同用户能对文件干什么 第一个字符代表文件类型：文件(-),目录(d),链接(l) 其余字符每3个一组(rwx)读(r)写(w)执行(x) 第一组rwx:文件拥有者的权限是读、写和执行 第二组rw-:与文件拥有者同一组的用户的权限是读、写但不能执行 第三组r–:不与文件拥有者同组的其他用户的权限是读不能写和执行 可用数字表示为:r=4,w=2,x=1因此rwx=4+2+1=7 1 文件：硬连接数或目录：子目录数 root 用户root组 1213 文件大小(字节)，如果是文件夹，显示4096字节 Feb209:39 最后修改日期 abc 文件名 10.9文件及目录权限ls-l中显示的内容如下：(记住) -rwxrw-r–1rootroot1213Feb209:39abc 10修改权限-chmod10.10.1基本说明： 通过chmod指令，可以修改文件或者目录的权限 10.10.2第一种方式：+、-、=变更权限 u:所有者g:所有组o:其他人a:所有人(u、g、o的总和) 1)chmod u=rwx,g=rx,o=x文件目录名 2)chmod o+w 文件目录名 3)chmod a-x 文件目录名 •案例演示 1)给abc文件的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限 1234[root@hapdoop1 ~]## chmod u=rwx,g=x,o=rx abc[root@hapdoop1 ~]## ls -l总用量 136drwx--xr-x. 2 root root 4096 9月 16 02:34 abc 2)给abc文件的所有用户添加读的权限 1[root@hapdoop1 ~]## chmod a+r abc 10.10.3第二种方式：通过数字变更权限 规则：r=4 w=2 x=1 ,rwx=4+2+1=7 chmod u=rwx, g=rx, o=x文件目录名 相当于 chmod 751 文件目录名 •案例演示 要求：将/home/abc.txt文件的权限修改成rwxr-xr-x,使用给数字的方式实现：rwx=4+2+1=7 r-x=4+1=5 r-x=4+1=5 指令：chmod 755 /home/abc.txt 1chmod -R 777 /home/ubuntu/static 10.11修改文件所有者-chown(chmod - change file mode bits) 10.11.1基本介绍 1chown newowner file 改变文件的所有者 1chown [-R] newowner:newgroupfile 改变用户的所有者和所有组 [-R] 如果是目录则使其下所有子文件或目录递归生效 10.11.2案例演示： 1)请将/home/abc.txt文件的所有者修改成tom 1[root@hapdoop1 ~]## chown fox abc.txt 2)请将/home/kkk目录下所有的文件和目录的所有者都修改成tom 1[root@hapdoop1 ~]## chown -R tom kkk/ 10.13最佳实践-警察和土匪游戏police，bandit jack,jerry:警察 xh,xq:土匪 (1)创建组 12[root@hapdoop1 ~]## groupadd police[root@hapdoop1 ~]## groupadd bandit (2)创建用户 crond任务调度11.1原理示意图 crontab进行定时任务的设置。 1.2概述 任务调度：是指系统在某个时间执行的特定的命令或程序。 任务调度分类： 1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等 2.个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。 11.3基本语法 crontab [选项] 11.3.1常用选项 快速入门11.4.1任务的要求 设置任务调度文件：/etc/crontab 设置个人任务调度。执行crontab–e命令。 接着输入任务到调度文件如：/1ls–l/etc/&gt;/tmp/to.txt意思说每小时的每分钟执行ls–l/etc/&gt;/tmp/to.txt命令 11.4.2步骤如下 1) 1[root@hapdoop1 ~]## crontab -e 2) */1 * * * * ls -l /etc &gt;&gt; /tmp/to.txt 3)当保存退出后就程序。 4)在每一分钟都会自动的调用 ls -l /etc &gt;&gt; /tmp/to.txt 11.4.3参数细节说明 11.5.1 案例1：每隔1分钟，就将当前的日期信息，追加到/tmp/mydate文件中 1)先编写一个文件/home/mytask1.sh 1date &gt;&gt; /tmp/mydate 2)给mytask1.sh一个可以执行权限 1[root@hapdoop1 home]## chmod 774 mytask1.sh 3)crontab-e 4) 1*/1 * * * * /home/mytask1.sh 11.5.2 案例2：每隔1分钟，将当前日期和日历都追加到/home/mycal文件中 1)先编写一个文件/home/mytask2.sh 12date &gt;&gt; /tmp/mycalcal &gt;&gt; /tmp/mycal 2)给mytask2.sh一个可以执行权限 1[root@hapdoop1 home]## chmod 774 mytask2.sh 3)crontab -e 4) 1*/1 * * * * /home/mytask2.sh 11.5.3 案例3:每天凌晨2:00将mysql数据库testdb，备份到文件中mydb.bak。 1)先编写一个文件/home/mytask2.sh 1/usr/local/mysql/bin/mysqldump -u root-proot testdb&gt;/tmp/mydb.bak 2)给mytask3.sh一个可以执行权限 1[root@hapdoop1 home]## chmod 774 mytask2.sh 3)crontab -e 4) 10 2 * * */home/mytask3.sh 11.6crond相关指令: 1)conrtab–r：终止任务调度。 2)crontab–l：列出当前有那些任务调度 3)service crond restart [重启任务调度] Linux磁盘分区、挂载分区基础知识12.1.1分区的方式： 1)mbr分区: 1.最多支持四个主分区 2.系统只能安装在主分区 3.扩展分区要占一个主分区4.MBR最大只支持2TB，但拥有最好的兼容性 2)gpt分区: 1.支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区） 2.最大支持18EB的大容量（1EB=1024PB，1PB=1024TB）3.windows764位以后支持gpt 12.1.2windows下的磁盘分区 12.2Linux分区12.2.1原理介绍 1)Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构,Linux中每个分区都是用来组成整个文件系统的一部分。 2)Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。 3)示意图 12.2.2硬盘说明 1)Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘 2)对于IDE硬盘，驱动器标识符为“hdx”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。 3)对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样 12.2.3使用lsblk指令查看当前系统的分区情况 12.5磁盘情况查询12.5.1查询系统整体磁盘使用情况 基本语法 df -h 应用实例 查询系统整体磁盘使用情况 123456[root@hapdoop1 ~]## df -lhFilesystem Size Used Avail Use% Mounted on/dev/sda3 18G 4.2G 13G 26% /tmpfs 1003M 80K 1003M 1% /dev/shm/dev/sda1 190M 39M 142M 22% /boot/dev/sr0 3.7G 3.7G 0 100% /media/CentOS_6.8_Final 12.5.2查询指定目录的磁盘占用情况 •基本语法 du -h/目录查询指定目录的磁盘占用情况，默认为当前目录 -s指定目录占用大小汇总 -h带计量单位 -a含文件 –max-depth=1子目录深度 -c列出明细的同时，增加汇总值 •应用实例查询/opt目录的磁盘占用情况，深度为1 123456789101112131415161718[root@hapdoop1 ~]## du -ach --max-depth=1 /opt4.0K /opt/Hello.java64K /opt/tmp147M /opt/jdk-7u79-linux-x64.gz35M /opt/mysql-5.6.14.tar.gz8.6M /opt/apache-tomcat-7.0.70.tar.gz298M /opt/jdk1.7.0_794.0K /opt/rh4.0K /opt/Hello.class0 /opt/ok2.txt28M /opt/金庸-射雕英雄传txt精校版.txt69M /opt/VMwareTools-10.0.5-3228253.tar.gz15M /opt/apache-tomcat-7.0.70214M /opt/vmware-tools-distrib0 /opt/ok1.txt274M /opt/eclipse-jee-mars-2-linux-gtk-x86_64.tar.gz1.1G /opt1.1G 总用量 12.6磁盘情况-工作实用指令1)统计/home文件夹下文件的个数 12[root@hapdoop1 home]## ll /home | grep \"^-\" | wc -l11 2)统计/home文件夹下目录的个数 12[root@hapdoop1 home]## ll /home | grep \"^d\" | wc -l3 3)统计/home文件夹下文件的个数，包括子文件夹里的 12[root@hapdoop1 home]## ls -lR /home | grep \"^-\" | wc -l11 4)统计文件夹下目录的个数，包括子文件夹里的 12[root@hapdoop1 home]## ls -lR /home | grep \"^d\" | wc -l3 5)以树状显示目录结构 1234567891011121314151617[root@hapdoop1 home]## yum install tree[root@hapdoop1 home]## tree.├── a.tar.gz├── a.txt├── c.txt├── fox├── hello.txt├── mydate.txt├── mydate.txt~├── mypackge.zip├── mytask1.sh├── mytask2.sh├── ok1.txt├── ok2.txt├── tom└── xm 网络配置13.1Linux网络配置 原理图(含虚拟机) 目前我们的网络配置采用的是NAT。 13.2查看网络IP和网关 13.2.1查看虚拟网络编辑器 13.2.2修改ip地址(修改虚拟网络的ip) 3.2.3查看网关 13.2.4查看windows环境的中VMnet8网络配置(ipconfig指令) 1)使用ipconfig查看 2)界面查看 13.3ping测试主机之间网络连通 13.3.1基本语法ping目的主机（功能描述：测试当前服务器是否可以连接目的主机） 13.3.2应用实例测试当前服务器是否可以连接百度 [root@hadoop100桌面]#pingwww.baidu.com 1[root@hapdoop1 home]## vim /etc/sysconfig/network-scripts/ifcfg-eth0 13.4linux网络环境配置 13.4.1第一种方法(自动获取) 缺点:linux启动后会自动获取IP,缺点是每次自动获取的ip地址可能不一样。这个不适用于做服务器，因为我们的服务器的ip需要时固定的。 13.4.2第二种方法(指定固定的ip) 说明直接修改配置文件来指定IP,并可以连接到外网(程序员推荐)，编辑vi/etc/sysconfig/network-scripts/ifcfg-eth0 要求：将ip地址配置的静态的，ip地址为192.168.184.130 修改后，一定要重启服务 1)service network restart 2)reboot重启系统 不推荐 进程管理14.1进程的基本介绍1)在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。 2)每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。 3)每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。 4)一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。 14.2显示系统执行的进程ps14.2.1说明： 查看进行使用的指令是ps,一般来说使用的参数是ps -aux 14.2.2ps指令详解 1)指令： 1ps -aux | grep xxx ，比如我看看有没有sshd服务 2)指令说明 •SystemV展示风格•USER：用户名称 •PID：进程号•%CPU：进程占用CPU的百分比 •%MEM：进程占用物理内存的百分比 •VSZ：进程占用的虚拟内存大小（单位：KB） •RSS：进程占用的物理内存大小（单位：KB） •TT：终端名称,缩写 .•STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等 •STARTED：进程的启动时间 •TIME：CPU时间，即进程使用CPU的总时间•COMMAND：启动进程所用的命令和参数，如果过长会被截断显示 14.2.3应用实例 要求：以全格式显示当前所有的进程，查看进程的父进程。 •ps -ef是以全格式显示当前所有的进程 -e显示所有进程(every)。 -f全格式(Do full-format listing)。 •ps -ef|grep xxx •是BSD风格 •UID：用户ID •PID：进程ID •PPID：父进程ID •C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高•STIME：进程启动的时间 •TTY：完整的终端名称 •TIME：CPU时间 •CMD：启动进程所用的命令和参数 思考题，如果我们希望查看sshd进程的父进程号是多少，应该怎样查询？ 1234[root@hapdoop1 ~]## ps -ef | grep sshdroot 14263 1 0 (ppid) 05:34 ? 00:00:00 /usr/sbin/sshdroot 16269 14263 0 06:07 ? 00:00:00 sshd: root@pts/1 root 16321 16273 0 06:19 pts/1 00:00:00 grep sshd 14.3终止进程kill和killall14.3.1介绍: 若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。 14.3.2基本语法： 1kill [选项] 进程号 （功能描述：通过进程号杀死进程） killall进程名称（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用） 14.3.3常用选项： -9:表示强迫进程立即停止 14.3.4最佳实践： 案例1：踢掉某个非法登录用户 12345678[root@hapdoop1 ~]## ps -aux | grep sshdWarning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.8/FAQroot 14263 0.0 0.0 66236 1200 ? Ss 05:34 0:00 /usr/sbin/sshdroot 16269 0.0 0.2 102084 4156 ? Ss 06:07 0:00 sshd: root@pts/1 root 16357 0.4 0.1 102084 4040 ? Ss 06:28 0:00 sshd: fox [priv] fox 16361 0.1 0.0 102084 1904 ? S 06:28 0:00 sshd: fox@pts/2 root 16387 0.0 0.0 103332 860 pts/1 S+ 06:29 0:00 grep sshd[root@hapdoop1 ~]## kill 16361 案例2:终止远程登录服务sshd,在适当时候再次重启sshd服 12345678[root@hapdoop1 ~]## ps -aux | grep sshdWarning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.8/FAQroot 14263 0.0 0.0 66236 1200 ? Ss 05:34 0:00 /usr/sbin/sshdroot 16269 0.0 0.2 102084 4156 ? Ss 06:07 0:00 sshd: root@pts/1 root 16357 0.4 0.1 102084 4040 ? Ss 06:28 0:00 sshd: fox [priv] fox 16361 0.1 0.0 102084 1904 ? S 06:28 0:00 sshd: fox@pts/2 root 16387 0.0 0.0 103332 860 pts/1 S+ 06:29 0:00 grep sshd[root@hapdoop1 ~]## kill 14263 案例3:终止多个gedit编辑器【killall,通过进程名称来终止进程】 1[root@hapdoop1 桌面]## killall gedit 案例4：强制杀掉一个终端 12345678[root@hapdoop1 桌面]## ps -aux |grep bashWarning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.8/FAQroot 15158 0.0 0.0 108348 1840 pts/0 Ss 05:37 0:00 /bin/bashroot 16273 0.0 0.0 108348 1820 pts/1 Ss+ 06:07 0:00 -bashroot 16398 0.0 0.0 108428 1828 pts/2 Ss+ 06:33 0:00 /bin/bashroot 16411 0.0 0.0 108348 1788 pts/3 Ss 06:33 0:00 /bin/bashroot 16438 0.0 0.0 103328 856 pts/3 S+ 06:37 0:00 grep bash[root@hapdoop1 桌面]## kill -9 16398 14.4查看进程树pstree14.4.1基本语法： pstree [选项] ,可以更加直观的来看进程信息 14.4.2常用选项： -p:显示进程的PID -u:显示进程的所属用户 14.4.3应用实例： 案例1：请你树状的形式显示进程的pid 123456789[root@hapdoop1 ~]## pstree -pinit(1)─┬─ManagementAgent(13688)─┬─&#123;ManagementAgen&#125;(13706) │ └─&#123;ManagementAgen&#125;(13707) ├─NetworkManager(14070)─┬─dhclient(16203) │ └─&#123;NetworkManager&#125;(14099) ├─VGAuthService(13576) ├─abrtd(14468) ├─acpid(14133) ├─atd(14495) 服务(Service)管理4.5.1介绍: 服务(service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql,sshd防火墙等)，因此我们又称为守护进程，是Linux中非常重要的知识点。 【原理图】 14.5.2service管理指令： 1service 服务名 [start|stop|restart|reload|status] 在CentOS7.0后不再使用service,而是systemctl 14.5.3使用案例： 1)查看当前防火墙的状况，关闭防火墙和重启防火墙。 1234567891011121314151617[root@hapdoop1 ~]## service iptables status表格：filterChain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:8080 6 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT)num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT)num target prot opt source destination 1234567891011[root@hapdoop1 ~]## service iptables stopiptables：将链设置为政策 ACCEPT：filter [确定]iptables：清除防火墙规则： [确定]iptables：正在卸载模块： [确定][root@hapdoop1 ~]## service iptables statusiptables：未运行防火墙。[root@hapdoop1 ~]## service iptables startiptables：应用防火墙规则： [确定][root@hapdoop1 ~]## service iptables status表格：filterChain INPUT (policy ACCEPT) 14.5.4细节讨论： 1)关闭或者启用防火墙后，立即生效。[telnet测试某个端口即可]windows 1C:\\Users\\11623&gt;Telnet 192.168.163.129 22 2)这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。如果希望设置某个服务自启动或关闭永久生效，要使用chkconfig指令，马上讲 14.5.5查看服务名: 方式1：使用setup-&gt;系统服务就可以看到。 方式2:/etc/init.d/服务名称 123456root@hapdoop1 ~]## ll /etc/init.d/总用量 376-rwxr-xr-x. 1 root root 1288 5月 12 2016 abrt-ccpp-rwxr-xr-x. 1 root root 1628 5月 12 2016 abrtd-rwxr-xr-x. 1 root root 1642 5月 12 2016 abrt-oops-rwxr-xr-x. 1 root root 1818 2月 17 2016 acpid 14.5.6服务的运行级别(runlevel): 查看或者修改默认级别：vi/etc/inittab Linux系统有7种运行级别(runlevel)：常用的是级别3和5 •运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 •运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 •运行级别2：多用户状态(没有NFS)，不支持网络 •运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 •运行级别4：系统未使用，保留 •运行级别5：X11控制台，登陆后进入图形GUI模式 •运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 14.5.7开机的流程说明 14.5.8chkconfig指令 介绍 通过chkconfig命令可以给每个服务的各个运行级别设置自启动/关闭 基本语法 1)查看服务chkconfig –list| grep xxx 1234567[root@hapdoop1 ~]## chkconfig --list NetworkManager 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭abrt-ccpp 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭abrtd 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭....[root@hapdoop1 ~]## chkconfig --list | grep sshsshd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 2)chkconfig 服务名 –list 12[root@hapdoop1 ~]## chkconfig iptables --listiptables 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 3)chkconfig –level 5 服务名 on/off 12345[root@hapdoop1 ~]## chkconfig --list | grep sshsshd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭[root@hapdoop1 ~]## chkconfig --level 5 sshd off[root@hapdoop1 ~]## chkconfig sshd --listsshd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:关闭 6:关闭 14.5.9应用实例： 1)案例1：请显示当前系统所有服务的各个运行级别的运行状态bash&gt;chkconfig–list 2)案例2：请查看sshd服务的运行状态bash&gt;servicesshdstatus 3)案例3：将sshd服务在运行级别5下设置为不自动启动，看看有什么效果？bash&gt;chkconfig–level5sshdoff 4)案例4：当运行级别为5时，关闭防火墙。bash&gt;chkconfig–level5iptablesoff 5)案例5：在所有运行级别下，关闭防火墙bash&gt;chkconfigiptablesoff 6)案例6：在所有运行级别下，开启防火墙bash&gt;chkconfigiptableson 14.5.10•使用细节 1)chkconfig重新设置服务后自启动或关闭，需要重启机器reboot才能生效. 14.6动态监控进程14.6.1介绍： top与ps命令很相似。它们都用来显示正在执行的进程。Top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程。 14.6.2基本语法： top [选项] 14.6.3 选项说明： 14.6.4应用实例： 案例1.监视特定用户top：输入此命令，按回车键，查看执行的进程。 u：然后输入“u”回车，再输入用户名，即可 案例2：终止指定的进程。 top：输入此命令，按回车键，查看执行的进程。 k：然后输入“k”回车，再输入要结束的进程ID号 案例3:指定系统状态更新的时间(每隔10秒自动更新，默认是3秒)： bash&gt;top -d 10 14.6.5查看系统网络情况netstat(重要) •基本语法 netstat[选项] 1netstat -anp •选项说明 -an按一定顺序排列输出 -p显示哪个进程在调用 •应用案例 查看系统所有的网络服务 12345[root@hapdoop1 ~]## netstat -anp | moreActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 14263/sshd 请查看服务名为sshd的服务的信息。 1234567[root@hapdoop1 ~]## netstat -anp |grep sshd tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 14263/sshd tcp 0 0 127.0.0.1:6010 0.0.0.0:* LISTEN 16552/sshd tcp 0 0 192.168.163.129:22 192.168.163.1:61806 ESTABLISHED 16552/sshd tcp 0 0 :::22 :::* LISTEN 14263/sshd tcp 0 0 ::1:6010 :::* LISTEN 16552/sshd unix 2 [ ] DGRAM 48552 16552/sshd JavaEE篇搭建JavaEE环境 16.1概述16.1.1示意图： 16.2安装JDK16.2.1看老师演示，一会整理笔记： 16.2.2安装步骤 0)先将软件通过xftp5上传到/opt下 1)解压缩到/opt 1nicolas@ubuntu:~$ sudo tar -zxvf jdk-8u221-linux-x64.tar.gz -C /opt/jvm 2)配置环境变量的配置文件vim/etc/profile 123456unset iunset -f pathmungeJAVA_HOME=/opt/jdk1.7.0_79PATH=/opt/jdk1.7.0_79/bin:$PATHexport JAVA_HOME PATH 3)需要注销用户，环境变量才能生效。如果是在3运行级别，logout如果是在5运行级别， 4)在任何目录下就可以使用java和javac 16.2.3测试是否安装成功 编写一个简单的Hello.java输出”hello,world!” 12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(\"hello\"); &#125;&#125; 1234[root@hapdoop1 opt]# vim Hello.java[root@hapdoop1 opt]# javac Hello.java [root@hapdoop1 opt]# java Hellohello 16.3安装tomcat16.3.1步骤: 1)解压缩到/opt 1[root@hapdoop1 bin]# tar -zxvf apache-tomcat-7.0.70.tar.gz 2)启动tomcat./startup.sh 先进入到tomcat的bin目录 12[root@hapdoop1 bin]# cd apache-tomcat-7.0.70/bin/[root@hapdoop1 bin]# ./startup.sh 使用Linux本地的浏览是可以访问到tomcat 3)开放端口8080,这样外网才能访问到tomcat vim /etc/sysconfig/iptables 12-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 重启防火墙 12345678910111213141516171819202122[root@hapdoop1 bin]# service iptables restartiptables：将链设置为政策 ACCEPT：filter [确定]iptables：清除防火墙规则： [确定]iptables：正在卸载模块： [确定]iptables：应用防火墙规则： [确定][root@hapdoop1 bin]# service iptables status表格：filterChain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:8080 6 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT)num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT)num target prot opt source destination 16.4Eclipse的安装16.4.1步骤: 1)解压缩到/opt 1nicolas@ubuntu:~$ sudo tar -zxvf eclipse-java-2019-06-R-linux-gtk-x86_64.tar.gz -C /opt 2)启动eclipse，配置jre和server 12nicolas@ubuntu:/opt/sts-4.3.2.RELEASE$ sudo mkdir /opt/sts-4.3.2.RELEASE/jrenicolas@ubuntu:/opt/sts-4.3.2.RELEASE$ sudo ln -s /opt/jvm/jdk1.8.0_221/bin/ /opt/sts-4.3.2.RELEASE/jre/ 启动方法1:创建一个快捷方式 启动方式2:进入到eclipse解压后的文件夹，然后执行./eclipse即可 3)编写jsp页面,并测试成功! UbuntuUbuntu的介绍UbuntuPython：开发平台Ubuntu （友帮拓、优般图、乌班图）是一个以桌面应用为主的开源GNU/Linux操作系统，Ubuntu是基于GNU/Linux，支持x86、amd64（即x64）和ppc架构，由全球化的专业开发团队（CanonicalLtd）打造的。 专业的Python开发者一般会选择Ubuntu这款Linux系统作为生产平台. 温馨提示：Ubuntu和Centos都是基于GNU/Linux内核的，因此基本使用和Centos是几乎一样的，它们的各种指令可以通用，同学们在学习和使用Ubuntu的过程中，会发现各种操作指令在前面学习CentOS都使用过。只是界面和预安装的软件有所差别。 Ubuntu下载地址：http://cn.ubuntu.com/download/ Ubuntu的安装18.2.1安装的步骤 18.2.2设置Ubuntu支持中文 默认安装的ubuntu中只有英文语言，因此是不能显示汉字的。要正确显示汉字，需要安装中文语言包。安装中文支持步骤 1.单击左侧图标栏打开SystemSettings（系统设置）菜单，点击打开LanguageSupport（语言支持）选项卡。 2.点击Install/RemoveLanguages，在弹出的选项卡中下拉找到Chinese(Simplified)，即中文简体，在后面的选项框中打勾。然后点击ApplyChanges提交，系统会自动联网下载中文语言包。（保证ubuntu是联网的）。 3.这时“汉语（中国）”在最后一位因为当前第一位是”English”，所以默认显示都是英文。我们如果希望默认显示用中文，则应该将“汉语（中国）”设置为第一位。设置方法是拖动，鼠标单击“汉语（中国）”，当底色变化（表示选中了）后，按住鼠标左键不松手，向上拖动放置到第一位。 4.设置后不会即刻生效，需要下一次登录时才会生效。 ==如果中文包下载时间过长，可以给ubuntu换源（阿里源）；== Ubuntu的root用户18.3.1介绍 安装ubuntu成功后，都是普通用户权限，并没有最高root权限，如果需要使用root权限的时候，通常都会在命令前面加上sudo。 有的时候感觉很麻烦。我们一般使用su命令来直接切换到root用户的，但是如果没有给root设置初始密码，就会抛出su:Authentication failure这样的问题。所以，我们只要给root用户设置一个初始密码就好了。 18.3.2 给root用户设置密码并使用 1)输入sudo passwd命令，输入一般用户密码并设定root用户密码。 2)设定root密码成功后，输入su命令，并输入刚才设定的root密码，就可以切换成root了。提示符$代表一般用户，提示符#代表root用户。3)输入exit命令，退出root并返回一般用户4)以后就可以使用root用户了 123456789nicolas@ubuntu:~$ sudo passwd[sudo] nicolas 的密码： 对不起，请重试。[sudo] nicolas 的密码： 对不起，请重试。[sudo] nicolas 的密码： 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码 18.4Ubuntu下开发Python 18.4.1说明安装好Ubuntu后，默认就已经安装好Python的开发环境[Python2.7和Python3.5] 123456789nicolas@ubuntu:~$ pythonPython 2.7.12 (default, Nov 19 2016, 06:48:10) [GCC 5.4.0 20160609] on linux2Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; nicolas@ubuntu:~$ python3Python 3.5.2 (default, Nov 17 2016, 17:05:23) [GCC 5.4.0 20160609] on linuxType \"help\", \"copyright\", \"credits\" or \"license\" for more information. 18.4.2在Ubuntu下开发一个Python程序 1)vim hello.py[编写hello.py] 提示：如果Ubuntu没有vim我们可以根据提示信息安装一个vim 1sudo apt install vim apt软件管理和远程登录apt介绍apt是Advanced Packaging Tool的简称，是一款安装包管理工具。在Ubuntu下，我们可以使用apt命令可用于软件包的安装、删除、清理等，类似于Windows中的软件管理工具。 unbuntu软件管理的原理示意图： 19.2Ubuntu软件操作的相关命令 sudo apt-get update更新源 1sudo apt-get install package安装包 1234567891011sudo apt-get remove package删除包sudo apt-cache search package搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package -- reinstall重新安装包sudo apt-get -finstall修复安装sudo apt-get remove package --purge删除包，包括配置文件等sudo apt-get build -deppackage安装相关的编译环境 更新已安装的包系统最开始使用时尝试更新 1sudo apt-get upgrade 1sudo apt-get dist-upgrade升级系统 12345sudo apt-cache depends package了解使用该包依赖那些包sudo apt-cache rdepends package查看该包被哪些包依赖sudo apt-get source package下载该包的源代码 更新Ubuntu软件下载地址19.3.1原理示意图 19.3.2寻找国内镜像源 https://mirrors.tuna.tsinghua.edu.cn/ 所谓的镜像源：可以理解为提供下载软件的地方，比如Android手机上可以下载软件的安卓市场；iOS手机上可以下载软件的AppStore 19.3.3 备份Ubuntu默认的源地址 123456nicolas@ubuntu:/etc/apt$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup #拷贝root@ubuntu:/etc/apt## echo '' &gt; sources.list #清空root@ubuntu:/etc/apt## vim sources.list #拷贝清华镜像root@ubuntu:/etc/apt## exitexitnicolas@ubuntu:~$ sudo apt-get update #更新ubuntu软件列表 使用ssh远程登录Ubuntu19.5.1ssh介绍 SSH为SecureShell的缩写，由IETF的网络工作小组（NetworkWorkingGroup）所制定；SSH为建立在应用层和传输层基础上的安全协议。 SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。常用于远程登录，以及用户之间进行资料拷贝。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、DigitalUNIX、Irix，以及其他平台，都可运行SSH。 使用SSH服务，需要安装相应的服务器和客户端。客户端和服务器的关系：如果，A机器想被B机器远程控制，那么，A机器需要安装SSH服务器，B机器需要安装SSH客户端。和CentOS不一样，Ubuntu默认没有安装SSHD服务，因此，我们不能进行远程登录。 使用ssh远程登录Ubuntu19.6.1安装SSH和启用 1nicolas@ubuntu:~$ sudo apt-get install openssh-server 执行上面指令后，在当前这台Linux上就安装了SSH服务端和客户端。 1nicolas@ubuntu:~$ service sshd restart 执行上面的指令，就启动了sshd服务。会监听端口22 1234567891011121314151617181920212223242526nicolas@ubuntu:~$ netstat -anp | more（并非所有进程都能被检测到，所有非本用户的进程信息将不会显示，如果想看到所有信息，则必须切换到 root 用户）激活Internet连接 (服务器和已建立连接的)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 127.0.1.1:53 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp6 0 0 :::22 :::* LISTEN - udp 0 0 0.0.0.0:631 0.0.0.0:* - udp 0 0 0.0.0.0:36829 0.0.0.0:* - udp 0 0 127.0.1.1:53 0.0.0.0:* - udp 0 0 0.0.0.0:68 0.0.0.0:* - udp 0 0 0.0.0.0:5353 0.0.0.0:* - udp6 0 0 :::50035 :::* - udp6 0 0 :::5353 :::* - --更多-- 19.6.2在Windows使用XShell5/XFTP5登录Ubuntu 前面我们已经安装了XShell5，直接使用即可。 注意：使用atguigu用户登录，需要的时候再su-切换成root用户 19.6.3从linux系统客户机远程登陆linux 系统服务机首先，我们需要在linux的系统客户机也要安装openssh-server •基本语法：ssh 用户名@IP 例如：sshatguigu@192.168.188.131使用ssh访问，如访问出现错误。可查看是否有该文件～/.ssh/known_ssh尝试删除该文件解决。 •登出登出命令：exit或者logout 安装C++编译器打开终端输入sudo apt-get install build-essential 安装gcc和一些库函数。提供C/C++的编译环境 注意编译c++程序要用g++ 安装JDKhttps://blog.csdn.net/weixin_38924500/article/details/106215048 myLinux下rz/sz安装及使用方法能直接通过xshell拖拽文件到shell的当前目录 ubuntu 1apt-get install lrzsz 常见问题每次进入命令都要重新source /etc/profile 才能生效如java命令 1、也可以放在/.bashrc里面。或者在/.bashrc里面加一句source /etc/profile2、你可以把这几条命令写在 /etc/bash里面 就会自动执行了nohupnohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 nohup 是 no hang up 的缩写，就是不挂断的意思。 nohup命令： 如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。 在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。 案例 nohup command &gt; myout.file 2&gt;&amp;1 &amp; 在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ； 2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。 \\2. 0 22 * * * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py &gt; /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2&gt;&amp;1 这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中 ubuntu查看java安装路径和设置环境变量whereis java （java安装路径） which java （java执行路径） echo $JAVA_HOME（java环境变量） 环境变量路径 1echo $PATH","categories":[{"name":"note","slug":"note","permalink":"https://codeofli.github.io/categories/note/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://codeofli.github.io/tags/linux/"}]},{"title":"javaScript","slug":"js-note/javaScript/javaScript","date":"2019-11-12T02:18:21.000Z","updated":"2021-10-23T02:19:04.228Z","comments":true,"path":"2019/11/js-note/javaScript/javaScript/","link":"","permalink":"https://codeofli.github.io/2019/11/js-note/javaScript/javaScript/","excerpt":"github笔记下载地址[TOC]JavaScriptJavaScript负责页面中的的行为。 它是一门运行在浏览器端的脚本语言。 JS的编写的位置1.可以编写到标签的指定属性中 12&lt;button onclick=\"alert('hello');\"&gt;我是按钮&lt;/button&gt; &lt;a href=\"javascript:alert('aaa');\"&gt;超链接&lt;/a&gt;","text":"github笔记下载地址[TOC]JavaScriptJavaScript负责页面中的的行为。 它是一门运行在浏览器端的脚本语言。 JS的编写的位置1.可以编写到标签的指定属性中 12&lt;button onclick=\"alert('hello');\"&gt;我是按钮&lt;/button&gt; &lt;a href=\"javascript:alert('aaa');\"&gt;超链接&lt;/a&gt; 2.可以编写到script标签中 123&lt;script type=\"text/javascript\"&gt; //编写js代码 &lt;/script&gt; 3.可以将代码编写到外部的js文件中，然后通过标签将其引入 script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略 ,如果需要则可以在创建一个新的script标签用于编写内部代码 1&lt;script type=\"text/javascript\" src=\"文件路径\"&gt;&lt;/script&gt; 输出语句1alert(\"要输出的内容\"); 该语句会在浏览器窗口中弹出一个警告框 1document.write(\"要输出的内容\"); 该内容将会被写到body标签中，并在页面中显示 1console.log(\"要输出的内容\"); 该内容会被写到开发者工具的控制台中 基本的语法js函数声明不需要；分号，但是赋值语句要加；分号 123456function functionName(arg0,arg1,arg2)&#123; //函数声明 &#125; var functionName=function(arg0,arg1,arg2)&#123; //函数表达式 &#125;;(注意分号) 注释 单行注释 1//注释内容 多行注释 123/* 注释内容 */ JS严格区分大小写 JS中每条语句以分号(;)结尾如果不写分号，浏览器会自动添加，但是会消耗一些系统资源， 而且有些时候，浏览器会加错分号，所以在开发中分号必须写 JS中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。 字面量和变量字面量字面量实际上就是一些固定的值，比如 1 2 3 4 true false null NaN “hello”字面量都是不可以改变的。 由于字面量不是很方便使用，所以在JS中很少直接使用字面量 变量变量可以用来保存字面量，并且可以保存任意的字面量 一般都是通过变量来使用字面量，而不直接使用字面量，而且也可以通过变量来对字面量进行一个描述 声明变量 使用var关键字来声明一个变量 1var a; 为变量赋值 1a = 1; 声明和赋值同时进行 1var a = 456; 标识符在JS中所有的可以自主命名的内容，都可以认为是一个标识符，是标识符就应该遵守标识符的规范。 比如：变量名、函数名、属性名 规范：1.标识符中可以含有字母、数字、_、$2.标识符不能以数字开头3.标识符不能是JS中的关键字和保留字4.标识符一般采用驼峰命名法xxxYyyZzz 数据类型六种数据类型 JS中一共分成六种数据类型 5个基本数据类型+object String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 其中基本数据类型有 5个 typeof运算符检查数据类型 1.String 字符串JS中的字符串需要使用引号引起来双引号或单引号都行 在字符串中使用\\作为转义字符 12345\\' ==&gt; ' \\\" ==&gt; \" \\n ==&gt; 换行 \\t ==&gt; 制表符 \\\\ ==&gt; \\ 使用typeof运算符检查字符串时，会返回”string” 2.Number 数值 JS中所有的整数和浮点数都是Number类型 最大能表示的值：Number.MAX_VALUE= 1.7976931348623157e+308 特殊的数字：能赋值给变量 Infinity 正无穷 a = Infinity ,能赋值 -Infinity 负无穷 NaN 非法数字（Not A Number） 其他进制的数字的表示：0b 开头表示二进制，但是不是所有的浏览器都支持0 开头表示八进制0x 开头表示十六进制 使用typeof检查一个Number类型的数据时，会返回”number”（包括NaN 和 Infinity） 3.Boolean 布尔值 布尔值主要用来进行逻辑判断，布尔值只有两个 true 逻辑的真 false 逻辑的假 使用typeof检查一个布尔值时，会返回”boolean” 4.Null 空值 空值专门用来表示为空的对象，Null类型的值只有一个 null 使用typeof检查一个Null类型的值时会返回”object” 5.Undefined 未定义 如果声明一个变量但是没有为变量赋值此时变量的值就是undefined 该类型的值只有一个 undefined 使用typeof检查一个Undefined类型的值时，会返回”undefined” 引用数据类型 Object 对象 类型转换 类型转换就是指将其他的数据类型，转换为String Number 或 Boolean 转换为String方式一（强制类型转换）： 调用被转换数据的toString()方法 例子：var a = 123;a = a.toString(); 注意：这个方法不适用于null和undefined由于这两个类型的数据中没有方法，所以调用toString()时会报错 方式二（强制类型转换）： 调用String()函数 例子： 12var a = 123; a = String(a); 原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，对于null值，直接转换为字符串”null”。对于undefined直接转换为字符串”undefined” 方式三（隐式的类型转换）: 为任意的数据类型 +”” 例子： 12var a = true; a = a + \"\"; 原理：和String()函数一样 转换为Number方式一（强制类型转换）： 调用Number()函数 例子： 12var s = \"123\"; s = Number(s); 转换的情况： 字符串 &gt; 数字 如果字符串是一个合法的数字，则直接转换为对应的数字 如果字符串是一个非法的数字，则转换为NaN 如果是一个空串或纯空格的字符串，则转换为0 布尔值 &gt; 数字 true转换为1 false转换为0 空值 &gt; 数字 null转换为0 未定义 &gt; 数字 undefined 转换为NaN 方式二（强制类型转换）： 调用parseInt()或parseFloat() 这两个函数专门用来将一个字符串转换为数字的 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作 parseInt() 可以将一个字符串中的有效的整数位提取出来，并转换为Number 例子： 12var a = \"123.456px\"; a = parseInt(a); //123 如果需要可以在parseInt()中指定一个第二个参数，来指定进制parseFloat()可以将一个字符串中的有效的小数位提取出来，并转换为Number 例子： 12var a = \"123.456px\"; a = parseFloat(a); //123.456 方式三（隐式的类型转换）： 使用一元的+来进行隐式的类型转换 例子： 12var a = \"123\"; a = +a; 原理：和Number()函数一样 转换为布尔值方式一（强制类型转换）： 使用Boolean()函数 例子： 12var s = \"false\"; s = Boolean(s); //true 转换的情况字符串 &gt; 布尔 除了空串其余全是true 数值 &gt; 布尔 除了0和NaN其余的全是true null、undefined &gt; 布尔 都是false 对象 &gt; 布尔 都是true 方式二（隐式类型转换）： 为任意的数据类型做两次非运算，即可将其转换为布尔值 例子： 12var a = \"hello\"; a = !!a; //true 基础语法运算符 运算符也称为操作符 通过运算符可以对一个或多个值进行运算或操作 typeof运算符 用来检查一个变量的数据类型 语法：typeof 变量 它会返回一个用于描述类型的字符串作为结果 算数运算符+&ensp;对两个值进行加法运算并返回结果-&ensp;对两个值进行减法运算并返回结果*&ensp;对两个值进行乘法运算并返回结果/&ensp;对两个值进行除法运算并返回结果%&ensp;对两个值进行取余运算并返回结果 除了加法以外，对非Number类型的值进行运算时，都会先转换为Number然后在做运算。 而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。 任何值和字符串做加法，都会先转换为字符串，然后再拼串 一元运算符 一元运算符只需要一个操作数 一元的+ 就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字 例子： 12var a = true; a = +a; 一元的- 就是负号，可以对一个数字进行符号位取反 例子： 12var a = 10; a = a; 自增 自增可以使变量在原值的基础上自增1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增1不同的是++a和a++的值是不同的， ++a的值是变量的新值（自增后的值） a++的值是变量的原值（自增前的值） 自减 自减可以使变量在原值的基础上自减1 自减使用 自减可以使用 前（a）后(a) 无论是a 还是 a都会立即使原变量自减1不同的是a和a的值是不同的， a的值是变量的新值（自减后的值） a的值是变量的原值（自减前的值） 逻辑运算符! 非运算可以对一个布尔值进行取反，true变false false边true 当对非布尔值使用!时，会先将其转换为布尔值然后再取反 我们可以利用!来将其他的数据类型转换为布尔值 &amp;&amp; &amp;&amp;可以对符号两侧的值进行与运算 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。 与是一个短路的与，如果第一个值是false，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为false，则返回第一个值 2.如果第一个值为true，则返回第二个值 || ||可以对符号两侧的值进行或运算 只有两端都是false时，才会返回false。只要有一个true，就会返回true。 或是一个短路的或，如果第一个值是true，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为true，则返回第一个值 2.如果第一个值为false，则返回第二个值 赋值运算符= 可以将符号右侧的值赋值给左侧变量+= 12a += 5 相当于 a = a+5 var str = \"hello\"; str += \"world\"; -= 1a -= 5 相当于 a = a-5 *= 1a *= 5 相当于 a = a*5 /= 1a /= 5 相当于 a = a/5 %= 1a %= 5 相当于 a = a%5 关系运算符 关系运算符用来比较两个值之间的大小关系的 &gt; &gt;= &lt; &lt;= 关系运算符的规则和数学中一致，用来比较两个值之间的关系， 如果关系成立则返回true，关系不成立则返回false。 如果比较的两个值是非数值，会将其转换为Number然后再比较。 如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。 相等运算符 相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false 相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，转换后相等它也会返回true，null == undifined != 不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false 不等也会做自动的类型转换。 === 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换， 如果两个值的类型不同，则直接返回false !== 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true 特殊的值： null和undefined 由于undefined衍生自null，所以null == undefined 会返回true。 但是 null === undefined 会返回false。NaN NaN不与任何值相等，报告它自身 NaN == NaN //false 判断一个值是否是NaN 使用isNaN()函数 三元运算符：?: 语法：条件表达式?语句1:语句2; 执行流程： 先对条件表达式求值判断， 如果判断结果为true，则执行语句1，并返回执行结果 如果判断结果为false，则执行语句2，并返回执行结果 优先级： 和数学中一样，JS中的运算符也是具有优先级的， 比如 先乘除 后加减 先与 后或 具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高， 优先级越高的越优先计算，优先级相同的，从左往右计算。 优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。 流程控制语句 程序都是自上向下的顺序执行的，通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。 条件分支语句 条件判断语句也称为if语句 语法一： 123if(条件表达式)&#123; 语句... &#125; 1234执行流程： if语句执行时，会先对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则不执行 语法二： 12345if(条件表达式)&#123; 语句... &#125;else&#123; 语句... &#125; 1234执行流程： if...else语句执行时，会对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则执行else后的语句 语法三： 1234567891011if(条件表达式)&#123; 语句... &#125;else if(条件表达式)&#123; 语句... &#125;else if(条件表达式)&#123; 语句... &#125;else if(条件表达式)&#123; 语句... &#125;else&#123; 语句... &#125; 12345执行流程 if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断， 如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。 如果判断结果为false，则继续向下判断，直到找到为true的为止。 如果所有的条件表达式都是false，则执行else后的语句 1.条件分支语句switch语句语法: 1234567891011121314switch(条件表达式)&#123; case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; &#125; 执行流程： switch…case…语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较， 如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。 如果所有的case判断结果都为false，则从default处开始执行代码。 循环语句通过循环语句可以反复执行某些语句多次while循环 语法： 123while(条件表达式)&#123; 语句... &#125; 执行流程： while语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为false，则终止循环 如果判断结果为true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do…while循环 语法: 123do&#123; 语句... &#125;while(条件表达式) 执行流程 do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断， 如果判断判断结果为false，则终止循环。 如果判断结果为true，则继续执行循环体，依此类推 和while的区别： while：先判断后执行 do…while: 先执行后判断 do…while可以确保循环体至少执行一次。 for循环 语法： 123for(①初始化表达式 ; ②条件表达式 ; ④更新表达式)&#123; ③语句... &#125; 执行流程： 首先执行①初始化表达式，初始化一个变量， 然后对②条件表达式进行求值判断，如果为false则终止循环 如果判断结果为true，则执行③循环体 循环体执行完毕，执行④更新表达式，对变量进行更新。 更新表达式执行完毕重复② 死循环 1234567while(true)&#123; &#125; for(;;)&#123; &#125; 对象（Object）对象是JS中的引用数据类型对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性使用typeof检查一个对象时，会返回object 对象的分类：1.内建对象 - 由ES标准中定义的对象，在任何的ES的实现中都可以使用 - 比如：Math String Number Boolean Function Object…. 2.宿主对象 - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象 - 比如 BOM DOM 3.自定义对象 - 由开发人员自己创建的对象 创建对象 方式一： 1var obj = new Object(); 方式二： 1var obj = &#123;&#125;; 向对象中添加属性 语法： 对象.属性名 = 属性值; 对象[“属性名”] = 属性值; //这种方式能够使用特殊的属性名 对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。属性值也可以任意的数据类型。 读取对象中的属性 语法： 对象.属性名 对象[“属性名”] //“属性名”可以使字符串常量，也可以是字符串变量 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined 删除对象中的属性 语法： 12delete 对象.属性名 delete 对象[\"属性名\"] 遍历使用in检查对象中是否含有指定属性 语法：”属性名” in 对象 如果在对象中含有该属性，则返回true 如果没有则返回false 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性). 12345var obj = &#123;'0':'a','1':'b','2':'c'&#125;; for(var i in obj) &#123; console.log(i,\":\",obj[i]); &#125; ​使用对象字面量，在创建对象时直接向对象中添加属性语法： 123456var obj = &#123; 属性名:属性值, 属性名:属性值, 属性名:属性值, 属性名:属性值 &#125; 基本数据类型和引用数据类型 基本数据类型 String Number Boolean Null Undefined 引用数据类型 Object 基本数据类型的数据，变量是直接保存的它的值。 变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。 引用数据类型的数据，变量是保存的对象的引用（内存地址）。 如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。 比较两个变量时，对于基本数据类型，比较的就是值， 对于引用数据类型比较的是地址，地址相同才相同 函数（Function）函数也是一个对象，也具有普通对象的功能（能有属性）函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码使用typeof检查一个函数时会返回function创建函数 函数声明 123function 函数名([形参1,形参2...形参N])&#123; 语句... &#125; 函数表达式 123var 函数名 = function([形参1,形参2...形参N])&#123; 语句... &#125;; 调用函数 语法：函数对象([实参1,实参2…实参N]); fun() sum() alert() Number() parseInt() 当我们调用函数时，函数中封装的代码会按照编写的顺序执行 立即执行函数函数定义完，立即被调用，这种函数叫做立即执行函数立即执行函数往往只会执行一次 1234(function(a,b)&#123; console.log(\"a = \"+a); console.log(\"b = \"+b); &#125;)(123,456); 遍历对象 123for(var v in obj)&#123; document.write(\"property：name =\"+v+\"value=\"+obj[v]+\"&lt;br/&gt;\" ); &#125; 形参和实参 形参：形式参数 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开 定义形参就相当于在函数内声明了对应的变量但是并不赋值， 形参会在调用时才赋值。 实参：实际参数 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参, 调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。 如果实参的数量大于形参，多余实参将不会赋值， 如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined 返回值，就是函数执行的结果。 使用return 来设置函数的返回值。 语法：return 值; 该值就会成为函数的返回值，可以通过一个变量来接收返回值 return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。 return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。 如果return后不跟值，或者是不写return则函数默认返回undefined。 break、continue和return break 退出循环 continue 跳过当次循环 return 退出函数 参数，函数的实参也可以是任意的数据类型。 方法（method） 可以将一个函数设置为一个对象的属性， 当一个对象的属性是一个函数时， 我们称这个函数是该对象的方法。 对象.方法名(); 函数名() 函数的属性和方法call()apply() 这两个方法都是函数对象的方法需要通过函数对象来调用 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递arguments arguments和this类似，都是函数中的隐含的参数 arguments是一个类数组元素，它用来封装函数执行过程中的实参 所以即使不定义形参，也可以通过arguments来使用实参 arguments中有一个属性callee表示当前执行的函数对象 this（调用函数的那个对象） this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象 1.以函数的形式调用时，this是window 2.以方法的形式调用时，this是调用方法的对象 3.以构造函数的形式调用时，this是新建的那个对象 4.使用call和apply调用时，this是指定的那个对象 5.在全局作用域中this代表window 作用域作用域简单来说就是一个变量的作用范围。在JS中作用域分成两种： 1.全局作用域 直接在script标签中编写的代码都运行在全局作用域中全局作用域在打开页面时创建，在页面关闭时销毁。全局作用域中有一个全局对象window，window对象由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口。在全局作用域中创建的变量都会作为window对象的属性保存在全局作用域中创建的函数都会作为window对象的方法保存在全局作用域中创建的变量和函数可以在页面的任意位置访问。在函数作用域中也可以访问到全局作用域的变量。尽量不要在全局中创建变量 2.函数作用域 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。函数作用域在函数执行时创建，在函数执行结束时销毁。在函数作用域中创建的变量，不能在全局中访问。当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，如果找到了则使用，找不到则继续向上找，一直会 变量的声明提前 在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。 所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。 在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明， 如果没有使用var关键字声明变量，则变量会变成全局变量 函数的声明提前 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建， 也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。 this（上下文对象）我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。 指向当前对象 this的不同的情况：1.以函数的形式调用时，this是window2.以方法的形式调用时，this就是调用方法的对象3.以构造函数的形式调用时，this就是新创建的对象 4.构造函数构造函数是专门用来创建对象的函数一个构造函数我们也可以称为一个类通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例通过同一个构造函数创建的对象，我们称为一类对象构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数如果使用new来调用，则它就是一个构造函数 例子： 12345678function Person(name , age , gender)&#123; this.name = name; this.age = age; this.gender = gender; this.sayName = function()&#123; alert(this.name); &#125;; &#125; 构造函数的执行流程：1.创建一个新的对象2.将新的对象作为函数的上下文对象（this）3.执行函数中的代码4.将新建的对象返回 instanceof 用来检查一个对象是否是一个类的实例 语法：对象 instanceof 构造函数 如果该对象时构造函数的实例，则返回true，否则返回false Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true 枚举对象中的属性for…in语法： 123for(var 属性名 in 对象)&#123; &#125; for…in语句的循环体会执行多次，对象中有几个属性就会执行几次， 每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性 原型（prototype） 创建一个函数以后，解析器都会默认在函数中添加一个数prototype prototype属性指向的是一个对象，这个对象我们称为原型对象。 当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。 1这个隐含的属性可以通过对象.__proto__来访问。 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。 我们可以将对象中共有的属性和方法统一添加到原型对象中， 这样我们只需要添加一次，就可以使所有的对象都可以使用。 当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找， 如果在自身中找到了，则直接使用。 如果没有找到，则去原型对象中寻找，如果找到了则使用， 如果没有找到，则去原型的原型中寻找，依此类推。直到找到Object的原型为止，Object的原型的原型为null， 如果依然没有找到则返回undefined hasOwnProperty() 这个方法可以用来检查对象自身中是否含有某个属性 语法：对象.hasOwnProperty(“属性名”) toString方法当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值 如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法 1234//修改Person原型的toString Person.prototype.toString = function()&#123; return \"Person[name=\"+this.name+\",age=\"+this.age+\",gender=\"+this.gender+\"]\"; &#125;; 垃圾回收（GC）就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作我们需要做的只是要将不再使用的对象设置null即可 数组（Array） 数组也是一个对象，是一个用来存储数据的对象和Object类似，但是它的存储效率比普通对象要高 数组中保存的内容我们称为元素 数组使用索引（index）来操作元素 索引指由0开始的整数 数组的操作： 创建数组 12var arr = new Array(); var arr = []; 向数组中添加元素语法；数组对象[索引] = 值; 12arr[0] = 123; arr[1] = \"hello\"; 创建数组时直接添加元素 语法： 1var arr = [元素1,元素2....元素N]; 例子： 1var arr = [123,\"hello\",true,null]; 获取和修改数组的长度 使用length属性来操作数组的长度 获取长度： 数组.length length获取到的是数组的最大索引+1 对于连续的数组，length获取到的就是数组中元素的个数 修改数组的长度 数组.length = 新长度 如果修改后的length大于原长度，则多出的部分会空出来 如果修改后的length小于原长度，则原数组中多出的元素会被删除 向数组的最后添加元素 数组[数组.length] = 值; 数组的方法 functionName function usage push() 用来向数组的末尾添加一个或多个元素，并返回数组新的长度 语法：数组.push(元素1,元素2,元素N)pop() pop() 用来删除数组的最后一个元素，并返回被删除的元素 unshift() 向数组的开头添加一个或多个元素，并返回数组的新的长度 shift() 删除数组的开头的一个元素，并返回被删除的元素 reverse() 可以用来反转一个数组，它会对原数组产生影响 concat() 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回 slice(sart,[end])可以从一个数组中截取指定的元素 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回 参数： 1.截取开始位置的索引（包括开始位置） 2.截取结束位置的索引（不包括结束位置） 第二个参数可以省略不写，如果不写则一直截取到最后 参数可以传递一个负值，如果是负值，则从后往前数 splice()可以用来删除数组中指定元素，并使用新的元素替换 该方法会将删除的元素封装到新数组中返回 参数： 1.删除开始位置的索引 2.删除的个数 3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边 join([splitor]) 可以将一个数组转换为一个字符串 参数： 需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素 如果不指定连接符则默认使用, sort() 可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序 调用以后，会直接修改原数组。 可以自己指定排序的规则，需要一个回调函数作为参数： 我们可以自己来指定排序的规则我们可以在sort()添加一个回调函数，来指定排序规则， 回调函数中需要定义两个形参, 浏览器将会分别使用数组中的元素作为实参去调用回调函数 使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边 浏览器会根据回调函数的返回值来决定元素的顺序， 如果返回一个大于0的值，则元素会交换位置 如果返回一个小于0的值，则元素位置不变 如果返回一个0，则认为两个元素相等，也不交换位置 如果需要升序排列，则返回 a-b 如果需要降序排列，则返回b-a 1234567function(a,b)&#123; //升序排列 //return a-b; //降序排列 return b-a; &#125; 遍历数组 遍历数组就是将数组中元素都获取到 一般情况我们都是使用for循环来遍历数组 123for(var i=0 ; i&lt;数组.length ; i++)&#123; //数组[i] &#125; 使用forEach()方法来遍历数组（不兼容IE8） 123数组.forEach(function(value , index , obj)&#123; &#125;); forEach()方法需要一个回调函数作为参数，数组中有几个元素，回调函数就会被调用几次，每次调用时，都会将遍历到的信息以实参的形式传递进来，我们可以定义形参来获取这些信息。value:正在遍历的元素index:正在遍历元素的索引obj:被遍历对象 常用类和方法包装类在JS中为我们提供了三个包装类：String() Boolean() Number() 通过这三个包装类可以创建基本数据类型的对象例子： 123var num = new Number(2); var str = new String(\"hello\"); var bool = new Boolean(true); 但是在实际应用中千万不要这么干。 当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，操作完成以后再将这个临时对象进行销毁。 Date日期的对象，在JS中通过Date对象来表示一个时间创建对象 创建一个当前的时间对象 1var d = new Date(); 创建一个指定的时间对象 1var d = new Date(\"月/日/年 时:分:秒\"); 方法： name getDate() 当前日期对象是几日（1-31） getDay() 返回当前日期对象时周几（0-6） 0 周日 1 周一 。。。 getMonth() 返回当前日期对象的月份（0-11） 0 一月 1 二月 。。。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回当前日期对象的时间戳 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数 计算机底层保存时间都是以时间戳的形式保存的。 Date.now() 可以获取当前代码执行时的时间戳 setHours() 设置 Date 对象中的小时 (0 ~ 23) MathMath属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法我们可以直接使用它来进行数学运算相关的操作方法：Math.PI 常量，圆周率Math.abs() 绝对值运算Math.ceil() 向上取整Math.floor() 向下取整Math.round() 四舍五入取整Math.random() 生成一个01之间的随机数 生成一个xy之间的随机数 Math.round(Math.random()*(y-x)+x);Math.pow(x,y) 求x的y次幂Math.sqrt() 对一个数进行开方Math.max() 求多个数中最大值Math.min() 求多个数中的最小值 字符串的相关的方法使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； length 获取字符串的长度charAt() 根据索引获取指定的字符charCodeAt() 根据索引获取指定的字符编码String.fromCharCode() 根据字符编码获取字符indexOf()lastIndexOf() 从一个字符串中检索指定内容 需要一个字符串作为参数，这个字符串就是要检索的内容， 如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。 可以指定一个第二个参数，来表示开始查找的位置 indexOf()是从前向后找 lastIndexOf()是从后向前找slice(start,[end]) 可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量 参数： 第一个：截取开始的位置（包括开始） 第二个：截取结束的位置（不包括结束） 可以省略第二个参数，如果省略则一直截取到最后 可以传负数，如果是负数则从后往前数substr() 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量 substring() 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0， substring()中如果第二个参数小于第一个，自动调整位置toLowerCase() 将字符串转换为小写并返回toUpperCase() 将字符串转换为大写并返回 正则表达相关方法split() 可以根据指定内容将一个字符串拆分为一个数组 参数： 需要一个字符串作为参数，将会根据字符串去拆分数组 可以接收一个正则表达式，此时会根据正则表达式去拆分数组 match() 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来 默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索 我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容 可以为一个正则表达式设置多个匹配模式，且顺序无所谓 match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果 replace() 可以将字符串中指定内容替换为新的内容 参数： 1.被替换的内容，可以接受一个正则表达式作为参数 2.新的内容 空串则为删除”” 默认只会替换第一个 search() 可以搜索字符串中是否含有指定内容 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回1 它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串 serach()只会查找第一个，即使设置全局匹配也没用 正则表达式正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，也可以将一个字符串中符合规则的内容提取出来。创建正则表达式 var reg = new RegExp(“正则”,”匹配模式”); 注意：使用构造函数时，由于它的参数是一个字符串，而\\是字符串中转义字符，如果要使用\\则需要使用\\来代替 var reg = /正则表达式/匹配模式 （匹配模式可以多个一起写：/gi） 语法：匹配模式： i:忽略大小写（ignore） g:全局匹配模式（默认为1次） 设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求 正则语法 | 或 [] 或 [^ ] 除了 **[x-y] x的ascii到y的ascii码之间的值** [a-z] 小写字母 （也可以[e-i])[A-Z] 大写字母[A-z] 任意字母,但是还包括了其他ASCII在此之中的[0-9] 任意数字 元符号 检查一个字符串中是否含有 . . 表示任意字符 在正则表达式中使用\\作为转义字符 . 来表示. \\ 表示\\ \\w 任意字母、数字、_ [A-z0-9_] \\W 除了字母、数字、_ [ ^A-z0-9_] \\d 任意的数字 [0-9] \\D 除了数字 [ ^0-9] \\s 空格 \\S 除了空格 \\b 单词边界 \\B 除了单词边界 量词 通过量词可以设置一个内容出现的次数 量词只对它前边的一个内容起作用 {n} 正好出现n次 {m,n} 出现mn次 {m,} m次以上 +至少一个，相当于{1,}*个或多个，相当于{0,} ? 0个或1个，相当于{0,1} 边界表达式（不要在java中用，javaScript中用） ^:正则开始 $:正则结束 ：注意结束前一个才是结束匹配 12reg = /^a/; reg = /b$/; 方法：test() 可以用来检查一个字符串是否符合正则表达式 如果符合返回true，否则返回false例子 去掉两端的空格: 12var s = \" f afa \"; s = s.replace(/^\\s*|\\s*$/g,\"\"); DOMDocument Object Model文档对象模型，通过DOM可以来任意来修改网页中各个内容文档 文档指的是网页，一个网页就是一个文档对象 对象指将网页中的每一个节点都转换为对象 转换完对象以后，就可以以一种纯面向对象的形式来操作网页了模型 模型用来表示节点和节点之间的关系，方便操作页面节点（Node） 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点 虽然都是节点，但是节点的类型却是不同的 常用的节点 文档节点 （Document），代表整个网页 元素节点（Element），代表网页中的标签 属性节点（Attribute），代表标签中的属性 文本节点（Text），代表网页中的文本内容 DOM操作 DOM查询 在网页中浏览器已经为我们提供了document对象， 它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。 document查询方法： 根据元素的id属性查询一个元素节点对象： document.getElementById(“id属性值”); 根据元素的name属性值查询一组元素节点对象: document.getElementsByName(“name属性值”); 根据标签名来查询一组元素节点对象： document.getElementsByTagName(“标签名”); 元素的属性： 读取元素的属性： 语法：元素.属性名 例子：ele.name ele.id ele.value ele.className 注意：class属性不能采用这种方式， 读取class属性时需要使用 元素.className 修改元素的属性： 语法：元素.属性名 = 属性值 innerHTML 使用该属性可以获取或设置元素内部的HTML代码 事件（Event） 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。 我们可以为事件来绑定回调函数来响应事件。 绑定事件的方式： 1.可以在标签的事件属性中设置相应的JS代码 例子： 1&lt;button onclick=\"js代码。。。\"&gt;按钮&lt;/button&gt; 2.可以通过为对象的指定事件属性设置回调函数的形式来处理事件 例子： 1234567&lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(\"btn\"); btn.onclick = function()&#123; &#125;; &lt;/script&gt; 文档的加载 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载， 此时将会无法正常获取到DOM对象，导致DOM操作失败。 解决方式一： 可以将js代码编写到body的下边 12345678910&lt;body&gt; &lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(\"btn\"); btn.onclick = function()&#123; &#125;; &lt;/script&gt; &lt;/body&gt; 解决方式二： 将js代码编写到window.onload = function(){}中 window.onload 对应的回调函数会在整个页面加载完毕以后才执行， 所以可以确保代码执行时，DOM对象已经加载完毕了 1234567&lt;script&gt; window.onload = function()&#123; var btn = document.getElementById(\"btn\"); btn.onclick = function()&#123; &#125;; &#125;; &lt;/script&gt; DOM查询通过具体的元素节点来查询元素.getElementsByTagName()通过标签名查询当前元素的指定后代元素 子节点包括便签元素中的文本，子元素自包含标签元素 元素.childNodes 获取当前元素的所有子节点 会获取到空白的文本子节点 childNodes属性会获取包括文本节点在呢的所有节点 根据DOM标签标签间空白也会当成文本节点 注意：在IE8及以下的浏览器中，不会将空白文本当成子节点， 所以该属性在IE8中会返回4个子元素而其他浏览器是9个 元素.children 获取当前元素的所有子元素 元素.firstChild 获取当前元素的第一个子节点，会获取到空白的文本子节点 元素.lastChild 获取当前元素的最后一个子节点 元素.parentNode 获取当前元素的父元素 元素.previousSibling 获取当前元素的前一个兄弟节点 previousElementSibling获取前一个兄弟元素，IE8及以下不支持 元素.nextSibling 获取当前元素的后一个兄弟节点 firstElementChild获取当前元素的第一个子元素 firstElementChild不支持IE8及以下的浏览器， 如果需要兼容他们尽量不要使用 innerHTML和innerText这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性两个属性作用类似，都可以获取到标签内部的内容，不同是innerHTML会获取到html标签，而innerText会自动去除标签如果使用这两个属性来设置标签内部的内容时，没有任何区别的 读取标签内部的文本内容 h1中的文本内容 元素.firstChild.nodeValue document对象的其他的属性和方法document.all 获取页面中的所有元素，相当于document.getElementsByTagName(“*”); document.documentElement 获取页面中html根元素 document.body 获取页面中的body元素 document.getElementsByClassName() 根据元素的class属性值查询一组元素节点对象 这个方法不支持IE8及以下的浏览器 document.querySelector() 根据CSS选择器去页面中查询一个元素 如果匹配到的元素有多个，则它会返回查询到的第一个元素 document.querySelectorAll() 根据CSS选择器去页面中查询一组元素 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个 DOM修改document.createElement(“TagName”) 可以用于创建一个元素节点对象， 它需要一个标签名作为参数，将会根据该标签名创建元素节点对象， 并将创建好的对象作为返回值返回document.createTextNode(“textContent”)可以根据文本内容创建一个文本节点对象 父节点.appendChild(子节点) 向父节点中添加指定的子节点父节点.insertBefore(新节点,旧节点) 将一个新的节点插入到旧节点的前边父节点.replaceChild(新节点,旧节点) 使用一个新的节点去替换旧节点 父节点.removeChild(子节点) 删除指定的子节点 推荐方式：子节点.parentNode.removeChild(子节点) 以上方法，实际就是改变了相应元素（标签）的innerHTML的值。 123456789101112131415161718myClick(\"btn07\",function()&#123; //向city中添加广州 var city = document.getElementById(\"city\"); /* * 使用innerHTML也可以完成DOM的增删改的相关操作 * 一般我们会两种方式结合使用 */ //city.innerHTML += \"&lt;li&gt;广州&lt;/li&gt;\"; //创建一个li var li = document.createElement(\"li\"); //向li中设置文本 li.innerHTML = \"广州\"; //将li添加到city中 city.appendChild(li); &#125;); DOM对CSS的操作读取和修改内联样式使用style属性来操作元素的内联样式 读取内联样式： 语法：元素.style.样式名例子： 元素.style.width 元素.style.height 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法将-去掉，然后后的字母改大写 比如：backgroundcolor &gt; backgroundColor borderwidth &gt; borderWidth修改内联样式：语法：元素.style.样式名 = 样式值 通过style修改和读取的样式都是内联样式，由于内联样式的优先级比较高， 所以我们通过JS来修改的样式，往往会立即生效， 但是如果样式中设置了!important，则内联样式将不会生效。 读取元素的当前样式正常浏览器 使用getComputedStyle() 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式 参数： 1.要获取样式的元素 2.可以传递一个伪元素，一般传null 例子： 获取元素的宽度 getComputedStyle(box , null)[“width”]; 通过该方法读取到样式都是只读的不能修改 IE8 使用currentStyle 语法： 元素.currentStyle.样式名 例子： box.currentStyle[“width”] 通过这个属性读取到的样式是只读的不能修改 实现兼容性 //对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错 1234567891011121314151617/* * 定义一个函数，用来获取指定元素的当前的样式 * 参数： * obj 要获取样式的元素 * name 要获取的样式名 */ function getStyle(obj , name)&#123; //对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错 if(window.getComputedStyle)&#123; //正常浏览器的方式，具有getComputedStyle()方法 return getComputedStyle(obj , null)[name]; &#125;else&#123; //IE8的方式，没有getComputedStyle()方法 return obj.currentStyle[name]; &#125; //return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name]; &#125; 其他的样式相关的属性注意：以下样式都是只读的,未指明偏移量都是相对于当前窗口左上角 clientHeight 元素的可见高度，包括元素的内容区和内边距的高度clientWidth 元素的可见宽度，包括元素的内容区和内边距的宽度offsetHeight 整个元素的高度，包括内容区、内边距、边框offfsetWidth 整个元素的宽度，包括内容区、内边距、边框offsetParent 当前元素的定位父元素 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回bodyoffsetLeftoffsetTop 当前元素和定位父元素之间的偏移量 offsetLeft水平偏移量 offsetTop垂直偏移量 scrollHeightscrollWidth 获取元素滚动区域的高度和宽度 scrollTopscrollLeft 获取元素垂直和水平滚动条滚动的距离 判断滚动条是否滚动到底 垂直滚动条 scrollHeight -scrollTop = clientHeight 水平滚动 scrollWidth -scrollLeft = clientWidth 事件（Event）事件对象当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。 可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存 例子： 12345678元素.事件 = function(event)&#123; event = event || window.event; &#125;; 元素.事件 = function(e)&#123; e = e || event; &#125;; 获取到鼠标的坐标 clientX和clientY 用于获取鼠标在当前的可见窗口的坐标 div的偏移量，是相对于整个页面的 pageX和pageY 可以获取鼠标相对于当前页面的坐标 但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用var left = event.clientX;var top = event.clientY; 事件的冒泡（Bubble） 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消 可以将事件对象的cancelBubble设置为true，即可取消冒泡 例子： 1234元素.事件 = function(event)&#123; event = event || window.event; event.cancelBubble = true; &#125;; 事件的委派 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能 我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的我们可以尝试将其绑定给元素的共同的祖先元素 target : event中的target表示的触发事件的对象 事件的绑定addEventListener() 通过这个方法也可以为元素绑定响应函数参数： 1.事件的字符串，不要on 2.回调函数，当事件触发时该函数会被调用 3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行 这个方法不支持IE8及以下的浏览器 1234567btn01.addEventListener(\"click\",function()&#123; alert(1); &#125;,false); btn01.addEventListener(\"click\",function()&#123; alert(2); &#125;,false); attachEvent() 在IE8中可以使用attachEvent()来绑定事件参数： 1.事件的字符串，要on 2.回调函数 这个方法也可以同时为一个事件绑定多个处理函数， 不同的是它是后绑定先执行，执行顺序和addEventListener()相反 1234567btn01.attachEvent(\"onclick\",function()&#123; alert(1); &#125;); btn01.attachEvent(\"onclick\",function()&#123; alert(2); &#125;); 12345678910111213141516171819202122232425262728//定义一个函数，用来为指定元素绑定响应函数 /* * addEventListener()中的this，是绑定事件的对象 * attachEvent()中的this，是window * 需要统一两个方法this */ /* * 参数： * obj 要绑定事件的对象 * eventStr 事件的字符串(不要on) * callback 回调函数 */ function bind(obj , eventStr , callback)&#123; if(obj.addEventListener)&#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr , callback , false); &#125;else&#123; /* * this是谁由调用方式决定 * callback.call(obj) */ //IE8及以下 obj.attachEvent(\"on\"+eventStr , function()&#123; //在匿名函数中调用回调函数 callback.call(obj); &#125;); &#125; &#125; 事件的传播 关于事件的传播网景公司和微软公司有不同的理解 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件， 然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件， 然后在向内传播给后代元素 W3C综合了两个公司的方案，将事件传播分成了三个阶段 1.捕获阶段 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件 2.目标阶段 事件捕获到目标元素，捕获结束开始在目标元素上触发事件 3.冒泡阶段 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true 一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false IE8及以下的浏览器中没有捕获阶段 常用事件鼠标事件拖拽事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #box1&#123; width: 100px; height: 100px; background-color: red; position: absolute; &#125; #box2&#123; width: 100px; height: 100px; background-color: yellow; position: absolute; left: 200px; top: 200px; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; /* * 拖拽box1元素 * - 拖拽的流程 * 1.当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown * 2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove * 3.当鼠标松开时，被拖拽元素固定在当前位置 onmouseup */ //获取box1 var box1 = document.getElementById(\"box1\"); var box2 = document.getElementById(\"box2\"); var img1 = document.getElementById(\"img1\"); //开启box1的拖拽 drag(box1); //开启box2的 drag(box2); drag(img1); &#125;; /* * 提取一个专门用来设置拖拽的函数 * 参数：开启拖拽的元素 */ function drag(obj)&#123; //当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown obj.onmousedown = function(event)&#123; //设置box1捕获所有鼠标按下的事件 /* * setCapture() * - 只有IE支持，但是在火狐中调用时不会报错， * 而如果使用chrome调用，会报错 */ /*if(box1.setCapture)&#123; box1.setCapture(); &#125;*/ obj.setCapture &amp;&amp; obj.setCapture(); event = event || window.event; //div的偏移量 鼠标.clentX - 元素.offsetLeft //div的偏移量 鼠标.clentY - 元素.offsetTop var ol = event.clientX - obj.offsetLeft; var ot = event.clientY - obj.offsetTop; //为document绑定一个onmousemove事件 document.onmousemove = function(event)&#123; event = event || window.event; //当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove //获取鼠标的坐标 var left = event.clientX - ol; var top = event.clientY - ot; //修改box1的位置 obj.style.left = left+\"px\"; obj.style.top = top+\"px\"; &#125;; //为document绑定一个鼠标松开事件 document.onmouseup = function()&#123; //当鼠标松开时，被拖拽元素固定在当前位置 onmouseup //取消document的onmousemove事件 document.onmousemove = null; //取消document的onmouseup事件 document.onmouseup = null; //当鼠标松开时，取消对事件的捕获 obj.releaseCapture &amp;&amp; obj.releaseCapture(); &#125;; /* * 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容， * 此时会导致拖拽功能的异常，这个是浏览器提供的默认行为， * 如果不希望发生这个行为，则可以通过return false来取消默认行为 * * 但是这招对IE8不起作用 */ return false; &#125;; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 我是一段文字 &lt;div id=\"box1\"&gt;&lt;/div&gt; &lt;div id=\"box2\"&gt;&lt;/div&gt; &lt;img src=\"img/an.jpg\" id=\"img1\" style=\"position: absolute;\"/&gt; &lt;/body&gt; &lt;/html&gt; 滚轮事件： onwheel都支持 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #box1&#123; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; //获取id为box1的div var box1 = document.getElementById(\"box1\"); //为box1绑定一个鼠标滚轮滚动的事件 /* * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发， * 但是火狐不支持该属性 * * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件 * 注意该事件需要通过addEventListener()函数来绑定 */ box1.onmousewheel = function(event)&#123; event = event || window.event; //event.wheelDelta 可以获取鼠标滚轮滚动的方向 //向上滚 120 向下滚 -120 //wheelDelta这个值我们不看大小，只看正负 //alert(event.wheelDelta); //wheelDelta这个属性火狐中不支持 //在火狐中使用event.detail来获取滚动的方向 //向上滚 -3 向下滚 3 //alert(event.detail); /* * 当鼠标滚轮向下滚动时，box1变长 * 当滚轮向上滚动时，box1变短 */ //判断鼠标滚轮滚动的方向 if(event.wheelDelta &gt; 0 || event.detail &lt; 0)&#123; //向上滚，box1变短 box1.style.height = box1.clientHeight - 10 + \"px\"; &#125;else&#123; //向下滚，box1变长 box1.style.height = box1.clientHeight + 10 + \"px\"; &#125; /* * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false * 需要使用event来取消默认行为event.preventDefault(); * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错 */ event.preventDefault &amp;&amp; event.preventDefault(); /* * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动， * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为 */ return false; &#125;; //为火狐绑定滚轮事件 bind(box1,\"DOMMouseScroll\",box1.onmousewheel); &#125;; function bind(obj , eventStr , callback)&#123; if(obj.addEventListener)&#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr , callback , false); &#125;else&#123; /* * this是谁由调用方式决定 * callback.call(obj) */ //IE8及以下 obj.attachEvent(\"on\"+eventStr , function()&#123; //在匿名函数中调用回调函数 callback.call(obj); &#125;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body style=\"height: 2000px;\"&gt; &lt;div id=\"box1\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 键盘事件键盘事件：onkeydown 按键被按下 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生。onkeyup 按键被松开 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document keyCode 可以通过keyCode来获取按键的编码通过它可以判断哪个按键被按下除了keyCode，事件对象中还提供了几个属性altKeyctrlKeyshiftKey这个三个用来判断alt ctrl 和 shift是否被按下如果按下则返回true，否则返回false 1234567//console.log(event.keyCode); //判断一个y是否被按下 //判断y和ctrl是否同时被按下 if(event.keyCode === 89 &amp;&amp; event.ctrlKey)&#123; console.log(\"ctrl和y都被按下了\"); &#125; 12345678910input.onkeydown = function(event) &#123; event = event || window.event; //数字 48 - 57 //使文本框中不能输入数字 if(event.keyCode &gt;= 48 &amp;&amp; event.keyCode &lt;= 57) &#123; //在文本框中输入内容，属于onkeydown的默认行为 //如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中 return false; &#125; &#125;; BOM浏览器对象模型(browser object model)BOM可以使我们通过JS来操作浏览器在BOM中为我们提供了一组对象，用来完成对浏览器的操作BOM对象Window 代表的是整个浏览器的窗口，同时window也是网页中的全局对象Navigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器Location 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面History 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页 而且该操作只在当次访问时有效Screen 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用 Navigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了 一般我们只会使用userAgent来判断浏览器的信息， userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容， 不同的浏览器会有不同的userAgent 火狐的userAgentMozilla5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko20100101 Firefox50.0 Chrome的userAgentMozilla5.0 (Windows NT 6.1; Win64; x64) AppleWebKit537.36 (KHTML, like Gecko) Chrome52.0.2743.82 Safari537.36 IE8Mozilla4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE9Mozilla5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE10Mozilla5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE11Mozilla5.0 (Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko 在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了 123456789101112131415alert(navigator.appName); var ua = navigator.userAgent; console.log(ua); if(firefoxi.test(ua))&#123; alert(\"你是火狐！！！\"); &#125;else if(chromei.test(ua))&#123; alert(\"你是Chrome\"); &#125;else if(msiei.test(ua))&#123; alert(\"你是IE浏览器~~~\"); &#125;else if(\"ActiveXObject\" in window)&#123; alert(\"你是IE11，枪毙了你~~~\"); &#125; History 对象可以用来操作浏览器向前或向后翻页length 属性，可以获取到当成访问的链接数量back() 可以用来回退到上一个页面，作用和浏览器的回退按钮一样forward() 可以跳转下一个页面，作用和浏览器的前进按钮一样go() 可以用来跳转到指定的页面 它需要一个整数作为参数 1:表示向前跳转一个页面 相当于forward() 2:表示向前跳转两个页面 -1:表示向后跳转一个页面 -2:表示向后跳转两个页面 Location 该对象中封装了浏览器的地址栏的信息如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）alert(location);如果直接将location属性修改为一个完整的路径，或相对路径则我们页面会自动跳转到该路径，并且会生成相应的历史记录location = “http:www.baidu.com&quot;;location = “01.BOM.html”;assign() 用来跳转到其他的页面，作用和直接修改location一样reload() 用于重新加载当前页面，作用和刷新按钮一样 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面location.reload(true);replace() 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面 不会生成历史记录，不能使用回退按钮回退 window定时器setInterval() 定时调用 可以将一个函数，每隔一段时间执行一次 参数： 1.回调函数，该函数会每隔一段时间被调用一次 2.每次调用间隔的时间，单位是毫秒 返回值： 返回一个Number类型的数据 这个数字用来作为定时器的唯一标识clearInterval()可以用来关闭一个定时器方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器 clearInterval()可以接收任意参数， 如果参数是一个有效的定时器的标识，则停止对应的定时器 如果参数不是一个有效的标识，则什么也不做 12345678var num = 1; var timer = setInterval(function() &#123; count.innerHTML = num++; if(num == 11) &#123; //关闭定时器 clearInterval(timer); &#125; &#125;, 1000); 延时调用setTimeout 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择 var timer = setTimeout(function(){console.log(num++);},3000); 使用clearTimeout()来关闭一个延时调用clearTimeout(timer); #类的操作 直接修改元素的类css： 通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面。 这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便 我希望一行代码，可以同时修改多个样式 我们可以通过修改元素的class属性来间接的修改样式.这样一来，我们只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好，并且这种方式，可以使表现和行为进一步的分离 1box.className += \" b2\"; //注意有空格，添加class属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445//定义一个函数，用来向一个元素中添加指定的class属性值 /* * 参数: * obj 要添加class属性的元素 * cn 要添加的class值 * */ function addClass(obj, cn) &#123; if (!hasClass(obj, cn)) &#123; obj.className += \" \" + cn; &#125; &#125; /* * 判断一个元素中是否含有指定的class属性值 * 如果有该class，则返回true，没有则返回false * */ function hasClass(obj, cn) &#123; var reg = new RegExp(\"\\\\b\" + cn + \"\\\\b\"); return reg.test(obj.className); &#125; /* * 删除一个元素中的指定的class属性 */ function removeClass(obj, cn) &#123; //创建一个正则表达式 var reg = new RegExp(\"\\\\b\" + cn + \"\\\\b\"); //删除class obj.className = obj.className.replace(reg, \"\"); &#125; /* * toggleClass可以用来切换一个类 * 如果元素中具有该类，则删除 * 如果元素中没有该类，则添加 */ function toggleClass(obj , cn)&#123; //判断obj中是否含有cn if(hasClass(obj , cn))&#123; //有，则删除 removeClass(obj , cn); &#125;else&#123; //没有，则添加 addClass(obj , cn); &#125; &#125; JSON JavaScript Object Notation JS对象表示法 JSON 格式 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 JS中的对象只有JS自己认识，其他的语言都不认识JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互 JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号 其他的和JS语法一致JSON分类： 1.对象 {} 2.数组 [] JSON中允许的值： 1.字符串 2.数值 3.布尔值 4.null 5.对象 6.数组 举例： 12345var arr = '[1,2,3,\"hello\",true]'; var obj2 = '&#123;\"arr\":[1,2,3]&#125;'; var arr2 ='[&#123;\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"&#125;,&#123;\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"&#125;]'; JSON工具类 json &gt; js对象JSON.parse() 可以将以JSON字符串转换为js对象 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回 var o = JSON.parse(json);var o2 = JSON.parse(arr); var obj3 = {name:”猪八戒” , age:28 , gender:”男”}; JS对象 &gt; JSONJSON.stringify() -ify/fy，表示”使……化。 可以将一个JS对象转换为JSON字符串 需要一个js对象作为参数，会返回一个JSON字符串 var str = JSON.stringify(obj3);console.log(str); JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错 ​ otherlocalStorage只读的localStorage 属性允许你访问一个Document 源（origin）的对象 Storage；其存储的数据能在跨浏览器会话保留。localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除 。 eval()eval() 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回 如果使用eval()执行的字符串中含有{},它会将{}当成是代码块 如果不希望将其当成代码块解析，则需要在字符串前后各加一个() eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码， 但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患 var str = &apos;{&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;}&apos;; var obj = eval(&quot;(&quot;+str+&quot;)&quot;); 编码 12345678910111213141516171819202122&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; /* * 在字符串中使用转义字符输入Unicode编码 * \\u四位编码 */ console.log(\"\\u2620\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--在网页中使用Unicode编码 &amp;#编码; 这里的编码需要的是10进制 --&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9760;&lt;/h1&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9856;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; confirm()用于弹出一个带有确认和取消按钮的提示框需要一个字符串作为参数，该字符串将会作为提示文字显示出来如果用户点击确认则会返回true，如果点击取消则返回falsevar flag = confirm(“确认删除”+name+”吗?”); # 原生js原生js实现复制内容到剪切板1234567891011copy() &#123; const input = document.createElement(\"input\"); document.body.appendChild(input); input.setAttribute(\"value\",this.solution.code); input.select(); if (document.execCommand(\"copy\")) &#123; document.execCommand(\"copy\"); // console.log(\"复制成功\"); &#125; document.body.removeChild(input); &#125; github笔记下载地址","categories":[{"name":"js","slug":"js","permalink":"https://codeofli.github.io/categories/js/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://codeofli.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://codeofli.github.io/tags/js/"}]},{"title":"vue","slug":"js-note/vue/vue","date":"2019-11-11T15:23:44.000Z","updated":"2021-10-23T02:19:04.234Z","comments":true,"path":"2019/11/js-note/vue/vue/","link":"","permalink":"https://codeofli.github.io/2019/11/js-note/vue/vue/","excerpt":"第 1 章： Vue 核心1.1. Vue 的基本认识1.1.1. 官网1) 英文官网: https://vuejs.org/2) 中文官网: https://cn.vuejs.org/1.1.2. 介绍描述1) 渐进式 JavaScript 框架2) 作者: 尤雨溪(一位华裔前 Google 工程师)3) 作用: 动态构建用户界面","text":"第 1 章： Vue 核心1.1. Vue 的基本认识1.1.1. 官网1) 英文官网: https://vuejs.org/2) 中文官网: https://cn.vuejs.org/1.1.2. 介绍描述1) 渐进式 JavaScript 框架2) 作者: 尤雨溪(一位华裔前 Google 工程师)3) 作用: 动态构建用户界面 1.1.3. Vue 的特点1) 遵循 MVVM 模式2) 编码简洁, 体积小, 运行效率高, 适合移动/PC 端开发3) 它本身只关注 UI, 可以轻松引入 vue 插件或其它第三库开发项目 1.1.4. 与其它前端 JS 框架的关联1) 借鉴 angular 的模板和数据绑定技术2) 借鉴 react 的组件化和虚拟 DOM 技术 1.1.5. Vue 扩展插件1) vue-cli: vue 脚手架2) vue-resource(axios): ajax 请求3) vue-router: 路由4) vuex: 状态管理5) vue-lazyload: 图片懒加载6) vue-scroller: 页面滑动相关7) mint-ui: 基于 vue 的 UI 组件库(移动端)8) element-ui: 基于 vue 的 UI 组件库(PC 端) 1.2. Vue 的基本使用12345678910111213&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"username\"&gt; &lt;p&gt;Hello, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; username: 'atguigu' &#125; &#125;)&lt;/script&gt; 1.2.3. 使用 vue 开发者工具调试Vue.jsdevtools-翻墙安装方式-推荐 1.2.4.理解Vue的MVVM 1.3. 模板语法1.3.2.模板的理解1) 动态的 html 页面2) 包含了一些 JS 语法代码a. 双大括号表达式b. 指令(以 v-开头的自定义标签属性) 1.3.3. 双大括号表达式1) 语法: 2) 功能: 向页面输出数据3) 可以调用对象的方法 1.3.4. 指令一: 强制数据绑定1) 功能: 指定变化的属性值2) 完整写法: v-bind:xxx=’yyy’ //yyy 会作为表达式解析执行3) 简洁写法: :xxx=’yyy’ 1.3.5. 指令二: 绑定事件监听1) 功能: 绑定指定事件名的回调函数2) 完整写法:v-on:keyup=’xxx’v-on:keyup=’xxx(参数)’v-on:keyup.enter=’xxx’3) 简洁写法:@keyup=’xxx’@keyup.enter=’xx 1.3.6. 编码123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;h2&gt;1. 双大括号表达式&lt;/h2&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;msg.toUpperCase()&#125;&#125;&lt;/p&gt; &lt;h2&gt;2. 指令一: 强制数据绑定&lt;/h2&gt; &lt;a href=\"url\"&gt;访问指定站点&lt;/a&gt;&lt;br&gt;&lt;!--不能使用--&gt; &lt;a v-bind:href=\"url\"&gt;访问指定站点 2&lt;/a&gt;&lt;br&gt; &lt;a :href=\"url\"&gt;访问指定站点 3&lt;/a&gt;&lt;br&gt; &lt;h2&gt;3. 指令二: 绑定事件监听&lt;/h2&gt; &lt;button v-on:click=\"handleClick\"&gt;点我&lt;/button&gt; &lt;button @click=\"handleClick\"&gt;点我 2&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123;// data 的所有属性都会成功 vm 对象的属性, 而模板页面中可以直接访问 msg: 'NBA I Love This Game!', url: 'http://www.baidu.com' &#125;, methods: &#123; handleClick () &#123; alert('处理点击') &#125; &#125; &#125;)&lt;/script&gt; 1.3.8 v-model和双向数据绑定`v-model 只能运用在 表单元素和组件中 12345678&lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt;&lt;!-- v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 --&gt;&lt;input type=\"text\" v-bind:value=\"msg\" style=\"width:100%;\"&gt;&lt;!-- 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 --&gt;&lt;!-- input(radio, text, address, email....) select checkbox textarea --&gt;&lt;input type=\"text\" style=\"width:100%;\" v-model=\"msg\"&gt; 自定义组件的 v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。 1.4. 计算属性和监视1.4.2. 计算属性1) 在 computed 属性对象中定义计算属性的方法 2) 在页面中使用来显示计算的结果 1.4.3. 监视属性1) 通过通过 vm 对象的$watch()或 watch 配置来监视指定的属性2) 当属性变化时, 回调函数自动调用, 在函数内部进行计算 watch`属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 1.监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstName\"&gt; + &lt;input type=\"text\" v-model=\"lastName\"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; 'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 2.监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"app\"&gt; &lt;router-link to=\"/login\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: \"/login\", component: login &#125;, &#123; path: \"/register\", component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; '$route': function (newVal, oldVal) &#123; if (newVal.path === '/login') &#123; console.log('这是登录组件'); &#125; &#125; &#125; &#125;); &lt;/script&gt; 1.4.4. 计算属性高级1) 通过 getter/setter 实现对属性数据的显示和监视 2) 计算属性存在缓存, 多次读取只执行一次 getter 计算 computed计算属性的使用计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 注意1： 计算属性，在引用的时候，一定不要加 () 去调用，直接把它 当作 普通 属性去使用就好了； 注意2： 只要 计算属性，这个 function 内部，所用到的 任何 data 中的数据发送了变化，就会 立即重新计算 这个 计算属性的值 注意3： 计算属性的求值结果，会被缓存起来，方便下次直接使用； 如果 计算属性方法中，所以来的任何数据，都没有发生过变化，则，不会重新对 计算属性求值； 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstName\"&gt; + &lt;input type=\"text\" v-model=\"lastName\"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 2.定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstName\"&gt; &lt;input type=\"text\" v-model=\"lastName\"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=\"button\" value=\"修改fullName\" @click=\"changeName\"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; 1.4.5. 编码12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=\"demo\"&gt; 姓: &lt;input type=\"text\" placeholder=\"First Name\" v-model=\"firstName\"&gt;&lt;br&gt; 名: &lt;input type=\"text\" placeholder=\"Last Name\" v-model=\"lastName\"&gt;&lt;br&gt; 姓名 1(单向): &lt;input type=\"text\" placeholder=\"Full Name\" v-model=\"fullName1\"&gt;&lt;br&gt; 姓名 2(单向): &lt;input type=\"text\" placeholder=\"Full Name\" v-model=\"fullName2\"&gt;&lt;br&gt; 姓名 3(双向): &lt;input type=\"text\" placeholder=\"Full Name2\" v-model=\"fullName3\"&gt;&lt;br&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Kobe', lastName: 'bryant', fullName2: 'Kobe bryant' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + \" \" + this.lastName &#125;, fullName3: &#123; get: function () &#123; return this.firstName + \" \" + this.lastName &#125;, set: function (value) &#123; var names = value.split(' ') this.firstName = names[0] this.lastName = names[1] &#125; &#125; &#125;, watch: &#123; lastName: function (newVal, oldVal) &#123; this.fullName2 = this.firstName + ' ' + newVal &#125; &#125; &#125;) vm.$watch('firstName', function (val) &#123; this.fullName2 = val + ' ' + this.lastName &#125;) ``watch、computed和methods`之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； 1.5. class 与 style 绑定1.5.2. 理解1) 在应用界面中, 某个(些)元素的样式是变化的2) class/style 绑定就是专门用来实现动态样式效果的技术 1.5.3. class 绑定（使用class样式）1) :class=’xxx’2) 表达式是字符串: ‘classA’3) 表达式是对象: {classA:isA, classB: isB}4) 表达式是数组: [‘classA’, ‘classB’] 1.数组 1&lt;h1 :class=\"['red', 'thin']\"&gt;这是一个邪恶的H1&lt;/h1&gt; 2.数组中使用三元表达式 1&lt;h1 :class=\"['red', 'thin', isactive?'active':'']\"&gt;这是一个邪恶的H1&lt;/h1&gt; 3.数组中嵌套对象 1&lt;h1 :class=\"['red', 'thin', &#123;'active': isactive&#125;]\"&gt;这是一个邪恶的H1&lt;/h1&gt; 4.直接使用对象 1&lt;h1 :class=\"&#123;red:true, italic:true, active:true, thin:true&#125;\"&gt;这是一个邪恶的H1&lt;/h1&gt; 注意如果类名中有-，必须用&#39;&#39;括起来,不然没有用 1&lt;li :class=\"&#123;'page-item': true,active: true&#125;\"&gt;&lt;/li&gt; 1.5.4. style 绑定1) :style=”{ color: activeColor, fontSize: fontSize + ‘px’ }”2) 其中 activeColor/fontSize 是 data 属性 1.5.5. 编吗12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; .classA &#123; color: red; &#125; . classB &#123; background: blue; &#125; . classC &#123; font-size: 20px; &#125;&lt;/style&gt;&lt;div id=\"demo\"&gt; &lt;h2&gt;1. class 绑定: :class='xxx'&lt;/h2&gt; &lt;p class=\"classB\" :class=\"a\"&gt;表达式是字符串: 'classA'&lt;/p&gt; &lt;p :class=\"&#123;classA: isA, classB: isB&#125;\"&gt;表达式是对象: &#123;classA:isA, classB: isB&#125;&lt;/p&gt; &lt;p :class=\"['classA', 'classC']\"&gt; 表达式是数组: ['classA', 'classB']&lt;/p&gt; &lt;h2&gt;2. style 绑定&lt;/h2&gt; &lt;p :style=\"&#123;color, fontSize&#125;\"&gt;style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&lt;/p&gt; &lt;button @click=\"update\"&gt;更新&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el : '#demo', data : &#123; a: 'classA', isA: true, isB: false, color: 'red', fontSize: '20px' &#125;, methods : &#123; update () &#123; this.a = 'classC' this.isA = false this.isB = true this.color = 'blue' this.fontSize = '30px' &#125; &#125; &#125;)&lt;/script&gt; 1.6. 条件渲染1.6.2. 条件渲染指令1) v-if 与 v-else2) v-show 1.6.3. 比较 v-if 与 v-show3)如果需要频繁切换 v-show 较好4)当条件不成立时, v-if 的所有子节点不会解析(项目中使用) 1.6.4. 编码1234567891011121314151617&lt;div id=\"demo\"&gt; &lt;h2 v-if=\"ok\"&gt;表白成功&lt;/h2&gt; &lt;h2 v-else&gt;表白失败&lt;/h2&gt; &lt;h2 v-show=\"ok\"&gt;求婚成功&lt;/h2&gt; &lt;h2 v-show=\"!ok\"&gt;求婚失败&lt;/h2&gt; &lt;br&gt; &lt;button @click=\"ok=!ok\"&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#demo', data: &#123; ok: false &#125; &#125;)&lt;/script&gt; 1.7. 列表渲染1) 列表显示指令数组: v-for / index对象: v-for / key2) 列表的更新显示删除 item替换 item3) 列表的高级处理列表过滤列表排序 注意事项 由于 JavaScript 的限制，Vue 不能检测以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 1.7.2. 编码1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"demo\"&gt; &lt;h2&gt;测试: v-for 遍历数组&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"(p, index) in persons\" :key=\"index\"&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;p.name&#125;&#125;--&#123;&#123;p.age&#125;&#125; &lt;button @click=\"deleteItem(index)\"&gt;删除&lt;/button&gt; &lt;button @click=\"updateItem(index, &#123;name:'Jok',age:15&#125;)\"&gt;更新&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;测试: v-for 遍历对象&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"(value, key) in persons[0]\"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo', data: &#123; persons: [ &#123;id: 1, name: 'Tom', age: 13&#125;, &#123;id: 2, name: 'Jack', age: 12&#125;, &#123;id: 3, name: 'Bob', age: 14&#125; ] &#125;, methods: &#123; deleteItem(index) &#123; this.persons.splice(index, 1) &#125;, updateItem(index, p) &#123; // this.persons[index] = p // 页面不会更新 this.persons.splice(index, 1, p) &#125; &#125; &#125;)&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=\"demo\"&gt; &lt;input type=\"text\" name=\"searchName\" placeholder=\"搜索指定用户名\" v-model=\"searchName\"&gt; &lt;ul&gt; &lt;li v-for=\"(p, index) in filterPerson\" :key=\"index\"&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;p.name&#125;&#125;--&#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"setOrderType(1)\"&gt;年龄升序&lt;/button&gt; &lt;button @click=\"setOrderType(2)\"&gt;年龄降序&lt;/button&gt; &lt;button @click=\"setOrderType(0)\"&gt;原本顺序&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo', data: &#123; orderType: 0, //0 代表不排序, 1 为升序, 2 为降序 searchName: '', persons: [ &#123;id: 1, name: 'Tom', age: 13&#125;, &#123;id: 2, name: 'Jack', age: 12&#125;, &#123;id: 3, name: 'Bob', age: 17&#125;, &#123;id: 4, name: 'Cat', age: 14&#125;, &#123;id: 4, name: 'Mike', age: 14&#125;, &#123;id: 4, name: 'Monica', age: 16&#125; ] &#125;, methods: &#123; setOrderType (orderType) &#123; this.orderType = orderType &#125; &#125;, computed: &#123; filterPerson() &#123; let &#123;orderType, searchName, persons&#125; = this // 过滤 persons = persons.filter(p =&gt; p.name.indexOf(searchName)!=-1) // 排序 if(orderType!==0) &#123; persons = persons.sort(function (p1, p2) &#123; if(orderType===1) &#123; return p1.age-p2.age &#125; else &#123; return p2.age-p1.age &#125; &#125;) &#125; r eturn persons &#125; &#125; &#125;)&lt;/script&gt; 1.8. 事件处理1.8.2. 绑定监听1) v-on:xxx=”fun”2) @xxx=”fun”3) @xxx=”fun(参数)”4) 默认事件形参: event event 是原生 DOM 事件5) 隐含属性对象: $event 1.8.3. 事件修饰符1) .prevent : 阻止事件的默认行为 event.preventDefault()2) .stop : 停止事件冒泡 event.stopPropagation() 事件修饰符 .stop 阻止冒泡 1234&lt;!-- 使用 .stop 阻止冒泡 --&gt;&lt;div class=\"inner\" @click=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click.stop=\"btnHandler\"&gt;&lt;/div&gt; .prevent 阻止默认事件 12&lt;!-- 使用 .prevent 阻止默认行为 --&gt; &lt;a href=\"http://www.baidu.com\" @click.prevent=\"linkClick\"&gt;有问题，先去百度&lt;/a&gt; .capture 添加事件侦听器时使用事件捕获模式 1234&lt;!-- 使用 .capture 实现捕获触发事件的机制 --&gt;&lt;div class=\"inner\" @click.capture=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click=\"btnHandler\"&gt;&lt;/div&gt; .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 1234&lt;!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 --&gt;&lt;div class=\"inner\" @click=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click=\"btnHandler\"&gt;&lt;/div&gt; .once 事件只触发一次 12&lt;!-- 使用 .once 只触发一次事件处理函数 --&gt;&lt;a href=\"http://www.baidu.com\" @click.prevent.once=\"linkClick\"&gt;有问题，先去百度&lt;/a&gt; 1.8.4. 按键修饰符1) .keycode : 操作的是某个 keycode 值的键2) .keyName : 操作的某个按键名的键(少部分) 1.8.5. 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id=\"example\"&gt; &lt;h2&gt;1. 绑定监听&lt;/h2&gt; &lt;button v-on:click=\"test1\"&gt;Greet&lt;/button&gt; &lt;button @click=\"test1\"&gt;Greet2&lt;/button&gt; &lt;button @click=\"test2($event, 'hello')\"&gt;Greet3&lt;/button&gt; &lt;h2&gt;2. 事件修饰符&lt;/h2&gt; &lt;!-- 阻止事件默认行为 --&gt; &lt;a href=\"http://www.baidu.com\" @click.prevent=\"test3\"&gt;百度一下&lt;/a&gt; &lt;br/&gt; &lt;br/&gt; &lt;!-- 停止事件冒泡 --&gt; &lt;div style=\"width: 200px;height: 200px;background: red\" @click=\"test4\"&gt; &lt;div style=\"width: 100px;height: 100px;background: green\" @click.stop=\"test5\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;h2&gt;3. 按键修饰符&lt;/h2&gt; &lt;input @keyup.8=\"test6\"&gt; &lt;input @keyup.enter=\"test6\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(el: '#example', data: &#123; name: 'Vue.js' &#125;, methods: &#123; test1 (event) &#123; // 方法内 `this` 指向 vm // alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 alert(event.target.innerHTML) &#125;, test2 (event, msg) &#123; alert(event.target.innerHTML + '---' + msg) &#125;, test3() &#123; alert('阻止事件的默认行为') &#125;, test4() &#123; alert('out') &#125;, test5() &#123; alert('inner') &#125;, test6(event) &#123; alert(event.keyCode + '---' + event.target.value) &#125; &#125; &#125;)&lt;/script&gt; 1.9. 表单输入绑定1.9.2. 使用 v-model 对表单数据自动收集1) text/textarea2) checkbox3) radio4) select 1.9.3. 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;div id=\"demo\"&gt; &lt;form @submit.prevent=\"handleSubmit\"&gt; &lt;span&gt;用户名: &lt;/span&gt; &lt;input type=\"text\" v-model=\"user.username\"&gt;&lt;br&gt; &lt;span&gt;密码: &lt;/span&gt; &lt;input type=\"password\" v-model=\"user.pwd\"&gt;&lt;br&gt; &lt;span&gt;性别: &lt;/span&gt; &lt;input type=\"radio\" id=\"female\" value=\"female\" v-model=\"user.sex\"&gt; &lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;input type=\"radio\" id=\"male\" value=\"male\" v-model=\"user.sex\"&gt; &lt;label for=\"male\"&gt;男&lt;/label&gt;&lt;br&gt; &lt;span&gt;爱好: &lt;/span&gt; &lt;input type=\"checkbox\" id=\"basket\" value=\"basketball\" v-model=\"user.likes\"&gt; &lt;label for=\"basket\"&gt;篮球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"foot\" value=\"football\" v-model=\"user.likes\"&gt; &lt;label for=\"foot\"&gt;足球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"pingpang\" value=\"pingpang\" v-model=\"user.likes\"&gt; &lt;label for=\"pingpang\"&gt;乒乓&lt;/label&gt;&lt;br&gt; &lt;span&gt;城市: &lt;/span&gt; &lt;select v-model=\"user.cityId\"&gt; &lt;option value=\"\"&gt;未选择&lt;/option&gt; &lt;option v-for=\"city in allCitys\" :value=\"city.id\"&gt; &#123;&#123; city.name &#125;&#125; &lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;span&gt;介绍: &lt;/span&gt; &lt;textarea v-model=\"user.desc\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#demo', data: &#123; user: &#123; username: '', pwd: '', sex: 'female', likes: [], cityId: '', desc: '', &#125;, allCitys: [&#123;id: 1, name: 'BJ'&#125;, &#123;id: 2, name: 'SZ'&#125;,&#123;id: 4, name: 'SH'&#125;], &#125;, methods: &#123; handleSubmit (event) &#123; alert(JSON.stringify(this.user)) &#125; &#125; &#125;)&lt;/script&gt; 1.10. Vue 实例生命周期1.10.2. 生命周期流程图 vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 1.10.3. vue 生命周期分析1)初始化显示 beforeCreate() created() beforeMount() mounted() 2)更新状态: this.xxx = value beforeUpdate()updated() 3)销毁 vue 实例: vm.$destory() beforeDestory()estoryed() 1.10.4. 常用的生命周期方法1) created()/mounted(): 发送 ajax 请求, 启动定时器等异步任务2) beforeDestory(): 做收尾工作, 如: 清除定时器 1.10.5. 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div&gt; &lt;button @click=\"destoryVue\"&gt;destory vue&lt;/button&gt; &lt;p v-show=\"isShowing\"&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vue = new Vue(&#123; el: 'div', data: &#123; msg: '尚硅谷 IT 教育', isShowing: true, persons: [] &#125;, beforeCreate () &#123; console.log('beforeCreate() msg=' + this.msg) e.log('created() msg='+this.msg) this.intervalId = setInterval(() =&gt; &#123; console.log('-----') this.isShowing = !this.isShowing &#125;, 1000) &#125;, beforeMount () &#123; console.log('beforeMount() msg='+this.msg) &#125;, mounted () &#123; console.log('mounted() msg='+this.msg) &#125;, beforeUpdate() &#123; console.log('beforeUpdate isShowing='+this.isShowing) &#125;, updated () &#123; console.log('updated isShowing='+this.isShowing) &#125;, beforeDestroy () &#123; console.log('beforeDestroy() msg='+this.msg) clearInterval(this.intervalId) &#125;, destroyed () &#123; console.log('destroyed() msg='+this.msg) &#125;, methods: &#123; destoryVue () &#123; vue.$destroy() &#125; &#125; &#125;)&lt;/script&gt; 1.11. 过渡&amp;动画1.11.2. vue 动画的理解1) 操作 css 的 trasition 或 animation2) vue 会给目标元素添加/移除特定的 class3) 过渡的相关类名xxx-enter-active: 指定显示的 transitionxxx-leave-active: 指定隐藏的 transitionxxx-enter/xxx-leave-to: 指定隐藏时的样式 1.11.3. 基本过渡动画的编码1) 在目标元素外包裹&lt;transition name=&quot;xxx&quot;&gt;2) 定义 class 样式指定过渡样式: transition指定隐藏时的样式: opacity/其它 1.11.4. 编码 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt; .fade-enter-active, .fade-leave-active &#123; transition: opacity .5s &#125; . fade-enter, .fade-leave-to &#123; opacity: 0 &#125; / * 可以设置不同的进入和离开动画 */ .slide-fade-enter-active &#123; transition: all .3s ease; &#125; . slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0); &#125; . slide-fade-enter, .slide-fade-leave-to &#123; transform: translateX(10px); opacity: 0; &#125;&lt;/style&gt;&lt;div id=\"demo1\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle1 &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;div id=\"demo2\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle2 &lt;/button&gt; &lt;transition name=\"slide-fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo1', data: &#123; show: true &#125; &#125;) new Vue(&#123; el: '#demo2', data: &#123; show: true &#125; &#125;)&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435361.11.5. 编码 2&lt;style&gt; .bounce-enter-active &#123; animation: bounce-in .5s; &#125; . bounce-leave-active &#123; animation: bounce-in .5s reverse; &#125; @ keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125;&lt;/style&gt;&lt;div id=\"test2\"&gt; &lt;button @click=\"show = !show\"&gt;Toggle show&lt;/button&gt; &lt;br&gt; &lt;transition name=\"bounce\"&gt; &lt;p v-if=\"show\" style=\"display: inline-block\"&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: '#test2', data: &#123; show: true &#125; &#125;)&lt;/script&gt; 1.12. 过滤器1.12.2. 理解过滤器1) 功能: 对要显示的数据进行特定格式化后再显示2) 注意: 并没有改变原本的数据, 可是产生新的对应的数据 1.12.3. 定义和使用过滤器1) 定义过滤器 1234Vue.filter(filterName, function(value[,arg1,arg2,...])&#123; // 进行一定的数据处理 return newValue&#125;) 2)使用过滤器 12&lt;div&gt;&#123;&#123;myData | filterName&#125;&#125;&lt;/div&gt;&lt;div&gt;&#123;&#123;myData | filterName(arg)&#125;&#125;&lt;/div&gt; 1.12.4. 编码123456789101112131415161718192021&lt;div id=\"test\"&gt; &lt;p&gt;当前时间为: &#123;&#123;currentTime&#125;&#125;&lt;/p&gt; &lt;p&gt;当前时间 1 为: &#123;&#123;currentTime | dateStr&#125;&#125;&lt;/p&gt; &lt;p&gt;当前时间 2 为: &#123;&#123;currentTime | dateStr('YYYY-MM-DD')&#125;&#125;&lt;/p&gt; &lt;p&gt;当前时间 3 为: &#123;&#123;currentTime | dateStr('HH:mm:ss')&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://cdn.bootcss.com/moment.js/2.19.0/moment.js\"&gt;&lt;/script&gt;&lt;script&gt; // 注册过滤器 Vue.filter('dateStr', function (value, format) &#123; return moment(value).format(format || 'YYYY-MM-DD HH:mm:ss') &#125;) new Vue(&#123; el: '#test', data: &#123; currentTime: new Date() &#125; &#125;)&lt;/script&gt; 1.13. 内置指令与自定义指令1.13.2. 常用内置指令1) v:text : 更新元素的 textContent2) v-html : 更新元素的 innerHTML3) v-if : 如果为 true, 当前标签才会输出到页 面 4) v-else: 如果为 false, 当前标签才会输出到页面5) v-show : 通过控制 display 样式来控制显示/隐藏6) v-for : 遍历数组/对象7) v-on : 绑定事件监听, 一般简写为@8) v-bind : 强制绑定解析表达式, 可以省略 v-bind9) v-model : 双向数据绑定10) ref : 指定唯一标识, vue 对象通过$els 属性访问这个元素对象11) v-cloak : 防止闪现, 与 css 配合: [v-cloak] { display: none } 1.13.3. 自定义指令1) 注册全局指令 123Vue.directive('my-directive', function(el, binding)&#123; el.innerHTML = binding.value.toupperCase()&#125;) 2) 注册局部指令 1234567directives : &#123; 'my-directive' : &#123; bind (el, binding) &#123; el.innerHTML = binding.value.toupperCase() &#125; &#125;&#125; 3) 使用指令 1v-my-directive='xxx' 1.13.4. 编码 1(内置指令 ）1234567891011121314151617181920212223242526272829303132&lt;style&gt; [v-cloak] &#123; display: none &#125;&lt;/style&gt;&lt;div id=\"example\"&gt; &lt;p v-text=\"url\"&gt;&lt;/p&gt; &lt;p v-html=\"url\"&gt;&lt;/p&gt; &lt;img :id=\"myid\" :src=\"imageSrc\"&gt; &lt;p&gt; &lt;span ref=\"message\"&gt;atguigu.com&lt;/span&gt; &lt;button @click=\"showMsg\"&gt;显示左侧文本&lt;/button&gt; &lt;/p&gt; &lt;p v-cloak&gt;&#123;&#123;url&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; alert('模拟加载慢') new Vue(&#123; el: '#example', data: &#123; url: '&lt;a href=\"http://www.atguigu.com\"&gt;尚硅谷&lt;/a&gt;', myid: 'abc123', imageSrc: 'http://cn.vuejs.org/images/logo.png' &#125;, methods: &#123; showMsg: function () &#123; alert(this.$refs.message.textContent) &#125; &#125; &#125;)&lt;/script&gt; 1.13.5. 编码 2(自定义指令)需求: 自定义 2 个指令 功能类型于 v-text, 但转换为全大写 功能类型于 v-text, 但转换为全小写123456789101112131415161718192021222324252627282930313233&lt;div id=\"demo1\"&gt; &lt;p v-upper-text=\"msg\"&gt;&lt;/p&gt; &lt;p v-lower-text=\"msg\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;div id=\"demo2\"&gt; p v-upper-text=\"msg2\"&gt;&lt;/p&gt;&lt;p v-lower-text=\"msg2\"&gt;&lt;/p&gt; &lt;!--局部指令, 此处不能使用--&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //注册全局指令 Vue.directive('upper-text', function (el, binding) &#123; el.innerHTML = binding.value.toUpperCase() &#125;) new Vue(&#123; el: '#demo1', data: &#123; msg: 'NBA love this game!' &#125;, directives: &#123; // 注册局部指令 'lower-text': &#123; bind (el, binding) &#123; el.innerHTML = binding.value.toLowerCase() &#125; &#125; &#125; &#125;) new Vue(&#123; el: '#demo2', data: &#123; msg2: 'I Like You' &#125; &#125;)&lt;/script 1.14. 自定义插件1.14.2. 说明1) Vue 插件是一个包含 install 方法的对象2) 通过 install 方法给 Vue 或 Vue 实例添加方法, 定义全局指令等 1.14.3. 编码1) 插件 JS 12345678910111213141516171819202122/**- 自定义 Vue 插件 */(function () &#123; const MyPlugin = &#123;&#125; MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; alert('Vue 函数对象方法执行') &#125; // 2. 添加全局资源 Vue.directive('my-directive', function (el, binding) &#123; el.innerHTML = \"MyPlugin my-directive \" + binding.value &#125;) // 3. 添加实例方法 Vue.prototype.$myMethod = function () &#123; alert('vue 实例对象方法执行') &#125; &#125; window.MyPlugin = MyPlugin&#125;)() 2) 页面使用插件 1234567891011121314151617181920&lt;div id=\"demo\"&gt; &lt;!--使用自定义指令--&gt; &lt;p v-my-directive=\"ms》g\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"vue-myPlugin.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //使用自定义插件 Vue.use(MyPlugin) var vm = new Vue(&#123; el: '#demo', data: &#123; msg: 'atguigu' &#125; &#125;) //调用自定义的静态方法 Vue.myGlobalMethod() //调用自定义的对象方法 vm.$myMethod()&lt;/script&gt; 第 2 章： vue-cli 组件化编码2.1. 使用 vue-cli 创建模板项目说明1) vue-cli 是 vue 官方提供的脚手架工具2) github: https://github.com/vuejs/vue-cli3) 作用: 从 https://github.com/vuejs-templates 下载模板项目 2.1.2. 创建 vue 项目1npm install -g @vue/cli cli 2.x安装拉取 2.x 模板 (旧版本) Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具： 1npm install -g @vue/cli-init 1234vue init webpack vue_demo(project_name)cd vue_demonpm installnpm run dev 访问: http://localhost:8080/ 2.1.3. 模板项目的结构|– build : webpack 相关的配置文件夹(基本不需要修改)|– dev-server.js : 通过 express 启动后台服务器|– config: webpack 相关的配置文件夹(基本不需要修改)|– index.js: 指定的后台服务的端口号和静态资源文件夹|– node_modules|– src : 源码文件夹|– components: vue 组件及其相关资源文件夹|– App.vue: 应用根主组件|– main.js: 应用入口 js|– static: 静态资源文件夹（build打包原封不动的放到dist文件夹中）|– .babelrc: babel 的配置文件|– .eslintignore: eslint 检查忽略的配置|– .eslintrc.js: eslint 检查的配置|– .gitignore: git 版本管制忽略的配置|– index.html: 主页面文件|– package.json: 应用包配置文件|– README.md: 应用描述说明的 readme 文件 .editorconfig配置格式 cli 3.x安装 创建项目 1vue create hello-world 在c:user/xxx/.vuerc里可以删除预设的vuecli配置 rc-&gt; run command vuecli3配置文件的查看和修改1vue ui 自定义配置文件vue.config.js 1234// vue.config.jsmodule.exports = &#123; // 选项...&#125; 2.2. 项目的打包与发布2.2.1. 打包:1npm run build 2.2.2. 发布 1: 使用静态服务器工具包npm install -g serveserve dist访问: http://localhost:5000 2.2.3. 发布 2: 使用动态 web 服务器(tomcat)修改配置: .config/index.js 123456789build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: '/vue_demo',&#125; 重新打包:npm run build修改 dist 文件夹为项目名称: xxx将 xxx 拷贝到运行的 tomcat 的 webapps 目录下访问: http://localhost:8080/xx 2.3. eslint2.3.1. 说明1) ESLint 是一个代码规范检查工具2) 它定义了很多特定的规则, 一旦你的代码违背了某一规则, eslint会作出非常有用的提示3) 官网: http://eslint.org/4) 基本已替代以前的 JSLint 2.3.2. ESLint 提供以下支持1) ES2) JSX3) style 检查4) 自定义错误和提示 2.3.3. ESLint 提供以下几种校验1) 语法错误校验2) 不重要或丢失的标点符号， 如分号3) 没法运行到的代码块（使用过 WebStorm 的童鞋应该了解）4) 未被使用的参数提醒5) 确保样式的统一规则， 如 sass 或者 less6) 检查变量的命名 2.3.4. 规则的错误等级有三种1) 0： 关闭规则。2) 1： 打开规则， 并且作为一个警告（信息打印黄色字体）3) 2： 打开规则， 并且作为一个错误（信息打印红色字体 ) 2.3.5. 相关配置文件1) .eslintrc.js : 全局规则配置文件‘rules’: {‘no-new’: 1}2) 在 js/vue 文件中修改局部规则/* eslint-disable no-new */new Vue({el: ‘body’,components: { App }})3) .eslintignore: 指令检查忽略的文件*.js*.vu 2.4. 组件定义与使用2.4.1. vue 文件的组成(3 个部分)1) 模板页面 123&lt;template&gt;页面模板&lt;/template&gt; 2) JS 模块对象 12345678&lt;script&gt; export default &#123; data() &#123;return &#123;&#125;&#125;, methods: &#123;&#125;, computed: &#123;&#125;, components: &#123;&#125; &#125;&lt;/script&gt; 3) 样式 1234&lt;style&gt; 样式定义&lt;/style&gt; 2.4.2. 基本使用1) 引入组件2) 映射成标签3) 使用组件标签 123456789101112&lt;template&gt; &lt;HelloWorld&gt;&lt;/HelloWorld&gt; &lt;hello-world&gt;&lt;/hello-world&gt;&lt;/template&gt;&lt;script&gt; import HelloWorld from './components/HelloWorld' export default &#123; components: &#123; HelloWorld &#125; &#125;&lt;/script&gt; 2.4.3. 关于标签名与标签属性名书写问题 1) 写法一: 一模一样2) 写法二: 大写变小写, 并用-连接 2.5. 组件间通信2.5.1. 组件间通信基本原则1) 不要在子组件中直接修改父组件的状态数据2) 数据在哪, 更新数据的行为(函数)就应该定义在哪 2.5.2. vue 组件间通信方式1) props2) vue 的自定义事件3) 消息订阅与发布(如: pubsub 库)4) slot5) vuex(后面单独讲) 2.6. 组件间通信 1: props2.6.1. 使用组件标签时 1&lt;my-component name='tom' :age='3' :set-name='setName'&gt;&lt;/my-component&gt; 2.6.2. 定义 MyComponent 时1) 在组件内声明所有的 props2) 方式一: 只指定名称(类型要为字符串) 1props: ['name', 'age', 'setName'] 3) 方式二: 指定名称和类型 12345props: &#123; name: String, age: Number, setNmae: Function&#125; 4) 方式三: 指定名称/类型/必要性/默认值 123props: &#123;name: &#123;type: String, required: true, default:xxx&#125;,&#125; 2.6.3. 注意1) 此方式用于父组件向子组件传递数据2) 所有标签属性都会成为组件对象的属性, 模板页面可以直接引用3) 问题:a. 如果需要向非子后代传递数据必须多层逐层传递b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以 2.7. 组件间通信 2: vue 自定义事件子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func=\"getMsg\"&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id=\"app\"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func=\"getMsg\"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type=\"x-template\" id=\"son\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"向父组件传值\" @click=\"sendMsg\" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 使用 this.$refs 来获取元素和组件注：元素中的ref属性=xx与this.$refs.xx相对应。 123456789101112131415161718192021222324252627282930313233343536&lt;div id=\"app\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=\"myh1\"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=\"mycom\"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 2.7.1. 绑定事件监听使用 this.$refs 来获取元素和组件 12345678910111213141516171819202122232425262728293031323334&lt;div id=\"app\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=\"myh1\"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=\"mycom\"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 123456// 方式一: 通过 v-on 绑定@delete_todo=\"deleteTodo\"// 方式二: 通过$on()this.$refs.xxx.$on('delete_todo', function (todo) &#123; this.deleteTodo(todo)&#125;) 2.7.2. 触发事件12// 触发事件(只能在父组件中接收)this.$emit(eventName, data) 2.7.3. 注意:1) 此方式只用于子组件向父组件发送消息(数据)2) 问题: 隔代组件或兄弟组件间通信此种方式不合适 2.8. 组件间通信 3: 消息订阅与发布(PubSubJS 库)1npm install pubsub-js 1import PubSub from 'pubsub-js' 2.8.1. 订阅消息 1PubSub.subscribe('msg', function(msg, data)&#123;&#125;) 2.8.2. 发布消息 1PubSub.publish('msg', data) 2.8.3. 注意 1) 优点: 此方式可实现任意关系组件间通信(数据)2.8.4. 事件的 2 个重要操作(总结) 1) 绑定事件监听 (订阅消息)目标: 标签元素 &lt;button&gt;事件名(类型): click/focus回调函数: function(event){}2) 触发事件 (发布消息)DOM 事件: 用户在浏览器上对应的界面上做对应的操作自定义: 编码手动触发 组件间通信 插槽4: slot2.9.1. 理解此方式用于父组件向子组件传递标签数据 编译作用域父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 2.9.2. 子组件: Child.vue 1234567&lt;template&gt; &lt;div&gt; &lt;slot name=\"xxx\"&gt;不确定的标签结构 1&lt;/slot&gt; &lt;div&gt;组件确定的标签结构&lt;/div&gt; &lt;slot name=\"yyy\"&gt;不确定的标签结构 2&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 2.9.3. 父组件: Parent.vue 1234&lt;child&gt; &lt;div slot=\"xxx\"&gt;xxx 对应的标签结构&lt;/div&gt; &lt;div slot=\"yyy\"&gt;yyy 对应的标签结构&lt;/div&gt;&lt;/child&gt; 自定义组件的 v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突： 12345678910111213141516Vue.component('base-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=\"checkbox\" v-bind:checked=\"checked\" v-on:change=\"$emit('change', $event.target.checked)\" &gt; `&#125;) 现在在这个组件上使用 v-model 的时候： 1&lt;base-checkbox v-model=\"lovingVue\"&gt;&lt;/base-checkbox&gt; 这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 &lt;base-checkbox&gt; 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的属性将会被更新。 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。 第 3 章： vue-ajax3.1. vue 项目中常用的 2 个 ajax 库3.1.1. vue-resourcevue 插件, 非官方库, vue1.x 使用广泛 3.1.2. axios通用的 ajax 请求库, 官方推荐, vue2.x 使用广泛 3.2. vue-resource 的使用3.2.1. 在线文档https://github.com/pagekit/vue-resource/blob/develop/docs/http.md3.2.2. 下载 1npm install vue-resource --save 3.2.3. 编码 12345678910111213// 引入模块import VueResource from 'vue-resource'// 使用插件Vue.use(VueResource)// 通过 vue/组件对象发送 ajax 请求this.$http.get('/someUrl').then((response) =&gt; &#123;// success callbackconsole.log(response.data) //返回结果数据&#125;, (response) =&gt; &#123;// error callbacbconsole.log(response.statusText) //错误信息&#125;) 3.3. axios 的使用3.3.1. 效果ajax_test.gif3.2. 在线文档https://github.com/pagekit/vue-resource/blob/develop/docs/http.md3.3. 下载: 1npm install axios --save 3.4. 编码 12345678910// 引入模块import axios from 'axios'// 发送 ajax 请求axios.get(url).then(response =&gt; &#123;console.log(response.data) // 得到返回结果数据&#125;).catch(error =&gt; &#123;console.log(error.message)&#125; ) 第 4 章： vue UI 组件库4.1. 常用1) Mint UI:a. 主页: http://mint-ui.github.io/#!/zh-cnb. 说明: 饿了么开源的基于 vue 的移动端 UI 组件库2) Elmenta. 主页: http://element-cn.eleme.io/#/zh-CNb. 说明: 饿了么开源的基于 vue 的 PC 端 UI 组件库4.2. 使用 Mint UI4.2.1. 下载: 1npm install --save mint-ui 4.2.2. 实现按需打包 下载 1npm install --save-dev babel-plugin-component 2.修改 babel 配置 123456\"plugins\": [\"transform-runtime\",[\"component\", [ &#123; \"libraryName\": \"mint-ui\", \"style\": true &#125;]]] 4.2.3. mint-ui 组件分类 1) 标签组件 2) 非标签组件 4.2.4. 使用 mint-ui 的组件 1)index.html 1234567891011121314151617&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\" /&gt;&lt;script src=\"https://as.alipayobjects.com/g/component/fastclick/1.0.6/fastclick.js\"&gt;&lt;/scrip t&gt; &lt;script&gt; if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false); &#125; i f(!window.Promise) &#123; document.writeln('&lt;script src=\"https://as.alipayobjects.com/g/component/es6-promise/3.2.2/es6-promise.min.js\" '+'&gt;'+'&lt;'+'/'+'script&gt;'); &#125;&lt;/script &gt; 2) main.jsimport {Button} from ‘mint-ui’Vue.component(Button.name, Button)3) App.vue 12345678910111213&lt;template&gt; &lt;mt-button @click=\"handleClick\" type=\"primary\" style=\"width: 100%\"&gt;Test&lt;/mt-button&gt;&lt;/template&gt;&lt;script&gt; import &#123;Toast&#125; from 'mint-ui' export default &#123; methods: &#123; handleClick () &#123; Toast('点击了测试'); &#125; &#125; &#125;&lt;/script&gt; 第 5 章： vue-router5.1. 理解5.1.1. 说明 1) 官方提供的用来实现 SPA 的 vue 插件2) github: https://github.com/vuejs/vue-router3) 中文文档: http://router.vuejs.org/zh-cn/4) 下载: 1npm install vue-router --save 5.1.2. 相关 API 说明1) 1234VueRouter(): 用于创建路由器的构建函数new VueRouter(&#123; // 多个配置项&#125;) 2) 路由配置 12345678910routes: [ &#123; // 一般路由 path: '/about', component: About &#125;, &#123; // 自动跳转路由 path: '/', redirect: '/about' &#125;] 3) 注册路由器 1234import router from './router'new Vue(&#123; router&#125;) 4) 使用路由组件标签 12341. &lt;router-link&gt;: 用来生成路由链接 &lt;router-link to=\"/xxx\"&gt;Go to XXX&lt;/router-link&gt;2. &lt;router-view&gt;: 用来显示当前路由组件界面 &lt;router-view&gt;&lt;/router-view&gt; 编程式路由导航1) this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面) 1router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) 2) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)3) this.$router.back(): 请求(返回)上一个记录路由4) this.$router.go(-1): 请求(返回)上一个记录路由5) this.$router.go(1): 请求下一个记录路由 5.2. 基本路由5.2.2. 路由组件Home.vueAbout.vue5.2.3. 应用组件: App.vue 1234567&lt;div&gt; &lt;!--路由链接--&gt; &lt;router-link to=\"/about\"&gt;About&lt;/router-link&gt; &lt;router-link to=\"/home\"&gt;Home&lt;/router-link&gt; &lt;!--用于渲染当前路由组件--&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 5.2.4. 路由器模块: src/router/index.js 12345678910111213141516171819202122232425// 声明使用vue-router插件/*内部定义并注册了2个组件标签(router-link/router-view),给组件对象添加了2个属性: 1. $router: 路由器 2. $route: 当前路由 */Vue.use(VueRouter)export default new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/about' &#125;, &#123; path: '/about', component: About &#125;, &#123; path: '/home', component: Home &#125; ]&#125;） 5.2.5. 注册路由器: main.js12345678import Vue from 'vue'import router from './router'// 创建 vue 配置路由器new Vue(&#123;el: '#app',router,render: h =&gt; h(app)&#125;) 5.2.6. 优化路由器配置linkActiveClass: ‘active’, // 指定选中的路由链接的 class5.2.7. 总结: 编写使用路由的 3 步 1) 定义路由组件2) 注册路由3) 使用路由 12&lt;router-link&gt;&lt;router-view&gt; 注意注册VueRouter路由是的属性不是routers是==routes== 1234567Vue.use(VueRouter)export default new VueRouter(&#123; routes: [ &#123;&#125; ]&#125;） 5.3. 嵌套路由嵌套路由，通常是在page里放component使用 5.3.2. 子路由组件News.vueMessage.vue 5.3.3. 配置嵌套路由: router.js123456789101112path: '/home', component: home, children: [ &#123; path: 'news', component: News &#125;, &#123; path: 'message', component: Message &#125; ] 5.3.4. 路由链接: Home.vue123&lt;router-link to=\"/home/news\"&gt;News&lt;/router-link&gt;&lt;router-link to=\"/home/message\"&gt;Message&lt;/router-link&gt;&lt;router-view&gt;&lt;/route-view 默认子路由redirect：重定向到默认子路由的路径 123456789101112131415161718&#123; path: \"/contest/view/:id\", component: ContestView, redirect: '/contest/view/:id/contestProblem', name: 'contestView', children: [ &#123; // 当 /contest/view/:id/contestProblem 匹配成功， path: 'contestProblem', component: ContestProblem &#125;, &#123; // 当 /contest/view/:id/contestProblem 匹配成功， path: 'contestSolution', component: SolutionSet &#125; ]&#125; 5.4. 向路由组件传递数据5.4.2. 方式 1: 路由路径携带参数(param/query)1) 配置路由 123456children: [ &#123; path: 'mdetail/:id', component: MessageDetail &#125;] 2) 路由路径 1&lt;router-link :to=\"'/home/message/mdetail/'+m.id\"&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; 3) 路由组件中读取请求参数 123456789this.$route.params.idwatch: &#123; $route: function () &#123; // 改变当前路由组件参数数据时自动调用 console.log('$route()') const id = this.$route.params.id this.detail = messageDetails.find(detail =&gt; detail.id===id*1) &#125;&#125; $route.query 类型: Object 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。 5.4.3. 方式 2: &lt;router-view&gt;属性携带数据1&lt;router-view :msg=\"msg\"&gt;&lt;/router-view&gt; 5.5. 缓存路由组件对象5.5.1. 理解 1) 默认情况下, 被切换的路由组件对象会死亡释放, 再次回来时是重新创建的2) 如果可以缓存路由组件对象, 可以提高用户体验5.5.2. 编码实现 123&lt;keep-alive&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 实现跳转时判断是否登录main.js 1234567891011121314151617181920212223242526272829303132router.beforeEach((to, from, next) =&gt; &#123; if (to.meta.title) &#123; document.title = to.meta.title &#125; const flag = to.meta.withOutLogin console.log(flag) console.log(store.state.user) // 判断该路由是否需要登录权限 if (!flag &amp;&amp; !store.state.user) &#123; request(&#123; url: \"/user/info\", method: \"GET\" &#125;) .then(res =&gt; &#123; console.log(res); if(res.data.success)&#123; next() const user = res.data.extend.user; store.commit(RECEIVE_USER, &#123; user &#125;) &#125;else&#123; next('/login') &#125; &#125;) .catch(err =&gt; &#123; console.log(err); &#125;); &#125; else &#123; next() // 确保一定要有next()被调用 &#125;&#125;) 5.7 reoute.routes里的meta属性meta能给每个route指定附加值. 可以实现通过路径判断是否显示组件 1234567&#123; path: '/msite', component: Msite, meta: &#123; showFooter: true &#125;&#125; 1&lt;FooterGuide v-show=\"$route.meta.showFooter\"&gt;&lt;/FooterGuide&gt; 第 6 章： vuex6.1. vuex 理解6.1.1. vuex 是什么 1) github 站点: https://github.com/vuejs/vuex2) 在线文档: https://vuex.vuejs.org/zh-cn/3) 简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)6.1.2. 状态自管理应用 1) state: 驱动应用的数据源 2) view: 以声明方式将 state 映射到视图3) actions: 响应在 view 上的用户输入导致的状态变化(包含 n 个更新状态的方法) 6.1.3. 多组件共享状态的问题 1) 多个视图依赖于同一状态2) 来自不同视图的行为需要变更同一状态3) 以前的解决办法a. 将数据以及操作数据的行为都定义在父组件b. 将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)4) vuex 就是用来解决这个问题的 6.2. vuex 核心概念和 API6.2.1. state1) vuex 管理的状态对像 2) 它应该是唯一的 123const state = &#123; xxx: initValue&#125; 12345import &#123; mapState, mapActions &#125; from \"vuex\";computed: mapState([ // 映射 this.count 为 store.state.count 'count']) 6.2.2. mutations1) 包含多个直接更新 state 的方法(回调函数)的对象2) 谁来触发: action 中的 commit(‘mutation 名称’)3) 只能包含同步的代码, 不能写异步代码 12345const mutations = &#123; yyy (state, &#123;data1&#125;) &#123; // 更新 state 的某个属性 &#125;&#125; 6.2.3. actions1) 包含多个事件回调函数的对象2) 通过执行: commit()来触发 mutation 的调用, 间接更新 state3) 谁来触发: 组件中: $store.dispatch(‘action 名称’, data1) // ‘zzz’4) 可以包含异步代码(定时器, ajax) 12345const actions = &#123; zzz (&#123;commit, state&#125;, data1) &#123; commit('yyy', &#123;data1&#125;) &#125;&#125; 6.2.4. getters1) 包含多个计算属性(get)的对象2) 谁来读取: 组件中: $store.getters.xxx 123456const getters = &#123; mmm (state) &#123; return .. &#125;&#125; 6.2.5. modules1) 包含多个 module2) 一个 module 是一个 store 的配置对象3) 与一个组件(包含有共享数据)对应 6.2.6. 向外暴露 store 对象123456export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;) 6.2.7. 组件中123456789import &#123;mapState, mapGetters, mapActions&#125; from 'vuex'export default &#123; computed: &#123; ...mapState(['xxx']), ...mapGetters(['mmm']), &#125; m ethods: mapActions(['zzz'])&#125; &#123; &#123;xxx&#125;&#125; &#123;&#123;mmm&#125;&#125; @click=\"zzz(data)\" 6.2.8. 映射 store1234import store from './store'new Vue(&#123; store&#125; 6.2.9. store 对象1) 所有用 vuex 管理的组件中都多了一个属性$store, 它就是一个 store 对象2) 属性: 12state: 注册的 state 对象getters: 注册的 getters 对象 3) 方法:dispatch(actionName, data): 分发调用 action 6.3使用案例使用时安装 1npm install --save vuex 6.3. demo1: 计数器5.3.1 定义store模块store.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*** vuex 的 store 对象模块*/import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)/*state 对象类似于 data*/const state = &#123; count: 0 // 初始化状态数据&#125; /* mutations 对象包含个方法: 能直接更新 state一个方法就是一个 mutationmutation 只能包含更新 state 的同步代码, 也不会有逻辑mutation 由 action 触发调用: commit('mutationName') */const mutations = &#123; INCREMENT(state) &#123; state.count++ &#125;, DECREMENT (state) &#123; // ctrl + shift + x state.count-- &#125;&#125;/* actions 对象 包含个方法: 触发 mutation 调用, 间接更新 state 一个方法就是一个 action action 中可以有逻辑代码和异步代码 action 由组件来触发调用: this.$store.dispatch('actionName') */const actions = &#123; increment (&#123;commit&#125;) &#123; commit('INCREMENT') &#125;, decrement (&#123;commit&#125;) &#123; commit('DECREMENT') &#125;, incrementIfOdd (&#123;commit, state&#125;) &#123; if(state.count%2===1) &#123; commit('INCREMENT') &#125; &#125;, incrementAsync (&#123;commit&#125;) &#123; setTimeout(() =&gt; &#123; commit('INCREMENT') &#125;, 1000) &#125;&#125;/*getters 对象包含多个 get 计算计算属性方法*/const getters = &#123; oddOrEven (state) &#123; return state.count%2===0 ? '偶数' : '奇数' &#125;, count (state) &#123; return state.count &#125;&#125; //向外暴露 store 实例对象export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;） 6.3.2 在vue中注册 main.js 123456789import Vue from 'vue'import app from './app1.vue'// import app from './app.vue'import store from './store'new Vue(&#123; el: '#app', render: h =&gt; h(app), store // 所有组件都多个一个属性: $store&#125;) 6.3.3. app.vue(未优化前)12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;p&gt;clicked: &#123;&#123;$store.state.count&#125;&#125; times, count is &#123;&#123;oddOrEven&#125;&#125;&lt;/p&gt;&lt;button @click=\"increment\"&gt;+&lt;/button&gt;&lt;button @click=\"decrement\"&gt;-&lt;/button&gt;&lt;button @click=\"incrementIfOdd\"&gt;increment if odd&lt;/button&gt;&lt;button @click=\"incrementAsync\"&gt;increment async&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;computed: &#123; oddOrEven () &#123; return this.$store.getters.oddOrEven &#125;&#125;, methods: &#123; increment () &#123; this.$store.dispatch('increment') &#125;, decrement () &#123; this.$store.dispatch('decrement') &#125;, incrementIfOdd () &#123; this.$store.dispatch('incrementIfOdd') &#125;, incrementAsync () &#123; this.$store.dispatch('incrementAsync') &#125; &#125;&#125; &lt;/script&gt;&lt;style&gt; &lt;/style&gt; 6.3.4. app2.vue(优化后) 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;p&gt;clicked: &#123;&#123;count&#125;&#125; times, count is &#123;&#123;oddOrEven2&#125;&#125;&lt;/p&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;button @click=\"incrementIfOdd\"&gt;increment if odd&lt;/button&gt; &lt;button @click=\"incrementAsync\"&gt;increment async&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123;mapGetters, mapActions&#125; from 'vuex' export default &#123; computed: mapGetters(&#123; // 名称不一样 oddOrEven2: 'oddOrEven', count: 'count' &#125;), methods: mapActions(['increment', 'decrement', 'incrementIfOdd', 'incrementAsync']) // 名称一样 &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 6.5. vuex 结构分析 使用注意只有当前组件使用的数据不需要使用vuex管理 vue使用-me使用bootstarp1安装 需要安装jquery,因为bootstrap是依赖于jquery的。我们同样使用npm安装jquery。bootstrap也需要安装popper.js 123npm install --save jquerynpm install --save popper.jsnpm install --save bootstrap@4 2.在 vue.config.js 文件写入以下内容： 1234567891011121314151617/**Vue-CLI项目的核心配置文件*/const webpack = require(\"webpack\");module.exports = &#123; configureWebpack: &#123; plugins: [ new webpack.ProvidePlugin(&#123; $: \"jquery\", jQuery: \"jquery\", \"window.jQuery\": \"jquery\", Popper: [\"popper.js\", \"default\"] &#125;) ] &#125;&#125;; 2引入 12345678//使用bootstarpimport $ from 'jquery'import \"bootstrap/dist/css/bootstrap.css\";import \"bootstrap/dist/js/bootstrap.min.js\";new Vue(&#123; $, render: h =&gt; h(App),&#125;).$mount('#app') 使用 Font AwesomeFont Awesome：http://fontawesome.dashgame.com/ npm 安装 font-awesome 1npm install font-awesome --save-dev 1font-awesome引入在 mani.js 文件中引入 font-awesome 1import 'font-awesome/css/font-awesome.css' or 1import 'font-awesome/scss/font-awesome.scss' 1然后在组件中使用即可实现： 1&lt;span class=\"fa fa-camera-retro fa-lg\"&gt;&lt;/span&gt; vue-cli 3.x配置跨域代理1234567891011121314151617181920// vue.config.jsmodule.exports = &#123; // 修改的配置 // 将baseUrl: '/api',改为baseUrl: '/', baseUrl: '/', devServer: &#123; proxy: &#123; '/api': &#123; target: 'http://www.example.org', changeOrigin: true, ws: true, pathRewrite: &#123; '^/api': '' &#125; &#125; &#125; &#125;&#125;// .env.developmentVUE_APP_BASE_API=/api vue项目使用.env文件配置全局环境变量官方文档 关于文件名：必须以如下方式命名，不要乱起名，也无需专门手动控制加载哪个文件 .env 全局默认配置文件，不论什么环境都会加载合并 .env.development 开发环境下的配置文件 .env.production 生产环境下的配置文件 关于文件名：必须以如下方式命名，不要乱起名，也无需专门手动控制加载哪个文件 .env 全局默认配置文件，不论什么环境都会加载合并 .env.development 开发环境下的配置文件 .env.production 生产环境下的配置文件 更新package-lock.json如果要升级package-lock.json里面的库包，怎么操作呢？ 1npm install XXX@x.x.x package.json和package-lock.json到底是什么npm官方文档：http://caibaojian.com/npm/files/package.json.html 我们每次，去npm install xxx会把内容记录到package.json文件中，下载的包都会发生变化，为了系统的稳定性考虑，每次执行完npm install之后会对应生成package-lock文件，该文件记录了上一次安装的具体的版本号。 根据官方文档，package-lock.json 是生成的系统当前安装的库的具体来源和版本号，锁定版本。 当你执行npm install的时候， node会先从package.json文件中读取所有dependencies信息，然后根据dependencies中的信息与node_modules中的模块进行对比，没有的直接下载，node是从package.json文件读取模块名称，从package-lock.json文件中获取版本号，然后进行下载或者更新。 当package.json与package-lock.json都不存在，执行”npm install”时，node会重新生成package-lock.json文件，然后把node_modules中的模块信息全部记入package-lock.json文件，但不会生成package.json文件。但是，你可以通过”npm init –yes”来生成package.json文件 vue打包在官网有说，comments当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。 https://segmentfault.com/a/1190000019499007 分析12vuecli 2.x`自带了分析工具只要运行`npm run build --report 如果是vuecli 3的话，先安装插件 1npm install webpack-bundle-analyzer -save-dev 然后在vue.config.js中对webpack进行配置 1234567891011chainWebpack: (config) =&gt; &#123; /* 添加分析工具*/ if (process.env.NODE_ENV === 'production') &#123; if (process.env.npm_config_report) &#123; config .plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin) .end(); config.plugins.delete('prefetch') &#125; &#125; &#125; 再运行npm run build --report 会在浏览器打开一个项目打包的情况图，便于直观地比较各个bundle文件的大小 可以看到 项目中所有的依赖，所有的路由，都被打包进了同一个文件中 另外，在浏览器中，也可以通过converge来查看代码的使用状况 路由懒加载 当打包构建应用时，JavaScript包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 如果是在vuecli 3中，我们还需要多做一步工作因为vuecli 3默认开启prefetch(预先加载模块)，提前获取用户未来可能会访问的内容在首屏会把这十几个路由文件，都一口气下载了所以我们要关闭这个功能，在vue.config.js中设置参考官网的做法：","categories":[{"name":"js","slug":"js","permalink":"https://codeofli.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://codeofli.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://codeofli.github.io/tags/vue/"}]},{"title":"pythonSpider","slug":"python/pythonSpider/pythonSpider","date":"2019-11-10T14:21:09.000Z","updated":"2021-10-23T02:19:04.278Z","comments":true,"path":"2019/11/python/pythonSpider/pythonSpider/","link":"","permalink":"https://codeofli.github.io/2019/11/python/pythonSpider/pythonSpider/","excerpt":"[TOC]安装1pip install requests安装chromedrivehttps://www.cnblogs.com/lfri/p/10542797.html1、查看自己chrome浏览器的版本。 浏览器地址栏输入以下地址 chrome://version通过自己的版本下载相应的chromedriver.exe","text":"[TOC]安装1pip install requests安装chromedrivehttps://www.cnblogs.com/lfri/p/10542797.html1、查看自己chrome浏览器的版本。 浏览器地址栏输入以下地址 chrome://version通过自己的版本下载相应的chromedriver.exe 下载地址：http://npm.taobao.org/mirrors/chromedriver/ 配置解压压缩包，找到chromedriver.exe复制到chrome的安装目录（其实也可以随便放一个文件夹）。复制chromedriver.exe文件的路径并加入到电脑的环境变量中去。 在shell中输入 1chromedriver 显示： 123Starting ChromeDriver 78.0.3904.105 (60e2d8774a8151efa6a00b1f358371b1e0e07ee2-refs/branch-heads/3904@&#123;#877&#125;) on port 9515Only local connections are allowed.Please protect ports used by ChromeDriver and related test frameworks to prevent access by malicious code. 则安装成功 使用python selenium测试 123import seleniumfrom selenium import webdriverdriver = webdriver.Chrome() 能打开浏览器则安装成功 phantomjs已经没人用了，都是headless chrome 爬虫基本原理讲解爬虫——请求网站并提取数据的自动化程序 爬取代码 12345678910import requests# response = requests.get('http://www.baidu.com')# print(response.text)response = requests.get('http://www.baidu.com/img/baidu_jgylogo3.gif')print(response.content)with open('baidu.jpg','wb') as f: f.write(response.content) f.close Urlliburllib提供了一系列用于操作URL的功能。 Python内置的HTTP请求库 urllib.request 请求模块 urllib.error 异常处理理模块urllib.parse url解析模块urllib.robotparser robots.txt解析模块 123import urllib.requestresponse = urllib.request.urlopen('http://www.baidu.com')print(response.read().decode('utf-8')) 123456import urllib.parseimport urllib.requestdata = bytes(urllib.parse.urlencode(&#123;'word': 'hello'&#125;), encoding='utf8')response = urllib.request.urlopen('http://httpbin.org/post', data=data)print(response.read()) 1234import urllib.requestresponse = urllib.request.urlopen('http://httpbin.org/get', timeout=1)print(response.read()) 1234import urllib.requestresponse = urllib.request.urlopen('http://httpbin.org/get', timeout=1)print(response.read()) 响应响应类型1234import urllib.requestresponse = urllib.request.urlopen('https://www.python.org')print(type(response)) 状态码、响应头123456import urllib.requestresponse = urllib.request.urlopen('https://www.python.org')print(response.status)print(response.getheaders())print(response.getheader('Server')) 1234import urllib.requestresponse = urllib.request.urlopen('https://www.python.org')print(response.read().decode('utf-8')) Request12345import urllib.requestrequest = urllib.request.Request('https://python.org')response = urllib.request.urlopen(request)print(response.read().decode('utf-8')) 1234567891011121314from urllib import request, parseurl = 'http://httpbin.org/post'headers = &#123; 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)', 'Host': 'httpbin.org'&#125;dict = &#123; 'name': 'Germey'&#125;data = bytes(parse.urlencode(dict), encoding='utf8')req = request.Request(url=url, data=data, headers=headers, method='POST')response = request.urlopen(req)print(response.read().decode('utf-8')) Handler代理12345678910import urllib.requestproxy_handler = urllib.request.ProxyHandler(&#123; 'http': 'http://127.0.0.1:9743', 'https': 'https://127.0.0.1:9743'&#125;)opener = urllib.request.build_opener(proxy_handler)response = opener.open('http://httpbin.org/get')print(response.read()) Cookie12345678import http.cookiejar, urllib.requestcookie = http.cookiejar.CookieJar()handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')for item in cookie: print(item.name+\"=\"+item.value) 1234567import http.cookiejar, urllib.requestfilename = \"cookie.txt\"cookie = http.cookiejar.MozillaCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')cookie.save(ignore_discard=True, ignore_expires=True) 1234567import http.cookiejar, urllib.requestfilename = 'cookie.txt'cookie = http.cookiejar.LWPCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')cookie.save(ignore_discard=True, ignore_expires=True) 1234567891048import http.cookiejar, urllib.requestcookie = http.cookiejar.LWPCookieJar()cookie.load('cookie.txt', ignore_discard=True, ignore_expires=True)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')print(response.read().decode('utf-8')) 异常处理12345from urllib import request, errortry: response = request.urlopen('http://cuiqingcai.com/index.htm')except error.URLError as e: print(e.reason) 12345678910from urllib import request, errortry: response = request.urlopen('http://cuiqingcai.com/index.htm')except error.HTTPError as e: print(e.reason, e.code, e.headers, sep='\\n')except error.URLError as e: print(e.reason)else: print('Request Successfully') 12345678910import socketimport urllib.requestimport urllib.errortry: response = urllib.request.urlopen('https://www.baidu.com', timeout=0.01)except urllib.error.URLError as e: print(type(e.reason)) if isinstance(e.reason, socket.timeout): print('TIME OUT') 12&lt;class 'socket.timeout'&gt;TIME OUT URL解析urlparse1234567urllib.parse.urlparse(urlstring, scheme='', allow_fragments=True)52from urllib.parse import urlparseresult = urlparse('http://www.baidu.com/index.html;user?id=5#comment')print(type(result), result) 1234567&lt;class 'urllib.parse.ParseResult'&gt; ParseResult(scheme='http', netloc='www.baidu.com', path='/index.html', params='user', query='id=5', fragment='comment')53from urllib.parse import urlparseresult = urlparse('www.baidu.com/index.html;user?id=5#comment', scheme='https')print(result) 1234567ParseResult(scheme='https', netloc='', path='www.baidu.com/index.html', params='user', query='id=5', fragment='comment')54from urllib.parse import urlparseresult = urlparse('http://www.baidu.com/index.html;user?id=5#comment', scheme='https')print(result) 1234567ParseResult(scheme='http', netloc='www.baidu.com', path='/index.html', params='user', query='id=5', fragment='comment')55from urllib.parse import urlparseresult = urlparse('http://www.baidu.com/index.html;user?id=5#comment', allow_fragments=False)print(result) 1234567ParseResult(scheme='http', netloc='www.baidu.com', path='/index.html', params='user', query='id=5#comment', fragment='')56from urllib.parse import urlparseresult = urlparse('http://www.baidu.com/index.html#comment', allow_fragments=False)print(result) 1ParseResult(scheme='http', netloc='www.baidu.com', path='/index.html#comment', params='', query='', fragment='') urlunparse1234from urllib.parse import urlunparsedata = ['http', 'www.baidu.com', 'index.html', 'user', 'a=6', 'comment']print(urlunparse(data)) 1http://www.baidu.com/index.html;user?a=6#comment urljoin12345678910111258from urllib.parse import urljoinprint(urljoin('http://www.baidu.com', 'FAQ.html'))print(urljoin('http://www.baidu.com', 'https://cuiqingcai.com/FAQ.html'))print(urljoin('http://www.baidu.com/about.html', 'https://cuiqingcai.com/FAQ.html'))print(urljoin('http://www.baidu.com/about.html', 'https://cuiqingcai.com/FAQ.html?question=2'))print(urljoin('http://www.baidu.com?wd=abc', 'https://cuiqingcai.com/index.php'))print(urljoin('http://www.baidu.com', '?category=2#comment'))print(urljoin('www.baidu.com', '?category=2#comment'))print(urljoin('www.baidu.com#comment', '?category=2')) 12345678http://www.baidu.com/FAQ.htmlhttps://cuiqingcai.com/FAQ.htmlhttps://cuiqingcai.com/FAQ.htmlhttps://cuiqingcai.com/FAQ.html?question=2https://cuiqingcai.com/index.phphttp://www.baidu.com?category=2#commentwww.baidu.com?category=2#commentwww.baidu.com?category=2 urlencode123456789from urllib.parse import urlencodeparams = &#123; 'name': 'germey', 'age': 22&#125;base_url = 'http://www.baidu.com?'url = base_url + urlencode(params)print(url) 1http://www.baidu.com?name=germey&amp;age=22 Requests库什么是RequestsRequests 是用Python语言编写，基于 urllib，采⽤用Apache2 Licensed 开源协议的 HTTP 库。它比 urllib 更加方便，可以节约我们大量的工作，完全满⾜足HTTP 测试需求。⼀一句句话——Python实现的简单易易用的HTTP库 实例引入12345678import requestsresponse = requests.get('https://www.baidu.com/')print(type(response))print(response.status_code)print(type(response.text))print(response.text)print(response.cookies) 各种请求方式123456import requestsrequests.post('http://httpbin.org/post')requests.put('http://httpbin.org/put')requests.delete('http://httpbin.org/delete')requests.head('http://httpbin.org/get')requests.options('http://httpbin.org/get') 请求基本GET请求基本写法1234import requestsresponse = requests.get('http://httpbin.org/get')print(response.text) 带参数GET请求123import requestsresponse = requests.get(\"http://httpbin.org/get?name=germey&amp;age=22\")print(response.text) 12345678import requestsdata = &#123; 'name': 'germey', 'age': 22&#125;response = requests.get(\"http://httpbin.org/get\", params=data)print(response.text) 解析json12345678import requestsimport jsonresponse = requests.get(\"http://httpbin.org/get\")print(type(response.text))print(response.json())print(json.loads(response.text))print(type(response.json())) 获取二进制数据123456import requestsresponse = requests.get(\"https://github.com/favicon.ico\")print(type(response.text), type(response.content))print(response.text)print(response.content) 123456import requestsresponse = requests.get(\"https://github.com/favicon.ico\")with open('favicon.ico', 'wb') as f: f.write(response.content) f.close() 添加headers1234import requestsresponse = requests.get(\"https://www.zhihu.com/explore\")print(response.text) 1234567import requestsheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'&#125;response = requests.get(\"https://www.zhihu.com/explore\", headers=headers)print(response.text) 基本POST请求12345import requestsdata = &#123;'name': 'germey', 'age': '22'&#125;response = requests.post(\"http://httpbin.org/post\", data=data)print(response.text) 12345678import requestsdata = &#123;'name': 'germey', 'age': '22'&#125;headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'&#125;response = requests.post(\"http://httpbin.org/post\", data=data, headers=headers)print(response.json()) 响应reponse属性12345678import requestsresponse = requests.get('http://www.jianshu.com')print(type(response.status_code), response.status_code)print(type(response.headers), response.headers)print(type(response.cookies), response.cookies)print(type(response.url), response.url)print(type(response.history), response.history) 状态码判断1234import requestsresponse = requests.get('http://www.jianshu.com/hello.html')exit() if not response.status_code == requests.codes.not_found else print('404 Not Found') 1234import requestsresponse = requests.get('http://www.jianshu.com')exit() if not response.status_code == 200 else print('Request Successfully') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475100: ('continue',),101: ('switching_protocols',),102: ('processing',),103: ('checkpoint',),122: ('uri_too_long', 'request_uri_too_long'),200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\\\o/', '✓'),201: ('created',),202: ('accepted',),203: ('non_authoritative_info', 'non_authoritative_information'),204: ('no_content',),205: ('reset_content', 'reset'),206: ('partial_content', 'partial'),207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),208: ('already_reported',),226: ('im_used',),# Redirection.300: ('multiple_choices',),301: ('moved_permanently', 'moved', '\\\\o-'),302: ('found',),303: ('see_other', 'other'),304: ('not_modified',),305: ('use_proxy',),306: ('switch_proxy',),307: ('temporary_redirect', 'temporary_moved', 'temporary'),308: ('permanent_redirect', 'resume_incomplete', 'resume',), # These 2 to be removed in 3.0# Client Error.400: ('bad_request', 'bad'),401: ('unauthorized',),402: ('payment_required', 'payment'),403: ('forbidden',),404: ('not_found', '-o-'),405: ('method_not_allowed', 'not_allowed'),406: ('not_acceptable',),407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),408: ('request_timeout', 'timeout'),409: ('conflict',),410: ('gone',),411: ('length_required',),412: ('precondition_failed', 'precondition'),413: ('request_entity_too_large',),414: ('request_uri_too_large',),415: ('unsupported_media_type', 'unsupported_media', 'media_type'),416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),417: ('expectation_failed',),418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),421: ('misdirected_request',),422: ('unprocessable_entity', 'unprocessable'),423: ('locked',),424: ('failed_dependency', 'dependency'),425: ('unordered_collection', 'unordered'),426: ('upgrade_required', 'upgrade'),428: ('precondition_required', 'precondition'),429: ('too_many_requests', 'too_many'),431: ('header_fields_too_large', 'fields_too_large'),444: ('no_response', 'none'),449: ('retry_with', 'retry'),450: ('blocked_by_windows_parental_controls', 'parental_controls'),451: ('unavailable_for_legal_reasons', 'legal_reasons'),499: ('client_closed_request',),# Server Error.500: ('internal_server_error', 'server_error', '/o\\\\', '✗'),501: ('not_implemented',),502: ('bad_gateway',),503: ('service_unavailable', 'unavailable'),504: ('gateway_timeout',),505: ('http_version_not_supported', 'http_version'),506: ('variant_also_negotiates',),507: ('insufficient_storage',),509: ('bandwidth_limit_exceeded', 'bandwidth'),510: ('not_extended',),511: ('network_authentication_required', 'network_auth', 'network_authentication'), 高级操作文件上传12345import requestsfiles = &#123;'file': open('favicon.ico', 'rb')&#125;response = requests.post(\"http://httpbin.org/post\", files=files)print(response.text) 12 获取cookie123456import requestsresponse = requests.get(\"https://www.baidu.com\")print(response.cookies)for key, value in response.cookies.items(): print(key + '=' + value) 会话维持模拟登录 12345import requestsrequests.get('http://httpbin.org/cookies/set/number/123456789')response = requests.get('http://httpbin.org/cookies')print(response.text) 123456import requestss = requests.Session()s.get('http://httpbin.org/cookies/set/number/123456789')response = s.get('http://httpbin.org/cookies')print(response.text) 12 证书验证12 1234import requestsresponse = requests.get('https://www.12306.cn')print(response.status_code) 12 12345import requestsfrom requests.packages import urllib3urllib3.disable_warnings()response = requests.get('https://www.12306.cn', verify=False)print(response.status_code) 12 1234import requestsresponse = requests.get('https://www.12306.cn', cert=('/path/server.crt', '/path/key'))print(response.status_code) 12 代理设置12 123456789import requestsproxies = &#123; \"http\": \"http://127.0.0.1:9743\", \"https\": \"https://127.0.0.1:9743\",&#125;response = requests.get(\"https://www.taobao.com\", proxies=proxies)print(response.status_code) 12 1234567import requestsproxies = &#123; \"http\": \"http://user:password@127.0.0.1:9743/\",&#125;response = requests.get(\"https://www.taobao.com\", proxies=proxies)print(response.status_code) 12 1pip3 install 'requests[socks]' 12 12345678import requestsproxies = &#123; 'http': 'socks5://127.0.0.1:9742', 'https': 'socks5://127.0.0.1:9742'&#125;response = requests.get(\"https://www.taobao.com\", proxies=proxies)print(response.status_code) 12 超时设置12 1234567import requestsfrom requests.exceptions import ReadTimeouttry: response = requests.get(\"http://httpbin.org/get\", timeout = 0.5) print(response.status_code)except ReadTimeout: print('Timeout') 12 认证设置12 12345import requestsfrom requests.auth import HTTPBasicAuthr = requests.get('http://120.27.34.24:9001', auth=HTTPBasicAuth('user', '123'))print(r.status_code) 12 1234import requestsr = requests.get('http://120.27.34.24:9001', auth=('user', '123'))print(r.status_code) 12 异常处理1234567891011121345import requestsfrom requests.exceptions import ReadTimeout, ConnectionError, RequestExceptiontry: response = requests.get(\"http://httpbin.org/get\", timeout = 0.5) print(response.status_code)except ReadTimeout: print('Timeout')except ConnectionError: print('Connection error')except RequestException: print('Error') 1Connection error BeautifulSoup解析库 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, “html.parser”) Python的内置标准库、执行速度适中 、文档容错能力强 Python 2.7.3 or 3.2.2)前的版本中文容错能力差 lxml HTML 解析器 BeautifulSoup(markup, “lxml”) 速度快、文档容错能力强 需要安装C语言库 lxml XML 解析器 BeautifulSoup(markup, “xml”) 速度快、唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, “html5lib”) 最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档 速度慢、不依赖外部扩展 基本使用12345678910111213141516171html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.prettify())print(soup.title.string) 12345678910111213141516171819202122232425262728293031323334&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"title\" name=\"dromouse\"&gt; &lt;b&gt; The Dormouse's story &lt;/b&gt; &lt;/p&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt; &lt;!-- Elsie --&gt; &lt;/a&gt; , &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt; ;and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;The Dormouse's story 12 1No output 标签选择器12 选择元素123456789101112131415161718192html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.title)print(type(soup.title))print(soup.head)print(soup.p) 1234&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;class 'bs4.element.Tag'&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; 获取名称123456789101112131415163html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.title.name) 1title 获取属性12345678910111213141516174html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.attrs['name'])print(soup.p['name']) 12dromousedromouse 获取内容123456789101112131415165html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p clss=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.string) 1The Dormouse's story 嵌套选择123456789101112131415166html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.head.title.string) 1The Dormouse's story 子节点和子孙节点12345678910111213141516171819202122237html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.contents) 12345678910111213141516171819202122232425262728['\\n Once upon a time there were three little sisters; and their names were\\n ', &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;, '\\n', &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;, ' \\n and\\n ', &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;, '\\n and they lived at the bottom of a well.\\n ']8html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.children)for i, child in enumerate(soup.p.children): print(i, child) 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;list_iterator object at 0x1064f7dd8&gt;0 Once upon a time there were three little sisters; and their names were 1 &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 3 &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;4 and 5 &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;6 and they lived at the bottom of a well. 9html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.descendants)for i, child in enumerate(soup.p.descendants): print(i, child) 123456789101112131415161718192021222324&lt;generator object descendants at 0x10650e678&gt;0 Once upon a time there were three little sisters; and their names were 1 &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 3 &lt;span&gt;Elsie&lt;/span&gt;4 Elsie5 6 7 &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;8 Lacie9 and 10 &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;11 Tillie12 and they lived at the bottom of a well. 父节点和祖先节点123456789101112131415161718192021222310html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.a.parent) 123456789101112131415161718192021222324252627282930313233&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;11html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(list(enumerate(soup.a.parents))) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[(0, &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;), (1, &lt;body&gt;&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;&lt;/body&gt;), (2, &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;), (3, &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;)] 兄弟节点12345678910111213141516171819202122232412html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(list(enumerate(soup.a.next_siblings)))print(list(enumerate(soup.a.previous_siblings))) 12[(0, '\\n'), (1, &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;), (2, ' \\n and\\n '), (3, &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;), (4, '\\n and they lived at the bottom of a well.\\n ')][(0, '\\n Once upon a time there were three little sisters; and their names were\\n ')] 标准选择器12 find_all( name , attrs , recursive , text , **kwargs )12 可根据标签名、属性、内容查找文档 12 name12345678910111213141516171819202122232413html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all('ul'))print(type(soup.find_all('ul')[0])) 123456789101112131415161718192021222324252627282930313233[&lt;ul class=\"list\" id=\"list-1\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;, &lt;ul class=\"list list-small\" id=\"list-2\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;/ul&gt;]&lt;class 'bs4.element.Tag'&gt;14html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.find_all('ul'): print(ul.find_all('li')) 12[&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;, &lt;li class=\"element\"&gt;Jay&lt;/li&gt;][&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;] attrs12345678910111213141516171819202122232415html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\" name=\"elements\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(attrs=&#123;'id': 'list-1'&#125;))print(soup.find_all(attrs=&#123;'name': 'elements'&#125;)) 12345678910111213141516171819202122232425262728293031323334[&lt;ul class=\"list\" id=\"list-1\" name=\"elements\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;][&lt;ul class=\"list\" id=\"list-1\" name=\"elements\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;]16html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(id='list-1'))print(soup.find_all(class_='element')) 123456[&lt;ul class=\"list\" id=\"list-1\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;][&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;, &lt;li class=\"element\"&gt;Jay&lt;/li&gt;, &lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;] text123456789101112131415161718192021222317html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(text='Foo')) 1['Foo', 'Foo'] find( name , attrs , recursive , text , **kwargs )12 find返回单个元素，find_all返回所有元素 1234567891011121314151617181920212223242518html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find('ul'))print(type(soup.find('ul')))print(soup.find('page')) 1234567&lt;ul class=\"list\" id=\"list-1\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;&lt;class 'bs4.element.Tag'&gt;None find_parents() find_parent()12 find_parents()返回所有祖先节点，find_parent()返回直接父节点。 12 find_next_siblings() find_next_sibling()12 find_next_siblings()返回后面所有兄弟节点，find_next_sibling()返回后面第一个兄弟节点。 12 find_previous_siblings() find_previous_sibling()12 find_previous_siblings()返回前面所有兄弟节点，find_previous_sibling()返回前面第一个兄弟节点。 12 find_all_next() find_next()12 find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点 12 find_all_previous() 和 find_previous()12 find_all_previous()返回节点后所有符合条件的节点, find_previous()返回第一个符合条件的节点 12 CSS选择器12 通过select()直接传入CSS选择器即可完成选择 123456789101112131415161718192021222324252619html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.select('.panel .panel-heading'))print(soup.select('ul li'))print(soup.select('#list-2 .element'))print(type(soup.select('ul')[0])) 123456789101112131415161718192021222324252627282930[&lt;div class=\"panel-heading\"&gt;&lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;][&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;, &lt;li class=\"element\"&gt;Jay&lt;/li&gt;, &lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;][&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;]&lt;class 'bs4.element.Tag'&gt;20html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.select('ul'): print(ul.select('li')) 12[&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;, &lt;li class=\"element\"&gt;Jay&lt;/li&gt;][&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;] 获取属性1234567891011121314151617181920212223242521html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.select('ul'): print(ul['id']) print(ul.attrs['id']) 1234list-1list-1list-2list-2 获取内容12345678910111213141516171819202122232423html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for li in soup.select('li'): print(li.get_text()) 12345FooBarJayFooBar 总结12 推荐使用lxml解析库，必要时使用html.parser 标签选择筛选功能弱但是速度快 建议使用find()、find_all() 查询匹配单个结果或者多个结果 如果对CSS选择器熟悉建议使用select() 记住常用的获取属性和文本值的方法 pyquery安装 1pip install pyquery 官方文档http://pyquery.readthedocs.io/ 初始化字符串初始化1doc = pq(html) 1234567891011121314html = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)print(doc('li')) 12345&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; URL初始化123from pyquery import PyQuery as pqdoc = pq(url='http://www.baidu.com')print(doc('head')) 1&lt;head&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"/&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"/&gt;&lt;meta content=\"always\" name=\"referrer\"/&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css\"/&gt;&lt;title&gt;ç¾åº¦ä¸ä¸ï¼ä½ å°±ç¥é&lt;/title&gt;&lt;/head&gt; 文件初始化123from pyquery import PyQuery as pqdoc = pq(filename='demo.html')print(doc('li')) 12345&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; 基本CSS选择器py产生的对象能和jquery对象一样使用css选择器 1234567891011121314html = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)print(doc('#container .list li')) 12345&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; 查找元素子元素12345678910111213141516171819html = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)items = doc('.list')print(type(items))print(items)lis = items.find('li')print(type(lis))print(lis) 123lis = items.children()print(type(lis))print(lis) 12lis = items.children('.active')print(lis) 12&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; 父元素1.parent() 1234567891011121314151617html = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)items = doc('.list')container = items.parent()print(type(container))print(container) 12345678910&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 12345678910111213141516171819html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)items = doc('.list')parents = items.parents()print(type(parents))print(parents) 12345678910111213141516171819202122232425&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 10parent = items.parents('.wrap')print(parent) 1234567891011&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; 兄弟元素1234567891011121314151617181911html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.list .item-0.active')print(li.siblings()) 123456789101112131415161718192021222324&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; 12html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.list .item-0.active')print(li.siblings('.active')) 1&lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; 遍历12 单个元素1234567891011121314151617html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')print(li) 1234567891011121314151617181920212223&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 14html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)lis = doc('li').items()print(type(lis))for li in lis: print(li) 12345678910&lt;class 'generator'&gt;&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; 获取信息获取属性1item.attr() 12345678910111213141516171819html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)a = doc('.item-0.active a')print(a)print(a.attr('href'))print(a.attr.href) 123&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;link3.htmllink3.html 获取文本1item.text() 获取HTML1item.html() DOM操作addClass、removeClass123456789101112131415161718192021222319html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')print(li)li.removeClass('active')print(li)li.addClass('active')print(li) 12345&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; attr、css123456789101112131415161718192021222320html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')print(li)li.attr('name', 'link')print(li)li.css('font-size', '14px')print(li) 12345&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\" name=\"link\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\" name=\"link\" style=\"font-size: 14px\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; remove123456789101112131421html = '''&lt;div class=\"wrap\"&gt; Hello, World &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)wrap = doc('.wrap')print(wrap.text())wrap.find('p').remove()print(wrap.text()) 12Hello, World This is a paragraph.Hello, World 其他DOM方法12 http://pyquery.readthedocs.io/en/latest/api.html 12 伪类选择器123456789101112131415161718192021222324252627282923html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('li:first-child')print(li)li = doc('li:last-child')print(li)li = doc('li:nth-child(2)')print(li)li = doc('li:gt(2)')print(li)li = doc('li:nth-child(2n)')print(li)li = doc('li:contains(second)')print(li) 12345678910111213&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; 更多CSS选择器可以查看http://www.w3school.com.cn/css/index.asp Selenium官方文档 中文官网 安装 1pip install selenium 基本使用12345678910111213141516171819from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitbrowser = webdriver.Chrome()try: browser.get('https://www.baidu.com') input = browser.find_element_by_id('kw') input.send_keys('Python') input.send_keys(Keys.ENTER) wait = WebDriverWait(browser, 10) wait.until(EC.presence_of_element_located((By.ID, 'content_left'))) print(browser.current_url) print(browser.get_cookies()) print(browser.page_source)finally: browser.close() 1234567https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=Python&amp;rsv_pq=c94d0df9000a72d0&amp;rsv_t=07099xvun1ZmC0bf6eQvygJ43IUTTUOl5FCJVPgwG2YREs70GplJjH2F%2BCQ&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=6&amp;rsv_sug2=0&amp;inputT=87&amp;rsv_sug4=87[&#123;'secure': False, 'value': 'B490B5EBF6F3CD402E515D22BCDA1598', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BDORZ', 'expiry': 1491688071.707553&#125;, &#123;'secure': False, 'value': '22473_1441_21084_17001', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'H_PS_PSSID'&#125;, &#123;'secure': False, 'value': '531', 'domain': 'www.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BDSVRTM'&#125;, &#123;'secure': False, 'value': '1', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'PSINO'&#125;, &#123;'secure': False, 'value': '2759B6BCB05A61360E722492B5ADE01F:FG=1', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BAIDUID', 'expiry': 3639085317.693848&#125;, &#123;'secure': False, 'value': '1', 'domain': 'www.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BD_CK_SAM'&#125;, &#123;'secure': False, 'value': '2759B6BCB05A61360E722492B5ADE01F', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BIDUPSID', 'expiry': 3639085317.693914&#125;, &#123;'secure': False, 'value': '1491601670', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'PSTM', 'expiry': 3639085317.693932&#125;, &#123;'secure': False, 'value': 'd69fIn5RRf0Bp01TcnTIY15NEdl5QudrAwHpE1x1AjuuYXbVOQkXABYVF5M', 'domain': 'www.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'H_PS_645EC', 'expiry': 1491604263&#125;, &#123;'secure': False, 'value': '123253', 'domain': 'www.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BD_UPN', 'expiry': 1492465670&#125;, &#123;'secure': False, 'value': '0', 'domain': 'www.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BD_HOME'&#125;, &#123;'secure': False, 'value': '12883875381399993259_00_0_I_R_2_0303_C02F_N_I_I_0', 'domain': '.www.baidu.com', 'path': '/', 'httpOnly': False, 'name': '__bsi', 'expiry': 1491601676.69722&#125;]&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;script type=\"text/javascript\" charset=\"gb2312\" src=\"//www.baidu.com/cache/aladdin/ui/tabs5/tabs5.js?v=20170208\" data-for=\"A.ui\"&gt;&lt;/script&gt;&lt;script charset=\"utf-8\" async=\"\" src=\"https://ss0.bdstatic.com/-0U0bnSm1A5BphGlnYG/tam-ogel/1c5d7b26-f3f0-4dd7-a025-8c79809fecac.js\"&gt;&lt;/script&gt; ......&lt;/body&gt;&lt;/html&gt; 声明浏览器对象1234567from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari() 访问页面123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')print(browser.page_source)browser.close() 查找元素单个元素 find_element_by_id find_element_by_name find_element_by_xpath find_element_by_link_text find_element_by_partial_link_text find_element_by_tag_name find_element_by_class_name find_element_by_css_selector 1find_element(By.ID, 'q') 123456789from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input_first = browser.find_element_by_id('q')input_second = browser.find_element_by_css_selector('#q')input_third = browser.find_element_by_xpath('//*[@id=\"q\"]')print(input_first, input_second, input_third)browser.close() 1&lt;selenium.webdriver.remote.webelement.WebElement (session=\"5e53d9e1c8646e44c14c1c2880d424af\", element=\"0.5649563096161541-1\")&gt; &lt;selenium.webdriver.remote.webelement.WebElement (session=\"5e53d9e1c8646e44c14c1c2880d424af\", element=\"0.5649563096161541-1\")&gt; &lt;selenium.webdriver.remote.webelement.WebElement (session=\"5e53d9e1c8646e44c14c1c2880d424af\", element=\"0.5649563096161541-1\")&gt; 12345678from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input_first = browser.find_element(By.ID, 'q')print(input_first)browser.close() 1&lt;selenium.webdriver.remote.webelement.WebElement (session=\"1f209c0d11551c40d9d20ad964fef244\", element=\"0.07914603542731591-1\")&gt; 多个元素 find_elements_by_name find_elements_by_xpath find_elements_by_link_text find_elements_by_partial_link_text find_elements_by_tag_name find_elements_by_class_name find_elements_by_css_selector 1driver.find_elements(By.CSS_SELECTOR, '.service-bd li') 1234567from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')lis = browser.find_elements_by_css_selector('.service-bd li')print(lis)browser.close() 123[&lt;selenium.webdriver.remote.webelement.WebElement (session=\"c26290835d4457ebf7d96bfab3740d19\", element=\"0.09221044033125603-1\")&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=\"c26290835d4457ebf7d96bfab3740d19\", element=\"0.09221044033125603-2\")&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=\"c26290835d4457ebf7d96bfab3740d19\", element=\"0.09221044033125603-3\")&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=\"c26290835d4457ebf7d96bfab3740d19\", element=\"0.09221044033125603-4\")&gt;, .........&lt;selenium.webdriver.remote.webelement.WebElement (session=\"c26290835d4457ebf7d96bfab3740d19\", element=\"0.09221044033125603-16\")&gt;] 12345678from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.taobao.com')lis = browser.find_elements(By.CSS_SELECTOR, '.service-bd li')print(lis)browser.close() 元素交互操作对获取的元素调用交互方法 123456789101112from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input = browser.find_element_by_id('q')input.send_keys('iPhone')time.sleep(1)input.clear()input.send_keys('iPad')button = browser.find_element_by_class_name('btn-search')button.click() 更多操作: http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement 交互动作将动作附加到动作链中串行执行 123456789101112from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'browser.get(url)browser.switch_to.frame('iframeResult')source = browser.find_element_by_css_selector('#draggable')target = browser.find_element_by_css_selector('#droppable')actions = ActionChains(browser)actions.drag_and_drop(source, target)actions.perform() 更多操作: http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains 执行JavaScript123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')browser.execute_script('alert(\"To Bottom\")') 获取元素信息获取属性1logo.get_attribute('class') 123456789from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)logo = browser.find_element_by_id('zh-top-link-logo')print(logo)print(logo.get_attribute('class')) 12&lt;selenium.webdriver.remote.webelement.WebElement (session=\"e08c0f28d7f44d75ccd50df6bb676104\", element=\"0.7236390660048155-1\")&gt;zu-top-link-logo 获取文本值1获取元素.text 1234567from selenium import webdriverbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')print(input.text) 获取ID、位置、标签名、大小12345678910from selenium import webdriverbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')print(input.id)print(input.location)print(input.tag_name)print(input.size) 12340.6822924344980397-1&#123;'y': 7, 'x': 774&#125;button&#123;'height': 32, 'width': 66&#125; Frame123456789101112131415161718import timefrom selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionbrowser = webdriver.Chrome()url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'browser.get(url)browser.switch_to.frame('iframeResult')source = browser.find_element_by_css_selector('#draggable')print(source)try: logo = browser.find_element_by_class_name('logo')except NoSuchElementException: print('NO LOGO')browser.switch_to.parent_frame()logo = browser.find_element_by_class_name('logo')print(logo)print(logo.text) 1234&lt;selenium.webdriver.remote.webelement.WebElement (session=\"4bb8ac03ced4ecbdefef03ffdc0e4ccd\", element=\"0.44746093888932004-1\")&gt;NO LOGO&lt;selenium.webdriver.remote.webelement.WebElement (session=\"4bb8ac03ced4ecbdefef03ffdc0e4ccd\", element=\"0.13792611320464965-2\")&gt;RUNOOB.COM 等待隐式等待当使用了隐式等待执行测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常, 换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是0 1234567from selenium import webdriverbrowser = webdriver.Chrome()browser.implicitly_wait(10)browser.get('https://www.zhihu.com/explore')input = browser.find_element_by_class_name('zu-top-add-question')print(input) 1&lt;selenium.webdriver.remote.webelement.WebElement (session=\"b29214772d59e912f1ac52e96ed29abe\", element=\"0.12886805191194894-1\")&gt; 显式等待12345678910111219from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECbrowser = webdriver.Chrome()browser.get('https://www.taobao.com/')wait = WebDriverWait(browser, 10)input = wait.until(EC.presence_of_element_located((By.ID, 'q')))button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, '.btn-search')))print(input, button) 1&lt;selenium.webdriver.remote.webelement.WebElement (session=\"07dd2fbc2d5b1ce40e82b9754aba8fa8\", element=\"0.5642646294074107-1\")&gt; &lt;selenium.webdriver.remote.webelement.WebElement (session=\"07dd2fbc2d5b1ce40e82b9754aba8fa8\", element=\"0.5642646294074107-2\")&gt; title_is 标题是某内容 title_contains 标题包含某内容 presence_of_element_located 元素加载出，传入定位元组，如(By.ID, ‘p’) visibility_of_element_located 元素可见，传入定位元组 visibility_of 可见，传入元素对象 presence_of_all_elements_located 所有元素加载出 text_to_be_present_in_element 某个元素文本包含某文字 text_to_be_present_in_element_value 某个元素值包含某文字 frame_to_be_available_and_switch_to_it frame加载并切换 invisibility_of_element_located 元素不可见 element_to_be_clickable 元素可点击 staleness_of 判断一个元素是否仍在DOM，可判断页面是否已经刷新 element_to_be_selected 元素可选择，传元素对象 element_located_to_be_selected 元素可选择，传入定位元组 element_selection_state_to_be 传入元素对象以及状态，相等返回True，否则返回False element_located_selection_state_to_be 传入定位元组以及状态，相等返回True，否则返回False alert_is_present 是否出现Alert 详细内容：http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions 前进后退1234567891011import timefrom selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com/')browser.get('https://www.taobao.com/')browser.get('https://www.python.org/')browser.back()time.sleep(1)browser.forward()browser.close() Cookies123456789from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')print(browser.get_cookies())browser.add_cookie(&#123;'name': 'name', 'domain': 'www.zhihu.com', 'value': 'germey'&#125;)print(browser.get_cookies())browser.delete_all_cookies()print(browser.get_cookies()) 这些键名都代表什么意思呢？参考博文《selenium3.7+ python3 添加cookie模拟登陆》，罗列如下 name：cookie的名称 value：cookie对应的值，动态生成的 domain：服务器域名 expiry：Cookie有效终止日期 path：Path属性定义了Web服务器上哪些路径下的页面可获取服务器设置的Cookie httpOnly：防脚本攻击 secure:在Cookie中标记该变量，表明只有当浏览器和Web Server之间的通信协议为加密认证协议时 选项卡管理(浏览器页面)123456789101112import timefrom selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.execute_script('window.open()')print(browser.window_handles)browser.switch_to_window(browser.window_handles[1])browser.get('https://www.taobao.com')time.sleep(1)browser.switch_to_window(browser.window_handles[0])browser.get('https://python.org') 1['CDwindow-4f58e3a7-7167-4587-bedf-9cd8c867f435', 'CDwindow-6e05f076-6d77-453a-a36c-32baacc447df'] 异常处理12345from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.find_element_by_id('hello') 1234567891011121314from selenium import webdriverfrom selenium.common.exceptions import TimeoutException, NoSuchElementExceptionbrowser = webdriver.Chrome()try: browser.get('https://www.baidu.com')except TimeoutException: print('Time Out')try: browser.find_element_by_id('hello')except NoSuchElementException: print('No Element')finally: browser.close() 详细文档：http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions Chrome options参数获取 12from selenium import webdriveroptions = webdriver.ChromeOptions() 针对编码格式的操作 12345# 设置默认编码为 utf-8from selenium import webdriveroptions = webdriver.ChromeOptions()options.add_argument('lang=zh_CN.UTF-8')driver = webdriver.Chrome(chrome_options = options) python selenium设置chrome的下载路径python可以通过ChromeOptions设置chrome参数，如下载路径等，代码如下(python 3.6.7)： 123456789101112#-*-coding=utf-8-*-from selenium import webdriverimport timedef set_chrome_pref(): chromeOptions = webdriver.ChromeOptions() prefs = &#123;\"download.default_directory\":\"D:\\\\\"&#125; chromeOptions.add_experimental_option(\"prefs\", prefs) driver = webdriver.Chrome(chrome_options=chromeOptions) time.sleep(10) 退出浏览器和退出窗口selenium中driver.close()和driver.quit()的不同点 driver.quit()与driver.close()的不同：driver.quit(): Quit this driver, closing every associated windows;driver.close(): Close the current window, quiting the browser if it is the last window currently open. 翻译成中文： driver.close() – 关闭当前窗口，如果是当前打开的最后一个窗口，则退出浏览器 driver.quit() – 退出驱动，关闭所有相关的窗口 pymongo安装 1pip install pymongo 使用 12345678910111213import pymongofrom config import *client = pymongo.MongoClient(MONGO_URL)db = client[MONGO_DB]def save_to_mongo(result): try: if db[MONGO_TABLE].insert(result): print('save to mongoDB successfully', result) except Exception: print('save to mongoDB fail',result) config.py 123MONGO_URL = 'localhost'MONGO_DB = 'taobao'MONGO_TABLE = 'product' 实战Requests+正则表达式爬取猫眼电影TOP100https://github.com/Germey/MaoYan Selenium+Chrome爬取淘宝美食https://github.com/codeOflI/TaobaoMeishi PhantomJS phantomjs已经没人用了，都是headless chrome 使用技巧chrome有copy selector选项，能直接copy元素的选择器。 还有xpath选项 learn-issue正则——豆瓣读书实战练习豆瓣读书源码改了，现在不好爬取了 跳过beautifulSoup和Pyquery跳过分析Ajax来抓取今⽇日头条街拍美图结构不一样了？ 跳过Taobao美食的phantomjs，因为停更了 跳过pySpider在python3.7中关键字与pyspider中的函数冲突，需要更改async关键字 跳过代理proxy和cookies [http://www.selenium.org.cn/]:","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/tags/python/"}]},{"title":"分布式缓存-Redis集群","slug":"java-note/SpringCloud/redis/redis","date":"2019-10-26T14:19:09.000Z","updated":"2021-10-31T01:09:18.887Z","comments":true,"path":"2019/10/java-note/SpringCloud/redis/redis/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/SpringCloud/redis/redis/","excerpt":"[TOC]分布式缓存-Redis集群单点Redis的问题数据丢失问题Redis是内存存储，服务重启可能会丢失数据并发能力问题单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景故障恢复问题如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段存储能力问题Redis基于内存，单节点能存储的数据量难以满足海量数据需求","text":"[TOC]分布式缓存-Redis集群单点Redis的问题数据丢失问题Redis是内存存储，服务重启可能会丢失数据并发能力问题单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景故障恢复问题如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段存储能力问题Redis基于内存，单节点能存储的数据量难以满足海量数据需求 Redis持久化RDB持久化RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。 快照文件称为RDB文件，默认是保存在当前运行目录。 Redis停机时会执行一次RDB。 1234567891011^C^C7509:signal-handler (1635042365) Received SIGINT scheduling shutdown...7509:M 23 Oct 2021 19:26:05.981 # User requested shutdown...7509:M 23 Oct 2021 19:26:05.981 * Saving the final RDB snapshot before exiting.7509:M 23 Oct 2021 19:26:05.982 * DB saved on disk7509:M 23 Oct 2021 19:26:05.982 * Removing the pid file.7509:M 23 Oct 2021 19:26:05.982 # Redis is now ready to exit, bye bye...[root@localhost redis-6.2.4]# [root@localhost redis-6.2.4]# lltotal 332-rw-r--r--. 1 root root 104 Oct 23 19:26 dump.rdb 首先需要在Linux系统中安装一个Redis，可以参考课前资料《Redis集群》： Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下： 1234# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save \"\" 则表示禁用RDBsave 900 1 save 300 10 save 60 10000 异步更新时间太长太短都不好，一般用默认设置即可 Bash，[Unix shell](https://baike.baidu.com/item/Unix shell)的一种，在1987年由布莱恩·福克斯为了GNU计划而编写。1989年发布第一个正式版本，原先是计划用在GNU操作系统上，但能运行于大多数类Unix系统的操作系统之上，包括Linux与Mac OS X v10.4都将它作为默认shell。 1234567891011121314151617# You can set these explicitly by uncommenting the three following lines.## save 3600 1# save 300 100# save 60 10000save 5 1# The filename where to dump the DBdbfilename dump.test.rdb7763:M 23 Oct 2021 19:41:04.697 * Ready to accept connections7763:M 23 Oct 2021 19:41:10.094 * 1 changes in 5 seconds. Saving...7763:M 23 Oct 2021 19:41:10.095 * Background saving started by pid 77767776:C 23 Oct 2021 19:41:10.096 * DB saved on disk7776:C 23 Oct 2021 19:41:10.096 * RDB: 2 MB of memory used by copy-on-write7763:M 23 Oct 2021 19:41:10.197 * Background saving terminated with success RDB的其它配置也可以在redis.conf文件中设置： 12345678# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱rdbcompression yes# RDB文件名称dbfilename dump.rdb # 文件保存的路径目录dir ./ bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。 fork采用的是copy-on-write技术： •当主进程执行读操作时，访问共享内存； •当主进程执行写操作时，则会拷贝一份数据，执行写操作。 RDB方式bgsave的基本流程？ •fork主进程得到一个子进程，共享内存空间 •子进程读取内存数据并写入新的RDB文件 •用新RDB文件替换旧的RDB文件。 RDB会在什么时候执行？save 60 1000代表什么含义？ •默认是服务停止时。 •代表60秒内至少执行1000次修改则触发RDB RDB的缺点？ •RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险 •fork子进程、压缩、写出RDB文件都比较耗时 AOF持久化AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。 AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF： 1234# 是否开启AOF功能，默认是noappendonly yes# AOF文件的名称appendfilename \"appendonly.aof\" AOF的命令记录的频率也可以通过redis.conf文件来配： 123456# 表示每执行一次写命令，立即记录到AOF文件appendfsync always # 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案appendfsync everysec # 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘appendfsync no 配置项 刷盘时机 优点 缺点 Always 同步刷盘 可靠性高，几乎不丢数据 性能影响大 everysec 每秒刷盘 性能适中 最多丢失1秒数据 no 操作系统控制 性能最好 可靠性较差，可能丢失大量数据 通常采用everysec，折中方案，redis默认方案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# You can set these explicitly by uncommenting the three following lines.## save 3600 1# save 300 100# save 60 10000#禁用rdbsave \"\"appendonly yes9588:M 23 Oct 2021 20:10:24.820 # Server initialized9588:M 23 Oct 2021 20:10:24.820 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.9588:M 23 Oct 2021 20:10:24.821 * Ready to accept connections#启动时，没有读取备份文件127.0.0.1:6379&gt; keys *(empty array)[root@localhost redis-6.2.4]# cat appendonly.aof *2$6SELECT$10*3$3set$3num$3123^C9588:signal-handler (1635045279) Received SIGINT scheduling shutdown...9588:M 23 Oct 2021 20:14:39.899 # User requested shutdown...9588:M 23 Oct 2021 20:14:39.899 * Calling fsync() on the AOF file.9588:M 23 Oct 2021 20:14:39.899 * Removing the pid file.9588:M 23 Oct 2021 20:14:39.899 # Redis is now ready to exit, bye bye...9683:M 23 Oct 2021 20:15:07.154 # Server initialized9683:M 23 Oct 2021 20:15:07.154 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.9683:M 23 Oct 2021 20:15:07.154 * DB loaded from append only file: 0.000 seconds9683:M 23 Oct 2021 20:15:07.154 * Ready to accept connections127.0.0.1:6379&gt; set num 666OK[root@localhost redis-6.2.4]# cat appendonly.aof *2$6SELECT$10*3$3set$3num$3123*3$3set$4name$4jack*2$6SELECT$10*3$3set$3num$3 bgrewriteaof命令因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。 Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置： 1234# AOF文件比上次文件 增长超过多少百分比则触发重写auto-aof-rewrite-percentage 100# AOF文件体积最小多大以上才触发重写 auto-aof-rewrite-min-size 64mb 1234567891011127.0.0.1:6379&gt; BGREWRITEAOFBackground append only file rewriting started[root@localhost redis-6.2.4]# cat appendonly.aof REDIS0009 redis-ver6.2.4redis-bits󿿀򳨭eµϴused-memè*𮤭preamble󿾁þ⭵mZnamejackÿ¬Zح.k127.0.0.1:6379&gt; keys *1) \"name\"2) \"num\" RDB和AOF的优缺点RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。 RDB AOF 持久化方式 定时对整个内存做快照 记录每一次执行的命令 数据完整性 不完整，两次备份之间会丢失 相对完整，取决于刷盘策略 文件大小 会有压缩，文件体积小 记录命令，文件体积很大 宕机恢复速度 很快 慢 数据恢复优先级 低，因为数据完整性不如AOF 高，因为数据完整性更高 系统资源占用 高，大量CPU和内存消耗 低，主要是磁盘IO资源 但AOF重写时会占用大量CPU和内存资源 使用场景 可以容忍数分钟的数据丢失，追求更快的启动速度 对数据安全性要求较高常见 Redis主从Redis集群本章是基于CentOS7下的Redis集群教程，包括： 单机安装Redis Redis主从 Redis分片集群 1.单机安装Redis首先需要安装Redis所需要的依赖： 1yum install -y gcc tcl Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。 然后将课前资料提供的Redis安装包上传到虚拟机的任意目录： redis-6.2.4.tar.gz 例如，我放到了/tmp目录： 解压缩： 1tar -xvf redis-6.2.4.tar.gz 解压后： 进入redis目录： 1cd redis-6.2.4 运行编译命令： 1make &amp;&amp; make install 如果没有出错，应该就安装成功了。 然后修改redis.conf文件中的一些配置： 1234# 绑定地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问bind 0.0.0.0# 数据库数量，设置为1databases 1 启动Redis：（要制定配置文件） 1redis-server redis.conf 停止redis服务： 1redis-cli shutdown 测试是否开启成功 1234567[root@localhost ~]# redis-cli127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set num 123OK127.0.0.1:6379&gt; get num\"123\" 2.Redis主从集群2.1.集群结构我们搭建的主从集群结构如图： 共包含三个节点，一个主节点，两个从节点。 这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下： IP PORT 角色 192.168.150.101 7001 master 192.168.150.101 7002 slave 192.168.150.101 7003 slave 2.2.准备实例和配置要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。 1）创建目录 我们创建三个文件夹，名字分别叫7001、7002、7003： 1234# 进入/tmp目录cd /tmp# 创建目录mkdir 7001 7002 7003 如图： 2）恢复原始配置 修改redis-6.2.4/redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。 12345678# 开启RDB# save \"\"save 3600 1save 300 100save 60 10000# 关闭AOFappendonly no 3）拷贝配置文件到每个实例目录 然后将redis-6.2.4/redis.conf文件拷贝到三个目录中（在/tmp目录执行下列命令）： 123456# 方式一：逐个拷贝cp redis-6.2.4/redis.conf 7001cp redis-6.2.4/redis.conf 7002cp redis-6.2.4/redis.conf 7003# 方式二：管道组合命令，一键拷贝echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf 4）修改每个实例的端口、工作目录 修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在/tmp目录执行下列命令）： 123sed -i -e 's/6379/7001/g' -e 's/dir .\\//dir \\/tmp\\/7001\\//g' 7001/redis.confsed -i -e 's/6379/7002/g' -e 's/dir .\\//dir \\/tmp\\/7002\\//g' 7002/redis.confsed -i -e 's/6379/7003/g' -e 's/dir .\\//dir \\/tmp\\/7003\\//g' 7003/redis.conf 5）修改每个实例的声明IP 虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下： 12# redis实例的声明 IPreplica-announce-ip 192.168.150.101 每个目录都要改，我们一键完成修改（在/tmp目录执行下列命令）： 1234567# 逐一执行sed -i '1a replica-announce-ip 192.168.150.101' 7001/redis.confsed -i '1a replica-announce-ip 192.168.150.101' 7002/redis.confsed -i '1a replica-announce-ip 192.168.150.101' 7003/redis.conf# 或者一键修改printf '%s\\n' 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i '1a replica-announce-ip 192.168.150.101' &#123;&#125;/redis.conf 2.3.启动为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令： 123456# 第1个redis-server 7001/redis.conf# 第2个redis-server 7002/redis.conf# 第3个redis-server 7003/redis.conf 启动后： 如果要一键停止，可以运行下面命令： 1printf '%s\\n' 7001 7002 7003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown 2.4.开启主从关系现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。 有临时和永久两种模式： 修改配置文件（永久生效） 在redis.conf中添加一行配置： ```12345- 使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）： ```sh slaveof &lt;masterip&gt; &lt;masterport&gt; 注意：在5.0以后新增命令replicaof，与salveof效果一致。 这里我们为了演示方便，使用方式二。 通过redis-cli命令连接7002，执行下面命令： 1234# 连接 7002redis-cli -p 7002# 执行slaveofslaveof 192.168.150.101 7001 通过redis-cli命令连接7003，执行下面命令： 1234# 连接 7003redis-cli -p 7003# 执行slaveofslaveof 192.168.150.101 7001 然后连接 7001节点，查看集群状态： 1234# 连接 7001redis-cli -p 7001# 查看状态info replication 结果： 2.5.测试执行下列操作以测试： 利用redis-cli连接7001，执行num 123```12- 利用redis-cli连接7002，执行```get num```，再执行```set num 666 利用redis-cli连接7003，执行num```，再执行```set num 888```12345678910111213141516171819202122232425262728293031323334353637383940可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。## 3.搭建哨兵集群### 3.1.集群结构这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：![image-20210701215227018](assets/image-20210701215227018.png)三个sentinel实例信息如下：| 节点 | IP | PORT || ---- | :-------------: | :---: || s1 | 192.168.150.101 | 27001 || s2 | 192.168.150.101 | 27002 || s3 | 192.168.150.101 | 27003 |### 3.2.准备实例和配置要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。我们创建三个文件夹，名字分别叫s1、s2、s3：```sh# 进入/tmp目录cd /tmp# 创建目录mkdir s1 s2 s3 如图： 然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容： 123456port 27001sentinel announce-ip 192.168.150.101sentinel monitor mymaster 192.168.150.101 7001 2sentinel down-after-milliseconds mymaster 5000sentinel failover-timeout mymaster 60000dir \"/tmp/s1\" 解读： port 27001：是当前sentinel实例的端口 sentinel monitor mymaster 192.168.150.101 7001 2：指定主节点信息 mymaster：主节点名称，自定义，任意写 192.168.150.101 7001：主节点的ip和端口 2：选举master时的quorum值 然后将s1/sentinel.conf文件拷贝到s2、s3两个目录中（在/tmp目录执行下列命令）： 12345# 方式一：逐个拷贝cp s1/sentinel.conf s2cp s1/sentinel.conf s3# 方式二：管道组合命令，一键拷贝echo s2 s3 | xargs -t -n 1 cp s1/sentinel.conf 修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003： 12sed -i -e 's/27001/27002/g' -e 's/s1/s2/g' s2/sentinel.confsed -i -e 's/27001/27003/g' -e 's/s1/s3/g' s3/sentinel.conf 3.3.启动为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令： 123456# 第1个redis-sentinel s1/sentinel.conf# 第2个redis-sentinel s2/sentinel.conf# 第3个redis-sentinel s3/sentinel.conf 启动后： 3.4.测试尝试让master节点7001宕机，查看sentinel日志： 查看7003的日志： 查看7002的日志： 4.搭建分片集群4.1.集群结构分片集群需要的节点数量较多，这里我们搭建一个最小的分片集群，包含3个master节点，每个master包含一个slave节点，结构如下： 这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下： IP PORT 角色 192.168.150.101 7001 master 192.168.150.101 7002 master 192.168.150.101 7003 master 192.168.150.101 8001 slave 192.168.150.101 8002 slave 192.168.150.101 8003 slave 4.2.准备实例和配置删除之前的7001、7002、7003这几个目录，重新创建出7001、7002、7003、8001、8002、8003目录： 123456# 进入/tmp目录cd /tmp# 删除旧的，避免配置干扰rm -rf 7001 7002 7003# 创建目录mkdir 7001 7002 7003 8001 8002 8003 在/tmp下准备一个新的redis.conf文件，内容如下： 123456789101112131415161718192021port 6379# 开启集群功能cluster-enabled yes# 集群的配置文件名称，不需要我们创建，由redis自己维护cluster-config-file /tmp/6379/nodes.conf# 节点心跳失败的超时时间cluster-node-timeout 5000# 持久化文件存放目录dir /tmp/6379# 绑定地址bind 0.0.0.0# 让redis后台运行daemonize yes# 注册的实例ipreplica-announce-ip 192.168.150.101# 保护模式protected-mode no# 数据库数量databases 1# 日志logfile /tmp/6379/run.log 将这个文件拷贝到每个目录下： 1234# 进入/tmp目录cd /tmp# 执行拷贝echo 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 cp redis.conf 修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致： 1234# 进入/tmp目录cd /tmp# 修改配置文件printf '%s\\n' 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i 's/6379/&#123;&#125;/g' &#123;&#125;/redis.conf 4.3.启动因为已经配置了后台启动模式，所以可以直接启动服务： 1234# 进入/tmp目录cd /tmp# 一键启动所有服务printf '%s\\n' 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf 通过ps查看状态： 1ps -ef | grep redis 发现服务都已经正常启动： 如果要关闭所有进程，可以执行命令： 1ps -ef | grep redis | awk '&#123;print $2&#125;' | xargs kill 或者（推荐这种方式）： 1printf '%s\\n' 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown 4.4.创建集群虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。 我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。 1）Redis5.0之前 Redis5.0之前集群命令都是用redis安装包下的src/redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。 123# 安装依赖yum -y install zlib ruby rubygemsgem install redis 然后通过命令来管理集群： 1234# 进入redis的src目录cd /tmp/redis-6.2.4/src# 创建集群./redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003 2）Redis5.0以后 我们使用的是Redis6.2.4版本，集群管理以及集成到了redis-cli中，格式如下： 1redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003 命令说明： redis-cli --cluster或者./redis-trib.rb：代表集群操作命令 create：代表是创建集群 --replicas 1或者--cluster-replicas 1 ：指定集群中每个master的副本个数为1，此时节点总数 ÷ (replicas + 1) 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master 运行后的样子： 这里输入yes，则集群开始创建： 通过命令可以查看集群状态： 1redis-cli -p 7001 cluster nodes 4.5.测试尝试连接7001节点，存储一个数据： 12345678# 连接redis-cli -p 7001# 存储数据set num 123# 读取数据get num# 再次存储set a 1 结果悲剧了： 集群操作时，需要给redis-cli加上-c参数才可以： 1redis-cli -c -p 7001 这次可以了：","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://codeofli.github.io/tags/Redis/"}]},{"title":"ssm-crud","slug":"java-note/ssm-crud/ssm-crud","date":"2019-10-21T07:25:49.000Z","updated":"2021-10-23T02:19:04.206Z","comments":true,"path":"2019/10/java-note/ssm-crud/ssm-crud/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/ssm-crud/ssm-crud/","excerpt":"[TOC]web路径 web路径： 1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题 2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名; 就是http//localhost/端口号/crud/…12345&lt;% pageContext.setAttribute(\"WEB_PATH\", request.getContextPath());%&gt; $&#123;WEB_PATH&#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css --&gt;","text":"[TOC]web路径 web路径： 1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题 2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名; 就是http//localhost/端口号/crud/…12345&lt;% pageContext.setAttribute(\"WEB_PATH\", request.getContextPath());%&gt; $&#123;WEB_PATH&#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css --&gt; 注：pageContext.setAttribute需要jsp_api.jar maven配置文件D:\\apache-maven-3.6.1\\conf\\settings.xml 设置镜像阿里mirrors 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 配置maven的jdk 12345678910111213&lt;profile&gt; &lt;id&gt;jdk18&lt;/id&gt; &lt;activation&gt; &lt;activaByDefault&gt;true&lt;/activaByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; maven使用spring单元测试test写在src/test/mapper/目录下 推荐Spring的项目就可以使用spring的单元测试，可以依赖注入我们需要的组件 1.导入springTest模块(meven导包) 2.@ContextConfiguration指定spring配置文件内容,@RunWith(SpringJUnit4ClassRunner.class) 3.直接autoWrited要使用的组件即可 1234567** * 测试dao工作层 * @author test */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:applicationContext.xml\"&#125;)public class MapperTest &#123; mybatis不在同一目录下如果需要mapper和mapper.xml文件不在一个文件夹里还能映射成功的话，需要在spring配置文件中，分别将mapper和mapper.xml的包添加扫描； 1234567891011121314151617&lt;!-- ============配置和mybatis的整合============== --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;property name=\"dataSource\" ref=\"pooledDataSource\"&gt;&lt;/property&gt; &lt;!-- 指定mybatis的mapper文件位置 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置扫描器，将mapper接口实现加入ioc容器 --&gt; &lt;!-- 批量生成mapper代理对象 批量产生的mapper对象在SpringIOC容器中的id值默认就是接口mapper名(首字母小写） --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.atguigu.crud.dao\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; maven中classpath路径在Maven工程中，classpath的路径指java resources路径下的目录，即 src/main/java、 src/main/resource、src/test/java 、src/test/resource 四个目录 所以在配置路径时需要注意文件名是否重名，导致加载文件失败 数据校验jsr303数据校验12345678910&lt;!--jsr303数据检验支持 （Hibernate Validator Engine Relocation Artifact） --&gt; &lt;!-- jrs303数据校验支持：tomcat7以上的服务器，tomcat7以下的服务器：el表达式，不是最新的。额外给服务器的lib包中替换新的标准的el--&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt;&lt;/dependency&gt; JSR303Hibernate Validator JSR 303提供的标准注解如表所示。 注解 简介 @Null 被注释的元素必须为 null。 @NotNull 被注释的元素必须不为 null。 @AssertTrue 被注释的元素必须为 true。 @AssertFalse 被注释的元素必须为 false。 @Min(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @Max(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @Size(max, min) 被注释的元素的取值范围必须是介于min和max之间。 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内。 @Past 被注释的元素必须是一个过去的日期。 @Future 被注释的元素必须是一个将来的日期。 @Pattern(value) 被注释的元素必须符合指定的正则表达式。 表JSR 303注解 Hibernate Validator 是JSR 303的扩展。Hibernate Validator 提供了 JSR 303中所有内置的注解，以及自身扩展的4个注解，如表所示。 注解 简介 @Email 被注释的元素值必须是合法的电子邮箱地址。 @Length 被注释的字符串的长度必须在指定的范围内。 @NotEmpty 被注释的字符串的必须非空。 @Range 被注释的元素必须在合适的范围内。 表 Hibernate Validator扩展注解 使用Hibernate Validator步骤： a.jar（注意各个jar之间可能存在版本不兼容）hibernate-validator-5.0.0.CR2.jar classmate-0.8.0.jar jboss-logging-3.1.1.GA.jarvalidation-api-1.1.0.CR1.jar hibernate-validator-annotation-processor-5.0.0.CR2.jar b配置 1&lt;mvc:annotation-driven &gt;&lt;/mvc:annotation-driven&gt; 此时mvc:annotation-driven的作用：要实现Hibernate Validator/JSR303 校验（或者其他各种校验），必须实现SpringMVC提供的一个接口：ValidatorFactory LocalValidatorFactoryBean是ValidatorFactory的一个实现类。&lt;mvc:annotation-driven &gt;会在springmvc容器中 自动加载一个LocalValidatorFactoryBean类，因此可以直接实现数据校验。 c.直接使用注解 12345678public class Student &#123;```@Past//当前时间以前private Date birthday ;```&#125; 在校验的Controller中 ，给校验的对象前增加 @Valid 12public String testDateTimeFormat(@Valid Student student, BindingResult result ,Map&lt;String,Object&gt; map) &#123; &#123;...&#125; mybatis分页插件PageHleper1234567891011121314151617181920212223/** * 导入jackson包 * * @author lmz * @date 2019年7月15日-上午8:59:36 * @param pageNumber * @return */ @RequestMapping(\"/emps\") @ResponseBody // 告诉SpringMVC，此时的返回 不是一个 View页面，而是一个 ajax调用的返回值（Json数组） public Msg getEmpsWithJson(@RequestParam(value = \"pageNumber\", defaultValue = \"1\") Integer pageNumber) &#123; // 引入分页插件PageHleper // 在查询之前调用即可 PageHelper.startPage(pageNumber, 5); // startPage之后紧跟着的查询就是分页查询 List&lt;Employee&gt; emps = employeeService.getAll(); // 用PageInfo对结果进行包装 // 将pagaInfo交给页面就可以了，封装了详细的分页信息，包括有我们的查询数据 // 传入连续显示的页数 PageInfo&lt;Employee&gt; page = new PageInfo&lt;Employee&gt;(emps, 5); return Msg.success().add(\"pageInfo\", page); &#125; 在mybatis中配置合理化参数，超过页数，返回最后一页 12345678910&lt;configuration&gt; &lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;!-- 分页参数合理化 --&gt; &lt;property name=\"reasonable\" value=\"true\" /&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; sprigMVC自带HttpputFormContentFilter12345678910111213141516171819/** * 解决方案 * 要能支持直接发送PUT之类的请求，还要封装请求体中的数据 * 1、配置上HttpputFormContentFilter； * 2、作用：将请求体中的数据解析包装成一个map。 * 3、request被重新包装，request.getParameter()被重写，就会从自己封装的map中取数据 * 员工更新方法 * @param employee * @return */@PutMapping(\"/emp/&#123;empId&#125;\")@ResponseBodypublic Msg saveEmp(Employee employee,HttpServletRequest request)&#123; System.out.println(\"requestScope中的值：\"+request.getParameter(\"email\")); System.out.println(employee); employeeService.updateEmp(employee); return Msg.success();&#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"ssm","slug":"ssm","permalink":"https://codeofli.github.io/tags/ssm/"}]},{"title":"springMvc","slug":"java-note/springMvc/springMvc","date":"2019-10-20T07:24:32.000Z","updated":"2021-10-23T02:19:04.204Z","comments":true,"path":"2019/10/java-note/springMvc/springMvc/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/springMvc/springMvc/","excerpt":"[TOC]springmvc:1.jarspring-aop.jarspring-bean.jarspring-context.jarspring-core.jarspring-web.jarspring-webmvc.jarcommons-logging.jar报错NoClassDefFoundError：缺少jar","text":"[TOC]springmvc:1.jarspring-aop.jarspring-bean.jarspring-context.jarspring-core.jarspring-web.jarspring-webmvc.jarcommons-logging.jar报错NoClassDefFoundError：缺少jar 2.第一个SpringMVC程序Servet - Springmvcjsp -&gt;Servlet (Springmvc)-&gt;Jsp url springmvc配置文件 springmvc.xml选中常用的命名空间：beans aop context mvc 普通的servlet流程：请求-url-pattern -交给对应的servlet去处理 如果现在想用springmvc，而不是普通的servlet，如何告知程序？-如何让springmvc 介入程序：需要配置一个 Springmvc自带的servlet 通过以下配置，拦截所有请求，交给SpringMVC处理： 1234567891011121314 &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 其中：.action /:一切请求 ，注意不是 /*/user:拦截以 /user开头的请求/user/abc.do :只拦截该请求.action:只拦截 .action结尾的请求 项目中同时兼容 springMVC和Servlet 1234567891011121314&lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 通过 1234&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; 123456&lt;context:component-scan base-package=\"pers.nicolas.handler\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器(InternalResourceViewResolver) --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/views/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; 指定springmvc配置文件的路径，如果要省略，必须放到 默认路径：/WEB-INF/（web.xml配置中）servetname的值-servlet.xml 可以提示工具自动生成alt+/ ,选 映射是 去匹配@RequestMapping注解可以和方法名、类名不一致通过method指定 请求方式（get post delete put） @RequestMapping(value=”welcome”,method=RequestMethod.POST)//映射 设置name=”xxxx”的情况：params= {“name2=zs”,”age!=23”} name2:必须有name=”name2”参数 age!=23 : a.如果有name=”age”，则age值不能是23 b.没有age!name2 ：不能name=”name2”的属性 ant风格的请求路径? 单字符 任意个字符（0或多个） 任意目录 @RequestMapping(value=”welcome3/**/test”)接受示例： a href=”welcome3/abc/xyz/abccc/test” … 通过@PathVariable获取动态参数**12345@RequestMapping(value = \"welcome5/&#123;name&#125;\")public String welcome5(@PathVariable(\"name\") String name ) &#123; System.out.println(name); return \"success\" ;&#125; 1234567891011121314151617181920212223//接口/类、注解、配置@Controller@RequestMapping(\"handler\") // 映射public class SpringMVCHandler &#123; @RequestMapping(value = \"welcome\", method = RequestMethod.POST, params = &#123; \"name=zs\", \"age!=23\", \"!height\" &#125;) // 映射 public String welcome() &#123; return \"success\"; // /views/success.jsp &#125; @RequestMapping(value = \"welcome2\", headers = &#123; \"Accept=text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Encoding=gzip, deflate\" &#125;) // 映射 public String welcome2() &#123; return \"success\"; // /views/success.jsp &#125; @RequestMapping(value = \"welcome3/**/test\") public String welcome3() &#123; return \"success\"; // /views/success.jsp &#125;@RequestMapping(value = \"welcome4/&#123;name&#125;\") // 映射public String welcome4(@PathVariable(\"name\") String name) &#123; System.out.println(name); return \"success\"; // /views/success.jsp &#125;&#125; 请求方式和获取参数REST风格 ：软件编程风格 Springmvc:GET :查POST ：增DELETE ：删PUT ：改 普通浏览器 只支持get post方式 ；其他请求方式 如 delelte|put请求是通过 过滤器新加入的支持。 springmvc实现 ：put|post请求方式的步骤a.增加过滤器 123456789&lt;!-- 增加HiddenHttpMethodFilte过滤器：目的是给普通浏览器 增加 put|delete请求方式 --&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilte&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilte&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; b.表单 1234&lt;form action=\"handler/testRest/1234\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"DELETE\"/&gt; &lt;input type=\"submit\" value=\"删\"&gt;&lt;/form&gt; i:必须是post方式ii:通过隐藏域 的value值 设置实际的请求方式 DELETE|PUT c.控制器 123456@RequestMapping(value=\"testRest/&#123;id&#125;\",method=RequestMethod.DELETE)public String testDelete(@PathVariable(\"id\") Integer id) &#123; System.out.println(\"delete：删 \" +id); //Service层实现 真正的增 return \"success\" ;//默认使用了请求转发的跳转方式&#125; 通过 method=RequestMethod.DELETE 匹配具体的请求方式 此外，可以发现 ，当映射名相同时@RequestMapping(value=”testRest)，可以通过method处理不同的请求。 过滤器中 处理put|delete请求的部分源码： 1234567891011protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;HttpServletRequest requestToUse = request; if (\"POST\".equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) &#123; String paramValue = request.getParameter(this.methodParam); if (StringUtils.hasLength(paramValue)) &#123; requestToUse = new HttpMethodRequestWrapper(request, paramValue); &#125; &#125; filterChain.doFilter(requestToUse, response);&#125; 原始请求：request，改请求默认只支持get post header但是如果 是”POST” 并且有隐藏域 则，过滤器 将原始的请求 request加入新的请求方式DELETE，并将原始请求 转为 requestToUse 请求（request+Delete请求）最后将requestToUse 放入 请求链中， 后续再事情request时 实际就使用改造后的 requestToUse 获取参数方法2@RequestParam(“uname”) String name,@RequestParam(value=”uage”,required=false,defaultValue=”23”) @RequestParam(“uname”):接受前台传递的值，等价于request.getParameter(“uname”); required=false:该属性 不是必须的。defaultValue=”23”：默认值23 获取请求头信息 @RequestHeaderpublic String testRequestHeader(@RequestHeader(“Accept-Language”) String al ) { 通过@RequestHeader(“Accept-Language”) String al 获取请求头中的Accept-Language值，并将值保存再al变量中 通过mvc获取cookie值（JSESSIONID）@CookieValue(前置知识： 服务端在接受客户端第一次请求时，会给该客户端分配一个session （该session包含一个sessionId）),并且服务端会在第一次响应客户端时 ，请该sessionId赋值给JSESSIONID 并传递给客户端的cookie中 小结： SpringMVC处理各种参数的流程/逻辑：请求： 前端发请求a-&gt; @RequestMappting(“a”)处理请求中的参数xyz： @RequestMappting(“a”) public String aa(@Xxx注解(“xyz”) xyz) { }使用对象（实体类Student）接受请求参数12345 @RequestMapping(value = \"testObjectProperties\") // 映射public String testObjectProperties(Student student) &#123; //student属性必须和from表单中的属性name值一致（支持级联属性） System.out.println(student); return \"success\"; &#125; 1234567&lt;form action=\"handler/testObjectProperties\" method=\"post\"&gt; id:&lt;input type=\"text\" name=\"id\"&gt;&lt;br/&gt; name:&lt;input type=\"text\" name=\"name\"&gt;&lt;br/&gt; homeAddress:&lt;input type=\"text\" name=\"address.homeAddress\"&gt;&lt;br/&gt; schoolAddress:&lt;input type=\"text\" name=\"address.schoolAddress\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"submit\"&gt;&lt;br/&gt;&lt;/form&gt; 在SpringMVC中使用原生态的Servlet APIHttpServletRequest ：直接将 servlet-api中的类、接口等 写在springMVC所映射的方法参数中即可： 12345@RequestMapping(value=\"testServletAPI\")public String testServletAPI(HttpServletRequest request,HttpServletResponse response) &#123; System.out.println(request); return \"success\" ;&#125; 1.处理模型数据如果跳转时需要带数据：V、M,则可以使用以下方式：ModelAndView、ModelMap 、Map(java.tuil.map)、Model -数据放在了request作用域 @SessionAttributes、@ModelAttribute 示例：public String testModel(Model model| Map&lt;String,Object&gt; m) { m.put(x,”..”); 就会将x对象 放入request域中 1234567891011121314151617@RequestMapping(value = \"testModelAndView\")public ModelAndView testModelAndView() &#123; // ModelAndView:既有数据，又有视图 ModelAndView mv = new ModelAndView(\"success\"); Student student = new Student(); student.setId(3); student.setName(\"zs\"); mv.addObject(\"student\", student); // 相当于request.setAtrribute(); return mv;&#125;@RequestMapping(value = \"testModelMap\") // 映射public String testModelMap(ModelMap mm) &#123; Student student1 = new Student(); student1.setId(3); student1.setName(\"zs\"); mm.put(\"student1\", student1); // request域 return \"success\"; // view&#125; 如何将上述数据放入session中？@SessionAttributes(..)在类上声明 1@SessionAttributes(value = &#123;\"student3\",\"student2\"&#125;) //如果在request域中存放studen3,student2对象，则同时放在session域中 1@SessionAttributes(types =&#123;Student.class,Address.class&#125;) //如果在request域中存放student,address类的对象，则同时放在session域中 @ModelAttributei.经常在 更新时使用ii.在不改变原有代码的基础之上，插入一个新方法。 通过@ModelAttribute修饰的方法 ，会在每次请求前先执行；并且该方法的参数map.put()可以将 对象 放入 即将查询的参数中；必须满足的约定：map.put(k,v) 其中的k 必须是即将查询的方法参数 的首字母小写testModelAttribute(Student xxx) ，即student；如果不一致，需要通过@ModelAttribute声明。如下： 1234567891011121314151617@ModelAttribute//在任何一次请求前，都会先执行@ModelAttribute修饰的方法// 在请求该类的每个方法前均会被调用的设计是基于一个思想：一个控制器一个功能public void queryStudentById(Map&lt;String,Object&gt; map) &#123; //模拟调用三层查询数据库的操作 Student student = new Student(); student.setId(31); student.setName(\"zs\"); student.setAge(23); map.put(\"stu\", student) ;//约定：map的key 就是方法参数 类型的首字母小写&#125;//修改:Zs-ls@RequestMapping(value=\"testModelAttribute\")public String testModelAttribute(@ModelAttribute(\"stu\")Student student) &#123; student.setName(student.getName());//将名字修改为ls System.out.println(student.getId()+\",\"+student.getName()+\",\"+student.getAge()); return \"success\";&#125; 一个Servlet 对应一个功能：增删改查 对应于 4个Servlet 更新： Servlet - SpringMVC的Controller 查询@ModelAttributepublic void query(){ } 修改public String update(){ } @ModelAttribute会在 该类的每个方法执行前 均被执行一次，因为使用时需要注意。 2.视图、视图解析器视图的顶级接口:View视图解析器：ViewResolver 常见的视图和解析器：InternalResourceView、InternalResourceViewResolver public class JstlView extends InternalResourceView： springMVC解析jsp时 会默认使用InternalResourceView，如果发现Jsp中包含了jstl语言相关的内容，则自动转为JstlView。 JstlView 可以解析jstl\\实现国际化操作 国际化： 针对不同地区、不同国家 ，进行不同的显示 中国:（大陆、香港） 欢迎美国： welcome i18n_zh_CN.propertiesresource.welcome=你好resource.exit=退出 i18n.properties 具体实现国际化步骤：a.创建资源文件基名_语言_地区.properties基名_语言.properties 常见的资源文件命名 资源文件名 简介 基名_en.properties 所有英文语言的资源 基名_en_US.properties 针对美国地区、英文语言的资源 基名_zh.properties 所有的中文语言的资源 基名_zh_CN.properties 针对中国大陆的、中文语言的资源 基名_zh_HK.properties 针对中国香港的、中文语言的资源 基名.properties 默认资源文件。如果请求相应语言的资源文件不存在，将使用此资源文件。例如，若是中国大陆地区用户，应该访问“基名_zh_CN.properties”，而如果不存在此文件，就会去访问默认的“基名.properties”。 b.配置springmvc.xml，加载资源文件 12345&lt;!-- 加载国际化资源文件 1.将ResourceBundleMessageSource在程序加载时 加入springmvc： springmvc在启动时，会自动查找一个叫messageSource的bean，如果有则自动加载 2.如果配置了ResourceBundleMessageSource，程序会在响应时介入 --&gt;&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt; &lt;property name=\"basename\" value=\"i18n\"&gt;&lt;/property&gt;&lt;/bean&gt; ResourceBundleMessageSource会在springmvc响应程序时 介入（解析国际化资源文件） c.通过jstl使用国际化 jstl.jar standar.jar springmvc在启动时，会自动查找一个id=”messageSource”的bean，如果有 则自动加载 InternalResourceViewResolver其他功能：1.&lt;mvc:view-controller …&gt;index.jsp -&gt; Controller(@RequsetMapping(“a”)) -&gt;succes.jsp 要用SpringMVC实现：index.jsp -&gt; succes.jsp ： 12&lt;!-- view-name也会被视图解析器添加前缀和后缀 --&gt;&lt;mvc:view-controller path=\"testMvcViewController\" view-name=\"success\"/&gt; 以上注解 ，会让所有的请求 转入mvc:..中匹配映射地址，而会忽略调@RequsetMapping()；如果想让 @RequsetMapping(“a”) 和mvc:..共存，则需要加入一个注解：&lt;1234```xml&lt;!--此配置是springmvc的基础配置，很多功能都需要该注解来调整 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 2.指定请求方式指定跳转方式：return “forward:/views/success.jsp”; forward(请求转发): redirect（重定向）: ，需要注意 此种方式，不会被视图解析器加上前缀(/views)、后缀(.jsp) 3.处理静态资源：html css js 图片 视频可以与用户交互、因为时间/地点的不同 而结果不同的内容：动态（百度：天气 ） 在SpringMVC中，如果直接访问静态资源：404 。原因：之前将所有的请求 通过通配符“/” 拦截，进而交给 SPringMVC的入口DispatcherServlet去处理：找该请求映射对应的 @requestMapping http://localhost:8888/SpringMVCProject/img.png @RequsetMapping(“img.png”)return sucess 解决：如果是 需要mvc处理的，则交给@RequsetMapping(“img.png”)处理；如果不需要springmvc处理，则使用 tomcat默认的Servlet去处理。tomcat默认的Servlet去处理：如果有 对应的请求拦截,则交给相应的Servlet去处理；如果没有对应的servlet，则直接访问。tomcat默认的Servlet在哪里？在tomcat配置文件\\conf\\web.xml中 &lt;servlet&gt; &lt;servlet-name&gt;abc&lt;/servlet-name&gt; &lt;servlet-class&gt;xxx.xxx.xx.ABCServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;abc&lt;/servlet-name&gt; &lt;url-pattern&gt;/abc&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;解决静态资源方案：如果有springmvc对应的@requestMapping则交给spring处理；如果没有对应@requestMapping,则交给服务器tomcat默认的servlet去处理 ：实现方法，只需要增加2个注解即可 springmvc.xml： 1234&lt;!-- 该注解会让springmvc在接受请求没有对应映射时，将该请求交给服务器默认的servlet处理(直接访问) --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--此配置是springmvc的基础配置，很多功能都需要该注解来调整 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 总结：要让springmvc访问静态资源，只需要加入以下2个注解： 1234&lt;!-- 该注解会让springmvc在接受请求没有对应映射时，将该请求交给服务器默认的servlet处理(直接访问) --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--此配置是springmvc的基础配置，很多功能都需要该注解来调整 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 4.类型转换a.Spring自带一些 常见的类型转换器：public String testDelete(@PathVariable(“id”) String id) ，即可以接受int类型数据id 也可以接受String类型的id b.可以自定义类型转换器i.编写 自定义类型转器的类 （实现Converter接口） 123456789101112public class MyConverter implements Converter&lt;String,Student&gt;&#123;@Override public Student convert(String source) &#123;//source:2-zs-23 //source接受前端传来的String:2-zs-23 String[] studentStrArr = source.split(\"-\") ; Student student = new Student(); student.setId( Integer.parseInt( studentStrArr[0]) ); student.setName(studentStrArr[1]); student.setAge(Integer.parseInt(studentStrArr[2] )); return student; &#125;&#125; ii.配置：将MyConverter加入到springmvc中 1234567891011121314&lt;!-- 1将 自定义转换器 纳入SpringIOC容器 --&gt; &lt;bean id=\"myConverter\" class=\"org.lanqiao.converter.MyConverter\"&gt;&lt;/bean&gt;&lt;!-- 2将myConverter再纳入 SpringMVC提供的转换器Bean --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;ref bean=\"myConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 3将conversionService注册到annotation-driven中 --&gt;&lt;!--此配置是SpringMVC的基础配置，很功能都需要通过该注解来协调 --&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\"&gt;&lt;/mvc:annotation-driven&gt; 测试转换器： 1234@RequestMapping(value=\"testConverter\")public String testConverter(@RequestParam(\"studentInfo\") Student student) &#123;// 前端：2-zs-23 System.out.println(student.getId()+\",\"+student.getName()+\",\"+student.getAge()); return \"success\"; &#125; 其中@RequestParam(“studentInfo”)是触发转换器的桥梁：@RequestParam(“studentInfo”)接受的数据 是前端传递过来的：2-zs-23 ，但是 需要将该数据 复制给 修饰的目的对象Student；因此SPringMVC可以发现 接收的数据 和目标数据不一致，并且 这两种数据分别是 String、Student,正好符合public Student convert(String source)转换器。 5.数据格式化​ SimpleDateForamt sdf = new SimpleDateFormat(“yyyy-MM-dd hh:mm:ss”);SPringMVC提供了很多注解，方便我们数据格式化实现步骤：a.配置 123456789&lt;!-- 配置数据格式化注解所依赖的beanFormattingConversionServiceFactoryBean既能实现数据日期格式化，又能实现类型转换 --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\" &gt; &lt;set&gt; &lt;ref bean=\"myConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; b.通过注解使用 12@DateTimeFormat(pattern = \"yyyy-MM-dd\") //接受前台传来的数据，转换为日期private Date birthday;//相应实体bean的属性 1234567891011@RequestMapping(value=\"testDateTimeStringFormat\")//如果student的格式化错误，会将错误转入BindingResult中public String testDateTimeStringFormat(Student student,BindingResult result) &#123; System.out.println(student); if(result.getErrorCount() &gt; 0) &#123; for (FieldError error : result.getFieldErrors()) &#123; System.out.println(error.getDefaultMessage()); &#125; &#125; return \"success\";&#125; @NumberFormat(parttern=”###,#”) 1.错误消息：public String testDateTimeFormat(Student student, BindingResult result ,Map&lt;String,Object&gt; map) {需要验证的数据是 Student中的birthday, SPringMVC要求 如果校验失败 则将错误信息自动放入该对象之后紧挨着的 BindingResult中。即Student student, BindingResult result之间 不能有其他参数。 如果要将控制台的错误消息 传到jsp中显示，则可以将 错误消息对象放入request域中，然后 在jsp中 从request中获取。 2.数据校验JSR303Hibernate Validator JSR 303提供的标准注解如表所示。 注解 简介 @Null 被注释的元素必须为 null。 @NotNull 被注释的元素必须不为 null。 @AssertTrue 被注释的元素必须为 true。 @AssertFalse 被注释的元素必须为 false。 @Min(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @Max(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @Size(max, min) 被注释的元素的取值范围必须是介于min和max之间。 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内。 @Past 被注释的元素必须是一个过去的日期。 @Future 被注释的元素必须是一个将来的日期。 @Pattern(value) 被注释的元素必须符合指定的正则表达式。 表JSR 303注解 Hibernate Validator 是JSR 303的扩展。Hibernate Validator 提供了 JSR 303中所有内置的注解，以及自身扩展的4个注解，如表所示。 注解 简介 @Email 被注释的元素值必须是合法的电子邮箱地址。 @Length 被注释的字符串的长度必须在指定的范围内。 @NotEmpty 被注释的字符串的必须非空。 @Range 被注释的元素必须在合适的范围内。 表 Hibernate Validator扩展注解 使用Hibernate Validator步骤： a.jar（注意各个jar之间可能存在版本不兼容）hibernate-validator-5.0.0.CR2.jar classmate-0.8.0.jar jboss-logging-3.1.1.GA.jarvalidation-api-1.1.0.CR1.jar hibernate-validator-annotation-processor-5.0.0.CR2.jar b配置 1&lt;mvc:annotation-driven &gt;&lt;/mvc:annotation-driven&gt; 此时mvc:annotation-driven的作用：要实现Hibernate Validator/JSR303 校验（或者其他各种校验），必须实现SpringMVC提供的一个接口：ValidatorFactory LocalValidatorFactoryBean是ValidatorFactory的一个实现类。&lt;mvc:annotation-driven &gt;会在springmvc容器中 自动加载一个LocalValidatorFactoryBean类，因此可以直接实现数据校验。 c.直接使用注解 123public class Student &#123;​ @Past//当前时间以前private Date birthday ;​12&#125; ​ 在校验的Controller中 ，给校验的对象前增加 @Valid 12public String testDateTimeFormat(@Valid Student student, BindingResult result ,Map&lt;String,Object&gt; map) &#123; &#123;...&#125; 3.Ajax请求SpringMVC，并且JSON格式的数据a.jarjackson-annotations-2.8.9.jarjackson-core-2.8.9.jarjackson-databind-2.8.9.jar b。@ResponseBod修饰的方法，会将该方法的返回值 以一个json数组的形式返回给前台 ​ 123456789101112131415@ResponseBody//告诉SpringMVC，此时的返回 不是一个 View页面，而是一个 ajax调用的返回值（Json数组） @RequestMapping(value=\"testJson\") public List&lt;Student&gt; testJson() &#123; //Controller-Service-dao //StudentService studentService = new StudentServiceImp();// List&lt;Student&gt; students = studentService.qeuryAllStudent(); //模拟调用service的查询操作... List&lt;Student&gt; students = new ArrayList&lt;&gt;(); students.add(stu1) ; students.add(stu2) ; students.add(stu3) ; return students; &#125; 前台：服务端将返回值结果 以json数组的形式 传给了result。 1234567891011$(\"#testJson\").click(function()&#123; //通过ajax请求springmvc $.post( \"handler/testJson\",//服务器地址 //&#123;\"name\":\"zs\",\"age\":23&#125; function(result)&#123;//服务端处理完毕后的回调函数 List&lt;Student&gt; students， 加上@ResponseBody后， students实质是一个json数组的格式 for(var i=0;i&lt;result.length ;i++)&#123; alert(result[i].id +\"-\"+result[i].name +\"-\"+result[i].age); &#125; &#125; ); 1.SpringMVC实现文件上传：和Servlet方式的本质一样，都是通过commons-fileupload.jar和commons-io.jarSpringMVC可以简化文件上传的代码，但是必须满足条件：实现MultipartResolver接口 ；而该接口的实现类SpringMVC也已经提供了CommonsMultipartResolver 具体步骤：（直接使用CommonsMultipartResolver实现上传）a.jar包commons-fileupload.jar、commons-io.jarb.配置CommonsMultipartResolver将其加入SpringIOC容器 12345678&lt;!-- 配置CommonsMultipartResolver,用于实现文件上传 springIoc容器在初始化时，会自动Id=\"multipartResolver\"的bean，并自动加入容器中 --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"&gt;&lt;/property&gt; &lt;!-- 上传单个文件的最大值，单位Byte;如果-1，表示无限制 --&gt; &lt;property name=\"maxUploadSize\" value=\"102400\"&gt;&lt;/property&gt;&lt;/bean&gt; c.处理方法 12345678910111213141516171819//文件上传处理方法@RequestMapping(value=\"testUpload\") //abc.pngpublic String testUpload(@RequestParam(\"desc\") String desc , @RequestParam(\"file\") MultipartFile file ) throws IOException &#123; System.out.println(\"文件描述信息：\"+desc); //jsp中上传的文件：file InputStream input = file.getInputStream() ;//IO String fileName = file.getOriginalFilename() ; OutputStream out = new FileOutputStream(\"d:\\\\\"+fileName) ; byte[] bs = new byte[1024]; int len = -1; while(( len = input.read(bs)) !=-1 ) &#123; out.write(bs, 0, len); &#125; out.close(); input.close(); //将file上传到服务器中的 某一个硬盘文件中 System.out.println(\"上传成功！\"); return \"success\";&#125; 123456&lt;!-- enctype=\"mulipart/form-data\"告诉浏览器我是要上传文件不是普通的请求 --&gt;&lt;form action=\"handler/testUpload\" method=\"post\" enctype=\"mulipart/form-data\"&gt; describe:&lt;input type=\"text\" name=\"desc\"&gt;&lt;br /&gt; file:&lt;input type=\"file\" name=\"file\"&gt;&lt;br /&gt; &lt;input type=\"submit\" value=\"upload\"&gt;&lt;br /&gt;&lt;/form&gt; 框架： 将原来自己写的1000行代码，变成：框架帮你写900行，剩下100行自己写 控制器：handler servlet controller action 2拦截器拦截器的原理和过滤器相同。SpringMVC：要想实现拦截器，必须实现一个接口HandlerInterceptor ctrl+shift+r ：自己编写的代码.java .jsp .htmlctrl+shift+t ：jar中的代码 a.编写拦截器implements HandlerInterceptorb.配置：将自己写的拦截器 配置到springmvc中（spring） 1234&lt;!-- 将自己写的拦截器 配置到springmvc中（spring）,默认拦截全部请求 --&gt;&lt;mvc:interceptors &gt; &lt;bean class=\"pers.nicolas.interceptor.MyInterceptor\"&gt;&lt;/bean&gt;&lt;/mvc:interceptors&gt; 1234567891011&lt;!-- 将自己写的拦截器 配置到springmvc中（spring）,默认拦截全部请求 --&gt;&lt;mvc:interceptors &gt; &lt;!-- 配置具体的拦截路径 --&gt; &lt;mvc:interceptor&gt; &lt;!--指定拦截的路径，ant风格 --&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--指定不拦截的路径，ant风格 --&gt; &lt;mvc:exclude-mapping path=\"/handler/testInterceptor\"/&gt; &lt;bean class=\"pers.nicolas.interceptor.MyInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 拦截器1拦截请求- 拦截器2拦截请求 - 请求方法 - 拦截器2处理相应-拦截器1处理相应- 拦截器2的afterCompletion()拦截-拦截器1的afterCompletion()拦截 如果有多个拦截器，则每个拦截器的preHandle postHandle afterCompletion都会在相应时机各被触发一次. 3.异常处理SpringMVC： HandlerExceptionResolver接口， 该接口的每个实现类 都是异常的一种处理方式： a.@ExceptionHandler注解ExceptionHandler,ExceptionResolver： 主要提供了@ExceptionHandler注解，并通过该注解处理异常 123456//该方法 可以捕获本类中 抛出的ArithmeticException异常@ExceptionHandler(&#123;ArithmeticException.class,ArrayIndexOutOfBoundsException.class &#125;)public String handlerArithmeticException(Exception e) &#123; System.out.println(e +\"============\"); return \"error\" ;&#125; @ExceptionHandler标识的方法的参数 必须在异常类型(Throwable或其子类) ，不能包含其他类型的参数(Model可以，可以查看官方文档) 异常处理路径：最短（接近的）优先如果有方法抛出一个ArithmeticException异常，而该类中 有2个对应的异常处理法你发： 12345@ExceptionHandler(&#123;Exception.class &#125;)public ModelAndView handlerArithmeticException2(Exception e) &#123;&#125;@ExceptionHandler(&#123;ArithmeticException.class &#125;)public ModelAndView handlerArithmeticException1(Exception e) &#123;&#125; 则优先级： 最短（接近的）优先。 @ExceptionHandler默认只能捕获 当前类中的异常方法。如果发生异常的方法 和处理异常的方法 不在同一个类中：@ControllerAdvice 总结：如果一个方法用于处理异常，并且只处理当前类中的异常：@ExceptionHandler 如果一个方法用于处理异常，并且处理所有类中的异常： 类前加@ControllerAdvice、 处理异常的方法前加@ExceptionHandler b.@ResponseStatusResponseStatusExceptionResolver：自定义异常显示页面 @ResponseStatus 1234567891011@ResponseStatus(value=HttpStatus.FORBIDDEN,reason=\"数组越界222!!!\")public class MyArrayIndexOutofBoundsException extends Exception &#123;//自定义异常&#125;@RequestMapping(\"testMyException\") public String testMyException(@RequestParam(\"i\") Integer i) throws MyArrayIndexOutofBoundsException &#123; if(i == 3) &#123; throw new MyArrayIndexOutofBoundsException();//抛出异常 &#125; return \"success\" ;&#125; 12345678910111213@RequestMapping(\"testMyException2\")public String testMyException2(@RequestParam(\"i\") Integer i) &#123; if(i == 3) &#123; return \"redirect:testResponseStatus\" ;//跳转到某一个 异常处理方法里 &#125; return \"success\" ;&#125;@ResponseStatus(value = HttpStatus.CONFLICT, reason = \"test exception！\")@RequestMapping(\"testResponseStatus\")public String testResponseStatus()&#123; return \"success\";&#125; c.DefaultHandlerExceptionResolver异常处理的实现类：DefaultHandlerExceptionResolver:SPringMVC在一些常见异常的基础上（300 500 404），新增了一些异常，例如： @see org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler @see #handleNoSuchRequestHandlingMethod @see #handleHttpRequestMethodNotSupported ：如果springmvc的处理方法限制为post方式，如果实际请求为get,则会触发此异常显示的页面 @see #handleHttpMediaTypeNotSupported @see #handleMissingServletRequestParameter @see #handleServletRequestBindingException @see #handleTypeMismatch @see #handleHttpMessageNotReadable @see #handleHttpMessageNotWritable @see #handleMethodArgumentNotValidException @see #handleMissingServletRequestParameter @see #handleMissingServletRequestPartException @see #handleBindException d.SimpleMappingExceptionResolver：通过配置来实现异常的处理 12345678910111213141516&lt;!--SimpleMappingExceptionResolver:以配置的方式处理异常 --&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;!-- 如果发生异常，异常对象会被保存在 exceptionAttribute的value值中；并且会放入request域中 ；异常变量的默认值是 exception--&gt; &lt;!--&lt;property name=\"exceptionAttribute\" value=\"exception\"&gt;&lt;/property&gt;--&gt; &lt;property name=\"exceptionMappings\"&gt; &lt;props&gt; &lt;!-- 相当于catch(ArithmeticException ex)&#123; 跳转：error &#125; --&gt; &lt;prop key=\"java.lang.ArithmeticException\"&gt; error &lt;/prop&gt; &lt;prop key=\"java.lang.NullPointerException\"&gt; error &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; SSM整合：Spring - SpringMVC - MyBatis 1.Spring - MyBatis : 需要整合：将MyBatis的SqlSessionFactory 交给Spring 2Spring - SpringMVC ： 就是将Spring - SpringMVC 各自配置一遍 思路： SqlSessionFactory -&gt; SqlSession -&gt;StudentMapper -&gt;CRUD可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据库，Spring整合MyBatis 其实就是 将MyBatis的SqlSessionFactory 交给Spring SM整合步骤：1.jarmybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jarspring-context-support.jar spring-core.jar spring-context.jarspring-beans.jar spring-aop.jar spring-web.jar commons-logging.jarcommons-dbcp.jar ojdbc.jar mybatis.jar log4j.jar commons-pool.jar 2.类-表 Student类 -student表 3.-（与Spring整合时，conf.xml可省）–MyBatis配置文件conf.xml（数据源、mapper.xml） –可省，将该文件中的配置 全部交由spring管理 spring配置文件 applicationContext.xml 4.通过mapper.xml将 类、表建立映射关系 5.之前使用MyBatis: conf.xml -&gt;SqlSessionFacotry 1234567891011&lt;!-- web项目中，spring介入项目 --&gt;&lt;!-- needed for ContextLoaderListener --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- Bootstraps the root web application context before servlet initialization --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 现在整合的时候，需要通过Spring管理SqlSessionFacotry ，因此 产生qlSessionFacotry 所需要的数据库信息 不在放入conf.xml 而需要放入spring配置文件中 配置Spring配置文件（applicationContext.xml） （Web项目）：web.xml 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 6.使用Spring整合MyBatis ：将MyBatis的SqlSessionFactory 交给Spring 注意xml文件路径有classpath:存在,和整合sm最大不同 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 加载db.properties文件 --&gt;&lt;bean id=\"config\" class=\"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;array&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 数据库信息(替代了mybatis中的配置文件conf.xml) --&gt;&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxActive\" value=\"$&#123;maxActive&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxIdle\" value=\"$&#123;maxIdle&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- cof.xml: 数据源、mapper.xml --&gt;&lt;!-- 在SpringIoc容器中 创建Mybatis的核心类SqlSessionFactory --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- 加载mapper.xml配置文件 --&gt; &lt;!-- 注意有classpath:存在,和整合sm最大不同 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:pers/nicolas/mapper/*.xml\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 将mybatis的SqlSessionFactory交给spring --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;!-- xxxxMapper --&gt; &lt;property name=\"basePackage\" value=\"pers.nicolas.mapper\"&gt;&lt;/property&gt;&lt;/bean&gt; 7.继续整合SpringMVC：将springmvc加入项目即可a.加入SpringMVC需要的jarspring-webmvc.jar b.给项目加入SpringMVC支持web.xml: dispatcherServlet（alt+/） 1234567891011121314151617&lt;!-- web项目整合springmvc --&gt;&lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-controller.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- Map all requests to the DispatcherServlet for handling --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; c.编写springmvc配置文件：applicationContext-controller.xml：视图解析器、基础配置 12345678910&lt;!-- 将控制器所在的包加入springIOC容器 --&gt;&lt;context:component-scan base-package=\"pers.nicolas.controller\"&gt;&lt;/context:component-scan&gt;&lt;!-- 配置视图解析器 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/views/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- springMVC基础配置、标配 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; d.示例","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://codeofli.github.io/tags/spring/"},{"name":"springMvc","slug":"springMvc","permalink":"https://codeofli.github.io/tags/springMvc/"}]},{"title":"spring","slug":"java-note/spring/spring","date":"2019-10-19T07:23:24.000Z","updated":"2021-10-23T02:19:04.201Z","comments":true,"path":"2019/10/java-note/spring/spring/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/spring/spring/","excerpt":"2002 Rod Johnon Spring 2003 ,IOC AopSpring data,spring boot,spring cloud,spring framework ,spring social [TOC]IOC :控制反转Inversion of Control（DI：，Dependency Injection，依赖注入）","text":"2002 Rod Johnon Spring 2003 ,IOC AopSpring data,spring boot,spring cloud,spring framework ,spring social [TOC]IOC :控制反转Inversion of Control（DI：，Dependency Injection，依赖注入） 1.搭建Spring环境开发spring至少需要使用的jar(5个+1个): spring-aop.jar 开发AOP特性时需要的JAR spring-beans.jar 处理Bean的jar spring-context.jar 处理spring上下文的jar spring-core.jar spring核心jar spring-expression.jar spring表达式 第三方提供的日志jar commons-logging.jar 日志 123456789101112131415161718192021222324&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt; 2.编写配置文件为了编写时有一些提示、自动生成一些配置信息：方式一：增加sts插件可以给eclipse增加 支持spring的插件：spring tool suite(https://spring.io/tools/sts/all)下载springsource-tool-suite-3.9.4.RELEASE-e4.7.3a-updatesite.zip,然后在Eclipse中安装：Help-Install new SoftWare.. - Add 方式二： 直接下载sts工具（相当于一个集合了Spring tool suite的Eclipse）: https://spring.io/tools/sts/ 新建：bean configuration .. - applicationContext.xml 3.开发Spring程序(IOC)通过ioc容器获取对象123ApplicationContext conext = new ClassPathXmlApplicationContext(\"applicationContext.xml\") ; //执行从springIOC容器中获取一个 id为student的对象Student student = (Student)conext.getBean(\"student\") ; 可以发现，springioc容器 帮我们new了对象，并且给对象赋了值 SpringIOC发展史：1.Student student = new Student();student.setXxx(); 2.简单工厂 3.ioc （超级工厂） IOC（控制反转,Inversion of Control）也可以称之为DI（依赖注入,Dependency Injection）：控制反转：将 创建对象、属性值 的方式 进行了翻转，从new、setXxx() 翻转为了 从springIOC容器getBean()依赖注入：将属性值 注入给了属性，将属性 注入给了bean，将bean注入给了ioc容器； ​总结：ioc/di ，无论要什么对象，都可以直接去springioc容器中获取，而不需要自己操作（new\\setXxx()） 因此之后的ioc分为2步：1 先给springioc中存放对象并赋值 2 拿 DI:依赖注入 ，Teacher Course : cname teacher IOC容器赋值：如果是简单类型（8个基本+String），value； 如果是对象类型，ref=”需要引用的id值”，因此实现了 对象与对象之间的依赖关系 conext.getBean(需要获取的bean的id值) 依赖注入3种方式：1.set注入：通过setXxx()赋值赋值，默认使用的是 set方法();依赖注入底层是通过反射实现的。 12345&lt;bean id=\"cat\" class=\"com.qst.pojo.Cat\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"color\" value=\"red\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"llmz\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.构造器注入：通过构造方法赋值需要注意：如果 的顺序 与构造方法参数的顺序不一致，则需要通过type或者index或name指定。 1&lt;constructor-arg value=\"ls\" type=\"String\" index=\"0\" name=\"name\"&gt;&lt;/constructor-arg&gt; 12345&lt;bean id=\"student\" class=\"com.qst.pojo.Student\"&gt; &lt;constructor-arg name=\"id\" value=\"0\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"studentName\" value=\"lmz\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"studentScore\" value=\"100\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 3.p命名空间注入1234引入p命名空间 xmlns:p=\"http://www.springframework.org/schema/p\"&lt;bean id=\"course\" class=\"org.lanqiao.entity.Course\" p:courseHour=\"300\" p:courseName=\"hadoop\" p:teacher-ref=\"teacher\"&gt; 本质也是反射 简单类型： p:属性名=”属性值”引用类型（除了String外）： p:属性名-ref=”引用的id”注意多个 p赋值的时候 要有空格。 注意：无论是String还是Int/short/long，在赋值时都是 value=”值” ，当参数重载时默认为String优先因此建议 此种情况 需要配合 name\\type进行区分 示例： 注入各种集合数据类型: List Set map properties set、list、数组 各自都有自己的标签 ，但是也可以混着用 ###value与注入方式的区别： 使用子元素注入 而使用value属性注入 参数值位置 写在首尾标签（）的中间(不加双引号) 写在value的属性值中（必须加双引号） type属性 有（可选） 可以通过type属性指定数据类型 无 参数值包含特殊字符（&lt;， &amp;）时的处理方法 两种处理方法。 一、使用标记 二、使用XML预定义的实体引用 一种处理方法。即使用XML预定义的实体引用 其中，XML预定义的实体引用，如表所示。 实体引用 表示的符号 &lt; &lt; &amp; &amp; &gt; &gt; 给对象类型赋值null ： 123&lt;property name=\"name\" &gt; &lt;null/&gt; --&gt;注意 没有&lt;value&gt; &lt;/property&gt; 赋空值 “” 123&lt;property name=\"name\" &gt; &lt;value&gt;&lt;/value&gt; &lt;/property&gt; 在ioc中定义bean的前提：该bean的类 必须提供了 无参构造 4.自动装配（只适用于 ref类型 ）：​ 约定优于配置 自动装配：&lt;bean … class=”org.lanqiao.entity.Course” autowire=”byName|byType|constructor|no” &gt; byName本质是byIdbyName: 自动寻找：其他bean的id值=该Course类的属性名byType: 其他bean的类型(class) 是否与 该Course类的ref属性类型一致 （注意，此种方式 必须满足：当前Ioc容器中 只能有一个Bean满足条件 ）constructor： 其他bean的类型(class) 是否与 该Course类的构造方法参数 的类型一致；此种方式的本质就是byType 可以在头文件中 一次性将该ioc容器的所有bean 统一设置成自动装配：&lt;beans xmlns=”http://www.springframework.org/schema/beans&quot;…default-autowire=”byName”&gt; 自动装配虽然可以减少代码量，但是会降低程序的可读性，使用时需要谨慎。 使用注解定义bean：通过注解的形式 将bean以及相应的属性值 放入ioc容器 1&lt;context:component-scan base-package=\"pers.nicolas.aop\"&gt;&lt;/context:component-scan&gt; 在启动的时候，会根据base-package在 该包中扫描所有类，查找这些类是否有注解@Component(“studentDao”),如果有，则将该类 加入spring Ioc容器。 @Component细化： dao层注解：@Repositoryservice层注解：@Service控制器层注解：@Controller 12345678910@Service(\"StudentService\") //注意添加scan扫描包public class StudentServiceImpl implements IStudentService&#123; @Autowired //自动装配，byType @Qualifier(\"stuDao\") // byIdName IStudentDao studentDao = new StudentDaoImp(); public void setStudentDao(IStudentDao studentDao) &#123; this.studentDao = studentDao; &#125;&#125; 使用注解实现事务（声明式事务） 目标：通过事务 使以下方法 要么全成功、要么全失败public void addStudent(){ //增加班级 //增加学生 //crdu} a. jar包spring-tx-4.3.9.RELEASEojdbc.jarcommons-dbcp.jar 连接池使用到数据源commons-pool.jar 连接池spring-jdbc-4.3.9.RELEASE.jaraopalliance.jar b.配置jdbc\\mybatis\\spring增加事务tx的命名空间 123456789101112131415161718192021&lt;!-- 配置数据库 --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"oracle.jdbc.OracleDriver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@localhost:1521:MLDN\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"scott\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"tigger\"&gt;&lt;/property&gt; &lt;property name=\"maxActive\" value=\"10\"&gt;&lt;/property&gt; &lt;property name=\"maxIdle\" value=\"6\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器txManager --&gt; &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 增加对事务的支持 --&gt; &lt;tx:annotation-driven transaction-manager=\"txManager\" /&gt; c.使用 将需要 成为事务的方法 前增加注解：@Transactional(readOnly=false,propagation=Propagation.REQUIRED) AOP：面向方面编程一个普通的类 -&gt; 有特定功能的类 a.继承类 b.实现接口 c.注解 d.配置 public class MyFilter exntends/implements Xx{ } 类 -&gt; “通知” ：实现接口 前置通知实现步骤：ThrowsAdvice a.jar aopaliance.jar aspectjweaver.jar b.配置 c.编写 aop：每当之前add()之前 自动执行一个方法log(); addStudent(); 业务方法（IStudentService.java中的 addStudent()） before(); 自动执行的通知，即aop前置通知12345678910111213&lt;!-- 前置通知类 --&gt; &lt;bean id=\"LogBefore\" class=\"pers.nicolas.aop.LogBefore\"&gt; &lt;/bean&gt; &lt;!-- 将方法和通知进行关联 --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点（在哪里执行通知） --&gt; &lt;aop:pointcut expression=\"execution(public void pers.nicolas.service.StudentServiceImpl.deleteStudentByNo(int)) or execution(public void pers.nicolas.service.StudentServiceImpl.addStudent(pers.nicolas.entity.Student))\" id=\"pointcut\" /&gt; &lt;!-- advisor相当于连接切入点和切面的线 --&gt; &lt;aop:advisor advice-ref=\"LogBefore\" pointcut-ref=\"pointcut\" /&gt;&lt;/aop:config&gt; 表达式expression的常见示例如表所示。expression=*”execution(…)”* 举例 含义 public boolean addStudent(org.lanqiao.entity.Student)) 所有返回类型为boolean、参数类型为org.lanqiao.entity.Student的addStudent()方法。 public boolean org.lanqiao.service.IStudentService. addStudent(org.lanqiao.entity.Student) org.lanqiao.service.IStudentService类（或接口）中的addStudent()方法，并且返回类型是boolean、参数类型是org.lanqiao.entity.Student public * addStudent(org.lanqiao.entity.Student) “*”代表任意返回类型 public void *( org.lanqiao.entity.Student) “*”代表任意方法名 public void addStudent(..) “..”代表任意参数列表 * org.lanqiao.service..(..) org.lanqiao.service.IStudentService包中，包含的所有方法（不包含子包中的方法） * org.lanqiao.service...(..) org.lanqiao.service.IStudentService包中，包含的所有方法（包含子包中的方法） execution(* com.atguigu.crud.service..*(..)) expression常见示例 org.lanqiao.service org.lanqiao.service.impl public class Xxx{ @Test a(){}} 如果出现异常：类似java.lang.NoClassDefFoundError: org/apache/commons/pool/impl/GenericObjectPool则说明缺少jar 后置通知：AfterReturningAdvice a.通知类 ，普通实现接口b.业务类、业务方法 StudentServiceImpl中的addStudent()c.配置： 将业务类、通知 纳入springIOC容器 定义切入点（一端）、定义通知类（另一端），通过pointcut-ref将两端连接起来 异常通知：ThrowsAdvice ​ 根据异常通知接口的定义可以发现，异常通知的实现类 必须编写以下方法：​ public void afterThrowing([Method, args, target], ThrowableSubclass)： a.public void afterThrowing(Method, args, target, ThrowableSubclass) b.public void afterThrowing( ThrowableSubclass)环绕通知：MethodInterceptor 在目标方法的前后、异常发生时、最终等各个地方都可以 进行的通知，最强大的一个通知； 可以获取目标方法的 全部控制权（目标方法是否执行、执行之前、执行之后、参数、返回值等） 在使用环绕通知时，目标方法的一切信息 都可以通过invocation参数获取到环绕通知 底层是通过拦截器实现的。 1234567891011121314151617public Object invoke(MethodInvocation invocation) throws Throwable &#123; Object result = null; try &#123; System.out.println(\"around advice[before advice]\"); // invocation.proceed()之前后的代码：前后置通知 result = invocation.proceed();// 控制目标方法的执行 xxx(),result就是目标方法的返回值 // invocation.proceed()之后的代码：后置通知 System.out.println(\"\"); System.out .println(\"around advice[after advice]: traget object :\" + invocation.getThis() + \", function name:=\" + invocation.getMethod().getName() + \",returnValue=\" + result + \",args=\" + invocation.getArguments()); &#125; catch (Exception e) &#123; // 异常通知 System.out.println(\"around advice[exception advice]\"); &#125; return result; &#125; 二、实现注解实现 通知 aopa.jar 与 实现接口 的方式相同b.配置 将业务类、通知 纳入springIOC容器 开启注解对AOP的支持aop:aspectj-autoproxy 业务类 addStudent - 通知 c.编写 通知：@Aspect //声明该类 是一个 通知public class LogBeforeAnnotation { } 注意：通过注解形式 将对象增加到 ioc容器时，需要设置 扫描器&lt;context:component-scan base-package=”org.lanqiao.aop”&gt; 扫描器 会将 指定的包 中的 @Componet @Service @Respository @Controller修饰的类产生的对象 增加到IOC容器中@Aspect不需要 加入扫描器，只需要开启即可：aop:aspectj-autoproxy 通过注解形式 实现的aop，如果想获取 目标对象的一些参数，则需要使用一个对象：JoinPoint 注解形式的返回值：a.声明返回值 的参数名： @AfterReturning( pointcut= “execution(public * addStudent(..))” ,returning=”returningValue” ) public void myAfter(JoinPoint jp,Object returningValue) {//returningValue是返回值，但需要告诉spring System.out.println(“返回值：”+returningValue );注解形式实现aop时，通知的方法的参数不能多、少 实现接口形式、注解形式 只捕获声明的特定类型的异常，而其他类型异常不捕获。cath() 1234567891011121314151617181920212223242526272829303132333435363738394041@Component(\"logAnnotaiton\")@Aspect // 声明此类是一个通知public class LogAopAnnotation &#123; //前置通知 @Before(\"execution(public * addStudent(..))\") // 属性：定义切点 public void MyBefore(JoinPoint jp) &#123; System.out.println(\"&lt;[Annotation]前置 advice&gt;: target object:\" + jp.getTarget() + \",methodName:\" + jp.getSignature().getName() + \",arguments:\" + Arrays.toString(jp.getArgs())); &#125; //后置通知 @AfterReturning(pointcut = \"execution(public * addStudent(..))\",returning = \"returningValue\") // 属性：定义切点,要得到返回值必须通过注解声明 public void AfterReturning(JoinPoint jp,Object returningValue) &#123; System.out.println(\"&lt;[Annotation]后置advice&gt; target object:\" + jp.getTarget() + \",methodName:\" + jp.getSignature().getName() + \",arguments:\" + Arrays.toString(jp.getArgs())+\",returnVlaue:\"+returningValue); &#125; //Exception Advice:如果只捕获指定异常，可以通过通过注解throwing指定 @AfterThrowing(pointcut = \"execution(public * addStudent(..))\",throwing = \"e\") public void MyException(JoinPoint jp,NullPointerException e) &#123; System.out.println(\"&lt;[Annotation]exception advice&gt; e:\"+e.getMessage()); &#125; //环绕通知,参数ProceedingJoinPoint @Around(\"execution(public * addStudent(..))\") public void MyAroud(ProceedingJoinPoint jp)&#123; try &#123; System.out.println(\"&lt;[Annotation【Around】]前置 advice&gt;\"); //方法之前，前置通知 jp.proceed();//方法执行 //方法之后，后前置通知 System.out.println(\"&lt;[Annotation【Around】]后置 advice&gt;\"); &#125;catch(Throwable e) &#123;//方法异常，异常通知 System.out.println(\"&lt;[Annotation【Around】]exception advice&gt;\"); &#125;finally &#123;//最终执行，最终通知 System.out.println(\"&lt;[Annotation【Around】]最终 advice&gt;\"); &#125; &#125; //最终通知 @After(\"execution(public * addStudent(..))\") public void MyAfter() &#123; System.out.println(\"&lt;[Annotation]最终advice&gt;\"); &#125;&#125; 三、通过 配置将 类-&gt;通知基于Schema配置类似 于 实现接口的方式 接口方式通知：public class LogAfter implements AfterReturningAdviceSchema方式通知： a.编写一个普通类 public class LogAfter {} b.将该类 通过配置，转为一个“通知” 如果要获取目标对象信息：注解、schema：JoinPoint接口：Method method, Object[] args, Object target schema形式 和注解形式相似，不同之处： 注解形式 使用了注册@After， schmema形式进行了多余的配置 12345678910111213141516&lt;aop:config&gt; &lt;!-- 配置切入点（在哪里执行通知） --&gt; &lt;aop:pointcut expression=\"execution(public void pers.nicolas.service.StudentServiceImpl.addStudent(pers.nicolas.entity.Student))\" id=\"pointcut_schema\" /&gt; &lt;!-- schema方式 --&gt; &lt;aop:aspect ref=\"LogSchema\"&gt; &lt;aop:before method=\"before\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;aop:after-returning method=\"afterReturning\" returning=\"returnValue\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;aop:after-throwing method=\"MyException\" throwing=\"e\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;aop:around method=\"around\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 1.Spring开发Web项目 及 拆分Spring配置文件a.Spring开发Web项目 Web项目如何初始化SpringIOC容器 ：思路：当服务启动时（tomcat），通过监听器将SpringIOC容器初始化一次（该监听器 spring-web.jar已经提供） 因此用spring开发web项目 至少需要7个jar： spring-java的6个jar + spring-web.jar，注意：web项目的jar包 是存入到WEB-INF/lib中 web项目启动时 ，会自动加载web.xml，因此需要在web.xml中加载 监听器（ioc容器初始化）。 Web项目启动时，启动实例化Ioc容器： 1234567891011121314&lt;!-- 指定 Ioc容器（applicationContext.xml）的位置--&gt; &lt;context-param&gt; &lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;!-- 配置spring-web.jar提供的监听器，此监听器 可以在服务器启动时 初始化Ioc容器。 初始化Ioc容器（applicationContext.xml） ， 1.告诉监听器 此容器的位置：context-param 2.默认约定的位置 :WEB-INF/applicationContext.xml --&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; b.拆分Spring配置文件​ java项目：​ applicationContext1.xml​ applicationContext2.xml​ applicationContext3.xml ApplicationContext conext = new ClassPathXmlApplicationContext(“applicationContext3.xml”) ; Web项目： 根据什么拆分？ i.三层结构 UI(html/css/jsp 、Servlet) applicationController.xml Service :applicationService.xml Dao:applicationDao.xml 公共 数据库:applicationDB.xml ii.功能结构 学生相关配置 applicationContextStudent.xml 班级相关配置 applicationContextClass.xml 合并：如何将多个配置文件 加载 （1） 12345678910&lt;context-param&gt; &lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml, classpath:applicationContext-Dao.xml, classpath:applicationContext-Service.xml, classpath:applicationContext-Controller.xml &lt;/param-value&gt;&lt;/context-param&gt; ​ （2）推荐 12345678&lt;context-param&gt; &lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml, classpath:applicationContext-*.xml &lt;/param-value&gt;&lt;/context-param&gt; （3）只在web.xml中加载主配置文件， 123&lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt; ​ 然后在主配置问加中，加载其他配置文件: 1&lt;import resource=\"applicationContext-*.xml\"/&gt; Web项目： 2.Spring整合MyBatisSpring - MyBatis 思路： SqlSessionFactory -&gt; SqlSession -&gt;StudentMapper -&gt;CRUD可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据库，Spring整合MyBatis 其实就是 将MyBatis的SqlSessionFactory 交给Spring SM整合步骤：1.jarmybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jarspring-context-support.jar spring-core.jar spring-context.jarspring-beans.jar spring-aop.jar spring-web.jar commons-logging.jarcommons-dbcp.jar ojdbc.jar mybatis.jar log4j.jar commons-pool.jar 2.类-表 3.MyBatis配置文件conf.xml 4.通过mapper.xml将 类、表建立映射关系 5.之前使用MyBatis: conf.xml -&gt;SqlSessionFacotry 现在整合的时候，需要通过Spring管理SqlSessionFacotry ，因此 产生qlSessionFacotry 所需要的数据库信息 不在放入conf.xml 而需要放入spring配置文件中 配置Spring配置文件（applicationContext.xml） 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 加载db.properties文件 --&gt; &lt;bean id=\"config\"class=\"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;array&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 数据库信息(替代了mybatis中的配置文件conf.xml) --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxActive\" value=\"$&#123;maxActive&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxIdle\" value=\"$&#123;maxIdle&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 在SpringIoc容器中 创建mybatis的核心类SqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;!-- 加载mybatis配置文件，如果只有映射，不需要写conf.xml文件--&gt;&lt;!-- &lt;property name=\"configLocation\" value=\"classpath:conf.xml\"&gt;&lt;/property&gt; --&gt; &lt;!-- 加载mapper.xml配置文件 --&gt; &lt;property name=\"mapperLocations\" value=\"pers/nicolas/mapper/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 第3种方式批量生成mapper代理对象批量产生的mapper对象在SpringIOC容器中的id值默认就是接口mapper名(首字母小写）--&gt;&lt;bean id=\"mappers\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"pers.nicolas.mapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; 6.使用Spring-MyBatis整合产物开发程序 目标：通过spring产生mybatis最终操作需要的 动态mapper对象(StudentMapper对象) Spring产生 动态mapper对象 有3种方法： a.第一种方式DAO层实现类 继承 SqlSessionDaoSupport类 1234567 SqlSessionDaoSupport类提供了一个属性 SqlSession &lt;!-- 第一种方式生成mapper代理对象 --&gt;&lt;bean id=\"studentMapper\" class=\"pers.nicolas.dao.impl.StudentDaoImpl\"&gt;&lt;!-- 将Spring配置的sqlSessionFactory交给Mapper（Dao) --&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; b.第二种方式 就是省略掉 第一种方式的 实现类 直接MyBatis提供的 Mapper实现类：org.mybatis.spring.mapper.MapperFactoryBean 缺点：每个mapper都需要一个配置一次 12345&lt;!-- 第二种方式生成mapper代理对象 --&gt;&lt;bean id=\"studentMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;property name=\"mapperInterface\" value=\"pers.nicolas.mapper.StudentMapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; c.第三种方式 批量配置 实现类 1234567&lt;!-- 第3种方式批量生成mapper代理对象批量产生的mapper对象在SpringIOC容器中的id值默认就是接口mapper名(首字母小写）--&gt;&lt;bean id=\"mappers\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"pers.nicolas.mapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; # spring注解版一个接口指定实现类接口定义 12345package com.yoj.used;public interface MyInterface &#123; void className();&#125; 实现类1 1234567@Service(\"impl1\")public class Implement1 implements MyInterface&#123; @Override public void className() &#123; System.out.println(Implement1.class); &#125;&#125; 实现类2 1234567@Service(\"impl2\")public class Implement2 implements MyInterface &#123; @Override public void className() &#123; System.out.println(Implement2.class); &#125;&#125; 1.@AutoWired+@Qualifier(“impl2”)指定 123@Autowired@Qualifier(\"impl2\")MyInterface myInterface; 2.使用@Resource注入，根据@Service指定的名称区分 12@Resource(name = \"impl2\")MyInterface myInterface; my同一类中内部调用aop失效Spring Bean初始化之后执行指定方法https://blog.csdn.net/forever7107/article/details/76446544/ 在运用Spring进行实际项目开发过程中，经常会有一种需求就是想要在Bean实例化完成后，自动执行指定方法，包括加载初始值，初始化缓存等。通过简单的XML配置或者使用注解即可实现。本文仅用于记录简单的使用介绍，不阐述详细的技术实现细节，达到抛砖引玉的效果。 Spring注解方式如果项目中bean是通过注解方式管理的，需要在初始化完成后，执行指定方法，仅仅需要在需要执行的方法上添加@PostConstruct注解即可，修改后的JAVA类如下： 123456789@Componentpublic class InitMethodTest &#123; @PostConstruct public void initMethod()&#123; System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;initMethod&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://codeofli.github.io/tags/spring/"}]},{"title":"python-crawler","slug":"python/python-crawler/python-crawler","date":"2019-10-16T13:27:10.000Z","updated":"2021-10-23T02:19:04.268Z","comments":true,"path":"2019/10/python/python-crawler/python-crawler/","link":"","permalink":"https://codeofli.github.io/2019/10/python/python-crawler/python-crawler/","excerpt":"requests库requests库的安装http://www.python-requests.org Win平台: “以管理员身份运行” cmd，执行 pip install requests requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get(url, params=None, **kwargs) 获取HTML网页的主要方法，对应于HTTP的GET requests.head(url, **kwargs) 获取HTML网页头信息的方法，对应于HTTP的HEAD requests.post(url, data=None, json=None, **kwargs) 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put(url, data=None, **kwargs) 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch(url, data=None, **kwargs) 向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete(url, **kwargs) 向HTML页面提交删除请求，对应于HTTP的DELETE","text":"requests库requests库的安装http://www.python-requests.org Win平台: “以管理员身份运行” cmd，执行 pip install requests requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get(url, params=None, **kwargs) 获取HTML网页的主要方法，对应于HTTP的GET requests.head(url, **kwargs) 获取HTML网页头信息的方法，对应于HTTP的HEAD requests.post(url, data=None, json=None, **kwargs) 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put(url, data=None, **kwargs) 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch(url, data=None, **kwargs) 向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete(url, **kwargs) 向HTML页面提交删除请求，对应于HTTP的DELETE requests库的get方法： requests.get(url, params=None, kwargs)∙ url : 拟获取页面的url链接∙ params : url中的额外参数，字典或字节流格式，可选∙ kwargs: 12个控制访问的参数 123456789101112def get(url, params=None, **kwargs): r\"\"\"Sends a GET request. :param url: URL for the new :class:`Request` object. :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`. :param \\*\\*kwargs: Optional arguments that ``request`` takes. :return: :class:`Response &lt;Response&gt;` object :rtype: requests.Response \"\"\" kwargs.setdefault('allow_redirects', True) return request('get', url, params=params, **kwargs) 主要方法解析requests.request(method, url, kwargs)∙ method : 请求方式，对应get/put/post等7种∙ url : 拟获取页面的url链接∙ kwargs: 控制访问的参数，共13个 method : 请求方式 1234567r = requests.request('GET', url, **kwargs) r = requests.request('HEAD', url, **kwargs) r = requests.request('POST', url, **kwargs) r = requests.request('PUT', url, **kwargs) r = requests.request('PATCH', url, **kwargs) r = requests.request('delete', url, **kwargs) r = requests.request('OPTIONS', url, **kwargs) \\kwargs: 控制访问的参数，均为可选项**params : 字典或字节序列，作为参数增加到url中data : 字典、字节序列或文件对象，作为Request的内容 json : JSON格式的数据，作为Request的内容 headers : 字典， HTTP定制头 cookies : 字典或CookieJar， Request中的cookie auth : 元组，支持HTTP认证功能 files : 字典类型，传输文件 timeout : 设定超时时间，秒为单位 proxies : 字典类型，设定访问代理服务器，可以增加登录认证 allow_redirects : True/False，默认为True，重定向开关stream : True/False，默认为True，获取内容立即下载开关verify : True/False，默认为True，认证SSL证书开关cert : 本地SSL证书路径 Response对象Response对象包含服务器返回的所有信息，也包含请求的Request信息 Response 对象的属性 属性 说明 r.status_code HTTP请求的返回状态， 200表示连接成功， 404表示失败 r.text HTTP响应内容的字符串形式，即， url对应的页面内容 r.encoding 从HTTP header中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） r.content HTTP响应内容的二进制形式 Response的编码 r.encoding 从HTTP header中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） r.encoding：如果header中不存在charset，则认为编码为ISO‐8859‐1r.text根据r.encoding显示网页内容r.apparent_encoding ：根据网页内容分析出的编码方式可以看作是r.encoding的备选 request库的异常 异常 说明 requests.ConnectionError 网络连接错误异常，如DNS查询失败、拒绝连接等 requests.HTTPError HTTP错误异常 requests.URLRequired URL缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器超时异常 requests.Timeout 请求URL超时，产生超时异常 r.raise_for_status() 如果不是200，产生异常 requests.HTTPError r.raise_for_status()在方法内部判断r.status_code是否等于200，不需要增加额外的if语句，该语句便于利用try‐except进行异常处理 爬取网页通用的代码(块)框架1234567891011121314151617import requests def getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return 'processing exception' if __name__ == \"__main__\": url = 'https://www.baidu.com/' print(getHTMLText(url)) response = requests.get('https://www.baidu.com/') print(type(response)) HTTP协议HTTP， Hypertext Transfer Protocol，超文本传输协议HTTP是一个基于“请求与响应”模式的、无状态的应用层协议HTTP协议采用URL作为定位网络资源的标识， URL格式如下：http://host[:port][path]host: 合法的Internet主机域名或IP地址port: 端口号，缺省端口为80path: 请求资源的路径 HTTP URL的理解：URL是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源 http协议对资源的操作 方法 说明 GET 请求获取URL位置的资源 HEAD 请求获取URL位置资源的响应消息报告，即获得该资源的头部信息 POST 请求向URL位置的资源后附加新的数据 PUT 请求向URL位置存储一个资源，覆盖原URL位置的资源 PATCH 请求局部更新URL位置的资源，即改变该处资源的部分内容 DELETE 请求删除URL位置存储的资源 理解patch和put的区别假设URL位置有一组数据UserInfo，包括UserID、 UserName等20个字段需求：用户修改了UserName，其他不变• 采用PATCH，仅向URL提交UserName的局部更新请求• 采用PUT，必须将所有20个字段一并提交到URL，未提交字段被删除PATCH的最主要好处：节省网络带宽 http协议与requests库 TTP协议方法 Requests库方法 功能一致性 GET requests.get() 一致 HEAD requests.head() 一致 POST requests.post() 一致 PUT requests.put() 一致 PATCH requests.patch() 一致 DELETE requests.delete() 一致 Requests库网络爬取实战实例2：亚马逊商品页面的爬取 12345678910import requests url = 'https://item.jd.com/2967929.html' kv = &#123;'user-agent':'Mozilla/5.0'&#125; try: r = requests.get(url,headers=kv) r.raise_for_status() r.encoding = r.apparent_encoding print(r.status_code) except: 'processing exception' 实例3：百度/360搜索关键字提交 百度的关键词接口：http://www.baidu.com/s?wd=keyword 123456789101112# https://item.jd.com/2967929.html import requests url = 'http://www.baidu.com/s' kv = &#123;'wd':'python'&#125; try: r = requests.get(url,params=kv) r.raise_for_status() r.encoding = r.apparent_encoding print(len(r.text)) print(r.status_code) except: 'processing exception' 实例4：网络图片的爬取和存储 123456789101112131415161718import requests,os url = 'http://image.nationalgeographic.com.cn/2017/0211/20170211061910157.jpg' root = 'E://img//' path = root + url.split('/')[-1] try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(url) r.raise_for_status() with open(path,'wb') as f: f.write(r.content) f.close() print('save file successfully') else: print('file exist') except: 'processing exception' 网络爬虫的相关问题 网络爬虫的限制来源审查：判断User‐Agent进行限制检查来访HTTP协议头的User‐Agent域，只响应浏览器或友好爬虫的访问• 发布公告： Robots协议告知所有爬虫网站的爬取策略，要求爬虫遵守 Robots协议Robots Exclusion Standard，网络爬虫排除标准 作用：网站告知网络爬虫哪些页面可以抓取，哪些不行形式：在网站根目录下的robots.txt文件 http://www.baidu.com/robots.txthttp://news.sina.com.cn/robots.txthttp://www.qq.com/robots.txthttp://news.qq.com/robots.txthttp://www.moe.edu.cn/robots.txt （无robots协议） Robots协议使用网络爬虫：自动或人工识别robots.txt，再进行内容爬取约束性：Robots协议是建议但非约束性，网络爬虫可以不遵守，但存在法律风险 beautifulSoup库https://www.crummy.com/software/BeautifulSoup/ https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/ Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库. 安装 1pip install beautifulsoup4 使用 12345678910111213141516from bs4 import BeautifulSoup html_doc = \"\"\" &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;, &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;; and they lived at the bottom of a well.&lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; \"\"\" soup = BeautifulSoup(html_doc, 'html.parser') print(soup.prettify()) Beautiful Soup库解析器1soup = BeautifulSoup('&lt;html&gt;data&lt;/html&gt;'， 'html.parser') 解析器 使用方法 条件 bs4的HTML解析器 BeautifulSoup(mk,’html.parser’) 安装bs4库 lxml的LXML解析器 BeautifulSoup(mk,’lxml’) pip install lxml lxml的XML解析器 BeautifulSoup(mk,’xml’) pip install lxml html5lib的解析器 BeautifulSoup(mk,’html5lib’) pip install html5lib BeautifulSoup类的基本元素 1&lt;p class=\"title\"&gt; … &lt;/p&gt; 基本元素 说明 Tag 标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;标明开头和结尾 Name 标签的名字， …的名字是’p’，格式： .name Attributes 标签的属性，字典形式组织，格式： .attrs NavigableString 标签内非属性字符串， &lt;&gt;…&lt;/&gt;中字符串，格式： .string Comment 标签内字符串的注释部分，一种特殊的Comment类型 Tag 标签 基本元素 说明 Tag 标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;标明开头和结尾 Name 标签的名字， …的名字是’p’，格式： .name Attributes 标签的属性，字典形式组织，格式： .attrs NavigableString 标签内非属性字符串， &lt;&gt;…&lt;/&gt;中字符串，格式： .string Comment 标签内字符串的注释部分，一种特殊的Comment类型 任何存在于HTML语法中的标签都可以用soup.&lt;tag&gt;访问获得当HTML文档中存在多个相同&lt;tag&gt;对应内容时， soup.&lt;tag&gt;返回第一个 基于bs4库的HTML内容遍历方法 标签树的下行遍历 属性 说明 .contents 子节点的列表，将所有儿子节点存入列表 .children 子节点的迭代类型，与.contents类似，用于循环遍历儿子节点 .descendants 子孙节点的迭代类型，包含所有子孙节点，用于循环遍历 BeautifulSoup类型是标签树的根节点 标签树的下行遍历 1234for child in soup.body.children: print(child) 遍历儿子节点 for child in soup.body.descendants: print(child) 遍历子孙节点 标签树的上行遍历 属性 说明 .parent 节点的父亲标签 .parents 节点先辈标签的迭代类型，用于循环遍历先辈节点 标签树的上行遍历 遍历所有先辈节点，包括soup本身，所以要区别判断 标签树的平行遍历 属性 说明 .next_sibling 返回按照HTML文本顺序的下一个平行节点标签 .previous_sibling 返回按照HTML文本顺序的上一个平行节点标签 .next_siblings 迭代类型，返回按照HTML文本顺序的后续所有平行节点标签 .previous_siblings 迭代类型，返回按照HTML文本顺序的前续所有平行节点标签 1234567标签树的平行遍历 for sibling in soup.a.next_sibling: print(sibling) for sibling in soup.a.previous_sibling: print(sibling) 遍历后续节点 遍历前续节点 信息标记和提取方法信息标记标记后的信息可形成信息组织结构，增加了信息维度标记的结构与信息一样具有重要价值标记后的信息可用于通信、存储或展示标记后的信息更利于程序理解和运用 信息标记的三种信息xml，json，yaml html的信息标记HTML是WWW(World Wide Web)的信息组织方式 HTML通过预定义的&lt;&gt;…&lt;/&gt;标签形式组织不同类型的信息 xml eXtensible Markup Language 空元素的缩写形式 1&lt;img src=“china.jpg” size=“10” /&gt; 注释书写形式 1&lt;!‐‐ This is a comment, very useful ‐‐&gt; json JavsScript Object Notation有类型的键值对 key:value yaml YAML Ain’t Markup Language无类型键值对 key:value 1234缩进表达所属关系 name : newName : 北京理工大学 oldName : 延安自然科学院 1234‐ 表达并列关系 name : ‐北京理工大学 ‐延安自然科学院 123456| 表达整块数据 # 表示注释 text: | #学校介绍 北京理工大学创立于1940年，前身是延安自然科学院， 是中国共产党创办的第一所理工科大学，毛泽东同志亲 自题写校名，李富春、徐特立、李强等老一辈无产阶级革命家先后担任学校主要领导。学校是新中国成立以来 国家历批次重点建设的高校，首批进入国家“211工程”和“985工程”建设行列；在全球具有广泛影响力的英 国QS“世界大学500强”中，位列入选的中国大陆高校第15位。学校现隶属于工业和信息化部。 XMLJSONYAML最早的通用信息标记语言，可扩展性好，但繁琐信息有类型，适合程序处理(js)，较XML简洁信息无类型，文本信息比例最高，可读性好 XMLJSONYAMLInternet上的信息交互与传递移动应用云端和节点的信息通信，无注释各类系统的配置文件，有注释易读 信息提取融合方法：结合形式解析与搜索方法，提取关键信息XML JSON YAML 搜索需要标记解析器及文本查找函数 12345678from bs4 import BeautifulSoup import requests r =requests.get('http://python123.io/ws/demo.html') demo = r.text soup = BeautifulSoup(demo, 'html.parser') for link in soup('a'): print(link) &lt;&gt;.find_all(name, attrs, recursive, string, **kwargs)∙ name : 对标签名称的检索字符串返回一个列表类型，存储查找的结果 attrs: 对标签属性值的检索字符串，可标注属性检索 recursive: 是否对子孙全部检索，默认True string: &lt;&gt;…&lt;/&gt;中字符串区域的检索字符串 &lt;tag&gt;(..) 等价于 &lt;tag&gt;.find_all(..)soup(..) 等价于 soup.find_all(..) 方法 说明 &lt;&gt;.find() 搜索且只返回一个结果，同.find_all()参数 &lt;&gt;.find_parents() 在先辈节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_parent() 在先辈节点中返回一个结果，同.find()参数 &lt;&gt;.find_next_siblings() 在后续平行节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_next_sibling() 在后续平行节点中返回一个结果，同.find()参数 &lt;&gt;.find_previous_siblings() 在前序平行节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_previous_sibling() 在前序平行节点中返回一个结果，同.find()参数 中国大学定向排名实例http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html 技术路线： requests‐bs4定向爬虫：仅对输入URL进行爬取，不扩展爬取 12345678910111213141516171819202122232425262728293031323334353637# CrawUnivRankingB.py import requests from bs4 import BeautifulSoup import bs4 def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return \"\" def fillUnivList(ulist, html): soup = BeautifulSoup(html, \"html.parser\") for tr in soup.find('tbody').children: if isinstance(tr, bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string, tds[1].string, tds[3].string]) def printUnivList(ulist, num): tplt = \"&#123;0:^10&#125;\\t&#123;1:&#123;3&#125;^10&#125;\\t&#123;2:^10&#125;\" print(tplt.format(\"排名\", \"学校名称\", \"总分\", chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0], u[1], u[2], chr(12288))) def main(): uinfo = [] url = 'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html' html = getHTMLText(url) fillUnivList(uinfo, html) printUnivList(uinfo, 20) # 20 univs main() 当中文字符宽度不够时，采用西文字符填充；中西文字符占用宽度不同采用中文字符的空格填充 chr(12288) 正则表达式regular expression, regex, RE 正则表达式是用来简洁表达一组字符串的表达式 正则表达式在文本处理中十分常用：表达文本类型的特征（病毒、入侵等）同时查找或替换一组字符串匹配字符串的全部或部分……最主要应用在字符串匹配中 正则表达式语法由字符和操作符构成 正则表达式常用操作符 操作符 说明 实例 . 表示任何单个字符 [ ] 字符集，对单个字符给出取值范围 [abc]表示a、 b、 c， [a‐z]表示a到z单个字符 [^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc* 表示 ab、 abc、 abcc、 abccc等 + 前一个字符1次或无限次扩展 abc+ 表示 abc、 abcc、 abccc等 ? 前一个字符0次或1次扩展 abc? 表示 ab、 abc | 左右表达式任意一个 abc|def 表示 abc、 def {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次（含n） ab{1,2}c表示abc、 abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 ( ) 分组标记，内部只能使用 | 操作符 (abc)表示abc， (abc|def)表示abc、 def \\d 数字，等价于[0‐9] \\w 单词字符，等价于[A‐Za‐z0‐9_] 经典正则表达式1234567^[A‐Za‐z]+$ 由26个字母组成的字符串 ^[A‐Za‐z0‐9]+$ 由26个字母和数字组成的字符串 ^‐?\\d+$ 整数形式的字符串 ^[0‐9]*[1‐9][0‐9]*$ 正整数形式的字符串 [1‐9]\\d&#123;5&#125; 中国境内邮政编码， 6位 [\\u4e00‐\\u9fa5] 匹配中文字符 \\d&#123;3&#125;‐\\d&#123;8&#125;|\\d&#123;4&#125;‐\\d&#123;7&#125; 国内电话号码， 010‐68913536 ip地址正则P地址字符串形式的正则表达式（ IP地址分4段，每段0‐255） 123456 精确写法 0‐99： [1‐9]?\\d 100‐199: 1\\d&#123;2&#125; 200‐249: 2[0‐4]\\d 250‐255: 25[0‐5] (([1‐9]?\\d|1\\d&#123;2&#125;|2[0‐4]\\d|25[0‐5]).)&#123;3&#125;([1‐9]?\\d|1\\d&#123;2&#125;|2[0‐4]\\d|25[0‐5]) re库Re库是Python的标准库，主要用于字符串匹配 正则表达式的表示类型raw string类型（原生字符串类型）库采用类型表示正则表达式，表示为： 1例如： r'[1‐9]\\d&#123;5&#125;' r'\\d&#123;3&#125;‐\\d&#123;8&#125;|\\d&#123;4&#125;‐\\d&#123;7&#125;' raw string是不包含对转义符再次转义的字符串 re库也可以采用string类型表示正则表达式，但更繁琐例如：‘[1‐9]\\d{5}’‘\\d{3}‐\\d{8}|\\d{4}‐\\d{7}’建议：当正则表达式包含转义符时，使用raw string Re库的主要功能函数 函数 说明 re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 re.match() 从一个字符串的开始位置起匹配正则表达式，返回match对象 re.findall() 搜索字符串，以列表类型返回全部能匹配的子串 re.split() 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re.finditer() 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 re.sub() 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 re.search(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记在一个字符串中搜索匹配正则表达式的第一个位置返回match对象 常用标记 说明 re.I re.IGNORECASE 忽略正则表达式的大小写， [A‐Z]能够匹配小写字符 re.M re.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始 re.S re.DOTALL 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符 1234import re match = re.search(r'[1-9]\\d&#123;5&#125;','bit 100001') if match: print(match.group(0)) re.match(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记从一个字符串的开始位置起匹配正则表达式返回match对象 re.findall(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记搜索字符串，以列表类型返回全部能匹配的子串 re.split(pattern, string, maxsplit=0, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ maxsplit: 最大分割数，剩余部分作为最后一个元素输出∙ flags : 正则表达式使用时的控制标记将一个字符串按照正则表达式匹配结果进行分割返回列表类型 re.finditer(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 1import refor m in re.finditer(r'[1-9]\\d&#123;5&#125;','bit100001 lmz312552'): if m: print(m.group(0)) re.sub(pattern, repl, string, count=0, flags=0)在一个字符串中替换所有匹配正则表达式的子串返回替换后的字符串 ∙ pattern 正则表达式的字符串或原生字符串表示: ∙ repl : 替换匹配字符串的字符串∙ string : 待匹配字符串∙ count∙ flags : 匹配的最大替换次数正则表达式使用时的控制标记 1import resub = re.sub(r'[1-9]\\d&#123;5&#125;', 'bitzip', 'bit100001 lmz312552')print(sub) 正则表达式对象123rst = re.search(r'[1‐9]\\d&#123;5&#125;', 'BIT 100081') pat = re.compile(r'[1‐9]\\d&#123;5&#125;') rst = pat.search('BIT 100081') 面向对象用法：编译后的多次操作函数式用法：一次性操作 regex = re.compile(pattern, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ flags : 正则表达式使用时的控制标记 regex = re.compile(r’[1‐9]\\d{5}’)将正则表达式的字符串形式编译成正则表达式对象 re库的match对象Match对象是一次匹配的结果，包含匹配的很多信息 属性 说明 .string 待匹配的文本 .re 匹配时使用的patter对象（正则表达式） .pos 正则表达式搜索文本的开始位置 .endpos 正则表达式搜索文本的结束位置 re库的贪婪匹配和最小匹配123match = re.search(r'PY.*N', 'PYANBNCNDN') print(match.group(0)) 'PYANBNCNDN' Re库默认采用贪婪匹配，即输出匹配最长的子串 操作符 说明 *? 前一个字符0次或无限次扩展，最小匹配 +? 前一个字符1次或无限次扩展，最小匹配 ?? 前一个字符0次或1次扩展，最小匹配 {m,n}? 扩展前一个字符m至n次（含n），最小匹配 *只要长度输出可能不同的，都可以通过在操作符后增加?变成最小匹配 * ScrapyScrapy是一个快速功能强大的网络爬虫框架 爬虫框架是实现爬虫功能的一个软件结构和功能组件集合。爬虫框架是一个半成品，能够帮助用户实现专业网络爬虫。 scrapy的安装 Win平台: “以管理员身份运行” cmd执行 1pip install scrapy 1conda install scrapy 安装后小测：执行 1scrapy Scrapy结构 Engine(1) 控制所有模块之间的数据流(2) 根据条件触发事件不需要用户修改 Downloader根据请求下载网页不需要用户修改 Scheduler对所有爬取请求进行调度管理不需要用户修改 Downloader Middleware目的：实施Engine、 Scheduler和Downloader之间进行用户可配置的控制功能：修改、丢弃、新增请求或响应用户可以编写配置代码 Spider(1) 解析Downloader返回的响应（ Response）(2) 产生爬取项（ scraped item）(3) 产生额外的爬取请求（ Request）需要用户编写配置代码 Item Pipelines(1) 以流水线方式处理Spider产生的爬取项(2) 由一组操作顺序组成，类似流水线，每个操作是一个Item Pipeline类型(3) 可能操作包括：清理、检验和查重爬取项中的HTML数据、将数据存储到数据库需要用户编写配置代码 Spider Middleware目的：对请求和爬取项的再处理功能：修改、丢弃、新增请求或爬取项用户可以编写配置代码 requests和scrapy相同点：两者都可以进行页面请求和爬取， Python爬虫的两个重要技术路线两者可用性都好，文档丰富，入门简单两者都没有处理js、提交表单、应对验证码等功能（可扩展） requests scrapy 页面级爬虫 网站级爬虫 功能库 框架 并发性考虑不足，性能较差 并发性好，性能较高 重点在于页面下载 重点在于爬虫结构 定制灵活 一般定制灵活，深度定制困难 上手十分简单 入门稍难 scrapy常用命令Scrapy是为持续运行设计的专业爬虫框架，提供操作的Scrapy命令行Win下，启动cmd控制台 为什么Scrapy采用命令行创建和运行爬虫？命令行（不是图形界面）更容易自动化，适合脚本控制本质上， Scrapy是给程序员用的，功能（而不是界面）更重要 1scrapy &lt;command&gt; [options] [args] 命令 说明 格式 startproject 创建一个新工程 scrapy startproject [dir] genspider 创建一个爬虫 scrapy genspider [options] settings 获得爬虫配置信息 scrapy settings [options] crawl 运行一个爬虫 scrapy crawl list 列出工程中所有爬虫 scrapy list shell 启动URL调试命令行 scrapy shell [url] 产生的步骤应用Scrapy爬虫框架主要是编写配置型代码 步骤1：建立一个Scrapy爬虫工程选取一个目录（ D:\\pycodes\\），然后执行如下命令： 1scrapy startproject python123demo 生成的工程目录12345678910python123demo/ 外层目录 scrapy.cfg 部署Scrapy爬虫的配置文件 python123demo/ Scrapy框架的用户自定义Python代码 __init__.py 初始化脚本 items.py Items代码模板（继承类） middlewares.py Middlewares代码模板（继承类） pipelines.py Pipelines代码模板（继承类） settings.py Scrapy爬虫的配置文件 spiders/ Spiders代码模板目录（继承类） 目录结构 __pycache__/ 缓存目录，无需修改 内层目录结构 用户自定义的spider代码增加在此处 123spiders/ Spiders代码模板目录（继承类） __init__.py 初始文件，无需修改 __pycache__/ 缓存目录，无需修改 步骤2：在工程中产生一个Scrapy爬虫进入工程目录（ D:\\pycodes\\python123demo），然后执行如下命令： 123You can start your first spider with: cd python123demo scrapy genspider example example.com 1E:\\Codes\\Python\\reptile\\python123demo&gt;scrapy genspider demo python123.io 该命令作用：(1) 生成一个名称为demo的spider(2) 在spiders目录下增加代码文件demo.py 该命令仅用于生成demo.py，该文件也可以手工生成 demo.py文件 12345678910# -*- coding: utf-8 -*- import scrapy class DemoSpider(scrapy.Spider): name = 'demo' allowed_domains = ['python123.io'] start_urls = ['http://python123.io/'] #parse()用于处理响应，解析内容形成字典，发现新的URL爬取请求 def parse(self, response): pass 步骤3：配置产生的spider爬虫配置：（ 1）初始URL地址 （ 2）获取页面后的解析方式 1234567891011121314# -*- coding: utf-8 -*- import scrapy class DemoSpider(scrapy.Spider): name = 'demo' # allowed_domains = ['python123.io'] 可选 start_urls = ['http://python123.io/ws/demo.html'] def parse(self, response): fname = response.url.split('/')[-1] with open(fname,\"wb\") as f: f.write(response.body) self.log('Saved file %s.' % fname) 步骤4：运行爬虫，获取网页在命令行下，执行如下命令： 1scrapy crawl demo 完整版代码： 123456789101112131415161718# -*- coding: utf-8 -*- import scrapy class DemoSpider(scrapy.Spider): name = 'demo' def start_requests(self): urls = [ 'http://python123.io/ws/demo.html' ] for url in urls: yield scrapy.Request(url=url,callback=self.parse) def parse(self, response): fname = response.url.split('/')[-1] with open(fname,\"wb\") as f: f.write(response.body) self.log('Saved file %s.' % fname) 数据类型Request类class scrapy.http.Request()Request对象表示一个HTTP请求由Spider生成，由Downloader执行 属性或方法 说明 .url Request对应的请求URL地址 .method 对应的请求方法， ‘GET’ ‘POST’等 .headers 字典类型风格的请求头 .body 请求内容主体，字符串类型 .meta 用户添加的扩展信息，在Scrapy内部模块间传递信息使用 .copy() 复制该请求 Response类class scrapy.http.Response()Response对象表示一个HTTP响应由Downloader生成，由Spider处理 属性或方法 说明 .url Response对应的URL地址 .status HTTP状态码，默认是200 .headers Response对应的头部信息 .body Response对应的内容信息，字符串类型 .flags 一组标记 .request 产生Response类型对应的Request对象 .copy() 复制该响应 Item类class scrapy.item.Item()Item对象表示一个从HTML页面中提取的信息内容由Spider生成，由Item Pipeline处理Item类似字典类型，可以按照字典类型操作 scrapy基本使用使用步骤步骤1：创建一个工程和Spider模板步骤2：编写Spider步骤3：编写Item Pipeline步骤4：优化配置策略 Scrapy爬虫支持多种HTML信息提取方法：• Beautiful Soup• lxml• re• XPath Selector• CSS Selector CSS Selector 1&lt;HTML&gt;.css('a::attr(href)').extract() CSS Selector由W3C组织维护并规范标签名称 标签属性 配置并发连接选项 settings.py文件 选项 说明 CONCURRENT_REQUESTS Downloader最大并发请求下载数量，默认32 CONCURRENT_ITEMS Item Pipeline最大并发ITEM处理数量，默认100 CONCURRENT_REQUESTS_PER_DOMAIN 每个目标域名最大的并发请求数量，默认8 CONCURRENT_REQUESTS_PER_IP 每个目标IP最大的并发请求数量，默认0，非0有效","categories":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/tags/python/"},{"name":"crawler","slug":"crawler","permalink":"https://codeofli.github.io/tags/crawler/"}]},{"title":"html-css","slug":"front-end/html-css/html-css","date":"2019-10-14T14:19:09.000Z","updated":"2021-10-23T02:19:02.839Z","comments":true,"path":"2019/10/front-end/html-css/html-css/","link":"","permalink":"https://codeofli.github.io/2019/10/front-end/html-css/html-css/","excerpt":"[TOC]HTMLHTML，超文本标记语言负责页面中的结构，定义出页面中的各个组成部分HTML是采用纯文本的形式的编写，采用HTML标签来标识出页面中的不同部分 HTML页面的基本结构一个网页有三个部分组成：结构html、表现css、行为js结构:html结构是页面的整体结构，哪里是标题，哪里是段落，哪里是图片结构使用HTML来编写","text":"[TOC]HTMLHTML，超文本标记语言负责页面中的结构，定义出页面中的各个组成部分HTML是采用纯文本的形式的编写，采用HTML标签来标识出页面中的不同部分 HTML页面的基本结构一个网页有三个部分组成：结构html、表现css、行为js结构:html结构是页面的整体结构，哪里是标题，哪里是段落，哪里是图片结构使用HTML来编写 123456789&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 表现css表现是页面的外在的样式，比如字体，字体大小，字体颜色，背景…使用CSS来设置页面中元素的样式 行为js页面和用户之间的交互行为使用JavaScript来设置页面的行为一个设计优良的网页要求结构、表现、行为三者分离在开发中总是要面临一个问题，就是程序之间的耦合，三者分离就是为了解耦合 标签(元素)成对出现 1&lt;标签名&gt;&lt;/标签名&gt; 自结束标签 1&lt;标签名 /&gt; 块元素和内联元素块元素块元素会独占页面中的一行，无论他的内容的多少一般使用块元素对页面进行布局常见的块元素divph1~h6 内联元素内联元素只占用自身的大小，不会独占一行内联元素也叫行内元素（inline）一般内联元素都是用来为文本来设置效果常见的内联 span a img包裹规则一般都是使用块元素去包裹内联元素，而不会使用内联去包裹块元素a元素可以包含任意元素，除了a本身p元素不能包含任何块元素 元素之间的关系父元素 直接包含子元素的的元素叫做父元素子元素 直接被父元素包含的元素叫做子元素祖先元素 直接或间接包含后代元素的元素叫做祖先元素，父元素也是祖先元素后代元素 直接或间接被祖先元素包含的元素叫后代元素，子元素也是后代元素兄弟元素 拥有相同父元素的元素叫做兄弟元素 属性通过属性可以设置标签的效果属性需要定义在开始标签中或这自结束标签中属性实际上是一组一组名值对结构例子： 12&lt;标签名 属性名=\"属性值\" 属性名=\"属性值\"&gt;&lt;/标签名&gt; &lt;标签名 属性名=\"属性值\" 属性名=\"属性值\" /&gt; 常用标签&lt;!doctype html&gt;文档声明用来标识当前页面的html的版本该声明用来告诉浏览器，当前的页面是使用HTML5的标准编写的&lt;html&gt;网页的根标签一个页面中有且只有一个根标签网页中的所有内容都需要写在html标签的内部 &lt;head&gt;网页的头部该标签中的内容不会在网页中直接显示该标签用于帮助浏览器解析页面子标签&lt;title&gt;用来设置网页的标题默认会在浏览器的标题栏中显示搜索引擎检索网页时，会主要检索title中的内容，它会影响到页面在搜索引擎中的排名&lt;meta&gt;用来设置网页的元数据，比如网页使用的字符集&lt;meta charset=&quot;utf-8&quot; /&gt;设置网页的关键字&lt;meta name=&quot;keywords&quot; content=&quot;关键字,关键字,关键字,关键字&quot;/&gt;设置网页的描述&lt;meta name=&quot;description&quot; content=&quot;网页的描述&quot;/&gt;请求的重定向&lt;meta http-equiv=&quot;refresh&quot; content=&quot;秒数;url=地址&quot; /&gt; &lt;body&gt;网页的主体网页中所有的可见部分都需要在body中编写&lt;h1&gt; ~ &lt;h6&gt;标题标签在html中一共有六级标题六级标题中，h1最重要，h6最不重要，一般页面中只会使用h1~h3h1的重要性仅次于title，浏览器也会主要检索h1中的内容，以判断页面的主要内容一般一个页面中只能写一个h1&lt;p&gt;段落标签&lt;br /&gt;换行标签&lt;hr /&gt;水平线标签内联框架可以向一个页面中引入其他的外部页面&lt;iframe&gt;``&lt;/iframe&gt;属性src外部页面的地址，可以使用相对路径width和height可以设置框架的宽度和高度name可以为内联框架指定一个名字可以将该属性值设置为超链接的target属性的值这样当点击超链接时，页面将会在相应的内联框架中打开内联框架中的内容不会被搜索引擎所检索，所以开发中尽量不要使用内联框架 &lt;a&gt;超链接可以使当前页面跳转到其他的页面&lt;a&gt;链接的文字&lt;/a&gt;属性href 指向链接跳转的目标地址，可以是一个相对路径 还可以是#id属性值，这样当点击超链接以后，将会跳转到当前页面的指定位置 可以使用mailto:来创建一个发送电子邮件的超链接target 指定在哪个窗口中打开链接 可选值 _self 默认值，默认在当前窗口打开链接 _blank 在新窗口中打开链接 内联框架的name属性值 在指定的内联框架中打开链接 语法注释&lt;!-- 注释内容 --&gt; 注释中的内容不会在页面中显示，但是会在源码中显示，我们可以通过注释来说明网页的代码也可以通过注释隐藏一些页面中不想显示的内容 实体在HTML页面中一些特殊符号是不能直接使用，需要使用实体来代替这些特殊符号实体也可以称为转义字符实体的语法 &amp;实体名;常用的实体 空格&amp;nbsp; Non-Breaking Space” 的缩写， &lt;&amp;lt; 、&gt;&amp;gt;、版权符号&copy;&amp;copy; 图片标签 使用图片标签可以向页面中引入一个外部图片 属性 src 指向一个外部图片的路径，可以使用相对路径 alt 指定一个在图片无法加载时对图片的描述 搜索引擎主要通过该属性来识别图片的内容 如果不写该属性则搜索引擎会对图片进行收录 width 设置图片的宽度 height 设置图片的高度 图片的格式 JPEG 颜色丰富的图片，如，照片 GIF 颜色单一，简单透明的图片，动态图 PNG 颜色丰富，复杂透明的图片 图片选择的原则 效果一致，用小的 效果不一致，用效果好的相对路径 相对于当前资源所在的目录的路径 可以使用../返回一级目录，返回几级使用几个../xHtml语法规范 1.HTML中不区分大小写，但是尽量使用小写 2.HTML的注释不能嵌套 3.标签必须结构完整 要么成对出现 要么自结束标签 4.标签可以嵌套但是不能交叉嵌套 5.属性必须有值，且值必须加引号，单引号双引号都可以 文本标签 `&lt;em&gt;` 表示语气上的强调 `&lt;strong&gt;` 表示内容的重要性 `&lt;i&gt;` 表示单纯的斜体 `&lt;b&gt;` 表示单纯的加粗 `&lt;small&gt;` 表示细则一类的内容 `&lt;cite&gt;` 表示参考的内容，凡是加书名号的都可以使用cite `&lt;q&gt;` 短引用，行内引用 &lt; blockquote&gt; 长引用，块级引用 &lt;sup&gt;上标&lt;sub&gt;下标&lt;del&gt;删除的内容&lt;ins&gt;插入的内容 &lt; pre&gt;预格式标签，可以保留代码中空格换行这些格式&lt; code&gt;表示程序代码 css基础Cascading（级联） Style Sheets(薄片，纸张，覆盖)，层叠样式表 css样式三种方式内联样式可以将css样式编写到元素的style属性中将样式直接编写在style属性中，这样的样式成为内联样式只对当前元素（标签）有效，不方便复用内联样式属于结构与表现耦合，不方便后期维护 12&lt;p style=\"color: red; font-size: 40px\"&gt;锄禾日当午，汗滴禾下土&lt;/p&gt; &lt;p&gt;谁知盘中餐，粒粒皆辛苦&lt;/p&gt; head编写style便签也可以将CSS样式编写到head中的style标签里将样式表编写的style标签中，然后通过CSS选择器选中指定元素然后可以同时为这些元素一起设置样式，这样可以使样式进一步的复用将样式表编写到style标签中，也可以使表现和结构进一步分离它也是我们推荐的使用方式 12345&lt;style type=\"text/css\"&gt; p&#123; color: red; font-size: 40px; &#125; &lt;/style&gt; 外部的CSS文件还可以将样式表编写到外部的CSS文件中,然后通过link标签来将外部的CSS文件引入到当前页面中，这样外部文件中的css样式表将会应用到当前页面中。 将CSS样式统一编写到外部的样式表中，完全使结构和表现分离，可以是样式表可以在不同的页面中使用，最大限度的使样式可以进行复用，将样式统一写在样式表中，然后通过link标签引入，可以利用浏览器的缓存加快用户访问的速度提高了用户体验，所以在开发中我们最推荐使用的方式就是外部的CSS文件 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" /&gt; css语法简介:选择器：通过选择器可以选中页面中指定的元素，并且将声明块中的样式应用到选择器对应的元素上 声明块：声明块紧跟在选择器的后边，使用一对{}括起来，声明块中实际上就是一组一组的名值对结构，这一组一组的名值对我们称为声明，在一个声明块中可以写多个声明，多个声明之间使用;隔开，声明的样式名和样式值之间使用:来连接 1234p&#123; color:red; font-size:50px; &#125; 注释123/* CSS的注释，作用和HTML注释类似，只不过它必须编写在style标签中，或者是css文件中 */ 单位长度单位px 像素，像素就是构成一个图片的最小的单位，我们的屏幕就是由一个一个像素点构成 一个像素指的就是一个像素点 在不同的显示器中，一个像素的大小是不同的，越清晰的屏幕像素越小% 可以将一个元素的样式值设置为一个百分比的值，这样浏览器将会根据父元素的值去计算出相应的值 当父元素的值改变时，子元素的值会按照一定比例一起改变，经常用于自适应的页面em em会相对于当前元素的字体大小来计算 1em = 1font-size em经常用于设置文字相关的一些样式，因为当文字大小发生改变时，em会随之改变 rem…. 颜色单位颜色单词 直接使用英文单词来表示颜色 red green blue orangeRGB值 所谓RGB值就是通过红 绿 蓝三元色的不同组合来搭配出各种不同的颜色语法：rgb(红色,绿色,蓝色)这三个值需要一个0-255之间的值 0表示没有 255表示最大 rgb(50,200,30)也可以使用百分数来设置RGB值，需要0%-100%之间的值 百分数最终也是转换为0-255的 0%相当于0 100%相当于255 rgb(100%,0%,0%)十六进制RGB值也是一种RGB值的表示方式，不同的是它使用的是16进制数字来表示而不是语法： #红色绿色蓝色这里的颜色需要一个00-ff之间的值例子： #ff0000如果颜色的是两位两位重复的，可以进行简写 比如 #aabbcc 可以写成 #abc 比如 #bbffaa 可以写成 #bfa 文本样式字体color 字体的颜色font-size 字体的大小 浏览器中默认的字体大小一般都是16px，而我们开发时一般会统一为12pxfont-family 设置文字的字体font-style 设置斜体font-weight 设置文字的加粗font-variant 小型大写字母font文字的简写属性可以同时设置所有的字体相关的样式语法： font: [加粗 斜体 小大字母] 大小[/行高] 字体加粗，斜体，小大字母，顺序无所谓，写不写都行，如果不写在使用默认值文本大小，和字体必须写，且大小必须是倒数第二个，字体必须是最后一个大小后可以设置行高，可写可不写，如果不写则使用默认值 文本样式 line-height 行高** 文本默认都是在行高中垂直居中的 通过line-height可以修改行高 行间距 = 行高 - 字体大小** text-transform 设置文本的大小写 可选值： none 默认值，该怎么显示就怎么显示，不做任何处理 capitalize 单词的首字母大写，通过空格来识别单词 uppercase 所有的字母都大写 lowercase 所有的字母都小写 text-decoration 设置文本修饰 123456a &#123; /*超链接会默认添加下划线，也就是超链接的text-decoration的默认值是underline 如果需要去除超链接的下划线则需要将该样式设置为none * */ text-decoration: none; &#125; text-align 设置文本对齐text-indent 设置首行缩进 它需要一个长度单位，如果是正值则首行向右移动，如果是负值则向左移动 1234567/* * text-indent用来设置首行缩进 * 当给它指定一个正值时，会自动向右侧缩进指定的像素 * 如果为它指定一个负值，则会向左移动指定的像素, * 通过这种方式可以将一些不想显示的文字隐藏起来 * 这个值一般都会使用em作为单位 */ letter-spacing 字符间距word-spacing 单词间距 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * 在CSS并没有为我们提供一个直接设置行间距的方式， * 我们只能通过设置行高来间接的设置行间距，行高越大行间距越大 * 使用line-height来设置行高 * 行高类似于我们上学单线本，单线本是一行一行，线与线之间的距离就是行高， * 网页中的文字实际上也是写在一个看不见的线中的，而文字会默认在行高中垂直居中显示 * * 行间距 = 行高 - 字体大小 */ .p1&#123; font-size: 20px; /* * 通过设置line-height可以间接的设置行高， * 可以接收的值： * 1.直接就收一个大小 * 2.可以指定一个百分数，则会相对于字体去计算行高 * 3.可以直接传一个数值，则行高会设置字体大小相应的倍数 */ /*line-height: 200%;*/ line-height: 2; &#125; .box&#123; width: 200px; height: 200px; round-color: #bfa; /* * 对于单行文本来说，可以将行高设置为和父元素的高度一致， * 这样可以是单行文本在父元素中垂直居中 */ line-height: 200px; &#125; .p2&#123; /* * 在font中也可以指定行高 * 在字体大小后可以添加/行高，来指定行高，该值是可选的，如果不指定则会使用默认值 */ font: 30px \"微软雅黑\"; line-height: 50px; &#125; 选择器通过选择器可以选中页面中的一组元素，然后为其设置样式 基础选择器元素选择器根据标签名，选中页面中的指定元素语法：标签名{ }例子： 123div&#123;&#125; p&#123;&#125; h1&#123;&#125; id选择器根据元素的id属性值选中一个唯一的元素语法：#id {}例子： 12#box1&#123;&#125; #hello&#123;&#125; 类选择器我们可以为元素设置class属性， class属性和id属性类似，只不过class属性可以重复 拥有相同class属性值的元素，我们说他们是一组元素 可以同时为一个元素设置多个class属性值，多个值之间使用空格隔开 根据元素的class属性值，选中一组元素语法：.class{}例子： 12.hello&#123;&#125; .box&#123;&#125; 通配选择器选中页面中的所有元素语法：*{}通配选择器的性能比较差，尽量避免使用 并集选择器可以同时选中符合多个选择器的元素语法：选择器1,选择器2,选择器N{}例子： 1div,p,#box,.hello&#123;&#125; 交集选择器对于id选择器来说，不建议使用复合选择器,因为id已经能唯一标识 可以选中满足多个条件的元素 先元素再类 语法：选择器1选择器2选择器N{} 例子： 1p.hello&#123;&#125; 后代元素选择器选中指定元素的指定后代元素语法：祖先元素 （空格）后代元素{}例子： 12div span &#123;&#125; div p&#123;&#125; 子元素选择器选中指定元素的指定子元素语法：父元素 &gt; 子元素 {}例子： 12div &gt; span &#123;&#125; div &gt; p&#123;&#125; 声明块声明块中实际上就是一个一个CSS声明声明每一个CSS声明都是一个样式，实际上就是一个名值对的结构名和值之间使用:链接:左边是样式的名字:右边是样式的值每一个声明以;结尾例子 12color:red; font-size:20px; 伪类和伪元素伪类和伪元素用来表示元素所处的一个特殊的状态，或者是一个特殊的位置 伪类：:link 表示一个普通的链接（未访问过的链接）:visited 表示访问过的链接 浏览器是通过历史记录来判断一个链接是否访问过,由于涉及到用户的隐私问题，所以使用visited伪类只能设置字体的颜色 :hover（盘旋，徘徊） 鼠标移入的链接，也可以为其他元素设置hover :active 正在被点击的链接，也可以为其他元素设置active :focus 表示元素获取焦点的状态，一般用于文本框 ::selection（注意有两个冒号） 表示内容被选中的状态 在火狐中使用::-moz-selection来代替 伪元素：:first-letter 表示第一个字符 :first-line 表示文字的第一行 :before 选中元素的最前边 一般该伪类都会结合content一起使用，通过content可以向指定位置添加内容 :after 选中元素的最后边 一般该伪类都会结合content一起使用，通过content可以向指定位置添加内容 属性选择器根据元素的属性选择指定元素 [属性名] 选取含有指定属性的元素 [属性名=&quot;属性值&quot;] 选取属性值等于指定值的元素 [属性名^=&quot;属性值&quot;] 选取属性值以指定内容**开头的元素** [属性名$=&quot;属性值&quot;] 选取属性值以指定内容结尾的元素 [属性名*=&quot;属性值&quot;] 选取属性值中**包含指定内容的元素** 子元素的伪类:first-child 寻找父元素的第一个子元素，**在所有的子元素中排序**（前面不指定特定元素就表示全部元素,指定就是交集选择器） :last-child 寻找父元素的最后一个子元素，在所有的子元素中排序 :nth-child 寻找父元素中的指定位置子元素，在所有的子元素中排序 例子 p:nth-child(3) 可以使用even，来找到偶数的子元素 可以使用odd，来找到奇数的子元素 :first-of-type 寻找指定类型中的第一个子元素 :last-of-type 寻找指定类型中的最后一个子元素 :nth-of-type 寻找指定类型中的指定子元素 :empty Selects elements that don’t have any other elements inside of them. div:empty selects all empty elements. :nth-of-type(A) Selects a specific element based on its type and order in another element - or even or odd instances of that element. div:nth-of-type(2) selects the second instance of a div. .example:nth-of-type(odd) selects all odd instances of a the example class. :only-child You can select any element that is the only element inside of another one. :nth-last-child(A) Selects the children from the bottom of the parent. This is like nth-child, but counting from the back! Nth-of-type Selector with Formula :nth-of-type(An+B) The nth-of-type formula selects every nth element, starting the count at a specific instance of that element. span:nth-of-type(6n+2) selects every 6th instance of a span, starting from (and including) the second instance. :only-of-type Selects the only element of its type within another element. p span:only-of-type selects a span within any p if it is the only span in there. 兄弟元素选择器**选取后一个兄弟元素** 前一个 + 后一个 选取后边所有的兄弟元素 前一个 ~ 后边所有 否定伪类从一组元素中将符合要求的元素剔除出去 语法： :not(选择器) 例子： .abc:not(div) 样式的继承为祖先元素设置样式，会同时应用到它的后代元素上，这一特性称为样式的继承。 通过样式的继承可以将一些样式统一设置个祖先元素，这样所有的后代都会应用到相同的样式。 但是并不是所有的样式都会继承，比如：背景相关的，边框相关的，定位相关的。具体参考文档 选择器的优先级当使用选择器为元素设置样式时，如果样式发生了冲突，采用哪个样式由选择器的优先级（权重）来决定。 越精准，越优先 优先级 内联样式1000 id选择器100 类和伪类选择器10 元素选择器1 通配选择器0 继承的样式：没有优先级 当样式发生冲突时，需要将相关的选择器优先级进行求和计算，优先级高的优先显示，如果优先级一样，则显示靠后的样式（覆盖） 优先级计算时，总大小不能超过他的最大的数量级 可以在样式后边添加一个!important，如果样式中添加了该内容，则该样式将会获取最大的优先级，将会优先于所有的样式显示，包括内联样式，但是这个属性要慎用。 盒子模型CSS 框模型Box Model CSS中将每一个元素都设置为了一个矩形的盒子将所有的元素都设置为盒子，是为了方便页面的布局当这些元素都是盒子以后，我们的布局就变成了在页面中摆放盒子 盒子模型构成每个盒子都由如下几部分构成 4 内容区： content内容区相当于盒子存放东西的空间内容区在盒子的最里边元素的所有的子元素都是放在父元素的内容区内容区设置 1234width 内容区的宽度 height 内容区的高度 边框 border边框盒子可见框最外侧，边框是盒子的边缘设置边框设置边框需要同时设置三个样式，缺一不可border-width 边框的宽度 可以同时指定四个边框的宽度，也可以分别指定 规则 123456789101112四个值 border-width : 10px 20px 30px 40px; border-width : 上 右 下 左;(顺时针) 三个值 border-width : 10px 20px 30px; border-width : 上 左右 下; 两个值 border-width : 10px 20px; border-width : 上下 左右; 一个值 border-width : 10px; border-width : 上下左右; border-color 边框的颜色border-style 边框的样式除了这三个样式，CSS中还提供了 border-xxx-width border-xxx-color border-xxx-style xxx可以是 top right bottom left 通过这些样式可以单独指定四个边的颜色，宽度和样式边框的简写属性 12345border border-left border-top border-right border-bottom 12border: red solid 10px ; border-left: red solid 10px ; 这个几个属性可以同时设置边框相关的的样式border可以同时设置四个边的颜色，宽度，样式border-xxx可以单独设置某一个边规则 使用这些样式可以同时设置border-width border-style border-color，不同的属性使用空格隔开，并且没有顺序要求 内边距： padding内边距指的是内容区和边框之间的距离，内边距会影响盒子的大小盒子中一共有四个方向的内边距 1234padding-top padding-right padding-bottom padding-left padding 可以同时设置四个方向的内边距，规则和border-width一致 1234padding:上 右 下 左 padding:上 左右 下 padding:上下 左右 padding:上下左右 盒子的可见框大小由内容区、内边距和边框共同决定 外边距 margin外边距盒子和其他盒子之间的距离，外边距不会影响可见框的大小，但是会影响盒子的位置也是具有四个方向的外边距 1234margin-top margin-right margin-bottom margin-left 简写属性margin规则和padding一致margin值可以设置为auto 如果单独将左右外边距设置为auto，则会将左或右外边距设置为最大值 如果同时将左右外边距设置为auto，则会将左右外边距设置为一个相等的值，通过这种方式使一个子元素在它的父元素中水平居中 margin:0 auto可以设置为负值 如果将margin设置为负值，则元素会向相反的方向移动 外边距的重叠 相邻的垂直外边距会发生重叠现象 相邻元素的外边距会取最大值 子元素的外边距会传递给父元素 水平外边距不会重叠，而是取和 内联元素的盒子模型内联元素不能设置width和heightpadding 支持水平方向的padding 垂直方向的padding也支持，但是不会影响布局border 支持四个方向边框，但是垂直的边框不会影响布局margin 支持水平方向外边距，水平方向的相邻外边距不会重叠，而是求和 不支持垂直方向的盒模型相关的样式 CSS 定位属性（Positioning）display设置元素的显示类型可选值none 元素不会在页面中显示，并且不会占据页面的位置block 元素会作为块元素显示inline 元素会作为内联元素显示inline-block 元素会作为行内块元素显示 既具有内联元素的特点也具有块元素的特点 既不独占一行，又可以设置宽高 visibility设置元素是否在页面中显示可选值visible 默认值，元素在页面中正常显示hidden 元素不在页面中显示，但是依然在页面中占据位置 overflow设置元素如何处理溢出内容可选值visible 默认值，不会处理溢出的内容，在父元素以外的地方显示hidden 溢出的内容会被隐藏不会显示scroll 在父元素中同时添加水平和垂直方向的滚动条 不内容是否溢出都会添加滚动条auto 根据需要自动生成滚动条 布局文档流文档流指的是网页中的一个位置文档流是网页的基础，是网页的最底层，所有的元素默认都是在文档流中排列元素在文档流中默认自左向右，自上向下排列（和我们的书写习惯一致）块元素 1.块元素在文档流中自上向下排列 2.块元素在文档流中宽度默认是父元素的100%(auto) 3.块元素在文档流中高度默认被内容撑开内联元素 1.内联元素在文档流中自左向右排列，如果一行中不足以容下所有的内联元素，则换到下一行，继续自左至右排列 2.内联元素在文档流中宽度和高度默认都被内容撑开 浮动使用float来设置元素浮动可选值none 默认值，不浮动，元素在文档流中left 元素向左浮动right 元素向右浮动特点1.元素浮动以后会完全脱离文档流2.浮动以后元素会一直向父元素的最上方移动3.直到遇到父元素的边框或者其他的浮动元素，会停止移动4.如果浮动元素的上边是一个块元素，则浮动元素不会覆盖块元素5.浮动元素不会超过他上边的浮动的兄弟元素，最多一边齐6.浮动元素不会覆盖文字，文字会自动环绕在浮动元素的周围，可以通过浮动来实现文字环绕的效果浮动以后元素的特点元素浮动以后，会使其完全脱离文档流。块元素 块元素脱离文档流以后 1.不会独占一行 2.宽度和高度都被内容撑开内联元素 内联元素脱离文档流以后会变成块元素 高度塌陷父元素在文档流中高度默认是被子元素撑开的，当子元素脱离文档流以后，将无法撑起父元素的高度，也就会导致父元素的高度塌陷父元素的高度一旦塌陷所有元素的位置将会上移，导致整个页面的布局混乱 我们可以将父元素的高度写死，以避免塌陷的问题出现，但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。 方法一 开启父元素的BFC或hasLayoutBFC:Block Formatting Context,块级格式化环境 BFC是元素的隐含属性，默认是在关闭状态的可以通过一些特殊的样式，来开启BFC开启BFC以后元素将会具有如下特性1、父元素的垂直外边距不会与子元素重叠2、开启BFC的元素不会被浮动元素所覆盖3、开启BFC的元素可以包含浮动子元素 开启BFC的方式1.设置元素浮动 使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失 且使用这种方式也会导致下边的元素上移，不能解决问题2.设置元素绝对定位3.设置元素为inline-block 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式4.将元素的overflow设置为一个非visible的值 推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。 一般都是使用overflow:hidden来开启BFChasLayout 在IE6中没有BFC，但是有一个和BFC类似的hasLayout 在IE6中可以通过开启hasLayout来解决高度塌陷的问题 副作用最小的开启方式 zoom:1 当为元素设置宽度非默认值时，会自动开启hasLayout 方法二：清除浮动clear可以用来清除其他浮动元素对当前元素的影响可选值：none，默认值，不清除浮动left，清除左侧浮动元素对当前元素的影响right，清除右侧浮动元素对当前元素的影响both，清除两侧浮动元素对当前元素的影响 清除对他影响最大的那个元素的浮动清除浮动以后，元素会回到其他元素浮动之前的位置 塌陷的父元素的最后添加一个空白的div，然后对该div进行**清除浮动** 然基本没有副作用，使用这种方式会在页面中添加多余的结构 方法三用after伪类，向父元素后添加一个块元素，并对其清除浮动 种方式的原理和方法二原理一样，但是不用向页面中添加对于的结构,这是我们最推荐使用的方式，几乎没有副作用 12345678.clearfix:after&#123; /*添加一个内容*/ content: \"\"; /*转换为一个块元素*/ display: block; /*清除两侧的浮动*/ clear: both; &#125; 定位通过定位可以将页面中的元素，摆放到页面的任意位置使用position来设置元素的定位 123456789可选值 static 默认值，元素没有开启定位 relative 开启元素的相对定位 absolute 开启元素的绝对定位 fixed 开启元素的固定定位 偏移量当元素开启了定位以后，可以通过偏移量来设置元素的位置。 靠近中心是正数，远离是负数。 12345678left 元素距离定位位置的左侧距离 top 元素距离定位位置的上边距离 right 元素距离定位位置的右侧距离 bottom 元素距离定位位置的底部距离 一般情况下，只使用两个值即可定义一个元素的位置。 相对定位：ralative1.开启元素的相对定位后，如果不设置偏移量元素不会发生任何变化2.相对定位元素相对于其自身在文档流中的位置来定位3.相对定位的元素不会脱离文档流4.相对定位不会改变元素的性质，块元素还是块元素，内联元素还是内联元素5.相对定位的元素会提升一个层级，会覆盖其他元素 绝对定位： absolute1.元素设置绝对定位以后，如果不设置偏移量，元素的位置不会发生变化2.绝对定位的元素是相对于距离他最近的开启了定位的祖先元素进行定位（一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位，子绝父相），如果所有的祖先元素都没开启定位，则相对于浏览器窗口进行定位。3.绝对定位的元素会完全脱离文档流4.绝对定位会改变元素的性质。内联变块，块的高度和宽度都被内容撑开，并且不独占一行5.绝对定位会使元素提升一个层级，会覆盖其他元素 固定定位:fixed固定定位是一种特殊的绝对定位，它的特点大部分都和绝对定位一样.不同的是，固定定位的元素永远都是相对于浏览器窗口进行定位的。并且他不会随滚动条滚动IE6不支持固定定位 层级定位元素 &gt; 浮动元素 &gt; 文档流中的元素 如果定位元素的层级是一样，则下边的元素会盖住上边的 当元素开启了定位以后，可以通过z-index来设置元素的层级1.z-index值越高元素越优先显示2.如果z-index值一样，或者都没有z-index则优先显示下边的元素3.父元素永远不会盖住子元素 弹性(Flex)布局详见Flex笔记 其他 css属性cursor 属性https://www.w3school.com.cn/cssref/pr_class_cursor.asp 定义和用法cursor 属性规定要显示的光标的类型（形状）。 该属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状 transform 属性https://www.w3school.com.cn/cssref/pr_transform.asp transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。 设置元素的透明背景opacity可以用来设置元素背景的透明，它需要一个0-1之间的值 0 表示完全透明 1 表示完全不透明 0.5 表示半透明 opacity属性在IE8及以下的浏览器中不支持IE8及以下的浏览器需要使用如下属性代替alpha(opacity=透明度) filter: alpha(opacity=50);透明度，需要一个0-100之间的值 0 表示完全透明 100 表示完全不透明 50 半透明 background属性使用backgroundimage来设置背景图片 语法：backgroundimage:url(相对路径); 如果背景图片大于元素，默认会显示图片的左上角 如果背景图片和元素一样大，则会将背景图片全部显示 如果背景图片小于元素大小，则会默认将背景图片平铺以充满元素 可以同时为一个元素指定背景颜色和背景图片，这样背景颜色将会作为背景图片的底色一般情况下设置背景图片时都会同时指定一个背景颜色 1backgroundimage:url(img2.jpg); backgroundrepeat用于设置背景图片的重复方式可选值： repeat，默认值，背景图片会双方向重复（平铺） norepeat ，背景图片不会重复，有多大就显示多大 repeatx， 背景图片沿水平方向重复 repeaty，背景图片沿垂直方向重复 background-position背景图片默认是贴着元素的左上角显示通过background-position可以调整背景图片在元素中的位置可选值：该属性可以使用 top right left bottom center中的两个值 来指定一个背景图片的位置 top left 左上 bottom right 右下 如果只给出一个值，则第二个值默认是center 也可以直接指定两个偏移量， 第一个值是水平偏移量 如果指定的是一个正值，则图片会向右移动指定的像素 如果指定的是一个负值，则图片会向左移动指定的像素 第二个是垂直偏移量 如果指定的是一个正值，则图片会向下移动指定的像素 如果指定的是一个负值，则图片会向上移动指定的像素 background-attachment用来设置背景图片是否随页面一起滚动可选值： scroll，默认值，背景图片随着窗口滚动 fixed，背景图片会固定在某一位置，不随页面滚动 不随窗口滚动的图片，我们一般都是设置给body，而不设置给其他元素 当背景图片的backgroundattachment设置为fixed时，背景图片的定位永远相对于浏览器的窗口 backgroundattachment: fixed; 常用标签span没有任何的语义，span标签专门用来选中文字，然后为文字来设置样式 a元素可以包含任意元素，除了他本身 p元素不可以包含任何块元素 div这个标签没有任何语义，就是一个纯粹的块元素，并且不会为它里边的元素设置任何的默认样式， div元素主要用来对页面进行布局的 form表单表单的作用就是用来将用户信息提交给服务器的 比如：百度的搜索框 注册 登录这些操作都需要填写表单 使用form标签创建一个表单 action属性 *form标签中必须指定一个，该属性指向的是一个服务器的地址** 我们提交表单时将会提交到action属性对应的地址 input框 使用input来创建一个文本框，它的type属性是text 如果希望表单项中的数据会提交到服务器中，还必须给表单项指定一个name属性 name表示提交内容的名字 用户填写的信息会附在url地址的后边以查询字符串的形式发送给服务器 url地址?查询字符串格式： 属性名=属性值&amp;属性名=属性值&amp;属性名=属性值&amp;属性名=属性值在文本框中也可以指定value属性值，该值将会作为文本框的默认值显示 单选按钮 使用input来创建一个单选按钮，它的type属性使用radio 单选按钮通过name属性进行分组，name属性相同是一组按钮 像这种需要用户选择但是不需要用户直接填写内容的表单项， 还必须指定一个value属性，这样被选中的表单项的value属性值将会最终提交给服务器 如果希望在单选按钮或者是多选框中指定默认选中的选项， 则可以在希望选中的项中添加checked=”checked”属性 多选框 使用input创建一个多选框，它的type属性使用checkbox 下拉列表 使用select来创建一个下拉列表下拉列表的name属性需要指定给select，而value属性需要指定给option可以通过在option中添加selected=”selected”来将选项设置为默认选中 当为select添加一个multiple=”multiple”，则下拉列表变为一个多选的下拉列表 12345678910111213141516171819202122 你喜欢的明星 &lt;select name=\"star\"&gt; &lt;!-- 在select中可以使用optgroup对选项进行分组 同一个optgroup中的选项是一组 可以通过label属性来指定分组的名字 --&gt; &lt;optgroup label=\"女明星\"&gt; &lt;!-- 在下拉列表中使用option标签来创建一个一个列表项 --&gt; &lt;option value=\"fbb\"&gt;范冰冰&lt;/option&gt; &lt;option value=\"lxr\"&gt;林心如&lt;/option&gt; &lt;option value=\"zw\"&gt;赵薇&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=\"男明星\"&gt; &lt;option value=\"ldh\"&gt;刘德华&lt;/option&gt; &lt;option value=\"pcj\"&gt;潘长江&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt; &lt;br /&gt;&lt;br /&gt; textarea使用textarea创建一个文本域按钮 提交按钮可以将表单中的信息提交给服务器使用input创建一个提交按钮,它的type属性值是submit在提交按钮中可以通过value属性来指定按钮上的文字 可以创建一个重置按钮， 点击重置按钮以后表单中内容将会恢复为默认值 使用input type=button可以用来创建一个单纯的按钮， 这个按钮没有任何功能，只能被点击 除了使用input，也可以使用button标签来创建按钮这种方式和使用input类似，只不过由于它是成对出现的标签 使用起来更加的灵活 123&lt;button type=\"submit\"&gt;提交&lt;/button&gt; &lt;button type=\"reset\"&gt;重置&lt;/button&gt; &lt;button type=\"button\"&gt;按钮&lt;/button&gt; 标签label 在html中还为我们提供了一个标签，专门用来选中表单中的提示文字的label标签该标签可以指定一个for属性，该属性的值需要指定一个表单项的id值 在点击标签时，相当于对for的表单向选中 12&lt;label for=\"um\"&gt;用户名&lt;/label&gt; &lt;input id=\"um\" type=\"text\" name=\"username\" /&gt; &lt;br/&gt; fieldset 在表单中可以使用fieldset来为表单项进行分组，可以将表单项中的同一组放到一个fieldset中 12345678&lt;fieldset&gt; &lt;!-- 在fieldset可以使用legend子标签，来指定组名 --&gt; &lt;legend&gt;用户信息&lt;/legend&gt; &lt;label for=\"um\"&gt;用户名&lt;/label&gt; &lt;input id=\"um\" type=\"text\" name=\"username\" /&gt; &lt;br /&gt; &lt;label for=\"pwd\"&gt;密码 &lt;/label&gt; &lt;input id=\"pwd\" type=\"pwd\" name=\"password\"/&gt;&lt;br /&gt; &lt;/fieldset&gt; table表格CSS border-collapse 属性 123table&#123; border-collapse:collapse; &#125; separate 默认值。边框会被分开。不会忽略 border-spacing 和 empty-cells 属性。 collapse 如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性。 inherit 规定应该从父元素继承 border-collapse 属性的值。 标签的 colspan. rowspan 属性 值 描述 number 设置单元格可横跨的列(行）数。 caption 元素定义表格标题。caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。 列表列表就相当于去超市购物时的那个购物清单， 在HTML也可以创建列表，在网页中一共有三种列表： 1.无序列表 2.有序列表 3.定义列表 无序列表使用ul(unordered list)来创建一个无序列表，在列表中使用li来表示一个列表项无序列表使用符号作为项目符号序列表使用ol(ordered list)来创建一个无序列表，在列表中使用li来表示一个列表项使用有序的序号作为项目符号义列表表相关的元素都是块元素，他们之间可以互相嵌套除项目符号list-style:none frameset框架集框架集和内联框架的作用类似，都是用于在一个页面中引入其他的外部的页面， 框架集可以同时引入多个页面，而内联框架只能引入一个， 在h5标准中，推荐使用框架集，而不使用内联框架 使用frameset来创建一个框架集，注意frameset不能和body出现在同一个页面中 所以要使用框架集，页面中就不可以使用body标签 属性： rows，指定框架集中的所有的框架，一行一行的排列 cols， 指定框架集中的所有的页面，一列一列的排列 这两个属性frameset必须选择一个，并且需要在属性中指定每一部分所占的大小 frameset中也可以再嵌套frameset frameset和iframe一样，它里边的内容都不会被搜索引擎所检索， 所以如果搜索引擎检索到的页面是一个框架页的话，它是不能去判断里边的内容的使用框架集则意味着页面中不能有自己的内容，只能引入其他的页面，而我们每单独加载一个页面 浏览器都需要重新发送一次请求，引入几个页面就需要发送几次请求，用户的体验比较差如果非得用建议使用frameset而不使用iframe 1234567891011121314151617181920&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;frameset cols=\"30% , * , 30%\"&gt; &lt;!-- 在frameset中使用frame子标签来指定要引入的页面 引入几个页面就写几个frame --&gt; &lt;frame src=\"table.html\" /&gt; &lt;frame src=\"form.html\" /&gt; &lt;!-- 嵌套一个frameset --&gt; &lt;frameset rows=\"30%,50%,*\"&gt; &lt;frame src=\"04.表格的布局.html\" /&gt; &lt;frame src=\"05.完善clearfix.html\" /&gt; &lt;frame src=\"06.表单.html\" /&gt; &lt;/frameset&gt; &lt;/frameset&gt; &lt;/html&gt; meCSS3 @media 查询如果文档宽度小于 300 像素则修改背景颜色(background-color): 12345@media screen and (max-width: 300px) &#123; body &#123; background-color:lightblue; &#125; &#125; min-height 属性设置元素的最小高度。设置以后：不能修改为小于此高度的距离 css hack 能有效识别低版本ie，具体八度 clearfix 1234567891011121314151617解决父子元素的外边距重叠 .box1:before&#123; content: \"\"; display:table可以将一个元素设置为表格显示 display: table; &#125; 解决父元素高度塌陷 .clearfix:after&#123; content: \"\"; display: block; clear: both; &#125; 经过修改后的clearfix是一个多功能的既可以解决高度塌陷，又可以确保父元素和子元素的垂直外边距不会重叠 123456.clearfix:before, .clearfix:after&#123; content: \"\"; display: table; clear: both; &#125; 长表格有一些情况下表格是非常的长的， 这时就需要将表格分为三个部分，表头，表格的主体，表格底部在HTML中为我们提供了三个标签： thead 表头 tbody 表格主体 tfoot 表格底部 这三个标签的作用，就来区分表格的不同的部分，他们都是table的子标签， 都需要直接写到table中，tr需要写在这些标签当中 thead中的内容，永远会显示在表格的头部tfoot中的内容，永远都会显示表格的底部tbody中的内容，永远都会显示表格的中间 如果表格中没有写tbody，浏览器会自动在表格中添加tbody并且将所有的tr都放到tbody中，所以注意tr并不是table的子元素，而是tbody的子元素通过table &gt; tr 无法选中行 需要通过tbody &gt; tr css精灵图CSS-Sprite 做完功能以后，发现在第一次切换图片时，会发现图片有一个非常快的闪烁，这个闪烁会造成一次不佳的用户体验。产生问题的原因：背景图片是以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独的发送一次请求，但是我们外部资源并不是同时加载，浏览器会在资源被使用才去加载资源我们这个练习，一上来浏览器只会加载link.png由于hover和active的状态没有马上触发， 所以hover.png和active.png并不是立即加载的当hover被触发时，浏览器才去加载hover.png当active被触发时，浏览器才去加载active.png由于加载图片需要一定的时间，所以在加载和显示过程会有一段时间，背景图片无法显示，导致出现闪烁的情况 为了解决该问题，可以将三个图片整合为一张图片，这样可以同时将三张图片一起加载，就不会出现闪烁的问题了，然后在通过background-position来切换要显示的图片的位置，这种技术叫做图片整合技术（CSS-Sprite,css精灵图）优点： 1 将多个图片整合为一张图片里，浏览器只需要发送一次请求，可以同时加载多个图片， 提高访问效率，提高了用户体验。 2 将多个图片整合为一张图片，减小了图片的总大小，提高请求的速度，增加了用户体验 title属性**，这个属性可以给任何标签指定当鼠标移入到元素上时，元素中的title属性的值将会作为提示文字显示 我是一个段落 ### **浏览器默认样式** 浏览器为了在页面中没有样式时，也可以有一个比较好的显示效果，所以为很多的元素都设置了一些默认的margin和padding，而它的这些默认样式，正常情况下我们是不需要使用的。所以我们往往在编写样式之前需要将浏览器中的默认的margin和padding统统的去掉清除浏览器的默认样式 1234*&#123; margin: 0; padding: 0; &#125; 这种方式支持IE6，但是这种效果在IE Tester中无法测试","categories":[{"name":"前端","slug":"前端","permalink":"https://codeofli.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://codeofli.github.io/tags/前端/"},{"name":"html","slug":"html","permalink":"https://codeofli.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"https://codeofli.github.io/tags/css/"}]},{"title":"git","slug":"git/git","date":"2019-10-13T14:19:09.000Z","updated":"2021-10-23T02:19:02.842Z","comments":true,"path":"2019/10/git/git/","link":"","permalink":"https://codeofli.github.io/2019/10/git/git/","excerpt":"[TOC]特点：分布式版本控制系统优势： SVN在开发过程中必须保证需要与SVN服务器连接才能使用，需要联网git官方文档基础操作1、设置全局信息1234567设置开发者的用户名 git config --global user.name nicolas设置开发者邮箱 git config --global user.email 1162314270@qq.com取得全部的全局信息 git config --list git config -l","text":"[TOC]特点：分布式版本控制系统优势： SVN在开发过程中必须保证需要与SVN服务器连接才能使用，需要联网git官方文档基础操作1、设置全局信息1234567设置开发者的用户名 git config --global user.name nicolas设置开发者邮箱 git config --global user.email 1162314270@qq.com取得全部的全局信息 git config --list git config -l 2、创建仓库1、创建目录当做仓库目录2、进入目录中配置将目录变为仓库目录，需要进入目录中配置3、初始化仓库方法一：创建一个包含有配置信息目录的仓库文件夹 12git initInitialized empty Git repository in E:/gitpro/.git/ 文件区域 工作区用户编写代码的文件夹所有的文件操作以工作区为主GIT仓库 暂存库只是将工作中的未保存文件保存到暂存区中，有GIT维护；保存的内容是暂时需要的 版本库Master 真正发布的代码 git stage 3、仓库基本操作1、观察仓库的状态 1git status 2、将文件添加到git暂存区 1git add 文件名称 4、批量添加新文件到暂存区 1git add . 添加所有在仓库目录中创建的新文件到暂存区3、将文件提交到版本库中 1git commit -m \"注释信息Comment\" 现在才表示将新的文件提交到了GIT之中进行管理（这个代码才能被项目使用）自动增加并提交修改到版本库中 1git commit -a -m \"注释Comment\" 4、修改仓库文件 ​ 查看修改历史 12git log 文件名git log ​ 每次提交时都会自动生成一个Commit ID（在日后版本恢复中使用） 比较同一文件12git diffgit diff 文件名 比对暂存区和工作区中readme.txt文件的差异 版本穿越​ 查看日志信息 12git loggit log --pretty=oneline 简化查看可以按q结束查看整个日志记录是用栈来记录的master库存在head指针回退到上一个版本 1git reset --hard head~1 查看所有删除的日志 1git reflog ​ 到指定版本 1git reset --hard 1fc9d3f（Commit id） 撤销修改撤销工作区修改显示那些文件发生了改变 1git checkout 恢复单个文件 1git checkout 文件名 恢复多个文件 1git checkout . 修改已在暂存区将暂存区的文件撤回到工作区 1git reset HEAD &lt;file&gt;... 将暂存区的文件撤回到工作区 :多个文件 1git reset HEAD . 文件删除 1del 文件名 删除工作区中的文件恢复 1git checkout -- 文件名 ​ 因为版本库中任存在，可以直接删除​ git commit -a -m “Commet”​ 提交之后，库中相应的文件也没有了​ 只能通过版本穿越恢复 远程仓库：GITHUB … git-book:github章节 远程仓库的使用git-book:Git-基础-远程仓库的使用 problemgithub每次push都要密码 原因是使用了https方式 push这种方式产生的原因，一般是我们clone是一定是使用了http的方式例如我们在github上创建了一个项目，然后我们clone到本地时使用了http而非git (ssh) 12git remote rm origingit remote add origin git@github.com:codeOflI/MyDouban.git 查看远程仓库1git remote [-v] 选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 添加远程仓库git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库 1git remote add origin https://github.com/codeOflI/rep.git 从远程仓库中抓取与拉取这个命令会访问远程仓库，从中拉取所有你还没有的数据。 1git fetch [remote-name] 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 Git 分支 了解更多信息），可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程仓库git push [remote-name] [branch-name]。 当你想要将 master 分支推送到 origin 服务器时 1git push origin master 查看某个远程仓库使用 git remote show [remote-name] 命令 可以通过 git remote show 看到更多的信息。 远程仓库的移除与重命名如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做： 1234$ git remote rename pb paul$ git remoteoriginpaul 移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 git remote rm ： 123$ git remote rm paul$ git remoteorigin 打标签Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 列出标签https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE 配置远程仓库ssh通信模式1.启动git bash 在此之中可以使用linux命令2、生成ssh key密钥 1ssh-keygen -t rsa -C &quot;1162314270@qq.com&quot; 1234命令输入后，首先询问用户密钥的保存位置 /c/Users/11623/.ssh/id_rsa 默认为公钥和私钥保存在：用户/.ssh/id_rsa瑞后询问是否设置保护密码 3、将公钥内容保存到GITHUB 公钥文件，保存在外部使用==(保存到github的ssh密匙中)== id_rsa.pub 私钥文件，做本机标识 id_rsa 打开github的setting页面添加ssh key 将公钥内容复制到key内容中 1ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDDaUZOQterXD2TZWb9VMO/s4jaIBIp0GIlsBlMZ+fl50NWbua4R8EtudIPIiMDGxsE7UmE/HGBMedsCjo1nS6h5OLz9ZT0n5h4FYOqurQWsyfdm+tgZK5mK/t1e93WlF+cjja+KiCMbntMYq7o/FGPWnlFlfiz9KiVos+oRWgC3RUx4hDqZoKFmfTxAiXQMJy2/pVYmHqliZ9+6mOvRJoe2C1mmTClTU5y9KLw8AWF0jTykUAeAfZjX1lwub8xkJ34QSNZFaBiouWcA7sz/Qa8kDGdFbZwR41Ugc+P4KYli72pecsbj2eVTZoHuCkW5GxxupV9jSbj/MePZPHHhhdH lmz 1234567891011121314151617181920212223C:\\Users\\11623&gt;ssh-keygen -t rsa -C \"lmz\"Generating public/private rsa key pair.Enter file in which to save the key (C:\\Users\\11623/.ssh/id_rsa):C:\\Users\\11623/.ssh/id_rsa already exists.Overwrite (y/n)? yEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in C:\\Users\\11623/.ssh/id_rsa.Your public key has been saved in C:\\Users\\11623/.ssh/id_rsa.pub.The key fingerprint is:SHA256:722mRw92N2R2fb71Yr3tBEgSQORYxzzzF6n4xRkh7Mk lmzThe key's randomart image is:+---[RSA 2048]----+| o=+o.. .o || + .=...+ || . . .B.+ +.|| .oE.=++|| S ..o=.o|| . = .o+|| .o + o*|| . .+ +o+|| o=.. ++|+----[SHA256]-----+ 4、在github上建立远程仓库信息 不选择：Initialize this repository with a README 创建仓库后界面上就给出了仓库的访问地址 SSH，有了SSH key直接连接 https://github.com/NicolasCoder/rep.git HRRPS,所有人都可以连接 https://github.com/NicolasCoder/rep.git删除github仓库 仓库的setting 客服端访问本地代码同步到远程仓库中 12345Either specify the URL from the command-line or configure a remote repository using git remote add &lt;name&gt; &lt;url&gt;and then push using the remote name git push &lt;name&gt; 2、连接成功后将本地仓库全部代码推送到服务器端 1git push -u origin master 强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容 12git push -fgit push -u origin master -f ：使用这个强制的方法 1git pull origin master --allow-unrelated-histories 后面加上 --allow-unrelated-histories ， 把两段不相干的 分支进行强行合并 提高本地修改 首先将修改提高到master分支上，然后推送代码到服务器 3、git pull的作用是从一个仓库或者本地的分支拉取并且整合代码。 1git pull [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…]] 实例：默认使用方式 1git pull 按照git branch 设置的默认跟踪的服务器和分支来拉取。 实例： 拉取远程服务器origin的master分支 1git pull origin master 删除远程分支 1git remote rm origin 克隆远程仓库已经初始化完成的仓库 已执行 Initialize this repository with a README克隆远程仓库：（直接在当前目录新建远程仓库的项目文件） 1git clone （HTTPS）https://github.com/codeOflI/ssm-crud ​ GIT分支1).基础操作1、查看当前仓库中可用的分支 1git branch 2、创建新的分支 1git branch 分支名 3、切换分支 1git checkout 分支名 要想进行开发，一定不能再master中开发，必须在子分支开发回到master进行合并分支 1git merge dev ​ 合并后提示Fast-forward​ 快速合并方式一般开发分支和master分支都在服务器上 1git push -u origin 分支名 删除分支 1git branch -d 分支名 删除远程分支 1git push origin --delete 分支名 推送空的分支 1git push origin:dev 2）合并操作冲突解决 创建并切换到dev分支 1git checkout -b dev 两个分支修改了同一文件 提交到master后会提示conflict和文件名 打开文件会发现相应的冲突都写在了里面 修改后再次提交即可分支合并模式 通过图形化的方式查看所有分支合并记录 1git log --graph --pretty=oneline 1Fast forwaed(默认)合并 ​ 不会产生新的提交点添加参数 -no-ff(Not Fast Forward)​ 1git merge --no-ff -m \"use no-ff merge\" dev –no-ff的作用： git merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。 git merge 则不会显示 feature，只保留单条分支记录。 ​ master不予许修改，dev分支如果有多人共享，需要在创建自己的分支在进行开发，合并时使用no-ff方式bug分支,暂挂工作区​ 有错误的代码不能保存在暂存区​ 保存当前工作区的状态​ git stash​ 查看所有暂时挂起的工作区​ git stash list​ 两步​ 恢复挂起的工作区​ git stash apply​ 清除保存的工作区​ git stash drop​ 一步​ 恢复并清除保存区​ git stash popfeature,扩展分支​ 已经开发，但不准备使用的功能等​ 强制删除有不同修改的分支​ git branch -D feature补丁 比较分支区别​ git diff master &gt; patch​ 通过命令行的管道流，将diff保存再来patch文件里​ 通过补丁合并分支​ git apply patch​ 当项目很大的时候，效率更高​ 不便于开发者沟通​ git format-patch -M master​ 通知master​ 应用分支补丁​ git am （补丁路劲）”E:\\gitpro\\0001-git-apply-patch.patch” orphan分支创建一个新的分支（空）而不是从原分支拷贝 1git checkout --orphan branchName 可以将A和B两个完全不同的工程，可以作为两个分支放到git中。 这时候还是一个分支 12git branchmaster 1.创建orphan分支，名为dev（本地和远程都需要) 1$ git checkout --orphan dev 注： 如果不提交东西，这个分支实际上没有创建 2.修改一些东西，并提交 注意： 远程分支和本地分支保持名称一致，可减少不必要麻烦 123$ git add .$ git commit -m &quot;init&quot;$ git push origin dev 注： git push origin source表示把本地代码（origin）提交到source分支 git push origin master表示把本地代码（origin）提交到master分支 3.现在就有两个分支了master和source .gitignore的操作1234567下面是一些.gitignore文件忽略的匹配规则：*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 目的是忽略指定类型的文件或者某个文件夹 a、新建.gitignore文件： b、输入要忽略的文件（可用通配符） 利用git status 查看，可以看出排除了写入的文件，避免了其提交 12345678910111213141516171819202122232425262728293031323334353637HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**!**/src/test/**### xxx ###application.properties### STS ###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache### IntelliJ IDEA ###.idea*.iws*.iml*.ipr.mvn/mvnwmvnw.cmd### NetBeans ###/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/### VS Code ###.vscode/ 删除git上已经提交的文件1.先查看有哪些文件可以删除,但是不真执行删除 1git rm -r -n job-executor-common/target/* -r 递归移除目录 -n 加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览，所以一般用这个参数先看看要删除哪些文件，防止误删，确认之后，就去掉此参数，真正的删除文件。 上面这个命令就是先查看 job-executor-common/target/* 下有哪些可以删除的内容 2.执行删除 1git rm -r job-executor-common/target/* 此时,就把指定目录下所有内容从本地版本库中删除了 如果只想从版本库中删除,但是本地仍旧保留的话,加上 –cached 参数 1git rm -r --cached job-executor-common/target/* 3.删除远程版本库中的文件 再执行提交操作即可 12git commit -m\"移除target目录下所有文件\"git push origin dev其中origin dev为分支名称 git-me开发时不使用master(保存)分支 开发时添加大型文件，如果在主分支添加，将很难删除其占用的空间，通过合并分支，或者删除分支，很容易办到。 添加大型文件请慎重git commit之后git会保存此时所有文件，如果此时添加了不必要的大型文件，会不必要的增加文件大小。特别是master分支。 [https://git-scm.com/docs/git-checkout]: githubGithub 网页上 更新 Fork别人的 Repository github查看代码方式： github.com改成github1s.com /github1s.com/codeOflI/JudgeServer/blob/HEAD/src/main/java/com/yoj/judge_server/aspect/JudgePermitAspect.java","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"varay","slug":"v2ray/v2ray","date":"2019-10-13T14:19:09.000Z","updated":"2021-10-23T02:19:04.297Z","comments":true,"path":"2019/10/v2ray/v2ray/","link":"","permalink":"https://codeofli.github.io/2019/10/v2ray/v2ray/","excerpt":"[TOC]github仓库v2ray.comV2Ray一键安装脚本首先买个服务器解析域名能在国内ping到当前服务器1lmz.mookeyes.tk1ping ow.yestojudge.cnlinux 安装脚本1bash &lt;(curl -s -L https://git.io/v2ray.sh)","text":"[TOC]github仓库v2ray.comV2Ray一键安装脚本首先买个服务器解析域名能在国内ping到当前服务器1lmz.mookeyes.tk1ping ow.yestojudge.cnlinux 安装脚本1bash &lt;(curl -s -L https://git.io/v2ray.sh) 自行配置 12(默认协议: TCP):4 V2Ray 传输协议 = WebSocket + TLS 1234567891011121314151617---------- 安装信息 ------------- V2Ray 传输协议 = WebSocket + TLS V2Ray 端口 = 56911 你的域名 = lmz.yestojudge.cn 域名解析 = 我确定已经有解析了 自动配置 TLS = 打开 路径分流 = /233blog 是否配置 Shadowsocks = 未配置---------- END ------------- 123456789101112131415161718192021222324..由于你的 VPS 内核支持开启 BBR ...已经为你启用 BBR 优化....---------- V2Ray 配置信息 ------------- 地址 (Address) = lmz.yestojudge.cn 端口 (Port) = 443 用户ID (User ID / UUID) = 347b6ad3-8e14-492a-b05f-241cf9679401 额外ID (Alter Id) = 233 传输协议 (Network) = ws 伪装类型 (header type) = none 伪装域名 (host) = lmz.yestojudge.cn 路径 (path) = /233blog TLS (Enable TLS) = 打开---------- END ------------- 123456789101112131415161718192021---------- V2Ray 配置信息 ------------- 地址 (Address) = lmz.yestojudge.cn 端口 (Port) = 443 用户ID (User ID / UUID) = c0cc4cce-0993-4b40-a956-162ebee3d3e2 额外ID (Alter Id) = 233 传输协议 (Network) = ws 伪装类型 (header type) = none 伪装域名 (host) = lmz.yestojudge.cn 路径 (path) = /233blog TLS (Enable TLS) = 打开---------- END ------------- 获取连接1v2ray url 12345678910111213141516171819202122232425---------- V2Ray 配置信息 ------------- 地址 (Address) = lmz.mookeyes.tk 端口 (Port) = 443 用户ID (User ID / UUID) = d18116c8-8535-470b-80be-47aae169c2b3 额外ID (Alter Id) = 233 传输协议 (Network) = ws 伪装类型 (header type) = none 伪装域名 (host) = lmz.mookeyes.tk 路径 (path) = /233blog TLS (Enable TLS) = 打开---------- END -------------V2Ray 客户端使用教程: https://233v2.com/post/4/提示: 输入 v2ray url 可生成 vmess URL 链接 / 输入 v2ray qr 可生成二维码链接 v2ray局域网共享如果多个设备连接同一个wifi也在同一个局域网。但v2ray的局域网共享有独有的端口，故最好用设备（手机、电脑设置热点）。 1首先在相应开启热点设备的v2ray的软件上开启局域网代理选项 ipad在其连接wifi（无限局域网）中设置代理为手动并输入设备（设置热点的手机、电脑）的ip和v2ray监控的端口（通常默认为10809）， MyProblem:ListenIP6 https://www.linodovultr.com/post/resolve-v2ray-after-install-can-not-connect.html?replytocom=69 时间不同步，误差要小于90shttps://www.529i.com/archives/363.html 12date -R #查看系统时间dpkg-reconfigure tzdata #设置时区 1date -s \"2020-05-10 9:05:30\" #设置时间 123456hwclock --systohc #同步到硬件时间hwclock #chak查看硬件时间service v2ray stopservice v2ray start Ubuntu 18.04/18.10快速开启Google BBR的方法https://www.moerats.com/archives/612/ 12root@nicolas:~# cat /etc/issueUbuntu 18.04.2 LTS \\n \\l","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"OnJava8-appendix","slug":"java-note/OnJava8/OnJava8-appendix","date":"2019-10-13T14:19:09.000Z","updated":"2021-10-23T02:19:02.852Z","comments":true,"path":"2019/10/java-note/OnJava8/OnJava8-appendix/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/OnJava8/OnJava8-appendix/","excerpt":"[TOC]附录:流式IO Java 7 引入了一种简单明了的方式来读写文件和操作目录。大多情况下，文件这一章所介绍的那些库和技术就足够你用了。但是，如果你必须面对一些特殊的需求和比较底层的操作，或者处理一些老版本的代码，那么你就必须了解本附录中的内容。 对于编程语言的设计者来说，实现良好的输入/输出（I/O）系统是一项比较艰难的任务，不同实现方案的数量就可以证明这点。其中的挑战似乎在于要涵盖所有的可能性，你不仅要覆盖到不同的 I/O 源和 I/O 接收器（如文件、控制台、网络连接等），还要实现多种与它们进行通信的方式（如顺序、随机访问、缓冲、二进制、字符、按行和按字等）。","text":"[TOC]附录:流式IO Java 7 引入了一种简单明了的方式来读写文件和操作目录。大多情况下，文件这一章所介绍的那些库和技术就足够你用了。但是，如果你必须面对一些特殊的需求和比较底层的操作，或者处理一些老版本的代码，那么你就必须了解本附录中的内容。 对于编程语言的设计者来说，实现良好的输入/输出（I/O）系统是一项比较艰难的任务，不同实现方案的数量就可以证明这点。其中的挑战似乎在于要涵盖所有的可能性，你不仅要覆盖到不同的 I/O 源和 I/O 接收器（如文件、控制台、网络连接等），还要实现多种与它们进行通信的方式（如顺序、随机访问、缓冲、二进制、字符、按行和按字等）。 Java 类库的设计者通过创建大量的类来解决这一难题。一开始，你可能会对 Java I/O 系统提供了如此多的类而感到不知所措。Java 1.0 之后，Java 的 I/O 类库发生了明显的改变，在原来面向字节的类中添加了面向字符和基于 Unicode 的类。在 Java 1.4 中，为了改进性能和功能，又添加了 nio 类（全称是 “new I/O”，Java 1.4 引入，到现在已经很多年了）。这部分在附录：新 I/O 中介绍。 因此，要想充分理解 Java I/O 系统以便正确运用它，我们需要学习一定数量的类。另外，理解 I/O 类库的演化过程也很有必要，因为如果缺乏历史的眼光，很快我们就会对什么时候该使用哪些类，以及什么时候不该使用它们而感到困惑。 编程语言的 I/O 类库经常使用流这个抽象概念，它将所有数据源或者数据接收器表示为能够产生或者接收数据片的对象。 注意：Java 8 函数式编程中的 Stream 类和这里的 I/O stream 没有任何关系。这又是另一个例子，如果再给设计者一次重来的机会，他们将使用不同的术语。 I/O 流屏蔽了实际的 I/O 设备中处理数据的细节： 字节流对应原生的二进制数据； 字符流对应字符数据，它会自动处理与本地字符集之间的转换； 缓冲流可以提高性能，通过减少底层 API 的调用次数来优化 I/O。 从 JDK 文档的类层次结构中可以看到，Java 类库中的 I/O 类分成了输入和输出两部分。在设计 Java 1.0 时，类库的设计者们就决定让所有与输入有关系的类都继承自 InputStream，所有与输出有关系的类都继承自 OutputStream。所有从 InputStream 或 Reader 派生而来的类都含有名为 read() 的基本方法，用于读取单个字节或者字节数组。同样，所有从 OutputStream 或 Writer 派生而来的类都含有名为 write() 的基本方法，用于写单个字节或者字节数组。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口。 我们很少使用单一的类来创建流对象，而是通过叠合多个对象来提供所期望的功能（这是装饰器设计模式）。为了创建一个流，你却要创建多个对象，这也是 Java I/O 类库让人困惑的主要原因。 这里我只会提供这些类的概述，并假定你会使用 JDK 文档来获取它们的详细信息（比如某个类的所以方法的详细列表）。 输入流类型InputStream 表示那些从不同数据源产生输入的类，如表 I/O-1 所示，这些数据源包括： 字节数组； String 对象； 文件； “管道”，工作方式与实际生活中的管道类似：从一端输入，从另一端输出； 一个由其它种类的流组成的序列，然后我们可以把它们汇聚成一个流； 其它数据源，如 Internet 连接。 每种数据源都有相应的 InputStream 子类。另外，FilterInputStream 也属于一种 InputStream，它的作用是为“装饰器”类提供基类。其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起，这个我们稍后再讨论。 表 I/O-1 InputStream 类型 类 功能 构造器参数 如何使用 ByteArrayInputStream 允许将内存的缓冲区当做 InputStream 使用 缓冲区，字节将从中取出 作为一种数据源：将其与 FilterInputStream 对象相连以提供有用接口 StringBufferInputStream 将 String 转换成 InputStream 字符串。底层实现实际使用 StringBuffer 作为一种数据源：将其与 FilterInputStream 对象相连以提供有用接口 FileInputStream 用于从文件中读取信息 字符串，表示文件名、文件或 FileDescriptor 对象 作为一种数据源：将其与 FilterInputStream 对象相连以提供有用接口 PipedInputStream 产生用于写入相关 PipedOutputStream 的数据。实现“管道化”概念 PipedOutputSteam 作为多线程中的数据源：将其与 FilterInputStream 对象相连以提供有用接口 SequenceInputStream 将两个或多个 InputStream 对象转换成一个 InputStream 两个 InputStream 对象或一个容纳 InputStream 对象的容器 Enumeration 作为一种数据源：将其与 FilterInputStream 对象相连以提供有用接口 FilterInputStream 抽象类，作为“装饰器”的接口。其中，“装饰器”为其它的 InputStream 类提供有用的功能。见表 I/O-3 见表 I/O-3 见表 I/O-3 输出流类型如表 I/O-2 所示，该类别的类决定了输出所要去往的目标：字节数组（但不是 String，当然，你也可以用字节数组自己创建）、文件或管道。 另外，FilterOutputStream 为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来，这些稍后会讨论。 表 I/O-2：OutputStream 类型 类 功能 构造器参数 如何使用 ByteArrayOutputStream 在内存中创建缓冲区。所有送往“流”的数据都要放置在此缓冲区 缓冲区初始大小（可选） 用于指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用接口 FileOutputStream 用于将信息写入文件 字符串，表示文件名、文件或 FileDescriptor 对象 用于指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用接口 PipedOutputStream 任何写入其中的信息都会自动作为相关 PipedInputStream 的输出。实现“管道化”概念 PipedInputStream 指定用于多线程的数据的目的地：将其与 FilterOutputStream 对象相连以提供有用接口 FilterOutputStream 抽象类，作为“装饰器”的接口。其中，“装饰器”为其它 OutputStream 提供有用功能。见表 I/O-4 见表 I/O-4 见表 I/O-4 添加属性和有用的接口装饰器在泛型这一章引入。Java I/O 类库需要多种不同功能的组合，这正是使用装饰器模式的原因所在[^1]。而之所以存在 filter（过滤器）类，是因为让抽象类 filter 作为所有装饰器类的基类。装饰器必须具有和它所装饰对象相同的接口，但它也可以扩展接口，不过这种情况只发生在个别 filter 类中。 但是，装饰器模式也有一个缺点：在编写程序的时候，它给我们带来了相当多的灵活性（因为我们可以很容易地对属性进行混搭），但它同时也增加了代码的复杂性。Java I/O 类库操作不便的原因在于：我们必须创建许多类（“核心” I/O 类型加上所有的装饰器）才能得到我们所希望的单个 I/O 对象。 FilterInputStream 和 FilterOutputStream 是用来提供装饰器类接口以控制特定输入流 InputStream 和 输出流 OutputStream 的两个类，但它们的名字并不是很直观。FilterInputStream 和 FilterOutputStream 分别从 I/O 类库中的基类 InputStream 和 OutputStream 派生而来，这两个类是创建装饰器的必要条件（这样它们才能为所有被装饰的对象提供统一接口）。 通过 FilterInputStream 从 InputStream 读取FilterInputStream 类能够完成两件截然不同的事情。其中，DataInputStream 允许我们读取不同的基本数据类型和 String 类型的对象（所有方法都以 “read” 开头，例如 readByte()、readFloat()等等）。搭配其对应的 DataOutputStream，我们就可以通过数据“流”将基本数据类型的数据从一个地方迁移到另一个地方。具体是那些“地方”是由表 I/O-1 中的那些类决定的。 其它 FilterInputStream 类则在内部修改 InputStream 的行为方式：是否缓冲，是否保留它所读过的行（允许我们查询行数或设置行数），以及是否允许把单个字符推回输入流等等。最后两个类看起来就像是为了创建编译器提供的（它们被添加进来可能是为了对“用 Java 构建编译器”实现提供支持），因此我们在一般编程中不会用到它们。 在实际应用中，不管连接的是什么 I/O 设备，我们基本上都会对输入进行缓冲。所以当初 I/O 类库如果能默认都让输入进行缓冲，同时将无缓冲输入作为一种特殊情况（或者只是简单地提供一个方法调用），这样会更加合理，而不是像现在这样迫使我们基本上每次都得手动添加缓冲。 表 I/O-3：FilterInputStream 类型 类 功能 构造器参数 如何使用 DataInputStream 与 DataOutputStream 搭配使用，按照移植方式从流读取基本数据类型（int、char、long 等） InputStream 包含用于读取基本数据类型的全部接口 BufferedInputStream 使用它可以防止每次读取时都得进行实际写操作。代表“使用缓冲区” InputStream，可以指定缓冲区大小（可选） 本质上不提供接口，只是向进程添加缓冲功能。与接口对象搭配 LineNumberInputStream 跟踪输入流中的行号，可调用 getLineNumber() 和 setLineNumber(int) InputStream 仅增加了行号，因此可能要与接口对象搭配使用 PushbackInputStream 具有能弹出一个字节的缓冲区，因此可以将读到的最后一个字符回退 InputStream 通常作为编译器的扫描器，我们可能永远也不会用到 通过 FilterOutputStream 向 OutputStream 写入与 DataInputStream 对应的是 DataOutputStream，它可以将各种基本数据类型和 String 类型的对象格式化输出到“流”中，。这样一来，任何机器上的任何 DataInputStream 都可以读出它们。所有方法都以 “write” 开头，例如 writeByte()、writeFloat() 等等。 PrintStream 最初的目的就是为了以可视化格式打印所有基本数据类型和 String 类型的对象。这和 DataOutputStream 不同，后者的目的是将数据元素置入“流”中，使 DataInputStream 能够可移植地重构它们。 PrintStream 内有两个重要方法：print() 和 println()。它们都被重载了，可以打印各种各种数据类型。print() 和 println() 之间的差异是，后者在操作完毕后会添加一个换行符。 PrintStream 可能会造成一些问题，因为它捕获了所有 IOException（因此，我们必须使用 checkError() 自行测试错误状态，如果出现错误它会返回 true）。另外，PrintStream 没有处理好国际化问题。这些问题都在 PrintWriter 中得到了解决，这在后面会讲到。 BufferedOutputStream 是一个修饰符，表明这个“流”使用了缓冲技术，因此每次向流写入的时候，不是每次都会执行物理写操作。我们在进行输出操作的时候可能会经常用到它。 表 I/O-4：FilterOutputStream 类型 类 功能 构造器参数 如何使用 DataOutputStream 与 DataInputStream 搭配使用，因此可以按照移植方式向流中写入基本数据类型（int、char、long 等） OutputStream 包含用于写入基本数据类型的全部接口 PrintStream 用于产生格式化输出。其中 DataOutputStream 处理数据的存储，PrintStream 处理显示 OutputStream，可以用 boolean 值指示是否每次换行时清空缓冲区（可选） 应该是对 OutputStream 对象的 final 封装。可能会经常用到它 BufferedOutputStream 使用它以避免每次发送数据时都进行实际的写操作。代表“使用缓冲区”。可以调用 flush() 清空缓冲区 OutputStream，可以指定缓冲区大小（可选） 本质上并不提供接口，只是向进程添加缓冲功能。与接口对象搭配 Reader和WriterJava 1.1 对基本的 I/O 流类库做了重大的修改。你初次遇到 Reader 和 Writer 时，可能会以为这两个类是用来替代 InputStream 和 OutputStream 的，但实际上并不是这样。尽管一些原始的“流”类库已经过时了（如果使用它们，编译器会发出警告），但是 InputStream 和 OutputStream 在面向字节 I/O 这方面仍然发挥着极其重要的作用，而 Reader 和 Writer 则提供兼容 Unicode 和面向字符 I/O 的功能。另外： Java 1.1 往 InputStream 和 OutputStream 的继承体系中又添加了一些新类，所以这两个类显然是不会被取代的； 有时我们必须把来自“字节”层级结构中的类和来自“字符”层次结构中的类结合起来使用。为了达到这个目的，需要用到“适配器（adapter）类”：InputStreamReader 可以把 InputStream 转换为 Reader，而 OutputStreamWriter 可以把 OutputStream 转换为 Writer。 设计 Reader 和 Writer 继承体系主要是为了国际化。老的 I/O 流继承体系仅支持 8 比特的字节流，并且不能很好地处理 16 比特的 Unicode 字符。由于 Unicode 用于字符国际化（Java 本身的 char 也是 16 比特的 Unicode），所以添加 Reader 和 Writer 继承体系就是为了让所有的 I/O 操作都支持 Unicode。另外，新类库的设计使得它的操作比旧类库要快。 数据的来源和去处几乎所有原始的 Java I/O 流类都有相应的 Reader 和 Writer 类来提供原生的 Unicode 操作。但是在某些场合，面向字节的 InputStream 和 OutputStream 才是正确的解决方案。特别是 java.util.zip 类库就是面向字节而不是面向字符的。因此，最明智的做法是尽量尝试使用 Reader 和 Writer，一旦代码没法成功编译，你就会发现此时应该使用面向字节的类库了。 下表展示了在两个继承体系中，信息的来源和去处（即数据物理上来自哪里又去向哪里）之间的对应关系： 来源与去处：Java 1.0 类 相应的 Java 1.1 类 InputStream Reader 适配器：InputStreamReader OutputStream Writer 适配器：OutputStreamWriter FileInputStream FileReader FileOutputStream FileWriter StringBufferInputStream（已弃用） StringReader （无相应的类） StringWriter ByteArrayInputStream CharArrayReader ByteArrayOutputStream CharArrayWriter PipedInputStream PipedReader PipedOutputStream PipedWriter 总的来说，这两个不同的继承体系中的接口即便不能说完全相同，但也是非常相似的。 更改流的行为对于 InputStream 和 OutputStream 来说，我们会使用 FilterInputStream 和 FilterOutputStream 的装饰器子类来修改“流”以满足特殊需要。Reader 和 Writer 的类继承体系沿用了相同的思想——但是并不完全相同。 在下表中，左右之间对应关系的近似程度现比上一个表格更加粗略一些。造成这种差别的原因是类的组织形式不同，BufferedOutputStream 是 FilterOutputStream 的子类，但 BufferedWriter 却不是 FilterWriter 的子类（尽管 FilterWriter 是抽象类，但却没有任何子类，把它放在表格里只是占个位置，不然你可能奇怪 FilterWriter 上哪去了）。然而，这些类的接口却又十分相似。 过滤器：Java 1.0 类 相应 Java 1.1 类 FilterInputStream FilterReader FilterOutputStream FilterWriter (抽象类，没有子类) BufferedInputStream BufferedReader（也有 readLine()) BufferedOutputStream BufferedWriter DataInputStream 使用 DataInputStream（ 如果必须用到 readLine()，那你就得使用 BufferedReader。否则，一般情况下就用 DataInputStream PrintStream PrintWriter LineNumberInputStream LineNumberReader StreamTokenizer StreamTokenizer（使用具有 Reader 参数的构造器） PushbackInputStream PushbackReader 有一条限制需要明确：一旦要使用 readLine()，我们就不应该用 DataInputStream（否则，编译时会得到使用了过时方法的警告），而应该使用 BufferedReader。除了这种情况之外的情形中，DataInputStream 仍是 I/O 类库的首选成员。 为了使用时更容易过渡到 PrintWriter，它提供了一个既能接受 Writer 对象又能接受任何 OutputStream 对象的构造器。PrintWriter 的格式化接口实际上与 PrintStream 相同。 Java 5 添加了几种 PrintWriter 构造器，以便在将输出写入时简化文件的创建过程，你马上就会见到它们。 其中一种 PrintWriter 构造器还有一个执行自动 flush[^2] 的选项。如果构造器设置了该选项，就会在每个 println() 调用之后，自动执行 flush。 未发生改变的类有一些类在 Java 1.0 和 Java 1.1 之间未做改变。 以下这些 Java 1.0 类在 Java 1.1 中没有相应类 DataOutputStream File RandomAccessFile SequenceInputStream 特别是 DataOutputStream，在使用时没有任何变化；因此如果想以可传输的格式存储和检索数据，请用 InputStream 和 OutputStream 继承体系。 RandomAccessFile类RandomAccessFile 适用于由大小已知的记录组成的文件，所以我们可以使用 seek() 将文件指针从一条记录移动到另一条记录，然后对记录进行读取和修改。文件中记录的大小不一定都相同，只要我们能确定那些记录有多大以及它们在文件中的位置即可。 最初，我们可能难以相信 RandomAccessFile 不是 InputStream 或者 OutputStream 继承体系中的一部分。除了实现了 DataInput 和 DataOutput 接口（DataInputStream 和 DataOutputStream 也实现了这两个接口）之外，它和这两个继承体系没有任何关系。它甚至都不使用 InputStream 和 OutputStream 类中已有的任何功能。它是一个完全独立的类，其所有的方法（大多数都是 native 方法）都是从头开始编写的。这么做是因为 RandomAccessFile 拥有和别的 I/O 类型本质上不同的行为，因为我们可以在一个文件内向前和向后移动。在任何情况下，它都是自我独立的，直接继承自 Object。 从本质上来讲，RandomAccessFile 的工作方式类似于把 DataIunputStream 和 DataOutputStream 组合起来使用。另外它还有一些额外的方法，比如使用 getFilePointer() 可以得到当前文件指针在文件中的位置，使用 seek() 可以移动文件指针，使用 length() 可以得到文件的长度。另外，其构造器还需要传入第二个参数（和 C 语言中的 fopen() 相同）用来表示我们是准备对文件进行 “随机读”（r）还是“读写”（rw）。它并不支持只写文件，从这点来看，如果当初 RandomAccessFile 能设计成继承自 DataInputStream，可能也是个不错的实现方式。 在 Java 1.4 中，RandomAccessFile 的大多数功能（但不是全部）都被 nio 中的内存映射文件（mmap）取代，详见附录：新 I/O。 IO流典型用途尽管我们可以用不同的方式来组合 I/O 流类，但常用的也就其中几种。你可以下面的例子可以作为 I/O 典型用法的基本参照（在你确定无法使用文件这一章所述的库之后）。 在这些示例中，异常处理都被简化为将异常传递给控制台，但是这样做只适用于小型的示例和工具。在你自己的代码中，你需要考虑更加复杂的错误处理方式。 缓冲输入文件如果想要打开一个文件进行字符输入，我们可以使用一个 FileInputReader 对象，然后传入一个 String 或者 File 对象作为文件名。为了提高速度，我们希望对那个文件进行缓冲，那么我们可以将所产生的引用传递给一个 BufferedReader 构造器。BufferedReader 提供了 line() 方法，它会产生一个 Stream&lt;String&gt; 对象： 123456789101112131415161718192021// iostreams/BufferedInputFile.java// &#123;VisuallyInspectOutput&#125;import java.io.*;import java.util.stream.*;public class BufferedInputFile &#123; public static String read(String filename) &#123; try (BufferedReader in = new BufferedReader( new FileReader(filename))) &#123; return in.lines() .collect(Collectors.joining(\"\\n\")); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; System.out.print( read(\"BufferedInputFile.java\")); &#125;&#125; Collectors.joining() 在其内部使用了一个 StringBuilder 来累加其运行结果。该文件会通过 try-with-resources 子句自动关闭。 从内存输入下面示例中，从 BufferedInputFile.read() 读入的 String 被用来创建一个 StringReader 对象。然后调用其 read() 方法，每次读取一个字符，并把它显示在控制台上： 1234567891011121314// iostreams/MemoryInput.java// &#123;VisuallyInspectOutput&#125;import java.io.*;public class MemoryInput &#123; public static void main(String[] args) throws IOException &#123; StringReader in = new StringReader( BufferedInputFile.read(\"MemoryInput.java\")); int c; while ((c = in.read()) != -1) System.out.print((char) c); &#125;&#125; 注意 read() 是以 int 形式返回下一个字节，所以必须类型转换为 char 才能正确打印。 格式化内存输入要读取格式化数据，我们可以使用 DataInputStream，它是一个面向字节的 I/O 类（不是面向字符的）。这样我们就必须使用 InputStream 类而不是 Reader 类。我们可以使用 InputStream 以字节形式读取任何数据（比如一个文件），但这里使用的是字符串。 12345678910111213141516171819202122// iostreams/FormattedMemoryInput.java// &#123;VisuallyInspectOutput&#125;import java.io.*;public class FormattedMemoryInput &#123; public static void main(String[] args) &#123; try ( DataInputStream in = new DataInputStream( new ByteArrayInputStream( BufferedInputFile.read( \"FormattedMemoryInput.java\") .getBytes())) ) &#123; while (true) System.out.write((char) in.readByte()); &#125; catch (EOFException e) &#123; System.out.println(\"\\nEnd of stream\"); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; ByteArrayInputStream 必须接收一个字节数组，所以这里我们调用了 String.getBytes() 方法。所产生的的 ByteArrayInputStream 是一个适合传递给 DataInputStream 的 InputStream。 如果我们用 readByte() 从 DataInputStream 一次一个字节地读取字符，那么任何字节的值都是合法结果，因此返回值不能用来检测输入是否结束。取而代之的是，我们可以使用 available() 方法得到剩余可用字符的数量。下面例子演示了怎么一次一个字节地读取文件： 12345678910111213141516171819// iostreams/TestEOF.java// Testing for end of file// &#123;VisuallyInspectOutput&#125;import java.io.*;public class TestEOF &#123; public static void main(String[] args) &#123; try ( DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(\"TestEOF.java\"))) ) &#123; while (in.available() != 0) System.out.write(in.readByte()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 注意，available() 的工作方式会随着所读取媒介类型的不同而有所差异，它的字面意思就是“在没有阻塞的情况下所能读取的字节数”。对于文件，能够读取的是整个文件；但是对于其它类型的“流”，可能就不是这样，所以要谨慎使用。 我们也可以通过捕获异常来检测输入的末尾。但是，用异常作为控制流是对异常的一种错误使用方式。 基本文件的输出FileWriter 对象用于向文件写入数据。实际使用时，我们通常会用 BufferedWriter 将其包装起来以增加缓冲的功能（可以试试移除此包装来感受一下它对性能的影响——缓冲往往能显著地增加 I/O 操作的性能）。在本例中，为了提供格式化功能，它又被装饰成了 PrintWriter。按照这种方式创建的数据文件可作为普通文本文件来读取。 123456789101112131415161718192021222324// iostreams/BasicFileOutput.java// &#123;VisuallyInspectOutput&#125;import java.io.*;public class BasicFileOutput &#123; static String file = \"BasicFileOutput.dat\"; public static void main(String[] args) &#123; try ( BufferedReader in = new BufferedReader( new StringReader( BufferedInputFile.read( \"BasicFileOutput.java\"))); PrintWriter out = new PrintWriter( new BufferedWriter(new FileWriter(file))) ) &#123; in.lines().forEach(out::println); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; // Show the stored file: System.out.println(BufferedInputFile.read(file)); &#125;&#125; try-with-resources 语句会自动 flush 并关闭文件。 文本文件输出快捷方式Java 5 在 PrintWriter 中添加了一个辅助构造器，有了它，你在创建并写入文件时，就不必每次都手动执行一些装饰的工作。下面的代码使用这种快捷方式重写了 BasicFileOutput.java： 12345678910111213141516171819202122// iostreams/FileOutputShortcut.java// &#123;VisuallyInspectOutput&#125;import java.io.*;public class FileOutputShortcut &#123; static String file = \"FileOutputShortcut.dat\"; public static void main(String[] args) &#123; try ( BufferedReader in = new BufferedReader( new StringReader(BufferedInputFile.read( \"FileOutputShortcut.java\"))); // Here's the shortcut: PrintWriter out = new PrintWriter(file) ) &#123; in.lines().forEach(out::println); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; System.out.println(BufferedInputFile.read(file)); &#125;&#125; 使用这种方式仍具备了缓冲的功能，只是现在不必自己手动添加缓冲了。但遗憾的是，其它常见的写入任务都没有快捷方式，因此典型的 I/O 流依旧涉及大量冗余的代码。本书文件一章中介绍的另一种方式，对此类任务进行了极大的简化。 存储和恢复数据PrintWriter 是用来对可读的数据进行格式化。但如果要输出可供另一个“流”恢复的数据，我们可以用 DataOutputStream 写入数据，然后用 DataInputStream 恢复数据。当然，这些流可能是任何形式，在下面的示例中使用的是一个文件，并且对读写都进行了缓冲。注意 DataOutputStream 和 DataInputStream 是面向字节的，因此要使用 InputStream 和 OutputStream 体系的类。 123456789101112131415161718192021222324252627282930313233// iostreams/StoringAndRecoveringData.javaimport java.io.*;public class StoringAndRecoveringData &#123; public static void main(String[] args) &#123; try ( DataOutputStream out = new DataOutputStream( new BufferedOutputStream( new FileOutputStream(\"Data.txt\"))) ) &#123; out.writeDouble(3.14159); out.writeUTF(\"That was pi\"); out.writeDouble(1.41413); out.writeUTF(\"Square root of 2\"); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; try ( DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(\"Data.txt\"))) ) &#123; System.out.println(in.readDouble()); // Only readUTF() will recover the // Java-UTF String properly: System.out.println(in.readUTF()); System.out.println(in.readDouble()); System.out.println(in.readUTF()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 输出结果： 12343.14159That was pi1.41413Square root of 2 如果我们使用 DataOutputStream 进行数据写入，那么 Java 就保证了即便读和写数据的平台多么不同，我们仍可以使用 DataInputStream 准确地读取数据。这一点很有价值，众所周知，人们曾把大量精力耗费在数据的平台相关性问题上。但现在，只要两个平台上都有 Java，就不会存在这样的问题[^3]。 当我们使用 DastaOutputStream 时，写字符串并且让 DataInputStream 能够恢复它的唯一可靠方式就是使用 UTF-8 编码，在这个示例中是用 writeUTF() 和 readUTF() 来实现的。UTF-8 是一种多字节格式，其编码长度根据实际使用的字符集会有所变化。如果我们使用的只是 ASCII 或者几乎都是 ASCII 字符（只占 7 比特），那么就显得及其浪费空间和带宽，所以 UTF-8 将 ASCII 字符编码成一个字节的形式，而非 ASCII 字符则编码成两到三个字节的形式。另外，字符串的长度保存在 UTF-8 字符串的前两个字节中。但是，writeUTF() 和 readUTF() 使用的是一种适用于 Java 的 UTF-8 变体（JDK 文档中有这些方法的详尽描述），因此如果我们用一个非 Java 程序读取用 writeUTF() 所写的字符串时，必须编写一些特殊的代码才能正确读取。 有了 writeUTF() 和 readUTF()，我们就可以在 DataOutputStream 中把字符串和其它数据类型混合使用。因为字符串完全可以作为 Unicode 格式存储，并且可以很容易地使用 DataInputStream 来恢复它。 writeDouble() 将 double 类型的数字存储在流中，并用相应的 readDouble() 恢复它（对于其它的书类型，也有类似的方法用于读写）。但是为了保证所有的读方法都能够正常工作，我们必须知道流中数据项所在的确切位置，因为极有可能将保存的 double 数据作为一个简单的字节序列、char 或其它类型读入。因此，我们必须：要么为文件中的数据采用固定的格式；要么将额外的信息保存到文件中，通过解析额外信息来确定数据的存放位置。注意，对象序列化和 XML （二者都在附录：对象序列化中介绍）是存储和读取复杂数据结构的更简单的方式。 读写随机访问文件使用 RandomAccessFile 就像是使用了一个 DataInputStream 和 DataOutputStream 的结合体（因为它实现了相同的接口：DataInput 和 DataOutput）。另外，我们还可以使用 seek() 方法移动文件指针并修改对应位置的值。 在使用 RandomAccessFile 时，你必须清楚文件的结构，否则没法正确使用它。RandomAccessFile 有一套专门的方法来读写基本数据类型的数据和 UTF-8 编码的字符串： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// iostreams/UsingRandomAccessFile.javaimport java.io.*;public class UsingRandomAccessFile &#123; static String file = \"rtest.dat\"; public static void display() &#123; try ( RandomAccessFile rf = new RandomAccessFile(file, \"r\") ) &#123; for (int i = 0; i &lt; 7; i++) System.out.println( \"Value \" + i + \": \" + rf.readDouble()); System.out.println(rf.readUTF()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; try ( RandomAccessFile rf = new RandomAccessFile(file, \"rw\") ) &#123; for (int i = 0; i &lt; 7; i++) rf.writeDouble(i * 1.414); rf.writeUTF(\"The end of the file\"); rf.close(); display(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; try ( RandomAccessFile rf = new RandomAccessFile(file, \"rw\") ) &#123; rf.seek(5 * 8); rf.writeDouble(47.0001); rf.close(); display(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 输出结果： 12345678910111213141516Value 0: 0.0Value 1: 1.414Value 2: 2.828Value 3: 4.242Value 4: 5.656Value 5: 7.069999999999999Value 6: 8.484The end of the fileValue 0: 0.0Value 1: 1.414Value 2: 2.828Value 3: 4.242Value 4: 5.656Value 5: 47.0001Value 6: 8.484The end of the file display() 方法打开了一个文件，并以 double 值的形式显示了其中的七个元素。在 main() 中，首先创建了文件，然后打开并修改了它。因为 double 总是 8 字节长，所以如果要用 seek() 定位到第 5 个（从 0 开始计数） double 值，则要传入的地址值应该为 5*8。 正如前面所诉，虽然 RandomAccess 实现了 DataInput 和 DataOutput 接口，但实际上它和 I/O 继承体系中的其它部分是分离的。它不支持装饰，故而不能将其与 InputStream 及 OutputStream 子类中的任何一个组合起来，所以我们也没法给它添加缓冲的功能。 该类的构造器还有第二个必选参数：我们可以指定让 RandomAccessFile 以“只读”（r）方式或“读写”（rw）方式打开文件。 除此之外，还可以使用 nio 中的“内存映射文件”代替 RandomAccessFile，这在附录：新 I/O中有介绍。 本章小结Java 的 I/O 流类库的确能够满足我们的基本需求：我们可以通过控制台、文件、内存块，甚至因特网进行读写。通过继承，我们可以创建新类型的输入和输出对象。并且我们甚至可以通过重新定义“流”所接受对象类型的 toString() 方法，进行简单的扩展。当我们向一个期望收到字符串的方法传送一个非字符串对象时，会自动调用对象的 toString() 方法（这是 Java 中有限的“自动类型转换”功能之一）。 在 I/O 流类库的文档和设计中，仍留有一些没有解决的问题。例如，我们打开一个文件用于输出，如果在我们试图覆盖这个文件时能抛出一个异常，这样会比较好（有的编程系统只有当该文件不存在时，才允许你将其作为输出文件打开）。在 Java 中，我们应该使用一个 File 对象来判断文件是否存在，因为如果我们用 FileOutputStream 或者 FileWriter 打开，那么这个文件肯定会被覆盖。 I/O 流类库让我们喜忧参半。它确实挺有用的，而且还具有可移植性。但是如果我们没有理解“装饰器”模式，那么这种设计就会显得不是很直观。所以，它的学习成本相对较高。而且它并不完善，比如说在过去，我不得不编写相当数量的代码去实现一个读取文本文件的工具——所幸的是，Java 7 中的 nio 消除了此类需求。 一旦你理解了装饰器模式，并且开始在某些需要这种灵活性的场景中使用该类库，那么你就开始能从这种设计中受益了。到那时候，为此额外多写几行代码的开销应该不至于让人觉得太麻烦。但还是请务必检查一下，确保使用文件一章中的库和技术没法解决问题后，再考虑使用本章的 I/O 流库。 [^1]: 很难说这就是一个很好的设计选择，尤其是与其它编程语言中简单的 I/O 类库相比较。但它确实是如此选择的一个正当理由。[^2]: 译者注：“flush” 直译是“清空”，意思是把缓冲中的数据清空，输送到对应的目的地（如文件和屏幕）。[^3]: XML 是另一种方式，可以解决在不同计算平台之间移动数据，而不依赖于所有平台上都有 Java 这一问题。XML 将在附录：对象序列化一章中进行介绍。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"javaDev","slug":"java-note/javaDev/javaDev","date":"2019-10-13T14:19:09.000Z","updated":"2021-10-23T02:19:04.193Z","comments":true,"path":"2019/10/java-note/javaDev/javaDev/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/javaDev/javaDev/","excerpt":"[TOC]CGLIB什么是CGLIBCGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。CGLIB作为一个开源项目，其代码托管在github，地址为：https://github.com/cglib/cglib","text":"[TOC]CGLIB什么是CGLIBCGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。CGLIB作为一个开源项目，其代码托管在github，地址为：https://github.com/cglib/cglib 为什么使用CGLIBCGLIB代理主要通过对字节码的操作，为对象引入间接级别，以控制对象的访问。我们知道Java中有一个动态代理也是做这个事情的，那我们为什么不直接使用Java动态代理，而要使用CGLIB呢？答案是CGLIB相比于JDK动态代理更加强大，JDK动态代理虽然简单易用，但是其有一个致命缺陷是，只能对接口进行代理。如果要代理的类为一个普通类、没有接口，那么Java动态代理就没法使用了。关于Java动态代理，可以参者这里Java动态代理分析 model模型层分类概念： VO**（View Object**）：视图对象**，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。 DTO**（Data Transfer Object**）：数据传输对象**，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。 DO**（Domain Object**）：领域对象**，就是从现实世界中抽象出来的有形或无形的业务实体。 PO**（Persistent Object**）：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成**一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"OnJava8-4","slug":"java-note/OnJava8/OnJava8-4","date":"2019-10-13T14:19:09.000Z","updated":"2021-10-23T02:19:02.850Z","comments":true,"path":"2019/10/java-note/OnJava8/OnJava8-4/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/OnJava8/OnJava8-4/","excerpt":"[TOC]第二十二章 枚举 关键字 enum 可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。这是一种非常有用的功能 在初始化和清理 这章结束的时候，我们已经简单地介绍了枚举的概念。现在，你对 Java 已经有了更深刻的理解，因此可以更深入地学习 Java 中的枚举了。你将在本章中看到，使用 enum 可以做很多有趣的事情，同时，我们也会深入其他的 Java 特性，例如泛型和反射。在这个过程中，我们还将学习一些设计模式。","text":"[TOC]第二十二章 枚举 关键字 enum 可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。这是一种非常有用的功能 在初始化和清理 这章结束的时候，我们已经简单地介绍了枚举的概念。现在，你对 Java 已经有了更深刻的理解，因此可以更深入地学习 Java 中的枚举了。你将在本章中看到，使用 enum 可以做很多有趣的事情，同时，我们也会深入其他的 Java 特性，例如泛型和反射。在这个过程中，我们还将学习一些设计模式。 基本 enum 特性我们已经在初始化和清理 这章章看到，调用 enum 的 values() 方法，可以遍历 enum 实例 .values() 方法返回 enum 实例的数组，而且该数组中的元素严格保持其在 enum 中声明时的顺序，因此你可以在循环中使用 values() 返回的数组。 创建 enum 时，编译器会为你生成一个相关的类，这个类继承自 Java.lang.Enum。下面的例子演示了 Enum 提供的一些功能： 1234567891011121314151617181920212223242526// enums/EnumClass.java// Capabilities of the Enum classenum Shrubbery &#123; GROUND, CRAWLING, HANGING &#125;public class EnumClass &#123; public static void main(String[] args) &#123; for(Shrubbery s : Shrubbery.values()) &#123; System.out.println( s + \" ordinal: \" + s.ordinal()); System.out.print( s.compareTo(Shrubbery.CRAWLING) + \" \"); System.out.print( s.equals(Shrubbery.CRAWLING) + \" \"); System.out.println(s == Shrubbery.CRAWLING); System.out.println(s.getDeclaringClass()); System.out.println(s.name()); System.out.println(\"********************\"); &#125;// Produce an enum value from a String name: for(String s : \"HANGING CRAWLING GROUND\".split(\" \")) &#123; Shrubbery shrub = Enum.valueOf(Shrubbery.class, s); System.out.println(shrub); &#125; &#125;&#125; 输出： 123456789101112131415161718GROUND ordinal: 0-1 false falseclass ShrubberyGROUND********************CRAWLING ordinal: 10 true trueclass ShrubberyCRAWLING********************HANGING ordinal: 21 false falseclass ShrubberyHANGING********************HANGINGCRAWLINGGROUND ordinal() 方法返回一个 int 值，这是每个 enum 实例在声明时的次序，从 0 开始。可以使用==来比较 enum 实例，编译器会自动为你提供 equals() 和 hashCode() 方法。Enum 类实现了 Comparable 接口，所以它具有 compareTo() 方法。同时，它还实现了 Serializable 接口。 如果在 enum 实例上调用 getDeclaringClass() 方法，我们就能知道其所属的 enum 类。 name() 方法返回 enum 实例声明时的名字，这与使用 toString() 方法效果相同。valueOf() 是在 Enum 中定义的 static 方法，它根据给定的名字返回相应的 enum 实例，如果不存在给定名字的实例，将会抛出异常。 将静态类型导入用于 enum先看一看 初始化和清理 这章中 Burrito.java 的另一个版本： 123456789101112131415161718192021222324// enums/SpicinessEnum.javapackage enums;public enum SpicinessEnum &#123; NOT, MILD, MEDIUM, HOT, FLAMING&#125;// enums/Burrito2.java// &#123;java enums.Burrito2&#125;package enums;import static enums.SpicinessEnum.*;public class Burrito2 &#123; SpicinessEnum degree; public Burrito2(SpicinessEnum degree) &#123; this.degree = degree; &#125; @Override public String toString() &#123; return \"Burrito is \"+ degree; &#125; public static void main(String[] args) &#123; System.out.println(new Burrito2(NOT)); System.out.println(new Burrito2(MEDIUM)); System.out.println(new Burrito2(HOT)); &#125;&#125; 输出为： 123Burrito is NOTBurrito is MEDIUMBurrito is HOT 使用 static import 能够将 enum 实例的标识符带入当前的命名空间，所以无需再用 enum 类型来修饰 enum 实例。这是一个好的想法吗？或者还是显式地修饰 enum 实例更好？这要看代码的复杂程度了。编译器可以确保你使用的是正确的类型，所以唯一需要担心的是，使用静态导入会不会导致你的代码令人难以理解。多数情况下，使用 static import 还是有好处的，不过，程序员还是应该对具体情况进行具体分析。 注意，在定义 enum 的同一个文件中，这种技巧无法使用，如果是在默认包中定义 enum，这种技巧也无法使用（在 Sun 内部对这一点显然也有不同意见）。 方法添加除了不能继承自一个 enum 之外，我们基本上可以将 enum 看作一个常规的类。也就是说我们可以向 enum 中添加方法。enum 甚至可以有 main() 方法。 一般来说，我们希望每个枚举实例能够返回对自身的描述，而不仅仅只是默认的 toString() 实现，这只能返回枚举实例的名字。为此，你可以提供一个构造器，专门负责处理这个额外的信息，然后添加一个方法，返回这个描述信息。看一看下面的示例： 123456789101112131415161718192021// enums/OzWitch.java// The witches in the land of Ozpublic enum OzWitch &#123; // Instances must be defined first, before methods: WEST(\"Miss Gulch, aka the Wicked Witch of the West\"), NORTH(\"Glinda, the Good Witch of the North\"), EAST(\"Wicked Witch of the East, wearer of the Ruby \" + \"Slippers, crushed by Dorothy's house\"), SOUTH(\"Good by inference, but missing\"); private String description; // Constructor must be package or private access: private OzWitch(String description) &#123; this.description = description; &#125; public String getDescription() &#123; return description; &#125; public static void main(String[] args) &#123; for(OzWitch witch : OzWitch.values()) System.out.println( witch + \": \" + witch.getDescription()); &#125;&#125; 输出为： 12345WEST: Miss Gulch, aka the Wicked Witch of the WestNORTH: Glinda, the Good Witch of the NorthEAST: Wicked Witch of the East, wearer of the RubySlippers, crushed by Dorothy's houseSOUTH: Good by inference, but missing 注意，如果你打算定义自己的方法，那么必须在 enum 实例序列的最后添加一个分号。同时，Java 要求你必须先定义 enum 实例。如果在定义 enum 实例之前定义了任何方法或属性，那么在编译时就会得到错误信息。 enum 中的构造器与方法和普通的类没有区别，因为除了有少许限制之外，enum 就是一个普通的类。所以，我们可以使用 enum 做许多事情（虽然，我们一般只使用普通的枚举类型） 在这个例子中，虽然我们有意识地将 enum 的构造器声明为 private，但对于它的可访问性而言，其实并没有什么变化，因为（即使不声明为 private）我们只能在 enum 定义的内部使用其构造器创建 enum 实例。一旦 enum 的定义结束，编译器就不允许我们再使用其构造器来创建任何实例了。 覆盖 enum 的方法覆盖 toSring() 方法，给我们提供了另一种方式来为枚举实例生成不同的字符串描述信息。在下面的示例中，我们使用的就是实例的名字，不过我们希望改变其格式。覆盖 enum 的 toSring() 方法与覆盖一般类的方法没有区别： 12345678910111213141516// enums/SpaceShip.javaimport java.util.stream.*;public enum SpaceShip &#123; SCOUT, CARGO, TRANSPORT, CRUISER, BATTLESHIP, MOTHERSHIP; @Override public String toString() &#123; String id = name(); String lower = id.substring(1).toLowerCase(); return id.charAt(0) + lower; &#125; public static void main(String[] args) &#123; Stream.of(values()) .forEach(System.out::println); &#125;&#125; 输出为： 123456ScoutCargoTransportCruiserBattleshipMothership toString() 方法通过调用 name() 方法取得 SpaceShip 的名字，然后将其修改为只有首字母大写的格式。 switch 语句中的 enum在 switch 中使用 enum，是 enum 提供的一项非常便利的功能。一般来说，在 switch 中只能使用整数值，而枚举实例天生就具备整数值的次序，并且可以通过 ordinal() 方法取得其次序（显然编译器帮我们做了类似的工作），因此我们可以在 switch 语句中使用 enum。 虽然一般情况下我们必须使用 enum 类型来修饰一个 enum 实例，但是在 case 语句中却不必如此。下面的例子使用 enum 构造了一个小型状态机： 12345678910111213141516171819202122232425262728293031// enums/TrafficLight.java// Enums in switch statements// Define an enum type:enum Signal &#123; GREEN, YELLOW, RED, &#125;public class TrafficLight &#123; Signal color = Signal.RED; public void change() &#123; switch(color) &#123; // Note you don't have to say Signal.RED // in the case statement: case RED: color = Signal.GREEN; break; case GREEN: color = Signal.YELLOW; break; case YELLOW: color = Signal.RED; break; &#125; &#125; @Override public String toString() &#123; return \"The traffic light is \" + color; &#125; public static void main(String[] args) &#123; TrafficLight t = new TrafficLight(); for(int i = 0; i &lt; 7; i++) &#123; System.out.println(t); t.change(); &#125; &#125;&#125; 输出为： 1234567The traffic light is REDThe traffic light is GREENThe traffic light is YELLOWThe traffic light is REDThe traffic light is GREENThe traffic light is YELLOWThe traffic light is RED 编译器并没有抱怨 switch 中没有 default 语句，但这并不是因为每一个 Signal 都有对应的 case 语句。如果你注释掉其中的某个 case 语句，编译器同样不会抱怨什么。这意味着，你必须确保自己覆盖了所有的分支。但是，如果在 case 语句中调用 return，那么编译器就会抱怨缺少 default 语句了。这与是否覆盖了 enum 的所有实例无关。 values 方法的神秘之处前面已经提到，编译器为你创建的 enum 类都继承自 Enum 类。然而，如果你研究一下 Enum 类就会发现，它并没有 values() 方法。可我们明明已经用过该方法了，难道存在某种“隐藏的”方法吗？我们可以利用反射机制编写一个简单的程序，来查看其中的究竟： 1234567891011121314151617181920212223242526272829303132333435363738// enums/Reflection.java// Analyzing enums using reflectionimport java.lang.reflect.*;import java.util.*;import onjava.*;enum Explore &#123; HERE, THERE &#125;public class Reflection &#123; public static Set&lt;String&gt; analyze(Class&lt;?&gt; enumClass) &#123; System.out.println( \"_____ Analyzing \" + enumClass + \" _____\"); System.out.println(\"Interfaces:\"); for(Type t : enumClass.getGenericInterfaces()) System.out.println(t); System.out.println( \"Base: \" + enumClass.getSuperclass()); System.out.println(\"Methods: \"); Set&lt;String&gt; methods = new TreeSet&lt;&gt;(); for(Method m : enumClass.getMethods()) methods.add(m.getName()); System.out.println(methods); return methods; &#125; public static void main(String[] args) &#123; Set&lt;String&gt; exploreMethods = analyze(Explore.class); Set&lt;String&gt; enumMethods = analyze(Enum.class); System.out.println( \"Explore.containsAll(Enum)? \" + exploreMethods.containsAll(enumMethods)); System.out.print(\"Explore.removeAll(Enum): \"); exploreMethods.removeAll(enumMethods); System.out.println(exploreMethods);// Decompile the code for the enum: OSExecute.command( \"javap -cp build/classes/main Explore\"); &#125;&#125; 输出为： 1234567891011121314151617181920212223242526_____ Analyzing class Explore _____Interfaces:Base: class java.lang.EnumMethods:[compareTo, equals, getClass, getDeclaringClass,hashCode, name, notify, notifyAll, ordinal, toString,valueOf, values, wait]_____ Analyzing class java.lang.Enum _____Interfaces:java.lang.Comparable&lt;E&gt;interface java.io.SerializableBase: class java.lang.ObjectMethods:[compareTo, equals, getClass, getDeclaringClass,hashCode, name, notify, notifyAll, ordinal, toString,valueOf, wait]Explore.containsAll(Enum)? trueExplore.removeAll(Enum): [values]Compiled from \"Reflection.java\"final class Explore extends java.lang.Enum&lt;Explore&gt; &#123; public static final Explore HERE; public static final Explore THERE; public static Explore[] values(); public static Explore valueOf(java.lang.String); static &#123;&#125;;&#125; 答案是，values() 是由编译器添加的 static 方法。可以看出，在创建 Explore 的过程中，编译器还为其添加了 valueOf() 方法。这可能有点令人迷惑，Enum 类不是已经有 valueOf() 方法了吗。 不过 Enum 中的 valueOf() 方法需要两个参数，而这个新增的方法只需一个参数。由于这里使用的 Set 只存储方法的名字，而不考虑方法的签名，所以在调用 Explore.removeAll(Enum) 之后，就只剩下[values] 了。 从最后的输出中可以看到，编译器将 Explore 标记为 final 类，所以无法继承自 enum，其中还有一个 static 的初始化子句，稍后我们将学习如何重定义该句。 由于擦除效应（在泛型 章节中介绍过），反编译无法得到 Enum 的完整信息，所以它展示的 Explore 的父类只是一个原始的 Enum，而非事实上的 Enum&lt;Explore&gt;。 由于 values() 方法是由编译器插入到 enum 定义中的 static 方法，所以，如果你将 enum 实例向上转型为 Enum，那么 values() 方法就不可访问了。不过，在 Class 中有一个 getEnumConstants0 方法，所以即便 Enum 接口中没有 values0 方法，我们仍然可以通过 Class 对象取得所有 enum 实例。 123456789101112// enums/UpcastEnum.java// No values() method if you upcast an enumenum Search &#123; HITHER, YON &#125;public class UpcastEnum &#123; public static void main(String[] args) &#123; Search[] vals = Search.values(); Enum e = Search.HITHER; // Upcast// e.values(); // No values() in Enum for(Enum en : e.getClass().getEnumConstants()) System.out.println(en); &#125;&#125; 输出为： 12HITHERYON 因为 getEnumConstants() 是 Class 上的方法，所以你甚至可以对不是枚举的类调用此方法： 123456789101112// enums/NonEnum.javapublic class NonEnum &#123; public static void main(String[] args) &#123; Class&lt;Integer&gt; intClass = Integer.class; try &#123; for(Object en : intClass.getEnumConstants()) System.out.println(en); &#125; catch(Exception e) &#123; System.out.println(\"Expected: \" + e); &#125; &#125;&#125; 输出为： 1Expected: java.lang.NullPointerException 只不过，此时该方法返回 null，所以当你试图使用其返回的结果时会发生异常。 实现而非继承我们已经知道，所有的 enum 都继承自 Java.lang.Enum 类。由于 Java 不支持多重继承，所以你的 enum 不能再继承其他类： 1enum NotPossible extends Pet &#123; ... // Won't work 然而，在我们创建一个新的 enum 时，可以同时实现一个或多个接口： 12345678910111213141516171819202122232425262728// enums/cartoons/EnumImplementation.java// An enum can implement an interface// &#123;java enums.cartoons.EnumImplementation&#125;package enums.cartoons;import java.util.*;import java.util.function.*;enum CartoonCharacter implements Supplier&lt;CartoonCharacter&gt; &#123; SLAPPY, SPANKY, PUNCHY, SILLY, BOUNCY, NUTTY, BOB; private Random rand = new Random(47); @Override public CartoonCharacter get() &#123; return values()[rand.nextInt(values().length)]; &#125;&#125;public class EnumImplementation &#123; public static &lt;T&gt; void printNext(Supplier&lt;T&gt; rg) &#123; System.out.print(rg.get() + \", \"); &#125; public static void main(String[] args) &#123;// Choose any instance: CartoonCharacter cc = CartoonCharacter.BOB; for(int i = 0; i &lt; 10; i++) printNext(cc); &#125;&#125; 输出为： 12BOB, PUNCHY, BOB, SPANKY, NUTTY, PUNCHY, SLAPPY, NUTTY,NUTTY, SLAPPY, 这个结果有点奇怪，不过你必须要有一个 enum 实例才能调用其上的方法。现在，在任何接受 Supplier 参数的方法中，例如 printNext()，都可以使用 CartoonCharacter。 随机选择就像你在 CartoonCharacter.get() 中看到的那样，本章中的很多示例都需要从 enum 实例中进行随机选择。我们可以利用泛型，从而使得这个工作更一般化，并将其加入到我们的工具库中。 1234567891011121314// onjava/Enums.javapackage onjava;import java.util.*;public class Enums &#123; private static Random rand = new Random(47); public static &lt;T extends Enum&lt;T&gt;&gt; T random(Class&lt;T&gt; ec) &#123; return random(ec.getEnumConstants()); &#125; public static &lt;T&gt; T random(T[] values) &#123; return values[rand.nextInt(values.length)]; &#125;&#125; 古怪的语法&lt;T extends Enum&lt;T&gt;&gt; 表示 T 是一个 enum 实例。而将 Class&lt;T&gt; 作为参数的话，我们就可以利用 Class 对象得到 enum 实例的数组了。重载后的 random() 方法只需使用 T[] 作为参数，因为它并不会调用 Enum 上的任何操作，它只需从数组中随机选择一个元素即可。这样，最终的返回类型正是 enum 的类型。 下面是 random() 方法的一个简单示例： 123456789101112// enums/RandomTest.javaimport onjava.*;enum Activity &#123; SITTING, LYING, STANDING, HOPPING, RUNNING, DODGING, JUMPING, FALLING, FLYING &#125; public class RandomTest &#123; public static void main(String[] args) &#123; for(int i = 0; i &lt; 20; i++) System.out.print( Enums.random(Activity.class) + \" \"); &#125;&#125; 输出为： 123STANDING FLYING RUNNING STANDING RUNNING STANDING LYINGDODGING SITTING RUNNING HOPPING HOPPING HOPPING RUNNINGSTANDING LYING FALLING RUNNING FLYING LYING 使用接口组织枚举无法从 enum 继承子类有时很令人沮丧。这种需求有时源自我们希望扩展原 enum 中的元素，有时是因为我们希望使用子类将一个 enum 中的元素进行分组。 在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类组织的目的。举例来说，假设你想用 enum 来表示不同类别的食物，同时还希望每个 enum 元素仍然保持 Food 类型。那可以这样实现： 1234567891011121314151617181920// enums/menu/Food.java// Subcategorization of enums within interfacespackage enums.menu;public interface Food &#123; enum Appetizer implements Food &#123; SALAD, SOUP, SPRING_ROLLS; &#125; enum MainCourse implements Food &#123; LASAGNE, BURRITO, PAD_THAI, LENTILS, HUMMOUS, VINDALOO; &#125; enum Dessert implements Food &#123; TIRAMISU, GELATO, BLACK_FOREST_CAKE, FRUIT, CREME_CARAMEL; &#125; enum Coffee implements Food &#123; BLACK_COFFEE, DECAF_COFFEE, ESPRESSO, LATTE, CAPPUCCINO, TEA, HERB_TEA; &#125;&#125; 对于 enum 而言，实现接口是使其子类化的唯一办法，所以嵌入在 Food 中的每个 enum 都实现了 Food 接口。现在，在下面的程序中，我们可以说“所有东西都是某种类型的 Food”。 123456789101112// enums/menu/TypeOfFood.java// &#123;java enums.menu.TypeOfFood&#125;package enums.menu;import static enums.menu.Food.*;public class TypeOfFood &#123; public static void main(String[] args) &#123; Food food = Appetizer.SALAD; food = MainCourse.LASAGNE; food = Dessert.GELATO; food = Coffee.CAPPUCCINO; &#125;&#125; 如果 enum 类型实现了 Food 接口，那么我们就可以将其实例向上转型为 Food，所以上例中的所有东西都是 Food。 然而，当你需要与一大堆类型打交道时，接口就不如 enum 好用了。例如，如果你想创建一个“校举的枚举”，那么可以创建一个新的 enum，然后用其实例包装 Food 中的每一个 enum 类： 12345678910111213141516// enums/menu/Course.javapackage enums.menu;import onjava.*;public enum Course &#123; APPETIZER(Food.Appetizer.class), MAINCOURSE(Food.MainCourse.class), DESSERT(Food.Dessert.class), COFFEE(Food.Coffee.class); private Food[] values; private Course(Class&lt;? extends Food&gt; kind) &#123; values = kind.getEnumConstants(); &#125; public Food randomSelection() &#123; return Enums.random(values); &#125;&#125; 每一个 Course 的实例都将其对应的 Class 对象作为构造器的参数。通过 getEnumConstants0 方法，可以从该 Class 对象中取得某个 Food 子类的所有 enum 实例。这些实例在 randomSelection() 中被用到。因此，通过从每一个 Course 实例中随机地选择一个 Food，我们便能够生成一份菜单： 1234567891011121314// enums/menu/Meal.java// &#123;java enums.menu.Meal&#125;package enums.menu;public class Meal &#123; public static void main(String[] args) &#123; for(int i = 0; i &lt; 5; i++) &#123; for(Course course : Course.values()) &#123; Food food = course.randomSelection(); System.out.println(food); &#125; System.out.println(\"***\"); &#125; &#125;&#125; 输出为： 12345678910111213141516171819202122232425SPRING_ROLLSVINDALOOFRUITDECAF_COFFEE***SOUPVINDALOOFRUITTEA***SALADBURRITOFRUITTEA***SALADBURRITOCREME_CARAMELLATTE***SOUPBURRITOTIRAMISUESPRESSO*** 在这个例子中，我们通过遍历每一个 Course 实例来获得“枚举的枚举”的值。稍后，在 VendingMachine.java 中，我们会看到另一种组织枚举实例的方式，但其也有一些其他的限制。 此外，还有一种更简洁的管理枚举的办法，就是将一个 enum 嵌套在另一个 enum 内。就像这样： 123456789101112131415161718192021222324252627282930// enums/SecurityCategory.java// More succinct subcategorization of enumsimport onjava.*;enum SecurityCategory &#123; STOCK(Security.Stock.class), BOND(Security.Bond.class); Security[] values; SecurityCategory(Class&lt;? extends Security&gt; kind) &#123; values = kind.getEnumConstants(); &#125; interface Security &#123; enum Stock implements Security &#123; SHORT, LONG, MARGIN &#125; enum Bond implements Security &#123; MUNICIPAL, JUNK &#125; &#125; public Security randomSelection() &#123; return Enums.random(values); &#125; public static void main(String[] args) &#123; for(int i = 0; i &lt; 10; i++) &#123; SecurityCategory category = Enums.random(SecurityCategory.class); System.out.println(category + \": \" + category.randomSelection()); &#125; &#125;&#125; 输出为： 12345678910BOND: MUNICIPALBOND: MUNICIPALSTOCK: MARGINSTOCK: MARGINBOND: JUNKSTOCK: SHORTSTOCK: LONGSTOCK: LONGBOND: MUNICIPALBOND: JUNK Security 接口的作用是将其所包含的 enum 组合成一个公共类型，这一点是有必要的。然后，SecurityCategory 才能将 Security 中的 enum 作为其构造器的参数使用，以起到组织的效果。 如果我们将这种方式应用于 Food 的例子，结果应该这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243// enums/menu/Meal2.java// &#123;java enums.menu.Meal2&#125;package enums.menu;import onjava.*;public enum Meal2 &#123; APPETIZER(Food.Appetizer.class), MAINCOURSE(Food.MainCourse.class), DESSERT(Food.Dessert.class), COFFEE(Food.Coffee.class); private Food[] values; private Meal2(Class&lt;? extends Food&gt; kind) &#123; values = kind.getEnumConstants(); &#125; public interface Food &#123; enum Appetizer implements Food &#123; SALAD, SOUP, SPRING_ROLLS; &#125; enum MainCourse implements Food &#123; LASAGNE, BURRITO, PAD_THAI, LENTILS, HUMMOUS, VINDALOO; &#125; enum Dessert implements Food &#123; TIRAMISU, GELATO, BLACK_FOREST_CAKE, FRUIT, CREME_CARAMEL; &#125; enum Coffee implements Food &#123; BLACK_COFFEE, DECAF_COFFEE, ESPRESSO, LATTE, CAPPUCCINO, TEA, HERB_TEA; &#125; &#125; public Food randomSelection() &#123; return Enums.random(values); &#125; public static void main(String[] args) &#123; for(int i = 0; i &lt; 5; i++) &#123; for(Meal2 meal : Meal2.values()) &#123; Food food = meal.randomSelection(); System.out.println(food); &#125; System.out.println(\"***\"); &#125; &#125;&#125; 输出为： 12345678910111213141516171819202122232425SPRING_ROLLSVINDALOOFRUITDECAF_COFFEE***SOUPVINDALOOFRUITTEA***SALADBURRITOFRUITTEA***SALADBURRITOCREME_CARAMELLATTE***SOUPBURRITOTIRAMISUESPRESSO*** 其实，这仅仅是重新组织了一下代码，不过多数情况下，这种方式使你的代码具有更清晰的结构。 使用 EnumSet 替代 FlagsSet 是一种集合，只能向其中添加不重复的对象。当然，enum 也要求其成员都是唯一的，所以 enumi 看起来也具有集合的行为。不过，由于不能从 enum 中删除或添加元素，所以它只能算是不太有用的集合。Java SE5 引入 EnumSet，是为了通过 enum 创建一种替代品，以替代传统的基于 int 的“位标志”。这种标志可以用来表示某种“开/关”信息，不过，使用这种标志，我们最终操作的只是一些 bit，而不是这些 bit 想要表达的概念，因此很容易写出令人难以理解的代码。 EnumSet 的设计充分考虑到了速度因素，因为它必须与非常高效的 bit 标志相竞争（其操作与 HashSet 相比，非常地快），就其内部而言，它（可能）就是将一个 long 值作为比特向量，所以 EnumSet 非常快速高效。使用 EnumSet 的优点是，它在说明一个二进制位是否存在时，具有更好的表达能力，并且无需担心性能。 EnumSet 中的元素必须来自一个 enum。下面的 enum 表示在一座大楼中，警报传感器的安放位置： 123456// enums/AlarmPoints.javapackage enums;public enum AlarmPoints &#123; STAIR1, STAIR2, LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM, UTILITY, KITCHEN&#125; 然后，我们用 EnumSet 来跟踪报警器的状态： 1234567891011121314151617181920212223242526// enums/EnumSets.java// Operations on EnumSets// &#123;java enums.EnumSets&#125;package enums;import java.util.*;import static enums.AlarmPoints.*;public class EnumSets &#123; public static void main(String[] args) &#123; EnumSet&lt;AlarmPoints&gt; points = EnumSet.noneOf(AlarmPoints.class); // Empty points.add(BATHROOM); System.out.println(points); points.addAll( EnumSet.of(STAIR1, STAIR2, KITCHEN)); System.out.println(points); points = EnumSet.allOf(AlarmPoints.class); points.removeAll( EnumSet.of(STAIR1, STAIR2, KITCHEN)); System.out.println(points); points.removeAll( EnumSet.range(OFFICE1, OFFICE4)); System.out.println(points); points = EnumSet.complementOf(points); System.out.println(points); &#125;&#125; 输出为： 1234567[BATHROOM][STAIR1, STAIR2, BATHROOM, KITCHEN][LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM,UTILITY][LOBBY, BATHROOM, UTILITY][STAIR1, STAIR2, OFFICE1, OFFICE2, OFFICE3, OFFICE4,KITCHEN] 使用 static import 可以简化 enum 常量的使用。EnumSet 的方法的名字都相当直观，你可以查阅 JDK 文档找到其完整详细的描述。如果仔细研究了 EnunSet 的文档，你还会发现 of() 方法被重载了很多次，不但为可变数量参数进行了重载，而且为接收 2 至 5 个显式的参数的情况都进行了重载。这也从侧面表现了 EnumSet 对性能的关注。因为，其实只使用单独的 of() 方法解决可变参数已经可以解决整个问题了，但是对比显式的参数，会有一点性能损失。采用现在这种设计，当你只使用 2 到 5 个参数调用 of() 方法时，你可以调用对应的重载过的方法（速度稍快一点），而当你使用一个参数或多过 5 个参数时，你调用的将是使用可变参数的 of() 方法。注意，如果你只使用一个参数，编译器并不会构造可变参数的数组，所以与调用只有一个参数的方法相比，也就不会有额外的性能损耗。 EnumSet 的基础是 long，一个 long 值有 64 位，而一个 enum 实例只需一位 bit 表示其是否存在。也就是说，在不超过一个 long 的表达能力的情况下，你的 EnumSet 可以应用于最多不超过 64 个元素的 enum。如果 enum 超过了 64 个元素会发生什么呢？ 12345678910111213141516// enums/BigEnumSet.javaimport java.util.*;public class BigEnumSet &#123; enum Big &#123; A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31, A32, A33, A34, A35, A36, A37, A38, A39, A40, A41, A42, A43, A44, A45, A46, A47, A48, A49, A50, A51, A52, A53, A54, A55, A56, A57, A58, A59, A60, A61, A62, A63, A64, A65, A66, A67, A68, A69, A70, A71, A72, A73, A74, A75 &#125; public static void main(String[] args) &#123; EnumSet&lt;Big&gt; bigEnumSet = EnumSet.allOf(Big.class); System.out.println(bigEnumSet); &#125;&#125; 输出为： 1234567[A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12,A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23,A24, A25, A26, A27, A28, A29, A30, A31, A32, A33, A34,A35, A36, A37, A38, A39, A40, A41, A42, A43, A44, A45,A46, A47, A48, A49, A50, A51, A52, A53, A54, A55, A56,A57, A58, A59, A60, A61, A62, A63, A64, A65, A66, A67,A68, A69, A70, A71, A72, A73, A74, A75] 显然，EnumSet 可以应用于多过 64 个元素的 enum，所以我猜测，Enum 会在必要的时候增加一个 long。 使用 EnumMapEnumMap 是一种特殊的 Map，它要求其中的键（key）必须来自一个 enum，由于 enum 本身的限制，所以 EnumMap 在内部可由数组实现。因此 EnumMap 的速度很快，我们可以放心地使用 enum 实例在 EnumMap 中进行查找操作。不过，我们只能将 enum 的实例作为键来调用 put() 可方法，其他操作与使用一般的 Map 差不多。 下面的例子演示了命令设计模式的用法。一般来说，命令模式首先需要一个只有单一方法的接口，然后从该接口实现具有各自不同的行为的多个子类。接下来，程序员就可以构造命令对象，并在需要的时候使用它们了： 123456789101112131415161718192021222324252627// enums/EnumMaps.java// Basics of EnumMaps// &#123;java enums.EnumMaps&#125;package enums;import java.util.*;import static enums.AlarmPoints.*;interface Command &#123; void action(); &#125;public class EnumMaps &#123; public static void main(String[] args) &#123; EnumMap&lt;AlarmPoints,Command&gt; em = new EnumMap&lt;&gt;(AlarmPoints.class); em.put(KITCHEN, () -&gt; System.out.println(\"Kitchen fire!\")); em.put(BATHROOM, () -&gt; System.out.println(\"Bathroom alert!\")); for(Map.Entry&lt;AlarmPoints,Command&gt; e: em.entrySet()) &#123; System.out.print(e.getKey() + \": \"); e.getValue().action(); &#125; try &#123; // If there's no value for a particular key: em.get(UTILITY).action(); &#125; catch(Exception e) &#123; System.out.println(\"Expected: \" + e); &#125; &#125;&#125; 输出为： 123BATHROOM: Bathroom alert!KITCHEN: Kitchen fire!Expected: java.lang.NullPointerException 与 EnumSet 一样，enum 实例定义时的次序决定了其在 EnumMap 中的顺序。 main0 方法的最后部分说明，enum 的每个实例作为一个键，总是存在的。但是，如果你没有为这个键调用 put() 方法来存人相应的值的话，其对应的值就是 null。 与常量相关的方法（constant-specific methods 将在下一节中介绍）相比，EnumMap 有一个优点，那 EnumMap 允许程序员改变值对象，而常量相关的方法在编译期就被固定了。稍后你会看到，在你有多种类型的 enum，而且它们之间存在互操作的情况下，我们可以用 EnumMap 实现多路分发（multiple dispatching）。 常量特定方法Java 的 enum 有一个非常有趣的特性，即它允许程序员为 enum 实例编写方法，从而为每个 enum 实例赋予各自不同的行为。要实现常量相关的方法，你需要为 enum 定义一个或多个 abstract 方法，然后为每个 enum 实例实现该抽象方法。参考下面的例子： 123456789101112131415161718192021222324252627282930// enums/ConstantSpecificMethod.javaimport java.util.*;import java.text.*;public enum ConstantSpecificMethod &#123; DATE_TIME &#123; @Override String getInfo() &#123; return DateFormat.getDateInstance() .format(new Date()); &#125; &#125;, CLASSPATH &#123; @Override String getInfo() &#123; return System.getenv(\"CLASSPATH\"); &#125; &#125;, VERSION &#123; @Override String getInfo() &#123; return System.getProperty(\"java.version\"); &#125; &#125;; abstract String getInfo(); public static void main(String[] args) &#123; for(ConstantSpecificMethod csm : values()) System.out.println(csm.getInfo()); &#125;&#125; 输出为： 12345May 9, 2017C:\\Users\\Bruce\\Documents\\GitHub\\on-java\\ExtractedExamples\\\\gradle\\wrapper\\gradle-wrapper.jar1.8.0_112 通过相应的 enum 实例，我们可以调用其上的方法。这通常也称为表驱动的代码（table-driven code，请注意它与前面提到的命令模式的相似之处）。 在面向对象的程序设计中，不同的行为与不同的类关联。而通过常量相关的方法，每个 enum 实例可以具备自己独特的行为，这似乎说明每个 enum 实例就像一个独特的类。在上面的例子中，enum 实例似乎被当作其“超类”ConstantSpecificMethod 来使用，在调用 getInfo() 方法时，体现出多态的行为。 然而，enum 实例与类的相似之处也仅限于此了。我们并不能真的将 enum 实例作为一个类型来使用： 1234567891011121314151617181920212223242526// enums/NotClasses.java// &#123;javap -c LikeClasses&#125;enum LikeClasses &#123; WINKEN &#123; @Override void behavior() &#123; System.out.println(\"Behavior1\"); &#125; &#125;, BLINKEN &#123; @Override void behavior() &#123; System.out.println(\"Behavior2\"); &#125; &#125;, NOD &#123; @Override void behavior() &#123; System.out.println(\"Behavior3\"); &#125; &#125;; abstract void behavior();&#125;public class NotClasses &#123; // void f1(LikeClasses.WINKEN instance) &#123;&#125; // Nope&#125; 输出为（前 12 行）： 12345678910111213Compiled from \"NotClasses.java\"abstract class LikeClasses extendsjava.lang.Enum&lt;LikeClasses&gt; &#123;public static final LikeClasses WINKEN;public static final LikeClasses BLINKEN;public static final LikeClasses NOD;public static LikeClasses[] values();Code:0: getstatic #2 // Field$VALUES:[LLikeClasses;3: invokevirtual #3 // Method\"[LLikeClasses;\".clone:()Ljava/lang/Object;... 在方法 f1() 中，编译器不允许我们将一个 enum 实例当作 class 类型。如果我们分析一下编译器生成的代码，就知道这种行为也是很正常的。因为每个 enum 元素都是一个 LikeClasses 类型的 static final 实例。 同时，由于它们是 static 实例，无法访问外部类的非 static 元素或方法，所以对于内部的 enum 的实例而言，其行为与一般的内部类并不相同。 再看一个更有趣的关于洗车的例子。每个顾客在洗车时，都有一个选择菜单，每个选择对应一个不同的动作。可以将一个常量相关的方法关联到一个选择上，再使用一个 EnumSet 来保存客户的选择： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// enums/CarWash.javaimport java.util.*;public class CarWash &#123; public enum Cycle &#123; UNDERBODY &#123; @Override void action() &#123; System.out.println(\"Spraying the underbody\"); &#125; &#125;, WHEELWASH &#123; @Override void action() &#123; System.out.println(\"Washing the wheels\"); &#125; &#125;, PREWASH &#123; @Override void action() &#123; System.out.println(\"Loosening the dirt\"); &#125; &#125;, BASIC &#123; @Override void action() &#123; System.out.println(\"The basic wash\"); &#125; &#125;, HOTWAX &#123; @Override void action() &#123; System.out.println(\"Applying hot wax\"); &#125; &#125;, RINSE &#123; @Override void action() &#123; System.out.println(\"Rinsing\"); &#125; &#125;, BLOWDRY &#123; @Override void action() &#123; System.out.println(\"Blowing dry\"); &#125; &#125;; abstract void action(); &#125; EnumSet&lt;Cycle&gt; cycles = EnumSet.of(Cycle.BASIC, Cycle.RINSE); public void add(Cycle cycle) &#123; cycles.add(cycle); &#125; public void washCar() &#123; for(Cycle c : cycles) c.action(); &#125; @Override public String toString() &#123; return cycles.toString(); &#125; public static void main(String[] args) &#123; CarWash wash = new CarWash(); System.out.println(wash); wash.washCar();// Order of addition is unimportant: wash.add(Cycle.BLOWDRY); wash.add(Cycle.BLOWDRY); // Duplicates ignored wash.add(Cycle.RINSE); wash.add(Cycle.HOTWAX); System.out.println(wash); wash.washCar(); &#125;&#125; 输出为： 12345678[BASIC, RINSE]The basic washRinsing[BASIC, HOTWAX, RINSE, BLOWDRY]The basic washApplying hot waxRinsingBlowing dry 与使用匿名内部类相比较，定义常量相关方法的语法更高效、简洁。 这个例子也展示了 EnumSet 了一些特性。因为它是一个集合，所以对于同一个元素而言，只能出现一次，因此对同一个参数重复地调用 add0 方法会被忽略掉（这是正确的行为，因为一个 bit 位开关只能“打开”一次），同样地，向 EnumSet 添加 enum 实例的顺序并不重要，因为其输出的次序决定于 enum 实例定义时的次序。 除了实现 abstract 方法以外，程序员是否可以覆盖常量相关的方法呢？答案是肯定的，参考下面的程序： 12345678910111213141516171819// enums/OverrideConstantSpecific.javapublic enum OverrideConstantSpecific &#123; NUT, BOLT, WASHER &#123; @Override void f() &#123; System.out.println(\"Overridden method\"); &#125; &#125;; void f() &#123; System.out.println(\"default behavior\"); &#125; public static void main(String[] args) &#123; for(OverrideConstantSpecific ocs : values()) &#123; System.out.print(ocs + \": \"); ocs.f(); &#125; &#125;&#125; 输出为： 123NUT: default behaviorBOLT: default behaviorWASHER: Overridden method 虽然 enum 有某些限制，但是一般而言，我们还是可以将其看作是类。 使用 enum 的职责链在职责链（Chain of Responsibility）设计模式中，程序员以多种不同的方式来解决一个问题，然后将它们链接在一起。当一个请求到来时，它遍历这个链，直到链中的某个解决方案能够处理该请求。 通过常量相关的方法，我们可以很容易地实现一个简单的职责链。我们以一个邮局的模型为例。邮局需要以尽可能通用的方式来处理每一封邮件，并且要不断尝试处理邮件，直到该邮件最终被确定为一封死信。其中的每一次尝试可以看作为一个策略（也是一个设计模式），而完整的处理方式列表就是一个职责链。 我们先来描述一下邮件。邮件的每个关键特征都可以用 enum 来表示。程序将随机地生成 Mail 对象，如果要减小一封邮件的 GeneralDelivery 为 YES 的概率，那最简单的方法就是多创建几个不是 YES 的 enum 实例，所以 enum 的定义看起来有点古怪。 我们看到 Mail 中有一个 randomMail() 方法，它负责随机地创建用于测试的邮件。而 generator() 方法生成一个 Iterable 对象，该对象在你调用 next() 方法时，在其内部使用 randomMail() 来创建 Mail 对象。这样的结构使程序员可以通过调用 Mail.generator() 方法，很容易地构造出一个 foreach 循环： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// enums/PostOffice.java// Modeling a post officeimport java.util.*;import onjava.*;class Mail &#123; // The NO's reduce probability of random selection: enum GeneralDelivery &#123;YES,NO1,NO2,NO3,NO4,NO5&#125; enum Scannability &#123;UNSCANNABLE,YES1,YES2,YES3,YES4&#125; enum Readability &#123;ILLEGIBLE,YES1,YES2,YES3,YES4&#125; enum Address &#123;INCORRECT,OK1,OK2,OK3,OK4,OK5,OK6&#125; enum ReturnAddress &#123;MISSING,OK1,OK2,OK3,OK4,OK5&#125; GeneralDelivery generalDelivery; Scannability scannability; Readability readability; Address address; ReturnAddress returnAddress; static long counter = 0; long id = counter++; @Override public String toString() &#123; return \"Mail \" + id; &#125; public String details() &#123; return toString() + \", General Delivery: \" + generalDelivery + \", Address Scanability: \" + scannability + \", Address Readability: \" + readability + \", Address Address: \" + address + \", Return address: \" + returnAddress; &#125; // Generate test Mail: public static Mail randomMail() &#123; Mail m = new Mail(); m.generalDelivery = Enums.random(GeneralDelivery.class); m.scannability = Enums.random(Scannability.class); m.readability = Enums.random(Readability.class); m.address = Enums.random(Address.class); m.returnAddress = Enums.random(ReturnAddress.class); return m; &#125; public static Iterable&lt;Mail&gt; generator(final int count) &#123; return new Iterable&lt;Mail&gt;() &#123; int n = count; @Override public Iterator&lt;Mail&gt; iterator() &#123; return new Iterator&lt;Mail&gt;() &#123; @Override public boolean hasNext() &#123; return n-- &gt; 0; &#125; @Override public Mail next() &#123; return randomMail(); &#125; @Override public void remove() &#123; // Not implemented throw new UnsupportedOperationException(); &#125; &#125;; &#125; &#125;; &#125;&#125;public class PostOffice &#123; enum MailHandler &#123; GENERAL_DELIVERY &#123; @Override boolean handle(Mail m) &#123; switch(m.generalDelivery) &#123; case YES: System.out.println( \"Using general delivery for \" + m); return true; default: return false; &#125; &#125; &#125;, MACHINE_SCAN &#123; @Override boolean handle(Mail m) &#123; switch(m.scannability) &#123; case UNSCANNABLE: return false; default: switch(m.address) &#123; case INCORRECT: return false; default: System.out.println( \"Delivering \"+ m + \" automatically\"); return true; &#125; &#125; &#125; &#125;, VISUAL_INSPECTION &#123; @Override boolean handle(Mail m) &#123; switch(m.readability) &#123; case ILLEGIBLE: return false; default: switch(m.address) &#123; case INCORRECT: return false; default: System.out.println( \"Delivering \" + m + \" normally\"); return true; &#125; &#125; &#125; &#125;, RETURN_TO_SENDER &#123; @Override boolean handle(Mail m) &#123; switch(m.returnAddress) &#123; case MISSING: return false; default: System.out.println( \"Returning \" + m + \" to sender\"); return true; &#125; &#125; &#125;; abstract boolean handle(Mail m); &#125; static void handle(Mail m) &#123; for(MailHandler handler : MailHandler.values()) if(handler.handle(m)) return; System.out.println(m + \" is a dead letter\"); &#125; public static void main(String[] args) &#123; for(Mail mail : Mail.generator(10)) &#123; System.out.println(mail.details()); handle(mail); System.out.println(\"*****\"); &#125; &#125;&#125; 输出为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Mail 0, General Delivery: NO2, Address Scanability:UNSCANNABLE, Address Readability: YES3, AddressAddress: OK1, Return address: OK1Delivering Mail 0 normally*****Mail 1, General Delivery: NO5, Address Scanability:YES3, Address Readability: ILLEGIBLE, Address Address:OK5, Return address: OK1Delivering Mail 1 automatically*****Mail 2, General Delivery: YES, Address Scanability:YES3, Address Readability: YES1, Address Address: OK1,Return address: OK5Using general delivery for Mail 2*****Mail 3, General Delivery: NO4, Address Scanability:YES3, Address Readability: YES1, Address Address:INCORRECT, Return address: OK4Returning Mail 3 to sender*****Mail 4, General Delivery: NO4, Address Scanability:UNSCANNABLE, Address Readability: YES1, AddressAddress: INCORRECT, Return address: OK2Returning Mail 4 to sender*****Mail 5, General Delivery: NO3, Address Scanability:YES1, Address Readability: ILLEGIBLE, Address Address:OK4, Return address: OK2Delivering Mail 5 automatically*****Mail 6, General Delivery: YES, Address Scanability:YES4, Address Readability: ILLEGIBLE, Address Address:OK4, Return address: OK4Using general delivery for Mail 6*****Mail 7, General Delivery: YES, Address Scanability:YES3, Address Readability: YES4, Address Address: OK2,Return address: MISSINGUsing general delivery for Mail 7*****Mail 8, General Delivery: NO3, Address Scanability:YES1, Address Readability: YES3, Address Address:INCORRECT, Return address: MISSINGMail 8 is a dead letter*****Mail 9, General Delivery: NO1, Address Scanability:UNSCANNABLE, Address Readability: YES2, AddressAddress: OK1, Return address: OK4Delivering Mail 9 normally***** 职责链由 enum MailHandler 实现，而 enum 定义的次序决定了各个解决策略在应用时的次序。对每一封邮件，都要按此顺序尝试每个解决策略，直到其中一个能够成功地处理该邮件，如果所有的策略都失败了，那么该邮件将被判定为一封死信。 使用 enum 的状态机枚举类型非常适合用来创建状态机。一个状态机可以具有有限个特定的状态，它通常根据输入，从一个状态转移到下一个状态，不过也可能存在瞬时状态（transient states），而一旦任务执行结束，状态机就会立刻离开瞬时状态。 每个状态都具有某些可接受的输入，不同的输入会使状态机从当前状态转移到不同的新状态。由于 enum 对其实例有严格限制，非常适合用来表现不同的状态和输入。一般而言，每个状态都具有一些相关的输出。 自动售贷机是一个很好的状态机的例子。首先，我们用一个 enum 定义各种输入： 123456789101112131415161718192021222324252627// enums/Input.javaimport java.util.*;public enum Input &#123; NICKEL(5), DIME(10), QUARTER(25), DOLLAR(100), TOOTHPASTE(200), CHIPS(75), SODA(100), SOAP(50), ABORT_TRANSACTION &#123; @Override public int amount() &#123; // Disallow throw new RuntimeException(\"ABORT.amount()\"); &#125; &#125;, STOP &#123; // This must be the last instance. @Override public int amount() &#123; // Disallow throw new RuntimeException(\"SHUT_DOWN.amount()\"); &#125; &#125;; int value; // In cents Input(int value) &#123; this.value = value; &#125; Input() &#123;&#125; int amount() &#123; return value; &#125;; // In cents static Random rand = new Random(47); public static Input randomSelection() &#123; // Don't include STOP: return values()[rand.nextInt(values().length - 1)]; &#125;&#125; 注意，除了两个特殊的 Input 实例之外，其他的 Input 都有相应的价格，因此在接口中定义了 amount（方法。然而，对那两个特殊 Input 实例而言，调用 amount（方法并不合适，所以如果程序员调用它们的 amount）方法就会有异常抛出（在接口内定义了一个方法，然后在你调用该方法的某个实现时就会抛出异常），这似乎有点奇怪，但由于 enum 的限制，我们不得不采用这种方式。 VendingMachine 对输入的第一个反应是将其归类为 Category enum 中的某一个 enum 实例，这可以通过 switch 实现。下面的例子演示了 enum 是如何使代码变得更加清晰且易于管理的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151// enums/VendingMachine.java// &#123;java VendingMachine VendingMachineInput.txt&#125;import java.util.*;import java.io.IOException;import java.util.function.*;import java.nio.file.*;import java.util.stream.*;enum Category &#123; MONEY(Input.NICKEL, Input.DIME, Input.QUARTER, Input.DOLLAR), ITEM_SELECTION(Input.TOOTHPASTE, Input.CHIPS, Input.SODA, Input.SOAP), QUIT_TRANSACTION(Input.ABORT_TRANSACTION), SHUT_DOWN(Input.STOP); private Input[] values; Category(Input... types) &#123; values = types; &#125; private static EnumMap&lt;Input,Category&gt; categories = new EnumMap&lt;&gt;(Input.class); static &#123; for(Category c : Category.class.getEnumConstants()) for(Input type : c.values) categories.put(type, c); &#125; public static Category categorize(Input input) &#123; return categories.get(input); &#125;&#125;public class VendingMachine &#123; private static State state = State.RESTING; private static int amount = 0; private static Input selection = null; enum StateDuration &#123; TRANSIENT &#125; // Tagging enum enum State &#123; RESTING &#123; @Override void next(Input input) &#123; switch(Category.categorize(input)) &#123; case MONEY: amount += input.amount(); state = ADDING_MONEY; break; case SHUT_DOWN: state = TERMINAL; default: &#125; &#125; &#125;, ADDING_MONEY &#123; @Override void next(Input input) &#123; switch(Category.categorize(input)) &#123; case MONEY: amount += input.amount(); break; case ITEM_SELECTION: selection = input; if(amount &lt; selection.amount()) System.out.println( \"Insufficient money for \" + selection); else state = DISPENSING; break; case QUIT_TRANSACTION: state = GIVING_CHANGE; break; case SHUT_DOWN: state = TERMINAL; default: &#125; &#125; &#125;, DISPENSING(StateDuration.TRANSIENT) &#123; @Override void next() &#123; System.out.println(\"here is your \" + selection); amount -= selection.amount(); state = GIVING_CHANGE; &#125; &#125;, GIVING_CHANGE(StateDuration.TRANSIENT) &#123; @Override void next() &#123; if(amount &gt; 0) &#123; System.out.println(\"Your change: \" + amount); amount = 0; &#125; state = RESTING; &#125; &#125;, TERMINAL &#123;@Override void output() &#123; System.out.println(\"Halted\"); &#125; &#125;; private boolean isTransient = false; State() &#123;&#125; State(StateDuration trans) &#123; isTransient = true; &#125; void next(Input input) &#123; throw new RuntimeException(\"Only call \" + \"next(Input input) for non-transient states\"); &#125; void next() &#123; throw new RuntimeException( \"Only call next() for \" + \"StateDuration.TRANSIENT states\"); &#125; void output() &#123; System.out.println(amount); &#125; &#125; static void run(Supplier&lt;Input&gt; gen) &#123; while(state != State.TERMINAL) &#123; state.next(gen.get()); while(state.isTransient) state.next(); state.output(); &#125; &#125; public static void main(String[] args) &#123; Supplier&lt;Input&gt; gen = new RandomInputSupplier(); if(args.length == 1) gen = new FileInputSupplier(args[0]); run(gen); &#125;&#125;// For a basic sanity check:class RandomInputSupplier implements Supplier&lt;Input&gt; &#123; @Override public Input get() &#123; return Input.randomSelection(); &#125;&#125;// Create Inputs from a file of ';'-separated strings:class FileInputSupplier implements Supplier&lt;Input&gt; &#123; private Iterator&lt;String&gt; input; FileInputSupplier(String fileName) &#123; try &#123; input = Files.lines(Paths.get(fileName)) .skip(1) // Skip the comment line .flatMap(s -&gt; Arrays.stream(s.split(\";\"))) .map(String::trim) .collect(Collectors.toList()) .iterator(); &#125; catch(IOException e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public Input get() &#123; if(!input.hasNext()) return null; return Enum.valueOf(Input.class, input.next().trim()); &#125;&#125; 输出为： 12345678910111213141516171819202122232425255075here is your CHIPS0100200here is your TOOTHPASTE02535Your change: 3502535Insufficient money for SODA35607075Insufficient money for SODA75Your change: 750Halted 由于用 switch 语句从 enum 实例中进行选择是最常见的一种方式（请注意，为了使 enum 在 switch 语句中的使用变得简单，我们是需要付出其他代价的），所以，我们经常遇到这样的问题：将多个 enum 进行分类时，“我们希望在什么 enum 中使用 switch 语句？”我们通过 VendingMachine 的例子来研究一下这个问题。对于每一个 State，我们都需要在输入动作的基本分类中进行查找：用户塞入钞票，选择了某个货物，操作被取消，以及机器停止。然而，在这些基本分类之下，我们又可以塞人不同类型的钞票，可以选择不同的货物。Category enum 将不同类型的 Input 进行分组，因而，可以使用 categorize0 方法为 switch 语句生成恰当的 Cateroy 实例。并且，该方法使用的 EnumMap 确保了在其中进行查询时的效率与安全。 如果读者仔细研究 VendingMachine 类，就会发现每种状态的不同之处，以及对于输入的不同响应，其中还有两个瞬时状态。在 run() 方法中，状态机等待着下一个 Input，并一直在各个状态中移动，直到它不再处于瞬时状态。 通过两种不同的 Generator 对象，我们可以使用不同的 Supplier 对象来测试 VendingMachine，首先是 RandomInputSupplier，它会不停地生成除了 SHUT-DOWN 之外的各种输入。通过长时间地运行 RandomInputSupplier，可以起到健全测试（sanity test）的作用，能够确保该状态机不会进入一个错误状态。另一个是 FileInputSupplier，使用文件以文本的方式来描述输入，然后将它们转换成 enum 实例，并创建对应的 Input 对象。上面的程序使用的正是如下的文本文件： 12345678// enums/VendingMachineInput.txtQUARTER; QUARTER; QUARTER; CHIPS;DOLLAR; DOLLAR; TOOTHPASTE;QUARTER; DIME; ABORT_TRANSACTION;QUARTER; DIME; SODA;QUARTER; DIME; NICKEL; SODA;ABORT_TRANSACTION;STOP; FileInputSupplier 构造函数将此文件转换为流，并跳过注释行。然后它使用 String.split() 以分号进行分割。这会生成一个 String 数组，并可以通过将其转换为 Stream，然后应用 flatMap() 来将其输入到流中。其输出结果将去除所有空格空格，并转换为 List&lt;String&gt;，且从中获取 Iterator&lt;String&gt;。 这种设计有一个缺陷，它要求 enum State 实例访问的 VendingMachine 属性必须声明为 static，这意味着，你只能有一个 VendingMachine 实例。不过如果我们思考一下实际的（嵌入式 Java）应用，这也许并不是一个大问题，因为在一台机器上，我们可能只有一个应用程序。 多路分发当你要处理多种交互类型时，程序可能会变得相当杂乱。举例来说，如果一个系统要分析和执行数学表达式。我们可能会声明 Number.plus(Number)，Number.multiple(Number) 等等，其中 Number 是各种数字对象的超类。然而，当你声明 a.plus(b) 时，你并不知道 a 或 b 的确切类型，那你如何能让它们正确地交互呢？ 你可能从未思考过这个问题的答案.Java 只支持单路分发。也就是说，如果要执行的操作包含了不止一个类型未知的对象时，那么 Java 的动态绑定机制只能处理其中一个的类型。这就无法解决我们上面提到的问题。所以，你必须自己来判定其他的类型，从而实现自己的动态线定行为。 解决上面问题的办法就是多路分发（在那个例子中，只有两个分发，一般称之为两路分发）.多态只能发生在方法调用时，所以，如果你想使用两路分发，那么就必须有两个方法调用：第一个方法调用决定第一个未知类型，第二个方法调用决定第二个未知的类型。要利用多路分发，程序员必须为每一个类型提供一个实际的方法调用，如果你要处理两个不同的类型体系，就需要为每个类型体系执行一个方法调用。一般而言，程序员需要有设定好的某种配置，以便一个方法调用能够引出更多的方法调用，从而能够在这个过程中处理多种类型。为了达到这种效果，我们需要与多个方法一同工作：因为每个分发都需要一个方法调用。在下面的例子中（实现了 “石头、剪刀、布”游戏，也称为 RoShamBo）对应的方法是 compete() 和 eval()，二者都是同一个类型的成员，它们可以产生三种 Outcome 实例中的一个作为结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// enums/Outcome.javapackage enums;public enum Outcome &#123; WIN, LOSE, DRAW &#125;// enums/RoShamBo1.java// Demonstration of multiple dispatching// &#123;java enums.RoShamBo1&#125;package enums; import java.util.*; import static enums.Outcome.*;interface Item &#123; Outcome compete(Item it); Outcome eval(Paper p); Outcome eval(Scissors s); Outcome eval(Rock r);&#125;class Paper implements Item &#123; @Override public Outcome compete(Item it) &#123; return it.eval(this); &#125; @Override public Outcome eval(Paper p) &#123; return DRAW; &#125; @Override public Outcome eval(Scissors s) &#123; return WIN; &#125; @Override public Outcome eval(Rock r) &#123; return LOSE; &#125; @Override public String toString() &#123; return \"Paper\"; &#125;&#125;class Scissors implements Item &#123; @Override public Outcome compete(Item it) &#123; return it.eval(this); &#125; @Override public Outcome eval(Paper p) &#123; return LOSE; &#125; @Override public Outcome eval(Scissors s) &#123; return DRAW; &#125; @Override public Outcome eval(Rock r) &#123; return WIN; &#125; @Override public String toString() &#123; return \"Scissors\"; &#125;&#125;class Rock implements Item &#123; @Override public Outcome compete(Item it) &#123; return it.eval(this); &#125; @Override public Outcome eval(Paper p) &#123; return WIN; &#125; @Override public Outcome eval(Scissors s) &#123; return LOSE; &#125; @Override public Outcome eval(Rock r) &#123; return DRAW; &#125; @Override public String toString() &#123; return \"Rock\"; &#125;&#125;public class RoShamBo1 &#123; static final int SIZE = 20; private static Random rand = new Random(47); public static Item newItem() &#123; switch(rand.nextInt(3)) &#123; default: case 0: return new Scissors(); case 1: return new Paper(); case 2: return new Rock(); &#125; &#125; public static void match(Item a, Item b) &#123; System.out.println( a + \" vs. \" + b + \": \" + a.compete(b)); &#125; public static void main(String[] args) &#123; for(int i = 0; i &lt; SIZE; i++) match(newItem(), newItem()); &#125;&#125; 输出为： 1234567891011121314151617181920Rock vs. Rock: DRAWPaper vs. Rock: WINPaper vs. Rock: WINPaper vs. Rock: WINScissors vs. Paper: WINScissors vs. Scissors: DRAWScissors vs. Paper: WINRock vs. Paper: LOSEPaper vs. Paper: DRAWRock vs. Paper: LOSEPaper vs. Scissors: LOSEPaper vs. Scissors: LOSERock vs. Scissors: WINRock vs. Paper: LOSEPaper vs. Rock: WINScissors vs. Paper: WINPaper vs. Scissors: LOSEPaper vs. Scissors: LOSEPaper vs. Scissors: LOSEPaper vs. Scissors: LOSE Item 是这几种类型的接口，将会被用作多路分发。RoShamBo1.match() 有两个 Item 参数，通过调用 Item.compete90) 方法开始两路分发。要判定 a 的类型，分发机制会在 a 的实际类型的 compete（内部起到分发的作用。compete() 方法通过调用 eval() 来为另一个类型实现第二次分法。 将自身（this）作为参数调用 evalo，能够调用重载过的 eval() 方法，这能够保留第一次分发的类型信息。当第二次分发完成时，你就能够知道两个 Item 对象的具体类型了。 要配置好多路分发需要很多的工序，不过要记住，它的好处在于方法调用时的优雅的话法，这避免了在一个方法中判定多个对象的类型的丑陋代码，你只需说，“嘿，你们两个，我不在乎你们是什么类型，请你们自己交流！”不过，在使用多路分发前，请先明确，这种优雅的代码对你确实有重要的意义。 使用 enum 分发直接将 RoShamBol.java 翻译为基于 enum 的版本是有问题的，因为 enum 实例不是类型，不能将 enum 实例作为参数的类型，所以无法重载 eval() 方法。不过，还有很多方式可以实现多路分发，并从 enum 中获益。 一种方式是使用构造器来初始化每个 enum 实例，并以“一组”结果作为参数。这二者放在一块，形成了类似查询表的结构： 1234567891011121314151617181920212223242526272829// enums/RoShamBo2.java// Switching one enum on another// &#123;java enums.RoShamBo2&#125;package enums;import static enums.Outcome.*;public enum RoShamBo2 implements Competitor&lt;RoShamBo2&gt; &#123; PAPER(DRAW, LOSE, WIN), SCISSORS(WIN, DRAW, LOSE), ROCK(LOSE, WIN, DRAW); private Outcome vPAPER, vSCISSORS, vROCK; RoShamBo2(Outcome paper, Outcome scissors, Outcome rock) &#123; this.vPAPER = paper; this.vSCISSORS = scissors; this.vROCK = rock; &#125; @Override public Outcome compete(RoShamBo2 it) &#123; switch(it) &#123; default: case PAPER: return vPAPER; case SCISSORS: return vSCISSORS; case ROCK: return vROCK; &#125; &#125; public static void main(String[] args) &#123; RoShamBo.play(RoShamBo2.class, 20); &#125;&#125; 输出为： 1234567891011121314151617181920ROCK vs. ROCK: DRAWSCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSEPAPER vs. SCISSORS: LOSEPAPER vs. PAPER: DRAWPAPER vs. SCISSORS: LOSEROCK vs. SCISSORS: WINSCISSORS vs. SCISSORS: DRAWROCK vs. SCISSORS: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINROCK vs. PAPER: LOSEROCK vs. SCISSORS: WINSCISSORS vs. ROCK: LOSEPAPER vs. SCISSORS: LOSESCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WIN 在 compete() 方法中，一旦两种类型都被确定了，那么唯一的操作就是返回结果 Outcome 然而，你可能还需要调用其他的方法，（例如）甚至是调用在构造器中指定的某个命令对象上的方法。 RoShamBo2.javal 之前的例子短小得多，而且更直接，更易于理解。注意，我们仍然是使用两路分发来判定两个对象的类型。在 RoShamBol.java 中，两次分发都是通过实际的方法调用实现，而在这个例子中，只有第一次分发是实际的方法调用。第二个分发使用的是 switch，不过这样做是安全的，因为 enum 限制了 switch 语句的选择分支。 在代码中，enum 被单独抽取出来，因此它可以应用在其他例子中。首先，Competitor 接口定义了一种类型，该类型的对象可以与另一个 Competitor 相竞争： 123456// enums/Competitor.java// Switching one enum on anotherpackage enums;public interface Competitor&lt;T extends Competitor&lt;T&gt;&gt; &#123; Outcome compete(T competitor);&#125; 然后，我们定义两个 static 方法（static 可以避免显式地指明参数类型），第一个是 match() 方法，它会为一个 Competitor 对象调用 compete() 方法，并与另一个 Competitor 对象作比较。在这个例子中，我们看到，match()）方法的参数需要是 Competitor&lt;T&gt; 类型。但是在 play() 方法中，类型参数必须同时是 Enum&lt;T&gt; 类型（因为它将在 Enums.random() 中使用）和 Competitor&lt;T&gt; 类型因为它将被传递给 match() 方法）： 12345678910111213141516// enums/RoShamBo.java// Common tools for RoShamBo examplespackage enums;import onjava.*;public class RoShamBo &#123; public static &lt;T extends Competitor&lt;T&gt;&gt; void match(T a, T b) &#123; System.out.println( a + \" vs. \" + b + \": \" + a.compete(b)); &#125; public static &lt;T extends Enum&lt;T&gt; &amp; Competitor&lt;T&gt;&gt; void play(Class&lt;T&gt; rsbClass, int size) &#123; for(int i = 0; i &lt; size; i++) match(Enums.random(rsbClass),Enums.random(rsbClass)); &#125;&#125; play() 方法没有将类型参数 T 作为返回值类型，因此，似乎我们应该在 Class&lt;T&gt; 中使用通配符来代替上面的参数声明。然而，通配符不能扩展多个基类，所以我们必须采用以上的表达式。 使用常量相关的方法常量相关的方法允许我们为每个 enum 实例提供方法的不同实现，这使得常量相关的方法似乎是实现多路分发的完美解决方案。不过，通过这种方式，enum 实例虽然可以具有不同的行为，但它们仍然不是类型，不能将其作为方法签名中的参数类型来使用。最好的办法是将 enum 用在 switch 语句中，见下例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// enums/RoShamBo3.java// Using constant-specific methods// &#123;java enums.RoShamBo3&#125;package enums;import static enums.Outcome.*;public enum RoShamBo3 implements Competitor&lt;RoShamBo3&gt; &#123; PAPER &#123; @Override public Outcome compete(RoShamBo3 it) &#123; switch(it) &#123; default: // To placate the compiler case PAPER: return DRAW; case SCISSORS: return LOSE; case ROCK: return WIN; &#125; &#125; &#125;, SCISSORS &#123; @Override public Outcome compete(RoShamBo3 it) &#123; switch(it) &#123; default: case PAPER: return WIN; case SCISSORS: return DRAW; case ROCK: return LOSE; &#125; &#125; &#125;, ROCK &#123; @Override public Outcome compete(RoShamBo3 it) &#123; switch(it) &#123; default: case PAPER: return LOSE; case SCISSORS: return WIN; case ROCK: return DRAW; &#125; &#125; &#125;; @Override public abstract Outcome compete(RoShamBo3 it); public static void main(String[] args) &#123; RoShamBo.play(RoShamBo3.class, 20); &#125;&#125; 输出为： 1234567891011121314151617181920ROCK vs. ROCK: DRAWSCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSEPAPER vs. SCISSORS: LOSEPAPER vs. PAPER: DRAWPAPER vs. SCISSORS: LOSEROCK vs. SCISSORS: WINSCISSORS vs. SCISSORS: DRAWROCK vs. SCISSORS: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINROCK vs. PAPER: LOSEROCK vs. SCISSORS: WINSCISSORS vs. ROCK: LOSEPAPER vs. SCISSORS: LOSESCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WIN 虽然这种方式可以工作，但是却不甚合理，如果采用 RoShamB02.java 的解决方案，那么在添加一个新的类型时，只需更少的代码，而且也更直接。 :然而，RoShamBo3.java 还可以压缩简化一下： 12345678910111213141516171819202122232425262728293031// enums/RoShamBo4.java// &#123;java enums.RoShamBo4&#125;package enums;public enum RoShamBo4 implements Competitor&lt;RoShamBo4&gt; &#123; ROCK &#123; @Override public Outcome compete(RoShamBo4 opponent) &#123; return compete(SCISSORS, opponent); &#125; &#125;, SCISSORS &#123; @Override public Outcome compete(RoShamBo4 opponent) &#123; return compete(PAPER, opponent); &#125; &#125;, PAPER &#123; @Override public Outcome compete(RoShamBo4 opponent) &#123; return compete(ROCK, opponent); &#125; &#125;; Outcome compete(RoShamBo4 loser, RoShamBo4 opponent) &#123; return ((opponent == this) ? Outcome.DRAW : ((opponent == loser) ? Outcome.WIN : Outcome.LOSE)); &#125; public static void main(String[] args) &#123; RoShamBo.play(RoShamBo4.class, 20); &#125;&#125; 输出为： 1234567891011121314151617181920PAPER vs. PAPER: DRAWSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINROCK vs. SCISSORS: WINROCK vs. ROCK: DRAWROCK vs. SCISSORS: WINPAPER vs. SCISSORS: LOSESCISSORS vs. SCISSORS: DRAWPAPER vs. SCISSORS: LOSESCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSEPAPER vs. ROCK: WINPAPER vs. SCISSORS: LOSESCISSORS vs. PAPER: WINROCK vs. SCISSORS: WINSCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSE 其中，具有两个参数的 compete() 方法执行第二个分发，该方法执行一系列的比较，其行为类似 switch 语句。这个版本的程序更简短，不过却比较难理解，对于一个大型系统而言，难以理解的代码将导致整个系统不够健壮。 使用 EnumMap 进行分发使用 EnumMap 能够实现“真正的”两路分发。EnumMap 是为 enum 专门设计的一种性能非常好的特殊 Map。由于我们的目的是摸索出两种未知的类型，所以可以用一个 EnumMap 的 EnumMap 来实现两路分发： 123456789101112131415161718192021222324252627282930313233// enums/RoShamBo5.java// Multiple dispatching using an EnumMap of EnumMaps// &#123;java enums.RoShamBo5&#125;package enums;import java.util.*;import static enums.Outcome.*;enum RoShamBo5 implements Competitor&lt;RoShamBo5&gt; &#123; PAPER, SCISSORS, ROCK; static EnumMap&lt;RoShamBo5,EnumMap&lt;RoShamBo5,Outcome&gt;&gt; table = new EnumMap&lt;&gt;(RoShamBo5.class); static &#123; for(RoShamBo5 it : RoShamBo5.values()) table.put(it, new EnumMap&lt;&gt;(RoShamBo5.class)); initRow(PAPER, DRAW, LOSE, WIN); initRow(SCISSORS, WIN, DRAW, LOSE); initRow(ROCK, LOSE, WIN, DRAW); &#125; static void initRow(RoShamBo5 it, Outcome vPAPER, Outcome vSCISSORS, Outcome vROCK) &#123; EnumMap&lt;RoShamBo5,Outcome&gt; row = RoShamBo5.table.get(it); row.put(RoShamBo5.PAPER, vPAPER); row.put(RoShamBo5.SCISSORS, vSCISSORS); row.put(RoShamBo5.ROCK, vROCK); &#125; @Override public Outcome compete(RoShamBo5 it) &#123; return table.get(this).get(it); &#125; public static void main(String[] args) &#123; RoShamBo.play(RoShamBo5.class, 20); &#125;&#125; 输出为： 1234567891011121314151617181920ROCK vs. ROCK: DRAWSCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSEPAPER vs. SCISSORS: LOSEPAPER vs. PAPER: DRAWPAPER vs. SCISSORS: LOSEROCK vs. SCISSORS: WINSCISSORS vs. SCISSORS: DRAWROCK vs. SCISSORS: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINROCK vs. PAPER: LOSEROCK vs. SCISSORS: WINSCISSORS vs. ROCK: LOSEPAPER vs. SCISSORS: LOSESCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WIN 该程序在一个 static 子句中初始化 EnumMap 对象，具体见表格似的 initRow() 方法调用。请注意 compete() 方法，您可以看到，在一行语句中发生了两次分发。 使用二维数组我们还可以进一步简化实现两路分发的解决方案。我们注意到，每个 enum 实例都有一个固定的值（基于其声明的次序），并且可以通过 ordinal() 方法取得该值。因此我们可以使用二维数组，将竞争者映射到竞争结果。采用这种方式能够获得最简洁、最直接的解决方案（很可能也是最快速的，虽然我们知道 EnumMap 内部其实也是使用数组实现的）。 12345678910111213141516171819202122232425We can simplify the solution even more by noting that each enum instance has a fixed value (based on its declaration order) and that ordinal() produces this value. A two- dimensional array mapping the competitors onto the outcomes produces the smallest and most straightforward solution (and possibly the fastest, although remember that EnumMap uses an internal array):// enums/RoShamBo6.java// Enums using \"tables\" instead of multiple dispatch// &#123;java enums.RoShamBo6&#125; package enums; import static enums.Outcome.*;enum RoShamBo6 implements Competitor&lt;RoShamBo6&gt; &#123; PAPER, SCISSORS, ROCK; private static Outcome[][] table = &#123; &#123; DRAW, LOSE, WIN &#125;, // PAPER &#123; WIN, DRAW, LOSE &#125;, // SCISSORS &#123; LOSE, WIN, DRAW &#125;, // ROCK &#125;; @Override public Outcome compete(RoShamBo6 other) &#123; return table[this.ordinal()][other.ordinal()]; &#125; public static void main(String[] args) &#123; RoShamBo.play(RoShamBo6.class, 20); &#125;&#125; 输出为： 1234567891011121314151617181920ROCK vs. ROCK: DRAWSCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSESCISSORS vs. ROCK: LOSEPAPER vs. SCISSORS: LOSEPAPER vs. PAPER: DRAWPAPER vs. SCISSORS: LOSEROCK vs. SCISSORS: WINSCISSORS vs. SCISSORS: DRAWROCK vs. SCISSORS: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINROCK vs. PAPER: LOSEROCK vs. SCISSORS: WINSCISSORS vs. ROCK: LOSEPAPER vs. SCISSORS: LOSESCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WINSCISSORS vs. PAPER: WIN table 与前一个例子中 initRow() 方法的调用次序完全相同。 与前面一个例子相比，这个程序代码虽然简短，但表达能力却更强，部分原因是其代码更易于理解与修改，而且也更直接。不过，由于它使用的是数组，所以这种方式不太“安全”。如果使用一个大型数组，可能会不小心使用了错误的尺寸，而且，如果你的测试不能覆盖所有的可能性，有些错误可能会从你眼前溜过。 事实上，以上所有的解决方案只是各种不同类型的表罢了。不过，分析各种表的表现形式，找出最适合的那一种，还是很有价值的。注意，虽然上例是最简洁的一种解决方案，但它也是相当僵硬的方案，因为它只能针对给定的常量输入产生常量输出。然而，也没有什么特别的理由阻止你用 table 来生成功能对象。对于某类问题而言，“表驱动式编码”的概念具有非常强大的功能。 本章小结虽然枚举类型本身并不是特别复杂，但我还是将本章安排在全书比较靠后的位置，这是因为，程序员可以将 enum 与 Java 语言的其他功能结合使用，例如多态、泛型和反射。 虽然 Java 中的枚举比 C 或 C++中的 enum 更成熟，但它仍然是一个“小”功能，Java 没有它也已经（虽然有点笨拙）存在很多年了。而本章正好说明了一个“小”功能所能带来的价值。有时恰恰因为它，你才能够优雅而干净地解决问题。正如我在本书中一再强调的那样，优雅与清晰很重要，正是它们区别了成功的解决方案与失败的解决方案。而失败的解决方案就是因为其他人无法理解它。 关于清晰的话题，Java 1.0 对术语 enumeration 的选择正是一个不幸的反例。对于一个专门用于从序列中选择每一个元素的对象而言，Java 竟然没有使用更通用、更普遍接受的术语 ierator 来表示它（参见集合 章节），有些语言甚至将枚举的数据类型称为 “enumerators”！Java 修正了这个错误，但是 Enumeration 接口已经无法轻易地抹去了，因此它将一直存在于旧的（甚至有些新的）代码、类库以及文档中。 第二十三章 注解 issueequals() 方法的标准形式参考 附录：理解 equals 和 hashCode 方法 一章。 你可以在 附录:流式 I/O 了解更多内容）这种”困难方式”的全部细节都在 Appendix: I/O Streams。附录：集合主题中，还将学习到其余的那些集合和相关功能，以及如何使用它们的更多详细信息。在泛型章节中，你将了解到使用 Java 泛型来创建类可能很复杂。将在附录：理解equals和hashCode方法中了解有关散列码的内容。并行-并发：使用并行编程技术编写，如果只有一个处理器，结果程序仍然可以运行（==Java 8 Streams==就是一个很好的例子）。对并发性的语言和库支持似乎==Leaky Abstraction是完美候选者==。抽象的目标是“抽象出”那些对于手头想法不重要的东西，从不必要的细节中汲取灵感。如果抽象是漏洞，那些碎片和细节会不断重新声明自己是重要的，无论你试图隐藏它们多少直到 [附录:集合主题] 在附录中有包含：对象传递和返回。 我们直接给出正确的结果：Math.random() 的结果集范围包含 0.0 ，不包含 1.0。 在数学术语中，可用 [0,1）来表示。 otherjavap可以用 JDK 自带的 javap 工具来反编译以上代码。命令如下： 1javap -c Concatenation 这里的 -c 标志表示将生成 JVM 字节码。我们剔除不感兴趣的部分，然后做细微的修改，于是有了以下的字节码： 12345678910111213141516171819202122public static void main(java.lang.String[]); Code: Stack=2, Locals=3, Args_size=1 0: ldc #2; //String mango 2: astore_1 3: new #3; //class StringBuilder 6: dup 7: invokespecial #4; //StringBuilder.\"&lt;init&gt;\":() 10: ldc #5; //String abc 12: invokevirtual #6; //StringBuilder.append:(String) 15: aload_1 16: invokevirtual #6; //StringBuilder.append:(String) 19: ldc #7; //String def 21: invokevirtual #6; //StringBuilder.append:(String) 24: bipush 47 26: invokevirtual #8; //StringBuilder.append:(I) 29: invokevirtual #9; //StringBuilder.toString:() 32: astore_2 33: getstatic #10; //Field System.out:PrintStream; 36: aload_2 37: invokevirtual #11; //PrintStream.println:(String) 40: return 如果你有汇编语言的经验，以上代码应该很眼熟(其中的 dup 和 invokevirtual 语句相当于Java虚拟机上的汇编语句。即使你完全不了解汇编语言也无需担心)。需要重点注意的是：编译器自动引入了 java.lang.StringBuilder 类。虽然源代码中并没有使用 StringBuilder 类，但是编译器却自作主张地使用了它，就因为它更高效。 在这里，编译器创建了一个 StringBuilder 对象，用于构建最终的 String，并对每个字符串调用了一次 append() 方法，共计 4 次。最后调用 toString() 生成结果，并存为 s (使用的命令为 astore_2)。 System.out.format() System.out.format() 来显示。它类似于 System.out.println() 但提供了更多的显示选项。 这里，%f 表示我将 n 作为浮点值给出，%d 表示 n 是一个整数值。 这其中可以包含空格，输入 %n 会换行 — 当然使用传统的 \\n 也能换行，但 %n 是自动跨平台的，这是使用 format() 的另一个原因。 高阶函数这个名字可能听起来令人生畏，但是：高阶函数（Higher-order Function）只是一个消费或产生函数的函数。 我们先来看看如何产生一个函数： 12345678910111213141516// functional/ProduceFunction.javaimport java.util.function.*;interfaceFuncSS extends Function&lt;String, String&gt; &#123;&#125; // [1]public class ProduceFunction &#123; static FuncSS produce() &#123; return s -&gt; s.toLowerCase(); // [2] &#125; public static void main(String[] args) &#123; FuncSS f = produce(); System.out.println(f.apply(\"YELLING\")); &#125;&#125; 输出结果： 1yelling 这里，produce() 是高阶函数。 [1] 使用继承，可以轻松地为专用接口创建别名。 [2] 使用 Lambda 表达式，可以轻松地在方法中创建和返回一个函数。 要消费一个函数，消费函数需要在参数列表正确地描述函数类型。代码示例： 123456789101112131415// functional/ConsumeFunction.javaimport java.util.function.*;class One &#123;&#125;class Two &#123;&#125;public class ConsumeFunction &#123; static Two consume(Function&lt;One,Two&gt; onetwo) &#123; return onetwo.apply(new One()); &#125; public static void main(String[] args) &#123; Two two = consume(one -&gt; new Two()); &#125;&#125; 当基于消费函数生成新函数时，事情就变得相当有趣了。代码示例如下： 1234567891011121314151617181920212223242526272829// functional/TransformFunction.javaimport java.util.function.*;class I &#123; @Override public String toString() &#123; return \"I\"; &#125;&#125;class O &#123; @Override public String toString() &#123; return \"O\"; &#125;&#125;public class TransformFunction &#123; static Function&lt;I,O&gt; transform(Function&lt;I,O&gt; in) &#123; return in.andThen(o -&gt; &#123; System.out.println(o); return o; &#125;); &#125; public static void main(String[] args) &#123; Function&lt;I,O&gt; f2 = transform(i -&gt; &#123; System.out.println(i); return new O(); &#125;); O o = f2.apply(new I()); &#125;&#125; 输出结果： 12IO 在这里，transform() 生成一个与传入的函数具有相同签名的函数，但是你可以生成任何你想要的类型。 这里使用到了 Function 接口中名为 andThen() 的默认方法，该方法专门用于操作函数。 顾名思义，在调用 in 函数之后调用 toThen()（还有个 compose() 方法，它在 in 函数之前应用新函数）。 要附加一个 andThen() 函数，我们只需将该函数作为参数传递。 transform() 产生的是一个新函数，它将 in 的动作与 andThen() 参数的动作结合起来。 获取类名123class Reporter implements AutoCloseable &#123; String name = getClass().getSimpleName();&#125; 揭示细节为了研究 try-with-resources 的基本机制，我们将创建自己的 AutoCloseable 类： 123456789101112131415161718192021// exceptions/AutoCloseableDetails.javaclass Reporter implements AutoCloseable &#123; String name = getClass().getSimpleName(); Reporter() &#123; System.out.println(\"Creating \" + name); &#125; public void close() &#123; System.out.println(\"Closing \" + name); &#125;&#125;class First extends Reporter &#123;&#125;class Second extends Reporter &#123;&#125;public class AutoCloseableDetails &#123; public static void main(String[] args) &#123; try( First f = new First(); Second s = new Second() ) &#123; &#125; &#125;&#125; 输出为： 1234Creating FirstCreating SecondClosing SecondClosing First 退出 try 块会调用两个对象的 close() 方法，并以与创建顺序相反的顺序关闭它们。顺序很重要，因为在此配置中，Second 对象可能依赖于 First 对象，因此如果 First 在第 Second 关闭时已经关闭。 Second 的 close() 方法可能会尝试访问 First 中不再可用的某些功能。 异常匹配System.nanoTime() 返回正在运行的Java虚拟机的高分辨率时间源的当前值，以纳秒为单位。 此方法只能用于测量经过的时间，并且与系统或挂钟时间的任何其他概念无关。返回的值表示纳秒，因为某些固定的任意原点时间 （可能在将来，因此值可能为负）。 在Java虚拟机的实例中，所有对此方法的调用都使用相同的原点;其他虚拟机实例可能使用不同的来源。 此方法提供纳秒级精度，但不一定是纳秒级分辨率（即，值的变化频率） - 除了分辨率至少与currentTimeMillis（）的分辨率一样好之外，不做任何保证。 连续调用的差异超过大约292年（2^63纳秒）将无法正确计算由于数值溢出而导致的经过时间。 只有在计算在Java虚拟机的同一实例中获得的两个此类值之间的差异时，此方法返回的值才有意义。 例如，要测量某些代码执行所需的时间： long startTime = System.nanoTime（）; // …正在测量的代码…… long estimatedTime = System.nanoTime（） - startTime; 比较两个nanoTime值 long t0 = System.nanoTime（）; … long t1 = System.nanoTime（）; 一个应该使用t1 - t0 &lt;0，而不是t1 &lt;t0，因为数字溢出的可能性. Returns：正在运行的Java虚拟机的高分辨率时间源的当前值，以纳秒为单位 从以下版本开始：1.5 并发编程并发编程 对于更多凌乱，低级别的细节，请参阅附录：并发底层原理 概念要进一步深入这个领域，你还必须阅读Brian Goetz等人的Java Concurrency in Practice。 并发是关于正确有效地控制对共享资源的访问。 并行是使用额外的资源来更快地产生结果。 并发 同时完成多个任务。在开始处理其他任务之前，当前任务不需要完成。并发解决了阻塞发生的问题。当任务无法进一步执行，直到外部环境发生变化时才会继续执行。最常见的例子是I/O，其中任务必须等待一些input（在这种情况下会被阻止）。这个问题产生在I/O密集型。 并行 同时在多个地方完成多个任务。这解决了所谓的计算密集型问题，如果将程序分成多个部分并在不同的处理器上编辑不同的部分，程序可以运行得更快。 并发性是一系列性能技术，专注于减少等待 在Java中，并发是非常棘手和困难的，所以绝对不要使用它，除非你有一个重大的性能问题","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"OnJava8-3","slug":"java-note/OnJava8/OnJava8-3","date":"2019-10-13T14:19:09.000Z","updated":"2021-10-23T02:19:02.849Z","comments":true,"path":"2019/10/java-note/OnJava8/OnJava8-3/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/OnJava8/OnJava8-3/","excerpt":"[TOC]第二十章 泛型 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。 多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 final 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。","text":"[TOC]第二十章 泛型 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。 多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 final 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。 拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。 即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。 这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了参数化类型，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。 如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。 然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。 这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望. 与 C++ 的比较Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。 但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ 模板（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。 第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。 简单泛型促成泛型出现的最主要的动机之一是为了创建集合类，参见 集合 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。 在 Java 5 之前，我们可以让这个类直接持有 Object 类型的对象： 1234567891011121314151617// generics/ObjectHolder.javapublic class ObjectHolder &#123; private Object a; public ObjectHolder(Object a) &#123; this.a = a; &#125; public void set(Object a) &#123; this.a = a; &#125; public Object get() &#123; return a; &#125; public static void main(String[] args) &#123; ObjectHolder h2 = new ObjectHolder(new Automobile()); Automobile a = (Automobile)h2.get(); h2.set(\"Not an Automobile\"); String s = (String)h2.get(); h2.set(1); // 自动装箱为 Integer Integer x = (Integer)h2.get(); &#125;&#125; 现在，ObjectHolder 可以持有任何类型的对象，在上面的示例中，一个 ObjectHolder 先后持有了三种不同类型的对象。 一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。 因此，与其使用 Object ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，T 就是类型参数： 12345678910111213141516// generics/GenericHolder.javapublic class GenericHolder&lt;T&gt; &#123; private T a; public GenericHolder() &#123;&#125; public void set(T a) &#123; this.a = a; &#125; public T get() &#123; return a; &#125; public static void main(String[] args) &#123; GenericHolder&lt;Automobile&gt; h3 = new GenericHolder&lt;Automobile&gt;(); h3.set(new Automobile()); // 此处有类型校验 Automobile a = h3.get(); // 无需类型转换 //- h3.set(\"Not an Automobile\"); // 报错 //- h3.set(1); // 报错 &#125;&#125; 创建 GenericHolder 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 main() 中那样使用。然后，你就只能在 GenericHolder 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 get() 取值时，直接就是正确的类型。 这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。 你可能注意到 h3 的定义非常繁复。在 = 左边有 GenericHolder&lt;Automobile&gt;, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子： 1GenericHolder&lt;Bob&gt; h3 = new GenericHolder&lt;&gt;(); 注意，在 h3 的定义处，= 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。 一般来说，你可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，你只需要指定它们的名称和类型参数列表即可。 一个元组类库有时一个方法需要能返回多个对象。而 return 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。 这个概念称为元组，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 数据传输对象 或 信使 ）。 通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组： 1234567891011121314// onjava/Tuple2.javapackage onjava;public class Tuple2&lt;A, B&gt; &#123; public final A a1; public final B a2; public Tuple2(A a, B b) &#123; a1 = a; a2 = b; &#125; public String rep() &#123; return a1 + \", \" + a2; &#125; @Override public String toString() &#123; return \"(\" + rep() + \")\"; &#125;&#125; 构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。 初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。a1 和 a2 应该声明为 private，然后提供 getFirst() 和 getSecond() 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 a1 和 a2 然后对它们执行任何操作，但无法对 a1 和 a2 重新赋值。例子中的 final 可以实现同样的效果，并且更为简洁明了。 另一种设计思路是允许元组的用户给 a1 和 a2 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 Tuple2 对象。 我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// onjava/Tuple3.javapackage onjava;public class Tuple3&lt;A, B, C&gt; extends Tuple2&lt;A, B&gt; &#123; public final C a3; public Tuple3(A a, B b, C c) &#123; super(a, b); a3 = c; &#125; @Override public String rep() &#123; return super.rep() + \", \" + a3; &#125;&#125;// onjava/Tuple4.javapackage onjava;public class Tuple4&lt;A, B, C, D&gt; extends Tuple3&lt;A, B, C&gt; &#123; public final D a4; public Tuple4(A a, B b, C c, D d) &#123; super(a, b, c); a4 = d; &#125; @Override public String rep() &#123; return super.rep() + \", \" + a4; &#125;&#125;// onjava/Tuple5.javapackage onjava;public class Tuple5&lt;A, B, C, D, E&gt; extends Tuple4&lt;A, B, C, D&gt; &#123; public final E a5; public Tuple5(A a, B b, C c, D d, E e) &#123; super(a, b, c, d); a5 = e; &#125; @Override public String rep() &#123; return super.rep() + \", \" + a5; &#125;&#125; 演示需要，再定义两个类： 12345// generics/Amphibian.javapublic class Amphibian &#123;&#125;// generics/Vehicle.javapublic class Vehicle &#123;&#125; 使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型： 12345678910111213141516171819202122232425262728293031323334353637// generics/TupleTest.javaimport onjava.*;public class TupleTest &#123; static Tuple2&lt;String, Integer&gt; f() &#123; // 47 自动装箱为 Integer return new Tuple2&lt;&gt;(\"hi\", 47); &#125; static Tuple3&lt;Amphibian, String, Integer&gt; g() &#123; return new Tuple3&lt;&gt;(new Amphibian(), \"hi\", 47); &#125; static Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; h() &#123; return new Tuple4&lt;&gt;(new Vehicle(), new Amphibian(), \"hi\", 47); &#125; static Tuple5&lt;Vehicle, Amphibian, String, Integer, Double&gt; k() &#123; return new Tuple5&lt;&gt;(new Vehicle(), new Amphibian(), \"hi\", 47, 11.1); &#125; public static void main(String[] args) &#123; Tuple2&lt;String, Integer&gt; ttsi = f(); System.out.println(ttsi); // ttsi.a1 = \"there\"; // 编译错误，因为 final 不能重新赋值 System.out.println(g()); System.out.println(h()); System.out.println(k()); &#125;&#125;/* 输出： (hi, 47) (Amphibian@1540e19d, hi, 47) (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47) (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1) */ 有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。 通过 ttsi.a1 = &quot;there&quot; 语句的报错，我们可以看出，final 声明确实可以确保 public 字段在对象被构造出来之后就不能重新赋值了。 在上面的程序中，new 表达式有些啰嗦。本章稍后会介绍，如何利用 泛型方法 简化它们。 一个堆栈类接下来我们看一个稍微复杂一点的例子：堆栈。在 集合 一章中，我们用 LinkedList 实现了 onjava.Stack 类。在那个例子中，LinkedList 本身已经具备了创建堆栈所需的方法。Stack 是通过两个泛型类 Stack&lt;T&gt; 和 LinkedList&lt;T&gt; 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。 这次我们不用 LinkedList 来实现自己的内部链式存储机制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// generics/LinkedStack.java// 用链式结构实现的堆栈public class LinkedStack&lt;T&gt; &#123; private static class Node&lt;U&gt; &#123; U item; Node&lt;U&gt; next; Node() &#123; item = null; next = null; &#125; Node(U item, Node&lt;U&gt; next) &#123; this.item = item; this.next = next; &#125; boolean end() &#123; return item == null &amp;&amp; next == null; &#125; &#125; private Node&lt;T&gt; top = new Node&lt;&gt;(); // 栈顶 public void push(T item) &#123; top = new Node&lt;&gt;(item, top); &#125; public T pop() &#123; T result = top.item; if (!top.end()) &#123; top = top.next; &#125; return result; &#125; public static void main(String[] args) &#123; LinkedStack&lt;String&gt; lss = new LinkedStack&lt;&gt;(); for (String s : \"Phasers on stun!\".split(\" \")) &#123; lss.push(s); &#125; String s; while ((s = lss.pop()) != null) &#123; System.out.println(s); &#125; &#125;&#125; 输出结果： 123stun!onPhasers 内部类 Node 也是一个泛型，它拥有自己的类型参数。 这个例子使用了一个 末端标识 (end sentinel) 来判断栈何时为空。这个末端标识是在构造 LinkedStack 时创建的。然后，每次调用 push() 就会创建一个 Node&lt;T&gt; 对象，并将其链接到前一个 Node&lt;T&gt; 对象。当你调用 pop() 方法时，总是返回 top.item，然后丢弃当前 top 所指向的 Node&lt;T&gt;，并将 top 指向下一个 Node&lt;T&gt;，除非到达末端标识，这时就不能再移动 top 了。如果已经到达末端，程序还继续调用 pop() 方法，它只能得到 null，说明栈已经空了。 RandomList作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 select() 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型： 123456789101112131415161718// generics/RandomList.javaimport java.util.*;import java.util.stream.*;public class RandomList&lt;T&gt; extends ArrayList&lt;T&gt; &#123; private Random rand = new Random(47); public T select() &#123; return get(rand.nextInt(size())); &#125; public static void main(String[] args) &#123; RandomList&lt;String&gt; rs = new RandomList&lt;&gt;(); Array.stream(\"The quick brown fox jumped over the lazy brown dog\".split(\" \")).forEach(rs::add); IntStream.range(0, 11).forEach(i -&gt; System.out.print(rs.select() + \" \")); &#125;&#125; 输出结果： 1brown over fox quick quick dog brown The brown lazy brown RandomList 继承了 ArrayList 的所有方法。本例中只添加了 select() 这个方法。 泛型接口泛型也可以应用于接口。例如 生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。 一般而言，一个生成器只定义一个方法，用于创建对象。例如 java.util.function 类库中的 Supplier 就是一个生成器，调用其 get() 获取对象。get() 是泛型方法，返回值为类型参数 T。 泛型方法到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。 泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。 如果方法是 static 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。 泛型方法支持static 1234public static &lt;A, B&gt; Tuple2&lt;A, B&gt; tuple(A a, B b) &#123; return new Tuple2&lt;&gt;(a, b);&#125;public static&lt;T&gt; T executeQuery(String sql, Function&lt;ResultSet, T&gt; parseResultSet, Object... args) &#123;&#125; 要定义泛型方法，请将泛型参数列表放置在返回值之前。 12345678910111213141516171819202122232425// generics/GenericMethods.javapublic class GenericMethods &#123; public &lt;T&gt; void f(T x) &#123; System.out.println(x.getClass().getName()); &#125; public static void main(String[] args) &#123; GenericMethods gm = new GenericMethods(); gm.f(\"\"); gm.f(1); gm.f(1.0); gm.f(1.0F); gm.f('c'); gm.f(gm); &#125;&#125;/* Output:java.lang.Stringjava.lang.Integerjava.lang.Doublejava.lang.Floatjava.lang.CharacterGenericMethods*/ 尽管可以同时对类及其方法进行参数化，但这里未将 GenericMethods 类参数化。只有方法 f() 具有类型参数，该参数由方法返回类型之前的参数列表指示。 对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 类型参数推断。因此，对 f() 的调用看起来像普通的方法调用，并且 f() 看起来像被重载了无数次一样。它甚至会接受 GenericMethods 类型的参数。 如果使用基本类型调用 f() ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。 变长参数和泛型方法泛型方法和变长参数列表可以很好地共存： 123456789101112131415161718192021222324252627282930// generics/GenericVarargs.javaimport java.util.ArrayList;import java.util.List;public class GenericVarargs &#123; @SafeVarargs public static &lt;T&gt; List&lt;T&gt; makeList(T... args) &#123; List&lt;T&gt; result = new ArrayList&lt;&gt;(); for (T item : args) result.add(item); return result; &#125; public static void main(String[] args) &#123; List&lt;String&gt; ls = makeList(\"A\"); System.out.println(ls); ls = makeList(\"A\", \"B\", \"C\"); System.out.println(ls); ls = makeList( \"ABCDEFFHIJKLMNOPQRSTUVWXYZ\".split(\"\")); System.out.println(ls); &#125;&#125;/* Output:[A][A, B, C][A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,S, T, U, V, W, X, Y, Z]*/ 此处显示的 makeList() 方法产生的功能与标准库的 java.util.Arrays.asList() 方法相同。 @SafeVarargs 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。 一个泛型的 Supplier这是一个为任意具有无参构造方法的类生成 Supplier 的类。为了减少键入，它还包括一个用于生成 BasicSupplier 的泛型方法： 1234567891011121314151617181920212223242526272829// onjava/BasicSupplier.java// Supplier from a class with a no-arg constructorpackage onjava;import java.util.function.Supplier;public class BasicSupplier&lt;T&gt; implements Supplier&lt;T&gt; &#123; private Class&lt;T&gt; type; public BasicSupplier(Class&lt;T&gt; type) &#123; this.type = type; &#125; @Override public T get() &#123; try &#123; // Assumes type is a public class: return type.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125; // Produce a default Supplier from a type token: public static &lt;T&gt; Supplier&lt;T&gt; create(Class&lt;T&gt; type) &#123; return new BasicSupplier&lt;&gt;(type); &#125;&#125; 此类提供了产生以下对象的基本实现： 是 public 的。 因为 BasicSupplier 在单独的包中，所以相关的类必须具有 public 权限，而不仅仅是包级访问权限。 具有无参构造方法。要创建一个这样的 BasicSupplier 对象，请调用 create() 方法，并将要生成类型的类型令牌传递给它。通用的 create() 方法提供了 BasicSupplier.create(MyType.class) 这种较简洁的语法来代替较笨拙的 new BasicSupplier &lt;MyType&gt;(MyType.class)。 例如，这是一个具有无参构造方法的简单类： 123456789101112131415// generics/CountedObject.javapublic class CountedObject &#123; private static long counter = 0; private final long id = counter++; public long id() &#123; return id; &#125; @Override public String toString() &#123; return \"CountedObject \" + id; &#125;&#125; CountedObject 类可以跟踪自身创建了多少个实例，并通过 toString() 报告这些实例的数量。 BasicSupplier 可以轻松地为 CountedObject 创建 Supplier： 123456789101112131415161718192021 // generics/BasicSupplierDemo.javaimport onjava.BasicSupplier;import java.util.stream.Stream;public class BasicSupplierDemo &#123; public static void main(String[] args) &#123; Stream.generate( BasicSupplier.create(CountedObject.class)) .limit(5) .forEach(System.out::println); &#125;&#125;/* Output:CountedObject 0CountedObject 1CountedObject 2CountedObject 3CountedObject 4*/ 泛型方法减少了产生 Supplier 对象所需的代码量。 Java 泛型强制传递 Class 对象，以便在 create() 方法中将其用于类型推断。 简化元组的使用使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组： 123456789101112131415161718192021222324// onjava/Tuple.java// Tuple library using type argument inferencepackage onjava;public class Tuple &#123; public static &lt;A, B&gt; Tuple2&lt;A, B&gt; tuple(A a, B b) &#123; return new Tuple2&lt;&gt;(a, b); &#125; public static &lt;A, B, C&gt; Tuple3&lt;A, B, C&gt; tuple(A a, B b, C c) &#123; return new Tuple3&lt;&gt;(a, b, c); &#125; public static &lt;A, B, C, D&gt; Tuple4&lt;A, B, C, D&gt; tuple(A a, B b, C c, D d) &#123; return new Tuple4&lt;&gt;(a, b, c, d); &#125; public static &lt;A, B, C, D, E&gt; Tuple5&lt;A, B, C, D, E&gt; tuple(A a, B b, C c, D d, E e) &#123; return new Tuple5&lt;&gt;(a, b, c, d, e); &#125;&#125; 我们修改 TupleTest.java 来测试 Tuple.java : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// generics/TupleTest2.javaimport onjava.Tuple2;import onjava.Tuple3;import onjava.Tuple4;import onjava.Tuple5;import static onjava.Tuple.tuple;public class TupleTest2 &#123; static Tuple2&lt;String, Integer&gt; f() &#123; return tuple(\"hi\", 47); &#125; static Tuple2 f2() &#123; return tuple(\"hi\", 47); &#125; static Tuple3&lt;Amphibian, String, Integer&gt; g() &#123; return tuple(new Amphibian(), \"hi\", 47); &#125; static Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; h() &#123; return tuple( new Vehicle(), new Amphibian(), \"hi\", 47); &#125; static Tuple5&lt;Vehicle, Amphibian, String, Integer, Double&gt; k() &#123; return tuple(new Vehicle(), new Amphibian(), \"hi\", 47, 11.1); &#125; public static void main(String[] args) &#123; Tuple2&lt;String, Integer&gt; ttsi = f(); System.out.println(ttsi); System.out.println(f2()); System.out.println(g()); System.out.println(h()); System.out.println(k()); &#125;&#125;/* Output:(hi, 47)(hi, 47)(Amphibian@14ae5a5, hi, 47)(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)*/ 请注意，f() 返回一个参数化的 Tuple2 对象，而 f2() 返回一个未参数化的 Tuple2 对象。编译器不会在这里警告 f2() ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 Tuple2 。 但是，如果尝试将 f2() 的结果放入到参数化的 Tuple2 中，则编译器将发出警告。 一个 Set 工具对于泛型方法的另一个示例，请考虑由 Set 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法： 12345678910111213141516171819202122232425262728293031323334// onjava/Sets.javapackage onjava;import java.util.HashSet;import java.util.Set;public class Sets &#123; public static &lt;T&gt; Set&lt;T&gt; union(Set&lt;T&gt; a, Set&lt;T&gt; b) &#123; Set&lt;T&gt; result = new HashSet&lt;&gt;(a); result.addAll(b); return result; &#125; public static &lt;T&gt; Set&lt;T&gt; intersection(Set&lt;T&gt; a, Set&lt;T&gt; b) &#123; Set&lt;T&gt; result = new HashSet&lt;&gt;(a); result.retainAll(b); return result; &#125; // Subtract subset from superset: public static &lt;T&gt; Set&lt;T&gt; difference(Set&lt;T&gt; superset, Set&lt;T&gt; subset) &#123; Set&lt;T&gt; result = new HashSet&lt;&gt;(superset); result.removeAll(subset); return result; &#125; // Reflexive--everything not in the intersection: public static &lt;T&gt; Set&lt;T&gt; complement(Set&lt;T&gt; a, Set&lt;T&gt; b) &#123; return difference(union(a, b), intersection(a, b)); &#125;&#125; 前三个方法通过将第一个参数的引用复制到新的 HashSet 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 Set 对象。 这四种方法代表数学集合操作： union() 返回一个包含两个参数并集的 Set ， intersection() 返回一个包含两个参数集合交集的 Set ， difference() 从 superset 中减去 subset 的元素 ，而 complement() 返回所有不在交集中的元素的 Set。 构建复杂模型泛型的一个重要好处是能够简单安全地创建复杂模型。 123456789101112131415161718192021// generics/TupleList.java// Combining generic types to make complex generic typesimport onjava.Tuple4;import java.util.ArrayList;public class TupleList&lt;A, B, C, D&gt; extends ArrayList&lt;Tuple4&lt;A, B, C, D&gt;&gt; &#123; public static void main(String[] args) &#123; TupleList&lt;Vehicle, Amphibian, String, Integer&gt; tl = new TupleList&lt;&gt;(); tl.add(TupleTest2.h()); tl.add(TupleTest2.h()); tl.forEach(System.out::println); &#125;&#125;/* Output:(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)*/ 泛型擦除当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说 ArrayList.class，但不能说成 ArrayList&lt;Integer&gt;.class。 考虑下面的情况： 12345678910111213141516// generics/ErasedTypeEquivalence.javaimport java.util.*;public class ErasedTypeEquivalence &#123; public static void main(String[] args) &#123; Class c1 = new ArrayList&lt;String&gt;().getClass(); Class c2 = new ArrayList&lt;Integer&gt;().getClass(); System.out.println(c1 == c2); &#125; &#125;/* Output:true*/ ArrayList&lt;String&gt; 和 ArrayList&lt;Integer&gt; 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 ArrayList&lt;String&gt; 中放入一个 Integer，所得到的行为（失败）和向 ArrayList&lt;Integer&gt; 中放入一个 Integer 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。 下面的例子是对该谜题的补充： 1234567891011121314151617181920212223242526272829// generics/LostInformation.javaimport java.util.*;class Frob &#123;&#125;class Fnorkle &#123;&#125;class Quark&lt;Q&gt; &#123;&#125;class Particle&lt;POSITION, MOMENTUM&gt; &#123;&#125;public class LostInformation &#123; public static void main(String[] args) &#123; List&lt;Frob&gt; list = new ArrayList&lt;&gt;(); Map&lt;Frob, Fnorkle&gt; map = new HashMap&lt;&gt;(); Quark&lt;Fnorkle&gt; quark = new Quark&lt;&gt;(); Particle&lt;Long, Double&gt; p = new Particle&lt;&gt;(); System.out.println(Arrays.toString(list.getClass().getTypeParameters())); System.out.println(Arrays.toString(map.getClass().getTypeParameters())); System.out.println(Arrays.toString(quark.getClass().getTypeParameters())); System.out.println(Arrays.toString(p.getClass().getTypeParameters())); &#125;&#125;/* Output:[E][K,V][Q][POSITION,MOMENTUM] 根据 JDK 文档，Class.getTypeParameters() “返回一个 TypeVariable 对象数组，表示泛型声明中声明的类型参数…” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。 残酷的现实是： 在泛型代码内部，无法获取任何有关泛型参数类型的信息。 因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。 Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，List&lt;String&gt; 和 List&lt;Integer&gt; 在运行时实际上是相同的类型。它们都被擦除成原生类型 List。 理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。 C++ 的方式下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的： 12345678910111213141516171819202122232425// generics/Templates.cpp#include &lt;iostream&gt;using namespace std;template&lt;class T&gt; class Manipulator &#123; T obj;public: Manipulator(T x) &#123; obj = x; &#125; void manipulate() &#123; obj.f(); &#125;&#125;;class HasF &#123;public: void f() &#123; cout &lt;&lt; \"HasF::f()\" &lt;&lt; endl; &#125;&#125;;int main() &#123; HasF hf; Manipulator&lt;HasF&gt; manipulator(hf); manipulator.manipulate();&#125;/* Output:HasF::f()*/ Manipulator 类存储了一个 T 类型的对象。manipulate() 方法会调用 obj 上的 f() 方法。它是如何知道类型参数 T 中存在 f() 方法的呢？C++ 编译器会在你实例化模版时进行检查，所以在 Manipulator&lt;HasF&gt; 实例化的那一刻，它看到 HasF 中含有一个方法 f()。如果情况并非如此，你就会得到一个编译期错误，保持类型安全。 用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 HasF 的 Java 版本： 1234567// generics/HasF.javapublic class HasF &#123; public void f() &#123; System.out.println(\"HasF.f()\"); &#125;&#125; 如果我们将示例的其余代码用 Java 实现，就不会通过编译： 1234567891011121314151617181920212223// generics/Manipulation.java// &#123;WillNotCompile&#125;class Manipulator&lt;T&gt; &#123; private T obj; Manipulator(T x) &#123; obj = x; &#125; // Error: cannot find symbol: method f(): public void manipulate() &#123; obj.f(); &#125;&#125;public class Manipulation &#123; public static void main(String[] args) &#123; HasF hf = new HasF(); Manipulator&lt;HasF&gt; manipulator = new Manipulator&lt;&gt;(hf); manipulator.manipulate(); &#125;&#125; 因为擦除，Java 编译器无法将 manipulate() 方法必须能调用 obj 的 f() 方法这一需求映射到 HasF 具有 f() 方法这个事实上。为了调用 f()，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 extends 关键字。由于有了边界，下面的代码就能通过编译： 1234567891011public class Manipulator2&lt;T extends HasF&gt; &#123; private T obj; Manipulator2(T x) &#123; obj = x; &#125; public void manipulate() &#123; obj.f(); &#125;&#125; 边界 &lt;T extends HasF&gt; 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 obj 上调用 f() 方法。 我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，T 擦除到了 HasF，就像在类的声明中用 HasF 替换了 T 一样。 你可能正确地观察到了泛型在 Manipulator2.java 中没有贡献任何事。你可以很轻松地自己去执行擦除，生成没有泛型的类： 12345678910111213// generics/Manipulator3.javaclass Manipulator3 &#123; private HasF obj; Manipulator3(HasF x) &#123; ojb = x; &#125; public void manipulate() &#123; obj.f(); &#125;&#125; 这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 &lt;T extends HasF&gt; 形式就是有缺陷的。例如，如果某个类有一个返回 T 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型： 12345678910111213// generics/ReturnGenericType.javapublic class ReturnGenericType&lt;T extends HasF&gt; &#123; private T obj; ReturnGenericType(T x) &#123; obj = x; &#125; public T get() &#123; return obj; &#125;&#125; 你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。 迁移兼容性为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。 如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。 在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， List&lt;T&gt; 这样的类型注解会被擦除为 List，普通的类型变量在未指定边界的情况下会被擦除为 Object。 擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。 因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。 例如，假设一个应用使用了两个类库 X 和 Y，Y 使用了类库 Z。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。 如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的活唯一的迁移途径，还待时间来证明。 擦除的问题因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。 擦除的代码是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。 考虑如下的代码段： 123class Foo&lt;T&gt; &#123; T var;&#125; 看上去当你创建一个 Foo 实例时： 1Foo&lt;Cat&gt; f = new Foo&lt;&gt;(); class Foo 中的代码应该知道现在工作于 Cat 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 Object“。 另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样： 123456789101112131415161718192021222324252627282930// generics/ErasureAndInheritance.javaclass GenericBase&lt;T&gt; &#123; private T element; public void set(T arg) &#123; element = arg; &#125; public T get() &#123; return element; &#125;&#125;class Derived1&lt;T&gt; extends GenericBase&lt;T&gt; &#123;&#125;class Derived2 extends GenericBase &#123;&#125; // No warning// class Derived3 extends GenericBase&lt;?&gt; &#123;&#125;// Strange error:// unexpected type// required: class or interface without boundspublic class ErasureAndInteritance &#123; @SuppressWarnings(\"unchecked\") public static void main(String[] args) &#123; Derived2 d2 = new Derived2(); Object obj = d2.get(); d2.set(obj); // Warning here! &#125;&#125; Derived2 继承自 GenericBase，但是没有任何类型参数，编译器没有发出任何警告。直到调用 set() 方法时才出现警告。 为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它： 1@SuppressWarnings(\"unchecked\") 这个注解放置在产生警告的方法上，而不是整个类上。当你要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。 可以推断，Derived3 产生的错误意味着编译器期望得到一个原生基类。 当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。 边界处的动作因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如： 1234567891011121314151617181920212223242526// generics/ArrayMaker.javaimport java.lang.reflect.*;import java.util.*;public class ArrayMaker&lt;T&gt; &#123; private Class&lt;T&gt; kind; public ArrayMaker(Class&lt;T&gt; kind) &#123; this.kind = kind; &#125; @SuppressWarnings(\"unchecked\") T[] create(int size) &#123; return (T[]) Array.newInstance(kind, size); &#125; public static void main(String[] args) &#123; ArrayMaker&lt;String&gt; stringMaker = new ArrayMaker&lt;&gt;(String.class); String[] stringArray = stringMaker.create(9); System.out.println(Arrays.toString(stringArray)); &#125;&#125;/* Output[null,null,null,null,null,null,null,null,null]*/ 即使 kind 被存储为 Class&lt;T&gt;，擦除也意味着它实际被存储为没有任何参数的 Class。因此，当你在使用它时，例如创建数组，Array.newInstance() 实际上并未拥有 kind 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。 注意，对于在泛型中创建数组，使用 Array.newInstance() 是推荐的方式。 如果我们创建一个集合而不是数组，情况就不同了： 1234567891011121314// generics/ListMaker.javaimport java.util.*;public class ListMaker&lt;T&gt; &#123; List&lt;T&gt; create() &#123; return new ArrayList&lt;&gt;(); &#125; public static void main(String[] args) &#123; ListMaker&lt;String&gt; stringMaker = new ListMaker&lt;&gt;(); List&lt;String&gt; stringList = stringMaker.create(); &#125;&#125; 编译器不会给出任何警告，尽管我们知道（从擦除中）在 create() 内部的 new ArrayList&lt;&gt;() 中的 &lt;T&gt; 被移除了——在运行时，类内部没有任何 &lt;T&gt;，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 new ArrayList()，编译器就会发出警告。 本例中这么做真的毫无意义吗？如果在创建 List 的同时向其中放入一些对象呢，像这样： 12345678910111213141516171819202122232425262728// generics/FilledList.javaimport java.util.*;import java.util.function.*;import onjava.*;public class FilledList&lt;T&gt; extends ArrayList&lt;T&gt; &#123; FilledList&lt;Supplier&lt;T&gt; gen, int size) &#123; Suppliers.fill(this, gen, size); &#125; public FilledList(T t, int size) &#123; for (int i = 0; i &lt; size; i++) &#123; this.add(t); &#125; &#125; public static void main(String[] args) &#123; List&lt;String&gt; list = new FilledList&lt;&gt;(\"Hello\", 4); System.out.println(list); // Supplier version: List&lt;Integer&gt; ilist = new FilledList&lt;&gt;(() -&gt; 47, 4); System.out.println(ilist); &#125;&#125;/* Output:[Hello,Hello,Hello,Hello][47,47,47,47] 即使编译器无法得知 add() 中的 T 的任何信息，但它仍可以在编译期确保你放入 FilledList 中的对象是 T 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。 因为擦除移除了方法体中的类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。 考虑如下这段非泛型示例： 12345678910111213141516171819// generics/SimpleHolder.javapublic class SimpleHolder &#123; private Object obj; public void set(Object obj) &#123; this.obj = obj; &#125; public Object get() &#123; return obj; &#125; public static void main(String[] args) &#123; SimpleHolder holder = new SimpleHolder(); holder.set(\"Item\"); String s = (String) holder.get(); &#125;&#125; 如果用 javap -c SimpleHolder 反编译这个类，会得到如下内容（经过编辑）： 123456789101112131415161718192021222324public void set(java.lang.Object); 0: aload_0 1: aload_1 2: putfield #2; // Field obj:Object; 5: return public java.lang.Object get(); 0: aload_0 1: getfield #2; // Field obj:Object; 4: areturn public static void main(java.lang.String[]); 0: new #3; // class SimpleHolder 3: dup 4: invokespecial #4; // Method \"&lt;init&gt;\":()V 7: astore_1 8: aload_1 9: ldc #5; // String Item 11: invokevirtual #6; // Method set:(Object;)V 14: aload_1 15: invokevirtual #7; // Method get:()Object; 18: checkcast #8; // class java/lang/String 21: astore_2 22: return set() 和 get() 方法存储和产生值，转型在调用 get() 时接受检查。 现在将泛型融入上例代码中： 12345678910111213141516171819// generics/GenericHolder2.javapublic class GenericHolder2&lt;T&gt; &#123; private T obj; public void set(T obj) &#123; this.obj = obj; &#125; public T get() &#123; return obj; &#125; public static void main(String[] args) &#123; GenericHolder2&lt;String&gt; holder = new GenericHolder2&lt;&gt;(); holder.set(\"Item\"); String s = holder.get(); &#125;&#125; 从 get() 返回后的转型消失了，但是我们还知道传递给 set() 的值在编译期会被检查。下面是相关的字节码： 123456789101112131415161718192021222324public void set(java.lang.Object); 0: aload_0 1: aload_1 2: putfield #2; // Field obj:Object; 5: return public java.lang.Object get(); 0: aload_0 1: getfield #2; // Field obj:Object; 4: areturn public static void main(java.lang.String[]); 0: new #3; // class GenericHolder2 3: dup 4: invokespecial #4; // Method \"&lt;init&gt;\":()V 7: astore_1 8: aload_1 9: ldc #5; // String Item 11: invokevirtual #6; // Method set:(Object;)V 14: aload_1 15: invokevirtual #7; // Method get:()Object; 18: checkcast #8; // class java/lang/String 21: astore_2 22: return 所产生的字节码是相同的。对进入 set() 的类型进行检查是不需要的，因为这将由编译器执行。而对 get() 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。 get() 和 set() 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。 补偿擦除因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型： 12345678910111213141516171819// generics/Erased.java// &#123;WillNotCompile&#125;public class Erased&lt;T&gt; &#123; private final int SIZE = 100; public void f(Object arg) &#123; // error: illegal generic type for instanceof if (arg instanceof T) &#123; &#125; // error: unexpected type T var = new T(); // error: generic array creation T[] array = new T[SIZE]; // warning: [unchecked] unchecked cast T[] array = (T[]) new Object[SIZE]; &#125;&#125; 有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 Class 对象，以在类型表达式中使用它。 例如，由于擦除了类型信息，因此在上一个程序中尝试使用 instanceof 将会失败。类型标签可以使用动态 isInstance() ： 123456789101112131415161718192021222324252627282930313233343536// generics/ClassTypeCapture.javaclass Building &#123;&#125;class House extends Building &#123;&#125;public class ClassTypeCapture&lt;T&gt; &#123; Class&lt;T&gt; kind; public ClassTypeCapture(Class&lt;T&gt; kind) &#123; this.kind = kind; &#125; public boolean f(Object arg) &#123; return kind.isInstance(arg); &#125; public static void main(String[] args) &#123; ClassTypeCapture&lt;Building&gt; ctt1 = new ClassTypeCapture&lt;&gt;(Building.class); System.out.println(ctt1.f(new Building())); System.out.println(ctt1.f(new House())); ClassTypeCapture&lt;House&gt; ctt2 = new ClassTypeCapture&lt;&gt;(House.class); System.out.println(ctt2.f(new Building())); System.out.println(ctt2.f(new House())); &#125;&#125;/* Output:truetruefalsetrue*/ 编译器来保证类型标签与泛型参数相匹配。 创建类型的实例试图在 Erased.java 中 new T() 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 T 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）： 1234567891011121314151617// generics/InstantiateGenericType.cpp// C++, not Java!template&lt;class T&gt; class Foo &#123; T x; // Create a field of type T T* y; // Pointer to Tpublic: // Initialize the pointer: Foo() &#123; y = new T(); &#125;&#125;;class Bar &#123;&#125;;int main() &#123; Foo&lt;Bar&gt; fb; Foo&lt;int&gt; fi; // ... and it works with primitives&#125; Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 Class 对象，因此，如果使用类型标记，则可以使用 newInstance() 创建该类型的新对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// generics/InstantiateGenericType.javaimport java.util.function.Supplier;class ClassAsFactory&lt;T&gt; implements Supplier&lt;T&gt; &#123; Class&lt;T&gt; kind; ClassAsFactory(Class&lt;T&gt; kind) &#123; this.kind = kind; &#125; @Override public T get() &#123; try &#123; return kind.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125;class Employee &#123; @Override public String toString() &#123; return \"Employee\"; &#125;&#125;public class InstantiateGenericType &#123; public static void main(String[] args) &#123; ClassAsFactory&lt;Employee&gt; fe = new ClassAsFactory&lt;&gt;(Employee.class); System.out.println(fe.get()); ClassAsFactory&lt;Integer&gt; fi = new ClassAsFactory&lt;&gt;(Integer.class); try &#123; System.out.println(fi.get()); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125;/* Output:Employeejava.lang.InstantiationException: java.lang.Integer*/ 这样可以编译，但对于 ClassAsFactory&lt;Integer&gt; 会失败，这是因为 Integer 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（Supplier）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// generics/FactoryConstraint.javaimport onjava.Suppliers;import java.util.ArrayList;import java.util.List;import java.util.function.Supplier;class IntegerFactory implements Supplier&lt;Integer&gt; &#123; private int i = 0; @Override public Integer get() &#123; return ++i; &#125;&#125;class Widget &#123; private int id; Widget(int n) &#123; id = n; &#125; @Override public String toString() &#123; return \"Widget \" + id; &#125; public static class Factory implements Supplier&lt;Widget&gt; &#123; private int i = 0; @Override public Widget get() &#123; return new Widget(++i); &#125; &#125;&#125;class Fudge &#123; private static int count = 1; private int n = count++; @Override public String toString() &#123; return \"Fudge \" + n; &#125;&#125;class Foo2&lt;T&gt; &#123; private List&lt;T&gt; x = new ArrayList&lt;&gt;(); Foo2(Supplier&lt;T&gt; factory) &#123; Suppliers.fill(x, factory, 5); &#125; @Override public String toString() &#123; return x.toString(); &#125;&#125;public class FactoryConstraint &#123; public static void main(String[] args) &#123; System.out.println( new Foo2&lt;&gt;(new IntegerFactory())); System.out.println( new Foo2&lt;&gt;(new Widget.Factory())); System.out.println( new Foo2&lt;&gt;(Fudge::new)); &#125;&#125;/* Output:[1, 2, 3, 4, 5][Widget 1, Widget 2, Widget 3, Widget 4, Widget 5][Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]*/ IntegerFactory 本身就是通过实现 Supplier&lt;Integer&gt; 的工厂。 Widget 包含一个内部类，它是一个工厂。还要注意，Fudge 并没有做任何类似于工厂的操作，并且传递 Fudge::new 仍然会产生工厂行为，因为编译器将对函数方法 ::new 的调用转换为对 get() 的调用。 另一种方法是模板方法设计模式。在以下示例中，create() 是模板方法，在子类中被重写以生成该类型的对象： 123456789101112131415161718192021222324252627282930313233343536// generics/CreatorGeneric.javaabstract class GenericWithCreate&lt;T&gt; &#123; final T element; GenericWithCreate() &#123; element = create(); &#125; abstract T create();&#125;class X &#123;&#125;class XCreator extends GenericWithCreate&lt;X&gt; &#123; @Override X create() &#123; return new X(); &#125; void f() &#123; System.out.println( element.getClass().getSimpleName()); &#125;&#125;public class CreatorGeneric &#123; public static void main(String[] args) &#123; XCreator xc = new XCreator(); xc.f(); &#125;&#125;/* Output:X*/ GenericWithCreate 包含 element 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 create() 方法。这种创建方式可以在子类中定义，同时建立 T 的类型。 泛型数组正如在 Erased.java 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 ArrayList ： 12345678910111213141516// generics/ListOfGenerics.javaimport java.util.ArrayList;import java.util.List;public class ListOfGenerics&lt;T&gt; &#123; private List&lt;T&gt; array = new ArrayList&lt;&gt;(); public void add(T item) &#123; array.add(item); &#125; public T get(int index) &#123; return array.get(index); &#125;&#125; 这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。 有时，仍然会创建泛型类型的数组（例如， ArrayList 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用： 12345678// generics/ArrayOfGenericReference.javaclass Generic&lt;T&gt; &#123;&#125;public class ArrayOfGenericReference &#123; static Generic&lt;Integer&gt;[] gia;&#125; 编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 Object 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 ClassCastException ： 1234567891011121314151617181920212223242526// generics/ArrayOfGeneric.javapublic class ArrayOfGeneric &#123; static final int SIZE = 100; static Generic&lt;Integer&gt;[] gia; @SuppressWarnings(\"unchecked\") public static void main(String[] args) &#123; try &#123; gia = (Generic&lt;Integer&gt;[]) new Object[SIZE]; &#125; catch (ClassCastException e) &#123; System.out.println(e.getMessage()); &#125; // Runtime type is the raw (erased) type: gia = (Generic&lt;Integer&gt;[]) new Generic[SIZE]; System.out.println(gia.getClass().getSimpleName()); gia[0] = new Generic&lt;&gt;(); //- gia[1] = new Object(); // Compile-time error // Discovers type mismatch at compile time: //- gia[2] = new Generic&lt;Double&gt;(); &#125;&#125;/* Output:[Ljava.lang.Object; cannot be cast to [LGeneric;Generic[]*/ 问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 gia 被强制转换为 Generic&lt;Integer&gt;[] ，该信息也仅在编译时存在（并且没有 @SuppressWarnings 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 Object 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。 让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器： 1234567891011121314151617181920212223242526272829303132333435363738// generics/GenericArray.javapublic class GenericArray&lt;T&gt; &#123; private T[] array; @SuppressWarnings(\"unchecked\") public GenericArray(int sz) &#123; array = (T[]) new Object[sz]; &#125; public void put(int index, T item) &#123; array[index] = item; &#125; public T get(int index) &#123; return array[index]; &#125; // Method that exposes the underlying representation: public T[] rep() &#123; return array; &#125; public static void main(String[] args) &#123; GenericArray&lt;Integer&gt; gai = new GenericArray&lt;&gt;(10); try &#123; Integer[] ia = gai.rep(); &#125; catch (ClassCastException e) &#123; System.out.println(e.getMessage()); &#125; // This is OK: Object[] oa = gai.rep(); &#125;&#125;/* Output:[Ljava.lang.Object; cannot be cast to[Ljava.lang.Integer;*/ 和以前一样，我们不能说 T[] array = new T[sz] ，所以我们创建了一个 Object 数组并将其强制转换。 rep() 方法返回一个 T[] ，在主方法中它应该是 gai 的 Integer[]，但是如果调用它并尝试将结果转换为 Integer[] 引用，则会得到 ClassCastException ，这再次是因为实际的运行时类型为 Object[] 。 如果再注释掉 @SuppressWarnings 注解后编译 GenericArray.java ，则编译器会产生警告： 12GenericArray.java uses unchecked or unsafe operations.Recompile with -Xlint:unchecked for details. 在这里，我们收到了一个警告，我们认为这是有关强制转换的。 但是要真正确定，请使用 -Xlint：unchecked 进行编译： 1GenericArray.java:7: warning: [unchecked] unchecked cast array = (T[])new Object[sz]; ^ required: T[] found: Object[] where T is a type-variable: T extends Object declared in class GenericArray 1 warning 确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 @SuppressWarnings 将其关闭。这样，当警告确实出现时，我们将进行实际调查。 由于擦除，数组的运行时类型只能是 Object[] 。 如果我们立即将其转换为 T[] ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 Object[] ，并在使用数组元素时向 T 添加强制类型转换。让我们来看看在 GenericArray.java 示例中会是怎么样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243// generics/GenericArray2.javapublic class GenericArray2&lt;T&gt; &#123; private Object[] array; public GenericArray2(int sz) &#123; array = new Object[sz]; &#125; public void put(int index, T item) &#123; array[index] = item; &#125; @SuppressWarnings(\"unchecked\") public T get(int index) &#123; return (T) array[index]; &#125; @SuppressWarnings(\"unchecked\") public T[] rep() &#123; return (T[]) array; // Unchecked cast &#125; public static void main(String[] args) &#123; GenericArray2&lt;Integer&gt; gai = new GenericArray2&lt;&gt;(10); for (int i = 0; i &lt; 10; i++) gai.put(i, i); for (int i = 0; i &lt; 10; i++) System.out.print(gai.get(i) + \" \"); System.out.println(); try &#123; Integer[] ia = gai.rep(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125;&#125;/* Output:0 1 2 3 4 5 6 7 8 9java.lang.ClassCastException: [Ljava.lang.Object;cannot be cast to [Ljava.lang.Integer;*/ 最初，看起来并没有太大不同，只是转换的位置移动了。没有 @SuppressWarnings 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 Object[] 而不是 T[] 。 调用 get() 时，它将对象强制转换为 T ，实际上这是正确的类型，因此很安全。但是，如果调用 rep() ，它将再次尝试将 Object[] 强制转换为 T[] ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 Object[] 。在内部将数组视为 Object[] 而不是 T[] 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。 对于新代码，请传入类型标记。在这种情况下，GenericArray 如下所示： 123456789101112131415161718192021222324252627282930313233// generics/GenericArrayWithTypeToken.javaimport java.lang.reflect.Array;public class GenericArrayWithTypeToken&lt;T&gt; &#123; private T[] array; @SuppressWarnings(\"unchecked\") public GenericArrayWithTypeToken(Class&lt;T&gt; type, int sz) &#123; array = (T[]) Array.newInstance(type, sz); &#125; public void put(int index, T item) &#123; array[index] = item; &#125; public T get(int index) &#123; return array[index]; &#125; // Expose the underlying representation: public T[] rep() &#123; return array; &#125; public static void main(String[] args) &#123; GenericArrayWithTypeToken&lt;Integer&gt; gai = new GenericArrayWithTypeToken&lt;&gt;( Integer.class, 10); // This now works: Integer[] ia = gai.rep(); &#125;&#125; 类型标记 Class&lt;T&gt; 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 @SuppressWarnings 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 T[] 。 不幸的是，如果查看 Java 标准库中的源代码，你会发现到处都有从 Object 数组到参数化类型的转换。例如，这是ArrayList 中，复制一个 Collection 的构造函数，这里为了简化，去除了源码中对此不重要的代码： 12345public ArrayList(Collection c) &#123; size = c.size(); elementData = (E[])new Object[size]; c.toArray(elementData);&#125; 如果你浏览 ArrayList.java 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？ 12Note: ArrayList.java uses unchecked or unsafe operationsNote: Recompile with -Xlint:unchecked for details. 果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。 Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。 请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。 边界边界（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。 由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 Object 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 extends 关键字。 重要的是要理解，当用于限定泛型类型时，extends 的含义与通常的意义截然不同。此示例展示边界的基础应用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// generics/BasicBounds.javainterface HasColor &#123; java.awt.Color getColor();&#125;class WithColor&lt;T extends HasColor&gt; &#123; T item; WithColor(T item) &#123; this.item = item; &#125; T getItem() &#123; return item; &#125; // The bound allows you to call a method: java.awt.Color color() &#123; return item.getColor(); &#125;&#125;class Coord &#123; public int x, y, z;&#125;// This fails. Class must be first, then interfaces:// class WithColorCoord&lt;T extends HasColor &amp; Coord&gt; &#123;// Multiple bounds:class WithColorCoord&lt;T extends Coord &amp; HasColor&gt; &#123; T item; WithColorCoord(T item) &#123; this.item = item; &#125; T getItem() &#123; return item; &#125; java.awt.Color color() &#123; return item.getColor(); &#125; int getX() &#123; return item.x; &#125; int getY() &#123; return item.y; &#125; int getZ() &#123; return item.z; &#125;&#125;interface Weight &#123; int weight();&#125;// As with inheritance, you can have only one// concrete class but multiple interfaces:class Solid&lt;T extends Coord &amp; HasColor &amp; Weight&gt; &#123; T item; Solid(T item) &#123; this.item = item; &#125; T getItem() &#123; return item; &#125; java.awt.Color color() &#123; return item.getColor(); &#125; int getX() &#123; return item.x; &#125; int getY() &#123; return item.y; &#125; int getZ() &#123; return item.z; &#125; int weight() &#123; return item.weight(); &#125;&#125;class Bounded extends Coord implements HasColor, Weight &#123; @Override public java.awt.Color getColor() &#123; return null; &#125; @Override public int weight() &#123; return 0; &#125;&#125;public class BasicBounds &#123; public static void main(String[] args) &#123; Solid&lt;Bounded&gt; solid = new Solid&lt;&gt;(new Bounded()); solid.color(); solid.getY(); solid.weight(); &#125;&#125; 你可能会观察到 BasicBounds.java 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// generics/InheritBounds.javaclass HoldItem&lt;T&gt; &#123; T item; HoldItem(T item) &#123; this.item = item; &#125; T getItem() &#123; return item; &#125;&#125;class WithColor2&lt;T extends HasColor&gt; extends HoldItem&lt;T&gt; &#123; WithColor2(T item) &#123; super(item); &#125; java.awt.Color color() &#123; return item.getColor(); &#125;&#125;class WithColorCoord2&lt;T extends Coord &amp; HasColor&gt; extends WithColor2&lt;T&gt; &#123; WithColorCoord2(T item) &#123; super(item); &#125; int getX() &#123; return item.x; &#125; int getY() &#123; return item.y; &#125; int getZ() &#123; return item.z; &#125;&#125;class Solid2&lt;T extends Coord &amp; HasColor &amp; Weight&gt; extends WithColorCoord2&lt;T&gt; &#123; Solid2(T item) &#123; super(item); &#125; int weight() &#123; return item.weight(); &#125;&#125;public class InheritBounds &#123; public static void main(String[] args) &#123; Solid2&lt;Bounded&gt; solid2 = new Solid2&lt;&gt;(new Bounded()); solid2.color(); solid2.getY(); solid2.weight(); &#125;&#125; HoldItem 拥有一个对象，因此此行为将继承到 WithColor2 中，这也需要其参数符合 HasColor。 WithColorCoord2 和 Solid2 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。 这是一个具有更多层次的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// generics/EpicBattle.java// Bounds in Java genericsimport java.util.List;interface SuperPower &#123;&#125;interface XRayVision extends SuperPower &#123; void seeThroughWalls();&#125;interface SuperHearing extends SuperPower &#123; void hearSubtleNoises();&#125;interface SuperSmell extends SuperPower &#123; void trackBySmell();&#125;class SuperHero&lt;POWER extends SuperPower&gt; &#123; POWER power; SuperHero(POWER power) &#123; this.power = power; &#125; POWER getPower() &#123; return power; &#125;&#125;class SuperSleuth&lt;POWER extends XRayVision&gt; extends SuperHero&lt;POWER&gt; &#123; SuperSleuth(POWER power) &#123; super(power); &#125; void see() &#123; power.seeThroughWalls(); &#125;&#125;classCanineHero&lt;POWER extends SuperHearing &amp; SuperSmell&gt; extends SuperHero&lt;POWER&gt; &#123; CanineHero(POWER power) &#123; super(power); &#125; void hear() &#123; power.hearSubtleNoises(); &#125; void smell() &#123; power.trackBySmell(); &#125;&#125;class SuperHearSmell implements SuperHearing, SuperSmell &#123; @Override public void hearSubtleNoises() &#123; &#125; @Override public void trackBySmell() &#123; &#125;&#125;class DogPerson extends CanineHero&lt;SuperHearSmell&gt; &#123; DogPerson() &#123; super(new SuperHearSmell()); &#125;&#125;public class EpicBattle &#123; // Bounds in generic methods: static &lt;POWER extends SuperHearing&gt; void useSuperHearing(SuperHero&lt;POWER&gt; hero) &#123; hero.getPower().hearSubtleNoises(); &#125; static &lt;POWER extends SuperHearing &amp; SuperSmell&gt; void superFind(SuperHero&lt;POWER&gt; hero) &#123; hero.getPower().hearSubtleNoises(); hero.getPower().trackBySmell(); &#125; public static void main(String[] args) &#123; DogPerson dogPerson = new DogPerson(); useSuperHearing(dogPerson); superFind(dogPerson); // You can do this: List&lt;? extends SuperHearing&gt; audioPeople; // But you can't do this: // List&lt;? extends SuperHearing &amp; SuperSmell&gt; dogPs; &#125;&#125; 接下来将要研究的通配符将会把范围限制在单个类型。 ? extends T and ? super TList&lt;? extends T&gt;如果去添加元素的时候，因为list中存放的其实是T的一种子类，如果我们去添加元素，其实不知道到底应该添加T的哪个子类，这个时候桥接方法在进行强转的时候会出错。但是如果是从集合中将元素取出来，我们可以知道取出来的元素肯定是T类型。所以? extends T这种方式可以取元素而不能添加，这个叫get原则。 List&lt;? super T&gt;因为存的都是类型T的父类，所以如果去添加T类或者T类子类的元素，肯定是可以的。但是如果将元素取出来，则不知道到底是什么类型，所以? super T可以添加元素但是没法取出来，这个叫put原则。 通配符你已经在 集合 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 类型信息 一章中这种示例更多。本节将更深入地探讨这个特性。 我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用： 12345678910111213141516171819202122232425262728293031323334// generics/CovariantArrays.javaclass Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Jonathan extends Apple &#123;&#125;class Orange extends Fruit &#123;&#125;public class CovariantArrays &#123; public static void main(String[] args) &#123; Fruit[] fruit = new Apple[10]; fruit[0] = new Apple(); // OK fruit[1] = new Jonathan(); // OK // Runtime type is Apple[], not Fruit[] or Orange[]: try &#123; // Compiler allows you to add Fruit: fruit[0] = new Fruit(); // ArrayStoreException &#125; catch (Exception e) &#123; System.out.println(e); &#125; try &#123; // Compiler allows you to add Oranges: fruit[0] = new Orange(); // ArrayStoreException &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125;&#125;/* Output:java.lang.ArrayStoreException: Fruitjava.lang.ArrayStoreException: Orange main() 中的第一行创建了 Apple 数组，并赋值给一个 Fruit 数组引用。这是有意义的，因为 Apple 也是一种 Fruit，因此 Apple 数组应该也是一个 Fruit 数组。 但是，如果实际的数组类型是 Apple[]，你可以在其中放置 Apple 或 Apple 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 Fruit 对象。这对编译器来说是有意义的，因为它有一个 Fruit[] 引用——它有什么理由不允许将 Fruit 对象或任何从 Fruit 继承出来的对象（比如 Orange），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 Apple[]，因此会在向数组中放置异构类型时抛出异常。 向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。 数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？ 123456789// generics/NonCovariantGenerics.java// &#123;WillNotCompile&#125;import java.util.*;public class NonCovariantGenerics &#123; // Compile Error: incompatible types: List&lt;Fruit&gt; flist = new ArrayList&lt;Apple&gt;();&#125; 尽管你在首次阅读这段代码时会认为“不能将一个 Apple 集合赋值给一个 Fruit 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 Apple 的泛型赋值给一个涉及 Fruit 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— Apple 的 List 不是 Fruit 的 List。Apple 的 List 将持有 Apple 和 Apple 的子类型，Fruit 的 List 将持有任何类型的 Fruit。是的，这包括 Apple，但是它不是一个 Apple 的 List，它仍然是 Fruit 的 List。Apple 的 List 在类型上不等价于 Fruit 的 List，即使 Apple 是一种 Fruit 类型。 真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。 但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。 123456789101112131415161718// generics/GenericsAndCovariance.javaimport java.util.*;public class GenericsAndCovariance &#123; public static void main(String[] args) &#123; // Wildcards allow covariance: List&lt;? extends Fruit&gt; flist = new ArrayList&lt;&gt;(); // Compile Error: can't add any type of object: // flist.add(new Apple()); // flist.add(new Fruit()); // flist.add(new Object()); flist.add(null); // Legal but uninteresting // We know it returns at least Fruit: Fruit f = flist.get(0); &#125; &#125; flist 的类型现在是 List&lt;? extends Fruit&gt;，你可以读作“一个具有任何从 Fruit 继承的类型的列表”。然而，这实际上并不意味着这个 List 将持有任何类型的 Fruit。通配符引用的是明确的类型，因此它意味着“某种 flist 引用没有指定的具体类型”。因此这个被赋值的 List 必须持有诸如 Fruit 或 Apple 这样的指定类型，但是为了向上转型为 Fruit，这个类型是什么没人在意。 List 必须持有一种具体的 Fruit 或 Fruit 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 List 做什么呢？如果不知道 List 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 CovariantArrays.java 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。 你可能认为事情开始变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有 Apple 对象的 List 中放入一个 Apple 对象。是的，但编译器并不知道这一点。List&lt;? extends Fruit&gt; 可能合法地指向一个 List&lt;Orange&gt;。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 Object 也不行。 另一方面，如果你调用了一个返回 Fruit 的方法，则是安全的，因为你知道这个 List 中的任何对象至少具有 Fruit 类型，因此编译器允许这么做。 编译器有多聪明现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码： 1234567891011121314// generics/CompilerIntelligence.javaimport java.util.*;public class CompilerIntelligence &#123; public static void main(String[] args) &#123; List&lt;? extends Fruit&gt; flist = Arrays.asList(new Apple()); Apple a = (Apple) flist.get(0); // No warning flist.contains(new Apple()); // Argument is 'Object' flist.indexOf(new Apple()); // Argument is 'Object' &#125; &#125; 这里对 contains() 和 indexOf() 的调用接受 Apple 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？ 通过查看 ArrayList 的文档，我们发现编译器没有那么聪明。尽管 add() 接受一个泛型参数类型的参数，但 contains() 和 indexOf() 接受的参数类型是 Object。因此当你指定一个 ArrayList&lt;? extends Fruit&gt; 时，add() 的参数就变成了”? extends Fruit“。从这个描述中，编译器无法得知这里需要 Fruit 的哪个具体子类型，因此它不会接受任何类型的 Fruit。如果你先把 Apple 向上转型为 Fruit，也没有关系——编译器仅仅会拒绝调用像 add() 这样参数列表中涉及通配符的方法。 contains() 和 indexOf() 的参数类型是 Object，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 Object 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。 下面展示一个简单的 Holder 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Holder&lt;T&gt; &#123; private T value; public Holder() &#123;&#125; public Holder(T val) &#123; value = val; &#125; public void set(T val) &#123; value = val; &#125; public T get() &#123; return value; &#125; @Override public boolean equals(Object o) &#123; return o instanceof Holder &amp;&amp; Objects.equals(value, ((Holder) o).value); &#125; @Override public int hashCode() &#123; return Objects.hashCode(value); &#125; public static void main(String[] args) &#123; Holder&lt;Apple&gt; apple = new Holder&lt;&gt;(new Apple()); Apple d = apple.get(); apple.set(d);// Holder&lt;Fruit&gt; fruit = apple; // Cannot upcast Holder&lt;? extends Fruit&gt; fruit = apple; // OK Fruit p = fruit.get(); d = (Apple) fruit.get(); try &#123; Orange c = (Orange) fruit.get(); // No warning &#125; catch (Exception e) &#123; System.out.println(e); &#125;// fruit.set(new Apple()); // Cannot call set()// fruit.set(new Fruit()); // Cannot call set() System.out.println(fruit.equals(d)); // OK &#125;&#125;/* Outputjava.lang.ClassCastException: Apple cannot be cast to Orangefalse*/ Holder 有一个接受 T 类型对象的 set() 方法，一个返回 T 对象的 get() 方法和一个接受 Object 对象的 equals() 方法。正如你所见，如果创建了一个 Holder&lt;Apple&gt;，就不能将其向上转型为 Holder&lt;Fruit&gt;，但是可以向上转型为 Holder&lt;? extends Fruit&gt;。如果调用 get()，只能返回一个 Fruit——这就是在给定“任何；额扩展自 Fruit 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 Fruit 而不会导致任何警告，但是存在得到 ClassCastException 的风险。set() 方法不能工作在 Apple 和 Fruit 上，因为 set() 的参数也是”? extends Fruit”，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。 但是，equals() 方法可以正常工作，因为它接受的参数是 Object 而不是 T 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。 Java 7 引入了 java.util.Objects 库，使创建 equals() 和 hashCode() 方法变得更加容易，当然还有很多其他功能。equals() 方法的标准形式参考 附录：理解 equals 和 hashCode 方法 一章。 逆变还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 &lt;？super MyClass&gt; ，或者甚至使用类型参数： &lt;？super T&gt;（尽管你不能对泛型参数给出一个超类型边界；即不能声明 &lt;T super MyClass&gt; ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 Collection 写入了： ==确定了泛型下界== 123456789// generics/SuperTypeWildcards.javaimport java.util.*;public class SuperTypeWildcards &#123; static void writeTo(List&lt;? super Apple&gt; apples) &#123; apples.add(new Apple()); apples.add(new Jonathan()); // apples.add(new Fruit()); // Error &#125;&#125; 参数 apples 是 Apple 的某种基类型的 List，这样你就知道向其中添加 Apple 或 Apple 的子类型是安全的。但是因为 Apple 是下界，所以你知道向这样的 List 中添加 Fruit 是不安全的，因为这将使这个 List 敞开口子，从而可以向其中添加非 Apple 类型的对象，而这是违反静态类型安全的。下面的示例复习了一下逆变和通配符的的使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// generics/GenericReading.javaimport java.util.*;public class GenericReading &#123; static List&lt;Apple&gt; apples = Arrays.asList(new Apple()); static List&lt;Fruit&gt; fruit = Arrays.asList(new Fruit()); static &lt;T&gt; T readExact(List&lt;T&gt; list) &#123; return list.get(0); &#125; // A static method adapts to each call: static void f1() &#123; Apple a = readExact(apples); Fruit f = readExact(fruit); f = readExact(apples); &#125; // A class type is established // when the class is instantiated: static class Reader&lt;T&gt; &#123; T readExact(List&lt;T&gt; list) &#123; return list.get(0); &#125; &#125; static void f2() &#123; Reader&lt;Fruit&gt; fruitReader = new Reader&lt;&gt;(); Fruit f = fruitReader.readExact(fruit); //- Fruit a = fruitReader.readExact(apples); // error: incompatible types: List&lt;Apple&gt; // cannot be converted to List&lt;Fruit&gt; &#125; static class CovariantReader&lt;T&gt; &#123; T readCovariant(List&lt;? extends T&gt; list) &#123; return list.get(0); &#125; &#125; static void f3() &#123; CovariantReader&lt;Fruit&gt; fruitReader = new CovariantReader&lt;&gt;(); Fruit f = fruitReader.readCovariant(fruit); Fruit a = fruitReader.readCovariant(apples); &#125; public static void main(String[] args) &#123; f1(); f2(); f3(); &#125;&#125; readExact() 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 List 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 readExact() 可以有效地“适应”每个方法调用，并能够从 List&lt;Apple&gt; 中返回一个 Apple ，从 List&lt;Fruit&gt; 中返回一个 Fruit ，就像在 f1() 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 f2() 中看到的，fruitReader 实例可以从 List&lt;Fruit&gt; 中读取一个 Fruit ，因为这就是它的确切类型。但是 List&lt;Apple&gt; 也应该产生 Fruit 对象，而 fruitReader 不允许这么做。为了修正这个问题，CovariantReader.readCovariant() 方法将接受 List&lt;？extends T&gt; ，因此，从这个列表中读取一个 T 是安全的（你知道在这个列表中的所有对象至少是一个 T ，并且可能是从 T 导出的某种对象）。在 f3() 中，你可以看到现在可以从 List&lt;Apple&gt; 中读取 Fruit 了。 无界通配符无界通配符 &lt;?&gt; 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// generics/UnboundedWildcards1.javaimport java.util.*;public class UnboundedWildcards1 &#123; static List list1; static List&lt;?&gt; list2; static List&lt;? extends Object&gt; list3; static void assign1(List list) &#123; list1 = list; list2 = list; //- list3 = list; // warning: [unchecked] unchecked conversion // list3 = list; // ^ // required: List&lt;? extends Object&gt; // found: List &#125; static void assign2(List&lt;?&gt; list) &#123; list1 = list; list2 = list; list3 = list; &#125; static void assign3(List&lt;? extends Object&gt; list) &#123; list1 = list; list2 = list; list3 = list; &#125; public static void main(String[] args) &#123; assign1(new ArrayList()); assign2(new ArrayList()); //- assign3(new ArrayList()); // warning: [unchecked] unchecked method invocation: // method assign3 in class UnboundedWildcards1 // is applied to given types // assign3(new ArrayList()); // ^ // required: List&lt;? extends Object&gt; // found: ArrayList // warning: [unchecked] unchecked conversion // assign3(new ArrayList()); // ^ // required: List&lt;? extends Object&gt; // found: ArrayList // 2 warnings assign1(new ArrayList&lt;&gt;()); assign2(new ArrayList&lt;&gt;()); assign3(new ArrayList&lt;&gt;()); // Both forms are acceptable as List&lt;?&gt;: List&lt;?&gt; wildList = new ArrayList(); wildList = new ArrayList&lt;&gt;(); assign1(wildList); assign2(wildList); assign3(wildList); &#125;&#125; 有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 &lt;?&gt; 。在这些情况中，&lt;?&gt; 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要： 123456789101112131415161718192021222324252627282930313233343536373839404142// generics/UnboundedWildcards2.javaimport java.util.*;public class UnboundedWildcards2 &#123; static Map map1; static Map&lt;?,?&gt; map2; static Map&lt;String,?&gt; map3; static void assign1(Map map) &#123; map1 = map; &#125; static void assign2(Map&lt;?,?&gt; map) &#123; map2 = map; &#125; static void assign3(Map&lt;String,?&gt; map) &#123; map3 = map; &#125; public static void main(String[] args) &#123; assign1(new HashMap()); assign2(new HashMap()); //- assign3(new HashMap()); // warning: [unchecked] unchecked method invocation: // method assign3 in class UnboundedWildcards2 // is applied to given types // assign3(new HashMap()); // ^ // required: Map&lt;String,?&gt; // found: HashMap // warning: [unchecked] unchecked conversion // assign3(new HashMap()); // ^ // required: Map&lt;String,?&gt; // found: HashMap // 2 warnings assign1(new HashMap&lt;&gt;()); assign2(new HashMap&lt;&gt;()); assign3(new HashMap&lt;&gt;()); &#125;&#125; 但是，当你拥有的全都是无界通配符时，就像在 Map&lt;?,?&gt; 中看到的那样，编译器看起来就无法将其与原生 Map 区分开了。另外， UnboundedWildcards1.java 展示了编译器处理 List&lt;?&gt; 和 List&lt;? extends Object&gt; 是不同的。令人困惑的是，编译器并非总是关注像 List 和 List&lt;?&gt; 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 List&lt;?&gt; 看起来等价于 List&lt;Object&gt; ，而 List 实际上也是 List&lt;Object&gt; ——除非这些语句都不为真。List 实际上表示“持有任何 Object 类型的原生 List ** ”，而 List&lt;?&gt; 表示“具有某种特定类型的非原生 List** ，只是我们不知道类型是什么。”编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 Holder&lt;T&gt; 类，它包含接受 Holder 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284// generics/Wildcards.java// Exploring the meaning of wildcardspublic class Wildcards &#123; // Raw argument: static void rawArgs(Holder holder, Object arg) &#123; //- holder.set(arg); // warning: [unchecked] unchecked call to set(T) // as a member of the raw type Holder // holder.set(arg); // ^ // where T is a type-variable: // T extends Object declared in class Holder // 1 warning // Can't do this; don't have any 'T': // T t = holder.get(); // OK, but type information is lost: Object obj = holder.get(); &#125; // Like rawArgs(), but errors instead of warnings: static void unboundedArg(Holder&lt;?&gt; holder, Object arg) &#123; //- holder.set(arg); // error: method set in class Holder&lt;T&gt; // cannot be applied to given types; // holder.set(arg); // ^ // required: CAP#1 // found: Object // reason: argument mismatch; // Object cannot be converted to CAP#1 // where T is a type-variable: // T extends Object declared in class Holder // where CAP#1 is a fresh type-variable: // CAP#1 extends Object from capture of ? // 1 error // Can't do this; don't have any 'T': // T t = holder.get(); // OK, but type information is lost: Object obj = holder.get(); &#125; static &lt;T&gt; T exact1(Holder&lt;T&gt; holder) &#123; return holder.get(); &#125; static &lt;T&gt; T exact2(Holder&lt;T&gt; holder, T arg) &#123; holder.set(arg); return holder.get(); &#125; static &lt;T&gt; T wildSubtype(Holder&lt;? extends T&gt; holder, T arg) &#123; //- holder.set(arg); // error: method set in class Holder&lt;T#2&gt; // cannot be applied to given types; // holder.set(arg); // ^ // required: CAP#1 // found: T#1 // reason: argument mismatch; // T#1 cannot be converted to CAP#1 // where T#1,T#2 are type-variables: // T#1 extends Object declared in method // &lt;T#1&gt;wildSubtype(Holder&lt;? extends T#1&gt;,T#1) // T#2 extends Object declared in class Holder // where CAP#1 is a fresh type-variable: // CAP#1 extends T#1 from // capture of ? extends T#1 // 1 error return holder.get(); &#125; static &lt;T&gt; void wildSupertype(Holder&lt;? super T&gt; holder, T arg) &#123; holder.set(arg); //- T t = holder.get(); // error: incompatible types: // CAP#1 cannot be converted to T // T t = holder.get(); // ^ // where T is a type-variable: // T extends Object declared in method // &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T) // where CAP#1 is a fresh type-variable: // CAP#1 extends Object super: // T from capture of ? super T // 1 error // OK, but type information is lost: Object obj = holder.get(); &#125; public static void main(String[] args) &#123; Holder raw = new Holder&lt;&gt;(); // Or: raw = new Holder(); Holder&lt;Long&gt; qualified = new Holder&lt;&gt;(); Holder&lt;?&gt; unbounded = new Holder&lt;&gt;(); Holder&lt;? extends Long&gt; bounded = new Holder&lt;&gt;(); Long lng = 1L; rawArgs(raw, lng); rawArgs(qualified, lng); rawArgs(unbounded, lng); rawArgs(bounded, lng); unboundedArg(raw, lng); unboundedArg(qualified, lng); unboundedArg(unbounded, lng); unboundedArg(bounded, lng); //- Object r1 = exact1(raw); // warning: [unchecked] unchecked method invocation: // method exact1 in class Wildcards is applied // to given types // Object r1 = exact1(raw); // ^ // required: Holder&lt;T&gt; // found: Holder // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;exact1(Holder&lt;T&gt;) // warning: [unchecked] unchecked conversion // Object r1 = exact1(raw); // ^ // required: Holder&lt;T&gt; // found: Holder // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;exact1(Holder&lt;T&gt;) // 2 warnings Long r2 = exact1(qualified); Object r3 = exact1(unbounded); // Must return Object Long r4 = exact1(bounded); //- Long r5 = exact2(raw, lng); // warning: [unchecked] unchecked method invocation: // method exact2 in class Wildcards is // applied to given types // Long r5 = exact2(raw, lng); // ^ // required: Holder&lt;T&gt;,T // found: Holder,Long // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;exact2(Holder&lt;T&gt;,T) // warning: [unchecked] unchecked conversion // Long r5 = exact2(raw, lng); // ^ // required: Holder&lt;T&gt; // found: Holder // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;exact2(Holder&lt;T&gt;,T) // 2 warnings Long r6 = exact2(qualified, lng); //- Long r7 = exact2(unbounded, lng); // error: method exact2 in class Wildcards // cannot be applied to given types; // Long r7 = exact2(unbounded, lng); // ^ // required: Holder&lt;T&gt;,T // found: Holder&lt;CAP#1&gt;,Long // reason: inference variable T has // incompatible bounds // equality constraints: CAP#1 // lower bounds: Long // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;exact2(Holder&lt;T&gt;,T) // where CAP#1 is a fresh type-variable: // CAP#1 extends Object from capture of ? // 1 error //- Long r8 = exact2(bounded, lng); // error: method exact2 in class Wildcards // cannot be applied to given types; // Long r8 = exact2(bounded, lng); // ^ // required: Holder&lt;T&gt;,T // found: Holder&lt;CAP#1&gt;,Long // reason: inference variable T // has incompatible bounds // equality constraints: CAP#1 // lower bounds: Long // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;exact2(Holder&lt;T&gt;,T) // where CAP#1 is a fresh type-variable: // CAP#1 extends Long from // capture of ? extends Long // 1 error //- Long r9 = wildSubtype(raw, lng); // warning: [unchecked] unchecked method invocation: // method wildSubtype in class Wildcards // is applied to given types // Long r9 = wildSubtype(raw, lng); // ^ // required: Holder&lt;? extends T&gt;,T // found: Holder,Long // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;wildSubtype(Holder&lt;? extends T&gt;,T) // warning: [unchecked] unchecked conversion // Long r9 = wildSubtype(raw, lng); // ^ // required: Holder&lt;? extends T&gt; // found: Holder // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;wildSubtype(Holder&lt;? extends T&gt;,T) // 2 warnings Long r10 = wildSubtype(qualified, lng); // OK, but can only return Object: Object r11 = wildSubtype(unbounded, lng); Long r12 = wildSubtype(bounded, lng); //- wildSupertype(raw, lng); // warning: [unchecked] unchecked method invocation: // method wildSupertype in class Wildcards // is applied to given types // wildSupertype(raw, lng); // ^ // required: Holder&lt;? super T&gt;,T // found: Holder,Long // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T) // warning: [unchecked] unchecked conversion // wildSupertype(raw, lng); // ^ // required: Holder&lt;? super T&gt; // found: Holder // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T) // 2 warnings wildSupertype(qualified, lng); //- wildSupertype(unbounded, lng); // error: method wildSupertype in class Wildcards // cannot be applied to given types; // wildSupertype(unbounded, lng); // ^ // required: Holder&lt;? super T&gt;,T // found: Holder&lt;CAP#1&gt;,Long // reason: cannot infer type-variable(s) T // (argument mismatch; Holder&lt;CAP#1&gt; // cannot be converted to Holder&lt;? super T&gt;) // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T) // where CAP#1 is a fresh type-variable: // CAP#1 extends Object from capture of ? // 1 error //- wildSupertype(bounded, lng); // error: method wildSupertype in class Wildcards // cannot be applied to given types; // wildSupertype(bounded, lng); // ^ // required: Holder&lt;? super T&gt;,T // found: Holder&lt;CAP#1&gt;,Long // reason: cannot infer type-variable(s) T // (argument mismatch; Holder&lt;CAP#1&gt; // cannot be converted to Holder&lt;? super T&gt;) // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;wildSupertype(Holder&lt;? super T&gt;,T) // where CAP#1 is a fresh type-variable: // CAP#1 extends Long from capture of // ? extends Long // 1 error &#125;&#125; 在 rawArgs() 中，编译器知道 Holder 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 set() 传递一个 Object 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 set() ，而这个对象将被向上转型为 Object 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 get() 的调用说明了相同的问题：没有任何 T 类型的对象，因此结果只能是一个 Object。人们很自然地会开始考虑原生 Holder 与 Holder&lt;?&gt; 是大致相同的事物。但是 unboundedArg() 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 Holder 将持有任何类型的组合，而 Holder&lt;?&gt; 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 Object 。在 exact1() 和 exact2() 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，exact2()与 exact1() 具有不同的限制，因为它有额外的参数。在 wildSubtype() 中，在 Holder 类型上的限制被放松为包括持有任何扩展自 T 的对象的 Holder 。这还是意味着如果 T 是 Fruit ，那么 holder 可以是 Holder&lt;Apple&gt; ，这是合法的。为了防止将 Orange 放置到 Holder&lt;Apple&gt; 中，对 set() 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自 Holder&lt;？extends Fruit&gt; 的对象至少是 Fruit ，因此 get() （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。wildSupertype() 展示了超类型通配符，这个方法展示了与 wildSubtype() 相反的行为：holder 可以是持有任何 T 的基类型的容器。因此， set() 可以接受 T ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 T ）。但是，尝试着调用 get() 是没有用的，因为由 holder 持有的类型可以是任何超类型，因此唯一安全的类型就是 Object 。这个示例还展示了对于在 unbounded() 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 T，所以你不能将 set() 或 get() 作用于 T 上。 在 main() 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，rawArgs() 将接受所有 Holder 的不同变体，而不会产生警告。unboundedArg() 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。 如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 Holder 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 exact1() 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。可以看到，exact2() 具有最多的限制，因为它希望精确地得到一个 Holder&lt;T&gt; ，以及一个具有类型 T 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 wildSubtype() 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 wildSupertype() 中看到的那样）。因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。 捕获转换有一种特殊情况需要使用 &lt;?&gt; 而不是原生类型。如果向一个使用 &lt;?&gt; 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 @SuppressWarnings 注解被移除之后才能起作用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// generics/CaptureConversion.javapublic class CaptureConversion &#123; static &lt;T&gt; void f1(Holder&lt;T&gt; holder) &#123; T t = holder.get(); System.out.println(t.getClass().getSimpleName()); &#125; static void f2(Holder&lt;?&gt; holder) &#123; f1(holder); // Call with captured type &#125; @SuppressWarnings(\"unchecked\") public static void main(String[] args) &#123; Holder raw = new Holder&lt;&gt;(1); f1(raw); // warning: [unchecked] unchecked method invocation: // method f1 in class CaptureConversion // is applied to given types // f1(raw); // ^ // required: Holder&lt;T&gt; // found: Holder // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;f1(Holder&lt;T&gt;) // warning: [unchecked] unchecked conversion // f1(raw); // ^ // required: Holder&lt;T&gt; // found: Holder // where T is a type-variable: // T extends Object declared in // method &lt;T&gt;f1(Holder&lt;T&gt;) // 2 warnings f2(raw); // No warnings Holder rawBasic = new Holder(); rawBasic.set(new Object()); // warning: [unchecked] unchecked call to set(T) // as a member of the raw type Holder // rawBasic.set(new Object()); // ^ // where T is a type-variable: // T extends Object declared in class Holder // 1 warning f2(rawBasic); // No warnings // Upcast to Holder&lt;?&gt;, still figures it out: Holder&lt;?&gt; wildcarded = new Holder&lt;&gt;(1.0); f2(wildcarded); &#125;&#125;/* Output:IntegerIntegerObjectDouble*/ f1() 中的类型参数都是确切的，没有通配符或边界。在 f2() 中，Holder 参数是一个无界通配符，因此它看起来是未知的。但是，在 f2() 中调用了 f1()，而 f1() 需要一个已知参数。这里所发生的是：在调用 f2() 的过程中捕获了参数类型，并在调用 f1() 时使用了这种类型。**你可能想知道这项技术是否可以用于写入，但是这要求在传递 Holder&lt;?&gt;** 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 f2() 中返回 T，因为 *T * 对于 f2() 来说是未知的。捕获转换十分有趣，但是非常受限。 问题本节将阐述在使用 Java 泛型时会出现的各类问题。 任何基本类型都不能作为类型参数正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建 ArrayList&lt;int&gt; 之类的东西。解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 ArrayList&lt;Integer&gt;，并将基本类型 int 应用于这个集合，那么你将发现自动装箱机制将自动地实现 int 到 Integer 的双向转换——因此，这几乎就像是有一个 ArrayList&lt;int&gt; 一样： 1234567891011121314151617// generics/ListOfInt.java// Autoboxing compensates for the inability// to use primitives in genericsimport java.util.*;import java.util.stream.*;public class ListOfInt &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; li = IntStream.range(38, 48) .boxed() // Converts ints to Integers .collect(Collectors.toList()); System.out.println(li); &#125;&#125;/* Output:[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]*/ 通常，这种解决方案工作得很好——能够成功地存储和读取 int，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 org.apache.commons.collections.primitives。下面是另外一种方式，它可以创建持有 Byte 的 Set： 12345678910// generics/ByteSet.javaimport java.util.*;public class ByteSet &#123; Byte[] possibles = &#123; 1,2,3,4,5,6,7,8,9 &#125;; Set&lt;Byte&gt; mySet = new HashSet&lt;&gt;(Arrays.asList(possibles)); // But you can't do this: // Set&lt;Byte&gt; mySet2 = new HashSet&lt;&gt;( // Arrays.&lt;Byte&gt;asList(1,2,3,4,5,6,7,8,9));&#125; 自动装箱机制解决了一些问题，但并没有解决所有问题。 在下面的示例中，FillArray 接口包含一些通用方法，这些方法使用 Supplier 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。Supplier 实现来自 数组 一章,并且在 main() 中，可以看到 FillArray.fill() 使用对象填充了数组： 123456789101112131415161718192021222324252627282930313233343536373839404142// generics/PrimitiveGenericTest.javaimport onjava.*;import java.util.*;import java.util.function.*;// Fill an array using a generator:interface FillArray &#123; static &lt;T&gt; T[] fill(T[] a, Supplier&lt;T&gt; gen) &#123; Arrays.setAll(a, n -&gt; gen.get()); return a; &#125; static int[] fill(int[] a, IntSupplier gen) &#123; Arrays.setAll(a, n -&gt; gen.getAsInt()); return a; &#125; static long[] fill(long[] a, LongSupplier gen) &#123; Arrays.setAll(a, n -&gt; gen.getAsLong()); return a; &#125; static double[] fill(double[] a, DoubleSupplier gen) &#123; Arrays.setAll(a, n -&gt; gen.getAsDouble()); return a; &#125;&#125;public class PrimitiveGenericTest &#123; public static void main(String[] args) &#123; String[] strings = FillArray.fill( new String[5], new Rand.String(9)); System.out.println(Arrays.toString(strings)); int[] integers = FillArray.fill( new int[9], new Rand.Pint()); System.out.println(Arrays.toString(integers)); &#125;&#125;/* Output:[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl][635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]*/ 自动装箱不适用于数组，因此我们必须创建 FillArray.fill() 的重载版本，或创建产生 Wrapped 输出的生成器。 FillArray 仅比 java.util.Arrays.setAll() 有用一点，因为它返回填充的数组。 实现参数化接口一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况： 123456789// generics/MultipleInterfaceVariants.java// &#123;WillNotCompile&#125;package generics;interface Payable&lt;T&gt; &#123;&#125;class Employee implements Payable&lt;Employee&gt; &#123;&#125;class Hourly extends Employee implements Payable&lt;Hourly&gt; &#123;&#125; Hourly 不能编译，因为擦除会将 Payable&lt;Employe&gt; 和 Payable&lt;Hourly&gt; 简化为相同的类 Payable，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 Payable 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。 在使用某些更基本的 Java 接口，例如 Comparable&lt;T&gt; 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。 转型和警告使用带有泛型类型参数的转型或 instanceof 不会有任何效果。下面的集合在内部将各个值存储为 Object，并在获取这些值时，再将它们转型回 T： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// generics/GenericCast.javaimport java.util.*;import java.util.stream.*;class FixedSizeStack&lt;T&gt; &#123; private final int size; private Object[] storage; private int index = 0; FixedSizeStack(int size) &#123; this.size = size; storage = new Object[size]; &#125; public void push(T item) &#123; if(index &lt; size) storage[index++] = item; &#125; @SuppressWarnings(\"unchecked\") public T pop() &#123; return index == 0 ? null : (T)storage[--index]; &#125; @SuppressWarnings(\"unchecked\") Stream&lt;T&gt; stream() &#123; return (Stream&lt;T&gt;)Arrays.stream(storage); &#125;&#125;public class GenericCast &#123; static String[] letters = \"ABCDEFGHIJKLMNOPQRS\".split(\"\"); public static void main(String[] args) &#123; FixedSizeStack&lt;String&gt; strings = new FixedSizeStack&lt;&gt;(letters.length); Arrays.stream(\"ABCDEFGHIJKLMNOPQRS\".split(\"\")) .forEach(strings::push); System.out.println(strings.pop()); strings.stream() .map(s -&gt; s + \" \") .forEach(System.out::print); &#125;&#125;/* Output:SA B C D E F G H I J K L M N O P Q R S*/ 如果没有 @SuppressWarnings 注解，编译器将对 pop() 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 pop() 方法实际上并没有执行任何转型。这是因为，T 被擦除到它的第一个边界，默认情况下是 Object ，因此 pop() 实际上只是将 Object 转型为 Object。有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如： 123456789101112// generics/NeedCasting.javaimport java.io.*;import java.util.*;public class NeedCasting &#123; @SuppressWarnings(\"unchecked\") public void f(String[] args) throws Exception &#123; ObjectInputStream in = new ObjectInputStream( new FileInputStream(args[0])); List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)in.readObject(); &#125;&#125; 正如你将在 附录：对象序列化 中学到的那样，readObject() 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 @SuppressWarnings 注解并编译这个程序时，就会得到下面的警告。 1234567891011NeedCasting.java uses unchecked or unsafe operations.Recompile with -Xlint:unchecked for details.And if you follow the instructions and recompile with -Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)NeedCasting.java:10: warning: [unchecked] unchecked cast List&lt;Widget&gt; shapes = (List&lt;Widget&gt;)in.readObject(); required: List&lt;Widget&gt; found: Object1 warning 你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，既通过泛型类来转型： 123456789101112131415// generics/ClassCasting.javaimport java.io.*;import java.util.*;public class ClassCasting &#123; @SuppressWarnings(\"unchecked\") public void f(String[] args) throws Exception &#123; ObjectInputStream in = new ObjectInputStream( new FileInputStream(args[0])); // Won't Compile: // List&lt;Widget&gt; lw1 = // List&lt;&gt;.class.cast(in.readObject()); List&lt;Widget&gt; lw2 = List.class.cast(in.readObject()); &#125;&#125; 但是，不能转型到实际类型（ List&lt;Widget&gt; ）。也就是说，不能声明： 1List&lt;Widget&gt;.class.cast(in.readobject()) 甚至当你添加一个像下面这样的另一个转型时： 1(List&lt;Widget&gt;)List.class.cast(in.readobject()) 仍旧会得到一个警告。 重载下面的程序是不能编译的，即使它看起来是合理的： 12345678// generics/UseList.java// &#123;WillNotCompile&#125;import java.util.*;public class UseList&lt;W, T&gt; &#123; void f(List&lt;T&gt; v) &#123;&#125; void f(List&lt;W&gt; v) &#123;&#125;&#125; 因为擦除，所以重载方法产生了的类型签名。 因而，当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名： 12345678// generics/UseList2.javaimport java.util.*;public class UseList2&lt;W, T&gt; &#123; void f1(List&lt;T&gt; v) &#123;&#125; void f2(List&lt;W&gt; v) &#123;&#125;&#125; 幸运的是，编译器可以检测到这类问题。 基类劫持接口假设你有一个实现了 Comparable 接口的 Pet 类： 12345678// generics/ComparablePet.javapublic class ComparablePet implements Comparable&lt;ComparablePet&gt; &#123; @Override public int compareTo(ComparablePet o) &#123; return 0; &#125;&#125; 尝试缩小 ComparablePet 子类的比较类型是有意义的。例如，Cat 类可以与其他的 Cat 比较： 12345678910111213// generics/HijackedInterface.java// &#123;WillNotCompile&#125;class Cat extends ComparablePet implements Comparable&lt;Cat&gt; &#123; // error: Comparable cannot be inherited with // different arguments: &lt;Cat&gt; and &lt;ComparablePet&gt; // class Cat // ^ // 1 error public int compareTo(Cat arg) &#123; return 0; &#125;&#125; 不幸的是，这不能工作。一旦 Comparable 的类型参数设置为 ComparablePet，其他的实现类只能比较 ComparablePet： 123456789101112131415// generics/RestrictedComparablePets.javapublic class Hamster extends ComparablePet implements Comparable&lt;ComparablePet&gt; &#123; @Override public int compareTo(ComparablePet arg) &#123; return 0; &#125;&#125;// Or just:class Gecko extends ComparablePet &#123; public int compareTo(ComparablePet arg) &#123; return 0; &#125;&#125; Hamster 显示了重新实现 ComparableSet 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 Gecko 中所示，这与直接覆写基类的方法完全相同。 自限定的类型在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解： 1class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt; &#123; // ... 这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。SelfBounded 类接受泛型参数 T，而 T 由一个边界类限定，这个边界就是拥有 T 作为其参数的 SelfBounded。 当你首次看到它时，很难去解析它，它强调的是当 extends 关键字用于边界与用来创建子类明显是不同的。 古怪的循环泛型为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。 不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明： 123456// generics/CuriouslyRecurringGeneric.javaclass GenericType&lt;T&gt; &#123;&#125;public class CuriouslyRecurringGeneric extends GenericType&lt;CuriouslyRecurringGeneric&gt; &#123;&#125; 这可以按照 Jim Coplien 在 C++ 中的古怪的循环模版模式的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 Object 的类型。下面是表示了这种情况的一个泛型类： 12345678910// generics/BasicHolder.javapublic class BasicHolder&lt;T&gt; &#123; T element; void set(T arg) &#123; element = arg; &#125; T get() &#123; return element; &#125; void f() &#123; System.out.println(element.getClass().getSimpleName()); &#125;&#125; 这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 Object 操作）。我们可以在一个古怪的循环泛型中使用 BasicHolder： 123456789101112131415// generics/CRGWithBasicHolder.javaclass Subtype extends BasicHolder&lt;Subtype&gt; &#123;&#125;public class CRGWithBasicHolder &#123; public static void main(String[] args) &#123; Subtype st1 = new Subtype(), st2 = new Subtype(); st1.set(st2); Subtype st3 = st1.get(); st1.f(); &#125;&#125;/* Output:Subtype*/ 注意，这里有些东西很重要：新类 Subtype 接受的参数和返回的值具有 Subtype 类型而不仅仅是基类 BasicHolder 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在Subtype 中，传递给 set() 的参数和从 get() 返回的类型都是确切的 Subtype。 自限定BasicHolder 可以使用任何类型作为其泛型参数，就像下面看到的那样： 1234567891011121314151617181920// generics/Unconstrained.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.class Other &#123;&#125;class BasicOther extends BasicHolder&lt;Other&gt; &#123;&#125;public class Unconstrained &#123; public static void main(String[] args) &#123; BasicOther b = new BasicOther(); BasicOther b2 = new BasicOther(); b.set(new Other()); Other other = b.get(); b.f(); &#125;&#125;/* Output:Other*/ 限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用： 12345678910111213141516171819202122232425262728293031323334353637383940// generics/SelfBounding.javaclass SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt; &#123; T element; SelfBounded&lt;T&gt; set(T arg) &#123; element = arg; return this; &#125; T get() &#123; return element; &#125;&#125;class A extends SelfBounded&lt;A&gt; &#123;&#125;class B extends SelfBounded&lt;A&gt; &#123;&#125; // Also OKclass C extends SelfBounded&lt;C&gt; &#123; C setAndGet(C arg) &#123; set(arg); return get(); &#125;&#125;class D &#123;&#125;// Can't do this:// class E extends SelfBounded&lt;D&gt; &#123;&#125;// Compile error:// Type parameter D is not within its bound// Alas, you can do this, so you cannot force the idiom:class F extends SelfBounded &#123;&#125;public class SelfBounding &#123; public static void main(String[] args) &#123; A a = new A(); a.set(new A()); a = a.set(new A()).get(); a = a.get(); C c = new C(); c = c.setAndGet(new C()); &#125;&#125; 自限定所做的，就是要求在继承关系中，像下面这样使用这个类： 1class A extends SelfBounded&lt;A&gt;&#123;&#125; 这会强制要求将正在定义的类当作参数传递给基类。 自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 SelfBounded 参数的 SelfBounded 中导出，尽管在 A 类看到的用法看起来是主要的用法。对定义 E 的尝试说明不能使用不是 SelfBounded 的类型参数。遗憾的是， F 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 E 也会因此而变得可编译： 123456789101112131415161718192021222324// generics/NotSelfBounded.javapublic class NotSelfBounded&lt;T&gt; &#123; T element; NotSelfBounded&lt;T&gt; set(T arg) &#123; element = arg; return this; &#125; T get() &#123; return element; &#125;&#125; class A2 extends NotSelfBounded&lt;A2&gt; &#123;&#125;class B2 extends NotSelfBounded&lt;A2&gt; &#123;&#125;class C2 extends NotSelfBounded&lt;C2&gt; &#123; C2 setAndGet(C2 arg) &#123; set(arg); return get(); &#125;&#125;class D2 &#123;&#125;// Now this is OK:class E2 extends NotSelfBounded&lt;D2&gt; &#123;&#125; 因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。还可以将自限定用于泛型方法： 1234567891011121314// generics/SelfBoundingMethods.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.public class SelfBoundingMethods &#123; static &lt;T extends SelfBounded&lt;T&gt;&gt; T f(T arg) &#123; return arg.set(arg).get(); &#125; public static void main(String[] args) &#123; A a = f(new A()); &#125;&#125; 这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。 参数协变自限定类型的价值在于它们可以产生协变参数类型——方法参数类型会随子类而变化。 尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为协变返回类型是在 Java 5 引入： 1234567891011121314151617181920// generics/CovariantReturnTypes.javaclass Base &#123;&#125;class Derived extends Base &#123;&#125;interface OrdinaryGetter &#123; Base get();&#125;interface DerivedGetter extends OrdinaryGetter &#123; // Overridden method return type can vary: @Override Derived get();&#125;public class CovariantReturnTypes &#123; void test(DerivedGetter d) &#123; Derived d2 = d.get(); &#125;&#125; DerivedGetter 中的 get() 方法覆盖了 OrdinaryGetter 中的 get() ，并返回了一个从 OrdinaryGetter.get() 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。 自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 get() 中所看到的一样： 1234567891011121314// generics/GenericsAndReturnTypes.javainterface GenericGetter&lt;T extends GenericGetter&lt;T&gt;&gt; &#123; T get();&#125;interface Getter extends GenericGetter&lt;Getter&gt; &#123;&#125;public class GenericsAndReturnTypes &#123; void test(Getter g) &#123; Getter result = g.get(); GenericGetter gg = g.get(); // Also the base type &#125;&#125; 注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。 然而，在非泛型代码中，参数类型不能随子类型发生变化： 12345678910111213141516171819202122232425262728// generics/OrdinaryArguments.javaclass OrdinarySetter &#123; void set(Base base) &#123; System.out.println(\"OrdinarySetter.set(Base)\"); &#125;&#125;class DerivedSetter extends OrdinarySetter &#123; void set(Derived derived) &#123; System.out.println(\"DerivedSetter.set(Derived)\"); &#125;&#125;public class OrdinaryArguments &#123; public static void main(String[] args) &#123; Base base = new Base(); Derived derived = new Derived(); DerivedSetter ds = new DerivedSetter(); ds.set(derived); // Compiles--overloaded, not overridden!: ds.set(base); &#125;&#125;/* Output:DerivedSetter.set(Derived)OrdinarySetter.set(Base)*/ set(derived) 和 set(base) 都是合法的，因此 DerivedSetter.set() 没有覆盖 OrdinarySetter.set() ，而是重载了这个方法。从输出中可以看到，在 DerivedSetter 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数： 123456789101112131415161718192021222324252627// generics/SelfBoundingAndCovariantArguments.javainterface SelfBoundSetter&lt;T extends SelfBoundSetter&lt;T&gt;&gt; &#123; void set(T arg);&#125;interface Setter extends SelfBoundSetter&lt;Setter&gt; &#123;&#125;public class SelfBoundingAndCovariantArguments &#123; void testA(Setter s1, Setter s2, SelfBoundSetter sbs) &#123; s1.set(s2); //- s1.set(sbs); // error: method set in interface SelfBoundSetter&lt;T&gt; // cannot be applied to given types; // s1.set(sbs); // ^ // required: Setter // found: SelfBoundSetter // reason: argument mismatch; // SelfBoundSetter cannot be converted to Setter // where T is a type-variable: // T extends SelfBoundSetter&lt;T&gt; declared in // interface SelfBoundSetter // 1 error &#125;&#125; 编译器不能识别将基类型当作参数传递给 set() 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样： 123456789101112131415161718192021222324252627// generics/PlainGenericInheritance.javaclass GenericSetter&lt;T&gt; &#123; // Not self-bounded void set(T arg) &#123; System.out.println(\"GenericSetter.set(Base)\"); &#125;&#125;class DerivedGS extends GenericSetter&lt;Base&gt; &#123; void set(Derived derived) &#123; System.out.println(\"DerivedGS.set(Derived)\"); &#125;&#125;public class PlainGenericInheritance &#123; public static void main(String[] args) &#123; Base base = new Base(); Derived derived = new Derived(); DerivedGS dgs = new DerivedGS(); dgs.set(derived); dgs.set(base); // Overloaded, not overridden! &#125;&#125;/* Output:DerivedGS.set(Derived)GenericSetter.set(Base)*/ 这段代码在模仿 OrdinaryArguments.java；在那个示例中，DerivedSetter 继承自包含一个 set(Base) 的OrdinarySetter 。而这里，DerivedGS 继承自泛型创建的也包含有一个 set(Base)的 GenericSetter&lt;Base&gt;。就像 OrdinaryArguments.java 一样，你可以从输出中看到， DerivedGS 包含两个 set() 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。 动态类型安全因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 java.util.Collections 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 checkedCollection() 、checkedList()、 checkedMap() 、 checkedSet() 、checkedSortedMap()和 checkedSortedSet()。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。 受检查的集合在你试图插入类型不正确的对象时抛出 ClassCastException ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，oldStyleMethod() 表示遗留代码，因为它接受的是原生的 List ，而 @SuppressWarnings（“unchecked”） 注解对于压制所产生的警告是必需的： 123456789101112131415161718192021222324252627282930313233// generics/CheckedList.java// Using Collection.checkedList()import typeinfo.pets.*;import java.util.*;public class CheckedList &#123; @SuppressWarnings(\"unchecked\") static void oldStyleMethod(List probablyDogs) &#123; probablyDogs.add(new Cat()); &#125; public static void main(String[] args) &#123; List&lt;Dog&gt; dogs1 = new ArrayList&lt;&gt;(); oldStyleMethod(dogs1); // Quietly accepts a Cat List&lt;Dog&gt; dogs2 = Collections.checkedList( new ArrayList&lt;&gt;(), Dog.class); try &#123; oldStyleMethod(dogs2); // Throws an exception &#125; catch(Exception e) &#123; System.out.println(\"Expected: \" + e); &#125; // Derived types work fine: List&lt;Pet&gt; pets = Collections.checkedList( new ArrayList&lt;&gt;(), Pet.class); pets.add(new Dog()); pets.add(new Cat()); &#125;&#125;/* Output:Expected: java.lang.ClassCastException: Attempt toinsert class typeinfo.pets.Cat element into collectionwith element type class typeinfo.pets.Dog*/ 运行这个程序时，你会发现插入一个 Cat 对于 dogs1 来说没有任何问题，而 dogs2 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。 混型术语混型随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点面向切面编程 （AOP） 的味道，而切面经常被建议用来解决混型问题。 C++ 中的混型在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// generics/Mixins.cpp#include &lt;string&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;using namespace std;template&lt;class T&gt; class TimeStamped : public T &#123; long timeStamp;public: TimeStamped() &#123; timeStamp = time(0); &#125; long getStamp() &#123; return timeStamp; &#125;&#125;;template&lt;class T&gt; class SerialNumbered : public T &#123; long serialNumber; static long counter;public: SerialNumbered() &#123; serialNumber = counter++; &#125; long getSerialNumber() &#123; return serialNumber; &#125;&#125;;// Define and initialize the static storage:template&lt;class T&gt; long SerialNumbered&lt;T&gt;::counter = 1;class Basic &#123; string value;public: void set(string val) &#123; value = val; &#125; string get() &#123; return value; &#125;&#125;;int main() &#123; TimeStamped&lt;SerialNumbered&lt;Basic&gt;&gt; mixin1, mixin2; mixin1.set(\"test string 1\"); mixin2.set(\"test string 2\"); cout &lt;&lt; mixin1.get() &lt;&lt; \" \" &lt;&lt; mixin1.getStamp() &lt;&lt; \" \" &lt;&lt; mixin1.getSerialNumber() &lt;&lt; endl; cout &lt;&lt; mixin2.get() &lt;&lt; \" \" &lt;&lt; mixin2.getStamp() &lt;&lt; \" \" &lt;&lt; mixin2.getSerialNumber() &lt;&lt; endl;&#125;/* Output:test string 1 1452987605 1test string 2 1452987605 2*/ 在 main() 中， mixin1 和 mixin2 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了： 1TimeStamped&lt;SerialNumbered&lt;Basic&gt;&gt; mixin1，mixin2； 遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此 泛型类不能直接继承自一个泛型参数 这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。 与接口混合一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// generics/Mixins.javaimport java.util.*;interface TimeStamped &#123; long getStamp(); &#125;class TimeStampedImp implements TimeStamped &#123; private final long timeStamp; TimeStampedImp() &#123; timeStamp = new Date().getTime(); &#125; @Override public long getStamp() &#123; return timeStamp; &#125;&#125;interface SerialNumbered &#123; long getSerialNumber(); &#125;class SerialNumberedImp implements SerialNumbered &#123; private static long counter = 1; private final long serialNumber = counter++; @Override public long getSerialNumber() &#123; return serialNumber; &#125;&#125;interface Basic &#123; void set(String val); String get();&#125;class BasicImp implements Basic &#123; private String value; @Override public void set(String val) &#123; value = val; &#125; @Override public String get() &#123; return value; &#125;&#125;class Mixin extends BasicImpimplements TimeStamped, SerialNumbered &#123; private TimeStamped timeStamp = new TimeStampedImp(); private SerialNumbered serialNumber = new SerialNumberedImp(); @Override public long getStamp() &#123; return timeStamp.getStamp(); &#125; @Override public long getSerialNumber() &#123; return serialNumber.getSerialNumber(); &#125;&#125;public class Mixins &#123; public static void main(String[] args) &#123; Mixin mixin1 = new Mixin(), mixin2 = new Mixin(); mixin1.set(\"test string 1\"); mixin2.set(\"test string 2\"); System.out.println(mixin1.get() + \" \" + mixin1.getStamp() + \" \" + mixin1.getSerialNumber()); System.out.println(mixin2.get() + \" \" + mixin2.getStamp() + \" \" + mixin2.getSerialNumber()); &#125;&#125;/* Output:test string 1 1494331663026 1test string 2 1494331663027 2*/ Mixin 类基本上是在使用委托，因此每个混入类型都要求在 Mixin 中有一个相应的域，而你必须在 Mixin 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。 使用装饰器模式当你观察混型的使用方式时，就会发现混型概念好像与装饰器设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。前面的示例可以被改写为使用装饰器： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// generics/decorator/Decoration.java// &#123;java generics.decorator.Decoration&#125;package generics.decorator;import java.util.*;class Basic &#123; private String value; public void set(String val) &#123; value = val; &#125; public String get() &#123; return value; &#125;&#125;class Decorator extends Basic &#123; protected Basic basic; Decorator(Basic basic) &#123; this.basic = basic; &#125; @Override public void set(String val) &#123; basic.set(val); &#125; @Override public String get() &#123; return basic.get(); &#125;&#125;class TimeStamped extends Decorator &#123; private final long timeStamp; TimeStamped(Basic basic) &#123; super(basic); timeStamp = new Date().getTime(); &#125; public long getStamp() &#123; return timeStamp; &#125;&#125;class SerialNumbered extends Decorator &#123; private static long counter = 1; private final long serialNumber = counter++; SerialNumbered(Basic basic) &#123; super(basic); &#125; public long getSerialNumber() &#123; return serialNumber; &#125;&#125;public class Decoration &#123; public static void main(String[] args) &#123; TimeStamped t = new TimeStamped(new Basic()); TimeStamped t2 = new TimeStamped( new SerialNumbered(new Basic())); //- t2.getSerialNumber(); // Not available SerialNumbered s = new SerialNumbered(new Basic()); SerialNumbered s2 = new SerialNumbered( new TimeStamped(new Basic())); //- s2.getStamp(); // Not available &#125;&#125; 产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。 与动态代理混合可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 类型信息 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。由于动态代理的限制，每个被混入的类都必须是某个接口的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// generics/DynamicProxyMixin.javaimport java.lang.reflect.*;import java.util.*;import onjava.*;import static onjava.Tuple.*;class MixinProxy implements InvocationHandler &#123; Map&lt;String, Object&gt; delegatesByMethod; @SuppressWarnings(\"unchecked\") MixinProxy(Tuple2&lt;Object, Class&lt;?&gt;&gt;... pairs) &#123; delegatesByMethod = new HashMap&lt;&gt;(); for(Tuple2&lt;Object, Class&lt;?&gt;&gt; pair : pairs) &#123; for(Method method : pair.a2.getMethods()) &#123; String methodName = method.getName(); // The first interface in the map // implements the method. if(!delegatesByMethod.containsKey(methodName)) delegatesByMethod.put(methodName, pair.a1); &#125; &#125; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); Object delegate = delegatesByMethod.get(methodName); return method.invoke(delegate, args); &#125; @SuppressWarnings(\"unchecked\") public static Object newInstance(Tuple2... pairs) &#123; Class[] interfaces = new Class[pairs.length]; for(int i = 0; i &lt; pairs.length; i++) &#123; interfaces[i] = (Class)pairs[i].a2; &#125; ClassLoader cl = pairs[0].a1.getClass().getClassLoader(); return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs)); &#125;&#125;public class DynamicProxyMixin &#123; public static void main(String[] args) &#123; Object mixin = MixinProxy.newInstance( tuple(new BasicImp(), Basic.class), tuple(new TimeStampedImp(), TimeStamped.class), tuple(new SerialNumberedImp(), SerialNumbered.class)); Basic b = (Basic)mixin; TimeStamped t = (TimeStamped)mixin; SerialNumbered s = (SerialNumbered)mixin; b.set(\"Hello\"); System.out.println(b.get()); System.out.println(t.getStamp()); System.out.println(s.getSerialNumber()); &#125;&#125;/* Output:Hello14943316533391*/ 因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。 潜在类型机制在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。 Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。 还是正如你所见到的，当要在泛型类型上执行操作（即调用 Object 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。 某些编程语言提供的一种解决方案称为潜在类型机制或结构化类型机制，而更古怪的术语称为鸭子类型机制，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。 泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 speak() 和 sit() 即可。”由于不要求具体类型，因此代码就可以更加泛化。 潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。 支持潜在类型机制的语言包括 Python（可以从 www.Python.org 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。 pyhton 中的潜在类型如果我们将上面的描述用 Python 来表示，如下所示： 123456789101112131415161718192021222324252627282930313233# generics/DogsAndRobots.pyclass Dog: def speak(self): print(\"Arf!\") def sit(self): print(\"Sitting\") def reproduce(self): passclass Robot: def speak(self): print(\"Click!\") def sit(self): print(\"Clank!\") def oilChange(self): passdef perform(anything): anything.speak() anything.sit()a = Dog()b = Robot()perform(a)perform(b)output = \"\"\"Arf!SittingClick!Clank!\"\"\" Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“#” 表示注释到行尾，就像Java中的 “ // ”。类的方法需要显式地指定 this 引用的等价物作为第一个参数，按惯例成为 self 。构造器调用不要求任何类型的“ new ”关键字，并且 Python 允许普通（非成员）函数，就像 perform() 所表明的那样。注意，在 perform(anything) 中，没有任何针对 anything 的类型，anything 只是一个标识符，它必须能够执行 perform() 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。perform() 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持 speak() 和 sit() 方法。如果传递给 perform() 的对象不支持这些操作，那么将会得到运行时异常。 输出规定使用三重引号创建带有内嵌换行符的字符串。 C++ 中的潜在类型我们可以用 C++ 产生相同的效果： 123456789101112131415161718192021222324252627282930313233343536// generics/DogsAndRobots.cpp#include &lt;iostream&gt;using namespace std;class Dog &#123;public: void speak() &#123; cout &lt;&lt; \"Arf!\" &lt;&lt; endl; &#125; void sit() &#123; cout &lt;&lt; \"Sitting\" &lt;&lt; endl; &#125; void reproduce() &#123;&#125;&#125;;class Robot &#123;public: void speak() &#123; cout &lt;&lt; \"Click!\" &lt;&lt; endl; &#125; void sit() &#123; cout &lt;&lt; \"Clank!\" &lt;&lt; endl; &#125; void oilChange() &#123;&#125;&#125;;template&lt;class T&gt; void perform(T anything) &#123; anything.speak(); anything.sit();&#125;int main() &#123; Dog d; Robot r; perform(d); perform(r);&#125;/* Output:Arf!SittingClick!Clank!*/ 在 Python 和 C++ 中，Dog 和 Robot 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，perform() 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。潜在类型机制没有损害强类型机制。 Go 中的潜在类型这里用 Go 语言编写相同的程序： 123456789101112131415161718192021222324252627282930// generics/dogsandrobots.gopackage mainimport \"fmt\"type Dog struct &#123;&#125;func (this Dog) speak() &#123; fmt.Printf(\"Arf!\\n\")&#125;func (this Dog) sit() &#123; fmt.Printf(\"Sitting\\n\")&#125;func (this Dog) reproduce() &#123;&#125;type Robot struct &#123;&#125;func (this Robot) speak() &#123; fmt.Printf(\"Click!\\n\") &#125;func (this Robot) sit() &#123; fmt.Printf(\"Clank!\\n\") &#125;func (this Robot) oilChange() &#123;&#125;func perform(speaker interface &#123; speak(); sit() &#125;) &#123; speaker.speak(); speaker.sit();&#125;func main() &#123; perform(Dog&#123;&#125;) perform(Robot&#123;&#125;)&#125;/* Output:Arf!SittingClick!Clank!*/ Go 没有 class 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 struct ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 func 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 this 来提醒您，就像在 C ++ 或 Java 中的 this 一样。 然后，在Go中像这样定义其余的函数。 Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。 perform() 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 speak() 和 sit() 方法即可。 该接口在此处匿名定义，内联，如 perform() 的参数列表所示。 main() 证明 perform() 确实对其参数的确切类型不在乎，只要可以在该参数上调用 talk() 和 sit() 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。 语法 Dog {} 和 Robot {} 创建匿名的 Dog 和 Robot 结构。 java中的直接潜在类型因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8 之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它： 123456// generics/Performs.javapublic interface Performs &#123; void speak(); void sit();&#125; 1234567891011121314151617181920212223242526272829303132333435363738// generics/DogsAndRobots.java// No (direct) latent typing in Javaimport typeinfo.pets.*;class PerformingDog extends Dog implements Performs &#123; @Override public void speak() &#123; System.out.println(\"Woof!\"); &#125; @Override public void sit() &#123; System.out.println(\"Sitting\"); &#125; public void reproduce() &#123;&#125;&#125;class Robot implements Performs &#123; public void speak() &#123; System.out.println(\"Click!\"); &#125; public void sit() &#123; System.out.println(\"Clank!\"); &#125; public void oilChange() &#123;&#125;&#125;class Communicate &#123; public static &lt;T extends Performs&gt; void perform(T performer) &#123; performer.speak(); performer.sit(); &#125;&#125;public class DogsAndRobots &#123; public static void main(String[] args) &#123; Communicate.perform(new PerformingDog()); Communicate.perform(new Robot()); &#125;&#125;/* Output:Woof!SittingClick!Clank!*/ 但是要注意，perform() 不需要使用泛型来工作，它可以被简单地指定为接受一个 Performs 对象： 12345678910111213141516171819202122// generics/SimpleDogsAndRobots.java// Removing the generic; code still worksclass CommunicateSimply &#123; static void perform(Performs performer) &#123; performer.speak(); performer.sit(); &#125;&#125;public class SimpleDogsAndRobots &#123; public static void main(String[] args) &#123; CommunicateSimply.perform(new PerformingDog()); CommunicateSimply.perform(new Robot()); &#125;&#125;/* Output:Woof!SittingClick!Clank!*/ 在本例中，泛型不是必需的，因为这些类已经被强制要求实现 Performs 接口。 对缺乏潜在类型机制的补偿尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。 反射可以使用的一种方式是反射，下面的 perform() 方法就是用了潜在类型机制： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// generics/LatentReflection.java// Using reflection for latent typingimport java.lang.reflect.*;// Does not implement Performs:class Mime &#123; public void walkAgainstTheWind() &#123;&#125; public void sit() &#123; System.out.println(\"Pretending to sit\"); &#125; public void pushInvisibleWalls() &#123;&#125; @Override public String toString() &#123; return \"Mime\"; &#125;&#125;// Does not implement Performs:class SmartDog &#123; public void speak() &#123; System.out.println(\"Woof!\"); &#125; public void sit() &#123; System.out.println(\"Sitting\"); &#125; public void reproduce() &#123;&#125;&#125;class CommunicateReflectively &#123; public static void perform(Object speaker) &#123; Class&lt;?&gt; spkr = speaker.getClass(); try &#123; try &#123; Method speak = spkr.getMethod(\"speak\"); speak.invoke(speaker); &#125; catch(NoSuchMethodException e) &#123; System.out.println(speaker + \" cannot speak\"); &#125; try &#123; Method sit = spkr.getMethod(\"sit\"); sit.invoke(speaker); &#125; catch(NoSuchMethodException e) &#123; System.out.println(speaker + \" cannot sit\"); &#125; &#125; catch(SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123; throw new RuntimeException(speaker.toString(), e); &#125; &#125;&#125;public class LatentReflection &#123; public static void main(String[] args) &#123; CommunicateReflectively.perform(new SmartDog()); CommunicateReflectively.perform(new Robot()); CommunicateReflectively.perform(new Mime()); &#125;&#125;/* Output:Woof!SittingClick!Clank!Mime cannot speakPretending to sit*/ 上例中，这些类完全是彼此分离的，没有任何公共基类（除了 Object ）或接口。通过反射, CommunicateReflectively.perform() 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 Mime 只具有一个必需的方法这一事实，并能够部分实现其目标。 将一个方法应用于序列反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？ 让我们看一个说明这个问题的示例。假设想要创建一个 apply() 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？ 最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的： 12345678910111213141516171819// generics/Apply.javaimport java.lang.reflect.*;import java.util.*;public class Apply &#123; public static &lt;T, S extends Iterable&lt;T&gt;&gt; void apply(S seq, Method f, Object... args) &#123; try &#123; for(T t: seq) f.invoke(t, args); &#125; catch(IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123; // Failures are programmer errors throw new RuntimeException(e); &#125; &#125;&#125; 在 Apply.java 中，异常被转换为 RuntimeException ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。 为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 f ？ 注意，invoke() 和 apply() 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。 为了测试 Apply ，我们首先创建一个 Shape 类： 12345678910111213141516// generics/Shape.javapublic class Shape &#123; private static long counter = 0; private final long id = counter++; @Override public String toString() &#123; return getClass().getSimpleName() + \" \" + id; &#125; public void rotate() &#123; System.out.println(this + \" rotate\"); &#125; public void resize(int newSize) &#123; System.out.println(this + \" resize \" + newSize); &#125;&#125; 被一个子类 Square 继承： 123// generics/Square.javapublic class Square extends Shape &#123;&#125; 通过这些，我们可以测试 Apply： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// generics/ApplyTest.javaimport java.util.*;import java.util.function.*;import onjava.*;public class ApplyTest &#123; public static void main(String[] args) throws Exception &#123; List&lt;Shape&gt; shapes = Suppliers.create(ArrayList::new, Shape::new, 3); Apply.apply(shapes, Shape.class.getMethod(\"rotate\")); Apply.apply(shapes, Shape.class.getMethod(\"resize\", int.class), 7); List&lt;Square&gt; squares = Suppliers.create(ArrayList::new, Square::new, 3); Apply.apply(squares, Shape.class.getMethod(\"rotate\")); Apply.apply(squares, Shape.class.getMethod(\"resize\", int.class), 7); Apply.apply(new FilledList&lt;&gt;(Shape::new, 3), Shape.class.getMethod(\"rotate\")); Apply.apply(new FilledList&lt;&gt;(Square::new, 3), Shape.class.getMethod(\"rotate\")); SimpleQueue&lt;Shape&gt; shapeQ = Suppliers.fill( new SimpleQueue&lt;&gt;(), SimpleQueue::add, Shape::new, 3); Suppliers.fill(shapeQ, SimpleQueue::add, Square::new, 3); Apply.apply(shapeQ, Shape.class.getMethod(\"rotate\")); &#125;&#125;/* Output:Shape 0 rotateShape 1 rotateShape 2 rotateShape 0 resize 7Shape 1 resize 7Shape 2 resize 7Square 3 rotateSquare 4 rotateSquare 5 rotateSquare 3 resize 7Square 4 resize 7Square 5 resize 7Shape 6 rotateShape 7 rotateShape 8 rotateSquare 9 rotateSquare 10 rotateSquare 11 rotateShape 12 rotateShape 13 rotateShape 14 rotateSquare 15 rotateSquare 16 rotateSquare 17 rotate*/ 在 Apply 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 Iterable 接口。正由于此， apply() 方法可以接受任何实现了 Iterable 接口的事物，包括诸如 List 这样的所有 Collection 类。但是它还可以接受其他任何事物，只要能够使这些事物是 Iterable 的——例如，在 main() 中使用下面定义的 SimpleQueue 类： 1234567891011121314// generics/SimpleQueue.java// A different kind of Iterable collectionimport java.util.*;public class SimpleQueue&lt;T&gt; implements Iterable&lt;T&gt; &#123; private LinkedList&lt;T&gt; storage = new LinkedList&lt;&gt;(); public void add(T t) &#123; storage.offer(t); &#125; public T get() &#123; return storage.poll(); &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return storage.iterator(); &#125;&#125; 正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。 几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 ApplyTest.java 进行了重写，以利用 Java 8 的流和函数工具： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// generics/ApplyFunctional.javaimport java.util.*;import java.util.stream.*;import java.util.function.*;import onjava.*;public class ApplyFunctional &#123; public static void main(String[] args) &#123; Stream.of( Stream.generate(Shape::new).limit(2), Stream.generate(Square::new).limit(2)) .flatMap(c -&gt; c) // flatten into one stream .peek(Shape::rotate) .forEach(s -&gt; s.resize(7)); new FilledList&lt;&gt;(Shape::new, 2) .forEach(Shape::rotate); new FilledList&lt;&gt;(Square::new, 2) .forEach(Shape::rotate); SimpleQueue&lt;Shape&gt; shapeQ = Suppliers.fill( new SimpleQueue&lt;&gt;(), SimpleQueue::add, Shape::new, 2); Suppliers.fill(shapeQ, SimpleQueue::add, Square::new, 2); shapeQ.forEach(Shape::rotate); &#125;&#125;/* Output:Shape 0 rotateShape 0 resize 7Shape 1 rotateShape 1 resize 7Square 2 rotateSquare 2 resize 7Square 3 rotateSquare 3 resize 7Shape 4 rotateShape 5 rotateSquare 6 rotateSquare 7 rotateShape 8 rotateShape 9 rotateSquare 10 rotateSquare 11 rotate*/ 由于使用 Java 8，因此不需要 Apply.apply() 。 我们首先生成两个 Stream ： 一个是 Shape ，一个是 Square ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 flatten() ，但是我们可以使用 flatMap(c-&gt; c) 产生相同的结果，后者使用身份映射将操作简化为“ flatten ”。 我们使用 peek() 当做对 rotate() 的调用，因为 peek() 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。 注意，使用 FilledList 和 shapeQ 调用 forEach() 比 Apply.apply() 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从 main() 引发异常。 Java8 中的辅助潜在类型先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。 我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。 我们将重写 DogsAndRobots.java 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 A： 12345678910111213141516171819202122232425262728293031323334353637383940414243// generics/DogsAndRobotMethodReferences.java// \"Assisted Latent Typing\"import typeinfo.pets.*;import java.util.function.*;class PerformingDogA extends Dog &#123; public void speak() &#123; System.out.println(\"Woof!\"); &#125; public void sit() &#123; System.out.println(\"Sitting\"); &#125; public void reproduce() &#123;&#125;&#125;class RobotA &#123; public void speak() &#123; System.out.println(\"Click!\"); &#125; public void sit() &#123; System.out.println(\"Clank!\"); &#125; public void oilChange() &#123;&#125;&#125;class CommunicateA &#123; public static &lt;P&gt; void perform(P performer, Consumer&lt;P&gt; action1, Consumer&lt;P&gt; action2) &#123; action1.accept(performer); action2.accept(performer); &#125;&#125;public class DogsAndRobotMethodReferences &#123; public static void main(String[] args) &#123; CommunicateA.perform(new PerformingDogA(), PerformingDogA::speak, PerformingDogA::sit); CommunicateA.perform(new RobotA(), RobotA::speak, RobotA::sit); CommunicateA.perform(new Mime(), Mime::walkAgainstTheWind, Mime::pushInvisibleWalls); &#125;&#125;/* Output:Woof!SittingClick!Clank!*/ PerformingDogA 和 RobotA 与 DogsAndRobots.java 中的相同，不同之处在于它们不继承通用接口 Performs ，因此它们没有通用性。 CommunicateA.perform() 在没有约束的 P 上生成。 只要可以使用 Consumer &lt;P&gt;，它在这里就可以是任何东西，这些 Consumer&lt;P&gt; 代表不带参数的 P 方法的未绑定方法引用。当您调用 Consumer 的 accept() 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 函数式编程 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 CommunicateA.perform() 。 之所以称其为“辅助”，是因为您必须显式地为 perform() 提供要使用的方法引用。 它不能只按名称调用方法。 尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 CommunicateA.perform() ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。 为了证明这一点，我还从 LatentReflection.java 中引入了 Mime。 使用Suppliers类的通用方法通过辅助潜在类型，我们可以定义本章其他部分中使用的 Suppliers 类。 此类包含使用生成器填充 Collection 的工具方法。 泛化这些操作很有意义： 123456789101112131415161718192021222324252627282930313233343536// onjava/Suppliers.java// A utility to use with Supplierspackage onjava;import java.util.*;import java.util.function.*;import java.util.stream.*;public class Suppliers &#123; // Create a collection and fill it: public static &lt;T, C extends Collection&lt;T&gt;&gt; C create(Supplier&lt;C&gt; factory, Supplier&lt;T&gt; gen, int n) &#123; return Stream.generate(gen) .limit(n) .collect(factory, C::add, C::addAll); &#125; // Fill an existing collection: public static &lt;T, C extends Collection&lt;T&gt;&gt; C fill(C coll, Supplier&lt;T&gt; gen, int n) &#123; Stream.generate(gen) .limit(n) .forEach(coll::add); return coll; &#125; // Use an unbound method reference to // produce a more general method: public static &lt;H, A&gt; H fill(H holder, BiConsumer&lt;H, A&gt; adder, Supplier&lt;A&gt; gen, int n) &#123; Stream.generate(gen) .limit(n) .forEach(a -&gt; adder.accept(holder, a)); return holder; &#125;&#125; create() 为你创建一个新的 Collection 子类型，而 fill() 的第一个版本将元素放入 Collection 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。 前两种方法一般都受约束，只能与 Collection 子类型一起使用。fill() 的第二个版本适用于任何类型的 holder 。 它需要一个附加参数：未绑定方法引用 adder. fill() ，使用辅助潜在类型来使其与任何具有添加元素方法的 holder 类型一起使用。因为此未绑定方法 adder 必须带有一个参数（要添加到 holder 的元素），所以 adder 必须是 BiConsumer &lt;H，A&gt; ，其中 H 是要绑定到的 holder 对象的类型，而 A 是要被添加的绑定元素类型。 对 accept() 的调用将使用参数 a 调用对象 holder 上的未绑定方法 holder。 在一个稍作模拟的测试中对 Suppliers 工具程序进行了测试，该仿真还使用了本章前面定义的 RandomList ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// generics/BankTeller.java// A very simple bank teller simulationimport java.util.*;import onjava.*;class Customer &#123; private static long counter = 1; private final long id = counter++; @Override public String toString() &#123; return \"Customer \" + id; &#125;&#125;class Teller &#123; private static long counter = 1; private final long id = counter++; @Override public String toString() &#123; return \"Teller \" + id; &#125;&#125;class Bank &#123; private List&lt;BankTeller&gt; tellers = new ArrayList&lt;&gt;(); public void put(BankTeller bt) &#123; tellers.add(bt); &#125;&#125;public class BankTeller &#123; public static void serve(Teller t, Customer c) &#123; System.out.println(t + \" serves \" + c); &#125; public static void main(String[] args) &#123; // Demonstrate create(): RandomList&lt;Teller&gt; tellers = Suppliers.create( RandomList::new, Teller::new, 4); // Demonstrate fill(): List&lt;Customer&gt; customers = Suppliers.fill( new ArrayList&lt;&gt;(), Customer::new, 12); customers.forEach(c -&gt; serve(tellers.select(), c)); // Demonstrate assisted latent typing: Bank bank = Suppliers.fill( new Bank(), Bank::put, BankTeller::new, 3); // Can also use second version of fill(): List&lt;Customer&gt; customers2 = Suppliers.fill( new ArrayList&lt;&gt;(), List::add, Customer::new, 12); &#125;&#125;/* Output:Teller 3 serves Customer 1Teller 2 serves Customer 2Teller 3 serves Customer 3Teller 1 serves Customer 4Teller 1 serves Customer 5Teller 3 serves Customer 6Teller 1 serves Customer 7Teller 2 serves Customer 8Teller 3 serves Customer 9Teller 3 serves Customer 10Teller 2 serves Customer 11Teller 4 serves Customer 12*/ 可以看到 create() 生成一个新的 Collection 对象，而 fill() 添加到现有 Collection 中。第二个版本fill() 显示，它不仅与无关的新类型 Bank 一起使用，还能与 List 一起使用。因此，从技术上讲，fill() 的第一个版本在技术上不是必需的，但在使用 Collection 时提供了较短的语法。 总结：类型转换真的如此之糟吗？自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。 这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 List 、各种 Set 、各种 Map 等你在 集合 和 附录：集合主题 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 Object ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 Cat 的 List （这个示例的一种使用苹果和桔子的变体在 集合 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 Object 。因此，我们很可能会将一个 Dog 放置到 Cat 的 List 中。 但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 Dog 扔到 Cat 的集合中，并且试图将这个集合中的所有东西都当作 Cat 处理，那么当你从这个 Cat 集合中取回那个 Dog 引用，并试图将其转型为 Cat 时，就会得到一个 RuntimeException 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。 在本书以前的版本中，我曾经说过： 这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。 但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 files 的 list 示例，它包含 String 对象。在这个示例中，向 files 中添加一个 File 对象看起来相当自然，因此这个对象的名字可能叫 fileNames 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 cats ，因为它们可以向试图添加非 Cat 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。 有一位作者甚至断言，这样的缺陷将“潜伏数年”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 多线程编程 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？我相信被称为泛型的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。 还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 Map ，在特定的方法 containsKey(Object key)和 get(Object key) 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 Object ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 map 中，键的类型总是在编译期检查的。 有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。 进阶阅读泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 http://java.oracle.com 获取。 Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。 你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。 Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。 [^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。[^2]: http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html[^3]: 参见本章章末引文。[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。[^6]: 我再次从 Brian Goetz 那获得帮助。 第二十一章 数组简单来看，数组需要你去创建和初始化，你可以通过下标对数组元素进行访问，数组的大小不会改变。大多数时候你只需要知道这些，但有时候你必须在数组上进行更复杂的操作，你也可能需要在数组和更加灵活的 集合 (Collection)之间做出评估。因此本章我们将对数组进行更加深入的分析。 注意： 随着 Java Collection 和 Stream 类中高级功能的不断增加，日常编程中使用数组的需求也在变少，所以你暂且可以放心地略读甚至跳过这一章。但是，即使你自己避免使用数组，也总会有需要阅读别人数组代码的那一天。 数组特性明明还有很多其他的办法来保存对象，那么是什么令数组如此特别？ 将数组和其他类型的集合区分开来的原因有三：效率，类型，保存基本数据类型的能力。在 Java 中，使用数组存储和随机访问对象引用序列是非常高效的。数组是简单的线性序列，这使得对元素的访问变得非常快。然而这种高速也是有代价的，代价就是数组对象的大小是固定的，且在该数组的生存期内不能更改。 速度通常并不是问题，如果有问题，你保存和检索对象的方式也很少是罪魁祸首。你应该总是从 ArrayList (来自 集合)开始，它将数组封装起来。必要时，它会自动分配更多的数组空间，创建新数组，并将旧数组中的引用移动到新数组。这种灵活性需要开销，所以一个 ArrayList 的效率不如数组。在极少的情况下效率会成为问题，所以这种时候你可以直接使用数组。 数组和集合(Collections)都不能滥用。不管你使用数组还是集合，如果你越界，你都会得到一个 RuntimeException 的异常提醒，这表明你的程序中存在错误。 在泛型前，其他的集合类以一种宽泛的方式处理对象（就好像它们没有特定类型一样）。事实上，这些集合类把保存对象的类型默认为 Object，也就是 Java 中所有类的基类。而数组是优于 预泛型 (pre-generic)集合类的，因为你创建一个数组就可以保存特定类型的数据。这意味着你获得了一个编译时的类型检查，而这可以防止你插入错误的数据类型，或者搞错你正在提取的数据类型。 当然，不管在编译时还是运行时，Java都会阻止你犯向对象发送不正确消息的错误。然而不管怎样，使用数组都不会有更大的风险。比较好的地方在于，如果编译器报错，最终的用户更容易理解抛出异常的含义。 一个数组可以保存基本数据类型，而一个预泛型的集合不可以。然而对于泛型而言，集合可以指定和检查他们保存对象的类型，而通过 自动装箱 (autoboxing)机制，集合表现地就像它们可以保存基本数据类型一样，因为这种转换是自动的。 所以在概念上，两者很容易切换。但是就像你在集合中看到的，集合的功能明显多于数组。随着 Java 自动装箱技术的出现，通过集合使用基本数据类型几乎和通过数组一样简单。数组唯一剩下的优势就是效率。然而，当你解决一个更加普遍的问题时，数组可能限制太多，这种情形下，您可以使用集合类。 用于显示数组的实用程序在本章中，我们处处都要显示数组。Java 提供了 Arrays.toString() 来将数组转换为可读字符串，然后可以在控制台上显示。然而这种方式视觉上噪音太大，所以我们创建一个小的库来完成这项工作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// onjava/ArrayShow.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.package onjava;import java.util.*;public interface ArrayShow &#123; static void show(Object[] a) &#123; System.out.println(Arrays.toString(a)); &#125; static void show(boolean[] a) &#123; System.out.println(Arrays.toString(a)); &#125; static void show(byte[] a) &#123; System.out.println(Arrays.toString(a)); &#125; static void show(char[] a) &#123; System.out.println(Arrays.toString(a)); &#125; static void show(short[] a) &#123; System.out.println(Arrays.toString(a)); &#125; static void show(int[] a) &#123; System.out.println(Arrays.toString(a)); &#125; static void show(long[] a) &#123; System.out.println(Arrays.toString(a)); &#125; static void show(float[] a) &#123; System.out.println(Arrays.toString(a)); &#125; static void show(double[] a) &#123; System.out.println(Arrays.toString(a)); &#125; // Start with a description: static void show(String info, Object[] a) &#123; System.out.print(info + \": \"); show(a); &#125; static void show(String info, boolean[] a) &#123; System.out.print(info + \": \"); show(a); &#125; static void show(String info, byte[] a) &#123; System.out.print(info + \": \"); show(a); &#125; static void show(String info, char[] a) &#123; System.out.print(info + \": \"); show(a); &#125; static void show(String info, short[] a) &#123; System.out.print(info + \": \"); show(a); &#125; static void show(String info, int[] a) &#123; System.out.print(info + \": \"); show(a); &#125; static void show(String info, long[] a) &#123; System.out.print(info + \": \"); show(a); &#125; static void show(String info, float[] a) &#123; System.out.print(info + \": \"); show(a); &#125; static void show(String info, double[] a) &#123; System.out.print(info + \": \"); show(a); &#125;&#125; 第一个方法适用于对象数组，包括那些包装基本数据类型的数组。所有的方法重载对于不同的数据类型是必要的。 第二组重载方法可以让你显示带有信息 字符串 前缀的数组。 为了简单起见，你通常可以静态地导入它们。 一等对象不管你使用的什么类型的数组，数组中的数据集实际上都是对堆中真正对象的引用。数组是保存指向其他对象的引用的对象，数组可以隐式地创建，作为数组初始化语法的一部分，也可以显式地创建，比如使用一个 new 表达式。数组对象的一部分（事实上，你唯一可以使用的方法）就是只读的 length 成员函数，它能告诉你数组对象中可以存储多少元素。[ ] 语法是你访问数组对象的唯一方式。 一等对象不管你使用的什么类型的数组，数组中的数据集实际上都是对堆中真正对象的引用。数组是保存指向其他对象的引用的对象，数组可以隐式地创建，作为数组初始化语法的一部分，也可以显式地创建，比如使用一个 new 表达式。数组对象的一部分（事实上，你唯一可以使用的方法）就是只读的 length 成员函数，它能告诉你数组对象中可以存储多少元素。[ ] 语法是你访问数组对象的唯一方式。 对象数组和基元数组在使用上是完全相同的。唯一的不同之处就是对象数组存储的是对象的引用，而基元数组则直接存储基本数据类型的值。 你无法找出到底有多少元素存储在数组中，因为 length 只能告诉你数组可以存储多少元素；这就是说，数组对象的大小并不是真正存储在数组中对象的个数。然而，当你创建一个数组对象，其引用将自动初始化为 null，因此你可以通过检查特定数组元素中的引用是否为 null 来判断其中是否有对象。基元数组也有类似的机制，比如自动将数值类型初始化为 0，char 型初始化为 (char)0，布尔类型初始化为 false。 表达式： 1a = d; 显示了你如何获取指向一个数组对象的引用并将其分配给另一个数组对象。就像你可以处理其他类型的对象引用。现在 a 和 d 都指向了堆中的同一个数组对象。 返回数组假设你写了一个方法，这个方法不是返回一个元素，而是返回多个元素。对 C++/C 这样的语言来说这是很困难的，因为你无法返回一个数组，只能是返回一个指向数组的指针。这会带来一些问题，因为对数组生存期的控制变得很混乱，这会导致内存泄露。 而在 Java 中，你只需返回数组，你永远不用为数组担心，只要你需要它，它就可用，垃圾收集器会在你用完后把它清理干净。 123456public static String[] flavorSet(int n) &#123; if(n &gt; FLAVORS.length) throw new IllegalArgumentException(\"Set too big\"); String[] results = new String[n]; return results;&#125; 多维数组要创建多维的基元数组，你要用大括号来界定数组中的向量： 123456789101112131415// arrays/MultidimensionalPrimitiveArray.javaimport java.util.*;public class MultidimensionalPrimitiveArray &#123; public static void main(String[] args) &#123; int[][] a = &#123; &#123; 1, 2, 3, &#125;, &#123; 4, 5, 6, &#125;, &#125;; System.out.println(Arrays.deepToString(a)); &#125;&#125;/* Output:[[1, 2, 3], [4, 5, 6]]*/。 每个嵌套的大括号都代表了数组的一个维度。 这个例子使用 Arrays.deepToString() 方法，将多维数组转换成 String 类型，就像输出中显示的那样。 你也可以使用 new 分配数组。这是一个使用 new 表达式分配的三维数组： 1234567891011121314// arrays/ThreeDWithNew.javaimport java.util.*;public class ThreeDWithNew &#123; public static void main(String[] args) &#123; // 3-D array with fixed length: int[][][] a = new int[2][2][4]; System.out.println(Arrays.deepToString(a)); &#125;&#125;/* Output:[[[0, 0, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0,0]]]*/ 倘若你不对基元数组进行显式的初始化，它的值会自动初始化。而对象数组将被初始化为 null 。 组成矩阵的数组中每一个向量都可以是任意长度的（这叫做不规则数组）： 1234567891011121314151617181920212223// arrays/RaggedArray.javaimport java.util.*;public class RaggedArray &#123; static int val = 1; public static void main(String[] args) &#123; SplittableRandom rand = new SplittableRandom(47); // 3-D array with varied-length vectors: int[][][] a = new int[rand.nextInt(7)][][]; for(int i = 0; i &lt; a.length; i++) &#123; a[i] = new int[rand.nextInt(5)][]; for(int j = 0; j &lt; a[i].length; j++) &#123; a[i][j] = new int[rand.nextInt(5)]; Arrays.setAll(a[i][j], n -&gt; val++); // [1] &#125; &#125; System.out.println(Arrays.deepToString(a)); &#125;&#125;/* Output:[[[1], []], [[2, 3, 4, 5], [6]], [[7, 8, 9], [10, 11,12], []]]*/ 第一个 new 创建了一个数组，这个数组首元素长度随机，其余的则不确定。第二个 new 在 for 循环中给数组填充了第二个元素，第三个 new 为数组的最后一个索引填充元素。 [1] Java 8 增加了 Arrays.setAll() 方法,其使用生成器来生成插入数组中的值。此生成器符合函数式接口 IntUnaryOperator ，只使用一个非 默认 的方法 ApplyAsint(int操作数) 。 Arrays.setAll() 传递当前数组索引作为操作数，因此一个选项是提供 n -&gt; n 的 lambda 表达式来显示数组的索引（在上面的代码中很容易尝试）。这里，我们忽略索引，只是插入递增计数器的值。 非基元的对象数组也可以定义为不规则数组。这里，我们收集了许多使用大括号的 new 表达式： 12345678910111213141516171819202122// arrays/MultidimensionalObjectArrays.javaimport java.util.*;public class MultidimensionalObjectArrays &#123; public static void main(String[] args) &#123; BerylliumSphere[][] spheres = &#123; &#123; new BerylliumSphere(), new BerylliumSphere() &#125;, &#123; new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere() &#125;, &#123; new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere() &#125;, &#125;; System.out.println(Arrays.deepToString(spheres)); &#125;&#125;/* Output:[[Sphere 0, Sphere 1], [Sphere 2, Sphere 3, Sphere 4,Sphere 5], [Sphere 6, Sphere 7, Sphere 8, Sphere 9,Sphere 10, Sphere 11, Sphere 12, Sphere 13]]*/ 数组初始化时使用自动装箱技术： 12345678910111213141516171819// arrays/AutoboxingArrays.javaimport java.util.*;public class AutoboxingArrays &#123; public static void main(String[] args) &#123; Integer[][] a = &#123; // Autoboxing: &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;, &#123; 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 &#125;, &#123; 51, 52, 53, 54, 55, 56, 57, 58, 59, 60 &#125;, &#123; 71, 72, 73, 74, 75, 76, 77, 78, 79, 80 &#125;, &#125;; System.out.println(Arrays.deepToString(a)); &#125;&#125;/* Output:[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [21, 22, 23, 24, 25,26, 27, 28, 29, 30], [51, 52, 53, 54, 55, 56, 57, 58,59, 60], [71, 72, 73, 74, 75, 76, 77, 78, 79, 80]]*/ 以下是如何逐个构建非基元的对象数组： 12345678910111213141516171819// arrays/AssemblingMultidimensionalArrays.java// Creating multidimensional arraysimport java.util.*;public class AssemblingMultidimensionalArrays &#123; public static void main(String[] args) &#123; Integer[][] a; a = new Integer[3][]; for(int i = 0; i &lt; a.length; i++) &#123; a[i] = new Integer[3]; for(int j = 0; j &lt; a[i].length; j++) a[i][j] = i * j; // Autoboxing &#125; System.out.println(Arrays.deepToString(a)); &#125;&#125;/* Output:[[0, 0, 0], [0, 1, 2], [0, 2, 4]]*/ i * j 在这里只是为了向 Integer 中添加有趣的值。 Arrays.deepToString() 方法同时适用于基元数组和对象数组。 泛型数组一般来说，数组和泛型并不能很好的结合。你不能实例化参数化类型的数组： 1Peel&lt;Banana&gt;[] peels = new Peel&lt;Banana&gt;[10]; // Illegal 类型擦除需要删除参数类型信息，而且数组必须知道它们所保存的确切类型，以强制保证类型安全。 但是，可以参数化数组本身的类型： 12345678910111213141516171819202122// arrays/ParameterizedArrayType.javaclass ClassParameter&lt;T&gt; &#123; public T[] f(T[] arg) &#123; return arg; &#125;&#125;class MethodParameter &#123; public static &lt;T&gt; T[] f(T[] arg) &#123; return arg; &#125;&#125;public class ParameterizedArrayType &#123; public static void main(String[] args) &#123; Integer[] ints = &#123; 1, 2, 3, 4, 5 &#125;; Double[] doubles = &#123; 1.1, 2.2, 3.3, 4.4, 5.5 &#125;; Integer[] ints2 = new ClassParameter&lt;Integer&gt;().f(ints); Double[] doubles2 = new ClassParameter&lt;Double&gt;().f(doubles); ints2 = MethodParameter.f(ints); doubles2 = MethodParameter.f(doubles); &#125;&#125; 比起使用参数化类，使用参数化方法很方便。您不必为应用它的每个不同类型都实例化一个带有参数的类，但是可以使它成为 静态 的。你不能总是选择使用参数化方法而不用参数化的类，但通常参数化方法是更好的选择。 你不能创建泛型类型的数组，这种说法并不完全正确。是的，编译器不会让你 实例化 一个泛型的数组。但是，它将允许您创建对此类数组的引用。例如： 1List&lt;String&gt;[] ls; 无可争议的，这可以通过编译。尽管不能创建包含泛型的实际数组对象，但是你可以创建一个非泛型的数组并对其进行强制类型转换： 123456789101112131415161718192021222324252627282930// arrays/ArrayOfGenerics.javaimport java.util.*;public class ArrayOfGenerics &#123; @SuppressWarnings(\"unchecked\") public static void main(String[] args) &#123; List&lt;String&gt;[] ls; List[] la = new List[10]; ls = (List&lt;String&gt;[])la; // Unchecked cast ls[0] = new ArrayList&lt;&gt;(); //- ls[1] = new ArrayList&lt;Integer&gt;(); // error: incompatible types: ArrayList&lt;Integer&gt; // cannot be converted to List&lt;String&gt; // ls[1] = new ArrayList&lt;Integer&gt;(); // ^ // The problem: List&lt;String&gt; is a subtype of Object Object[] objects = ls; // So assignment is OK // Compiles and runs without complaint: objects[1] = new ArrayList&lt;&gt;(); // However, if your needs are straightforward it is // possible to create an array of generics, albeit // with an \"unchecked cast\" warning: List&lt;BerylliumSphere&gt;[] spheres = (List&lt;BerylliumSphere&gt;[])new List[10]; Arrays.setAll(spheres, n -&gt; new ArrayList&lt;&gt;()); &#125;&#125; 一旦你有了对 List[] 的引用 , 你会发现多了一些编译时检查。问题是数组是协变的，所以 List[] 也是一个 Object[] ，你可以用这来将 *ArrayList * 分配进你的数组，在编译或者运行时都不会出错。 如果你知道你不会进行向上类型转换，你的需求相对简单，那么可以创建一个泛型数组，它将提供基本的编译时类型检查。然而，一个泛型 Collection 实际上是一个比泛型数组更好的选择。 一般来说，您会发现泛型在类或方法的边界上是有效的。在内部，擦除常常会使泛型不可使用。所以，就像下面的例子，不能创建泛型类型的数组： 12345678910111213// arrays/ArrayOfGenericType.javapublic class ArrayOfGenericType&lt;T&gt; &#123; T[] array; // OK @SuppressWarnings(\"unchecked\") public ArrayOfGenericType(int size) &#123; // error: generic array creation: //- array = new T[size]; array = (T[])new Object[size]; // unchecked cast &#125; // error: generic array creation: //- public &lt;U&gt; U[] makeArray() &#123; return new U[10]; &#125;&#125; 擦除再次从中作梗，这个例子试图创建已经擦除的类型数组，因此它们是未知的类型。你可以创建一个 对象 数组，然后对其进行强制类型转换，但如果没有 @SuppressWarnings 注释，你将会得到一个 “unchecked” 警告，因为数组实际上不真正支持而且将对类型 T 动态检查 。这就是说，如果我创建了一个 String[] , Java将在编译时和运行时强制执行，我只能在数组中放置字符串对象。然而，如果我创建一个 Object[] ,我可以把除了基元类型外的任何东西放入数组。 Arrays的fill方法通常情况下，当对数组和程序进行实验时，能够很轻易地生成充满测试数据的数组是很有帮助的。 Java 标准库 Arrays 类包括一个普通的 fill() 方法，该方法将单个值复制到整个数组，或者在对象数组的情况下，将相同的引用复制到整个数组： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// arrays/FillingArrays.java// Using Arrays.fill()import java.util.*;import static onjava.ArrayShow.*;public class FillingArrays &#123; public static void main(String[] args) &#123; int size = 6; boolean[] a1 = new boolean[size]; byte[] a2 = new byte[size]; char[] a3 = new char[size]; short[] a4 = new short[size]; int[] a5 = new int[size]; long[] a6 = new long[size]; float[] a7 = new float[size]; double[] a8 = new double[size]; String[] a9 = new String[size]; Arrays.fill(a1, true); show(\"a1\", a1); Arrays.fill(a2, (byte)11); show(\"a2\", a2); Arrays.fill(a3, 'x'); show(\"a3\", a3); Arrays.fill(a4, (short)17); show(\"a4\", a4); Arrays.fill(a5, 19); show(\"a5\", a5); Arrays.fill(a6, 23); show(\"a6\", a6); Arrays.fill(a7, 29); show(\"a7\", a7); Arrays.fill(a8, 47); show(\"a8\", a8); Arrays.fill(a9, \"Hello\"); show(\"a9\", a9); // Manipulating ranges: Arrays.fill(a9, 3, 5, \"World\"); show(\"a9\", a9); &#125;&#125;gedan/* Output:a1: [true, true, true, true, true, true]a2: [11, 11, 11, 11, 11, 11]a3: [x, x, x, x, x, x]a4: [17, 17, 17, 17, 17, 17]a5: [19, 19, 19, 19, 19, 19]a6: [23, 23, 23, 23, 23, 23]a7: [29.0, 29.0, 29.0, 29.0, 29.0, 29.0]a8: [47.0, 47.0, 47.0, 47.0, 47.0, 47.0]a9: [Hello, Hello, Hello, Hello, Hello, Hello]a9: [Hello, Hello, Hello, World, World, Hello]*/ 你既可以填充整个数组，也可以像最后两个语句所示，填充一系列的元素。但是由于你只能使用单个值调用 Arrays.fill() ，因此结果并非特别有用。 Arrays的setAll方法在Java 8中， 在RaggedArray.java 中引入并在 ArrayOfGenerics.java.Array.setAll() 中重用。它使用一个生成器并生成不同的值，可以选择基于数组的索引元素（通过访问当前索引，生成器可以读取数组值并对其进行修改）。 static Arrays.setAll() 的重载签名为： void setAll(int[] a, IntUnaryOperator gen) void setAll(long[] a, IntToLongFunction gen) void setAll(double[] a, IntToDoubleFunctiongen) void setAll(T[] a, IntFunction&lt;? extendsT&gt; gen) 除了 int , long , double 有特殊的版本，其他的一切都由泛型版本处理。生成器不是 Supplier 因为它们不带参数，并且必须将 int 数组索引作为参数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// arrays/SimpleSetAll.javaimport java.util.*;import static onjava.ArrayShow.*;class Bob &#123; final int id; Bob(int n) &#123; id = n; &#125; @Override public String toString() &#123; return \"Bob\" + id; &#125;&#125;public class SimpleSetAll &#123; public static final int SZ = 8; static int val = 1; static char[] chars = \"abcdefghijklmnopqrstuvwxyz\" .toCharArray(); static char getChar(int n) &#123; return chars[n]; &#125; public static void main(String[] args) &#123; int[] ia = new int[SZ]; long[] la = new long[SZ]; double[] da = new double[SZ]; Arrays.setAll(ia, n -&gt; n); // [1] Arrays.setAll(la, n -&gt; n); Arrays.setAll(da, n -&gt; n); show(ia); show(la); show(da); Arrays.setAll(ia, n -&gt; val++); // [2] Arrays.setAll(la, n -&gt; val++); Arrays.setAll(da, n -&gt; val++); show(ia); show(la); show(da); Bob[] ba = new Bob[SZ]; Arrays.setAll(ba, Bob::new); // [3] show(ba); Character[] ca = new Character[SZ]; Arrays.setAll(ca, SimpleSetAll::getChar); // [4] show(ca); &#125;&#125;/* Output:[0, 1, 2, 3, 4, 5, 6, 7][0, 1, 2, 3, 4, 5, 6, 7][0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0][1, 2, 3, 4, 5, 6, 7, 8][9, 10, 11, 12, 13, 14, 15, 16][17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0][Bob0, Bob1, Bob2, Bob3, Bob4, Bob5, Bob6, Bob7][a, b, c, d, e, f, g, h]*/ [1] 这里，我们只是将数组索引作为值插入数组。这将自动转化为 long 和 double 版本。 [2] 这个函数只需要接受索引就能产生正确结果。这个，我们忽略索引值并且使用 val 生成结果。 [3] 方法引用有效，因为 Bob 的构造器接收一个 int 参数。只要我们传递的函数接收一个 int 参数且能产生正确的结果，就认为它完成了工作。 [4] 为了处理除了 int ，long ，double 之外的基元类型，请为基元创建包装类的数组。然后使用 setAll() 的泛型版本。请注意，getChar（） 生成基元类型，因此这是自动装箱到 Character 。 增量生成这是一个方法库，用于为不同类型生成增量值。 这些被作为内部类来生成容易记住的名字；比如，为了使用 Integer 工具你可以用 new Conut.Interger() , 如果你想要使用基本数据类型 int 工具，你可以用 new Count.Pint() (基本类型的名字不能被直接使用，所以它们都在前面添加一个 P 来表示基本数据类型’primitive’, 我们的第一选择是使用基本类型名字后面跟着下划线，比如 int_ 和 double_ ,但是这种方式违背Java的命名习惯）。每个包装类的生成器都使用 get() 方法实现了它的 Supplier 。要使用Array.setAll() ，一个重载的 get(int n) 方法要接受（并忽略）其参数，以便接受 setAll() 传递的索引值。 注意，通过使用包装类的名称作为内部类名，我们必须调用 java.lang 包来保证我们可以使用实际包装类的名字： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217// onjava/Count.java// Generate incremental values of different typespackage onjava;import java.util.*;import java.util.function.*;import static onjava.ConvertTo.*;public interface Count &#123; class Boolean implements Supplier&lt;java.lang.Boolean&gt; &#123; private boolean b = true; @Override public java.lang.Boolean get() &#123; b = !b; return java.lang.Boolean.valueOf(b); &#125; public java.lang.Boolean get(int n) &#123; return get(); &#125; public java.lang.Boolean[] array(int sz) &#123; java.lang.Boolean[] result = new java.lang.Boolean[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pboolean &#123; private boolean b = true; public boolean get() &#123; b = !b; return b; &#125; public boolean get(int n) &#123; return get(); &#125; public boolean[] array(int sz) &#123; return primitive(new Boolean().array(sz)); &#125; &#125; class Byte implements Supplier&lt;java.lang.Byte&gt; &#123; private byte b; @Override public java.lang.Byte get() &#123; return b++; &#125; public java.lang.Byte get(int n) &#123; return get(); &#125; public java.lang.Byte[] array(int sz) &#123; java.lang.Byte[] result = new java.lang.Byte[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pbyte &#123; private byte b; public byte get() &#123; return b++; &#125; public byte get(int n) &#123; return get(); &#125; public byte[] array(int sz) &#123; return primitive(new Byte().array(sz)); &#125; &#125; char[] CHARS = \"abcdefghijklmnopqrstuvwxyz\".toCharArray(); class Character implements Supplier&lt;java.lang.Character&gt; &#123; private int i; @Override public java.lang.Character get() &#123; i = (i + 1) % CHARS.length; return CHARS[i]; &#125; public java.lang.Character get(int n) &#123; return get(); &#125; public java.lang.Character[] array(int sz) &#123; java.lang.Character[] result = new java.lang.Character[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pchar &#123; private int i; public char get() &#123; i = (i + 1) % CHARS.length; return CHARS[i]; &#125; public char get(int n) &#123; return get(); &#125; public char[] array(int sz) &#123; return primitive(new Character().array(sz)); &#125; &#125; class Short implements Supplier&lt;java.lang.Short&gt; &#123; short s; @Override public java.lang.Short get() &#123; return s++; &#125; public java.lang.Short get(int n) &#123; return get(); &#125; public java.lang.Short[] array(int sz) &#123; java.lang.Short[] result = new java.lang.Short[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pshort &#123; short s; public short get() &#123; return s++; &#125; public short get(int n) &#123; return get(); &#125; public short[] array(int sz) &#123; return primitive(new Short().array(sz)); &#125; &#125; class Integer implements Supplier&lt;java.lang.Integer&gt; &#123; int i; @Override public java.lang.Integer get() &#123; return i++; &#125; public java.lang.Integer get(int n) &#123; return get(); &#125; public java.lang.Integer[] array(int sz) &#123; java.lang.Integer[] result = new java.lang.Integer[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pint implements IntSupplier &#123; int i; public int get() &#123; return i++; &#125; public int get(int n) &#123; return get(); &#125; @Override public int getAsInt() &#123; return get(); &#125; public int[] array(int sz) &#123; return primitive(new Integer().array(sz)); &#125; &#125; class Long implements Supplier&lt;java.lang.Long&gt; &#123; private long l; @Override public java.lang.Long get() &#123; return l++; &#125; public java.lang.Long get(int n) &#123; return get(); &#125; public java.lang.Long[] array(int sz) &#123; java.lang.Long[] result = new java.lang.Long[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Plong implements LongSupplier &#123; private long l; public long get() &#123; return l++; &#125; public long get(int n) &#123; return get(); &#125; @Override public long getAsLong() &#123; return get(); &#125; public long[] array(int sz) &#123; return primitive(new Long().array(sz)); &#125; &#125; class Float implements Supplier&lt;java.lang.Float&gt; &#123; private int i; @Override public java.lang.Float get() &#123; return java.lang.Float.valueOf(i++); &#125; public java.lang.Float get(int n) &#123; return get(); &#125; public java.lang.Float[] array(int sz) &#123; java.lang.Float[] result = new java.lang.Float[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pfloat &#123; private int i; public float get() &#123; return i++; &#125; public float get(int n) &#123; return get(); &#125; public float[] array(int sz) &#123; return primitive(new Float().array(sz)); &#125; &#125; class Double implements Supplier&lt;java.lang.Double&gt; &#123; private int i; @Override public java.lang.Double get() &#123; return java.lang.Double.valueOf(i++); &#125; public java.lang.Double get(int n) &#123; return get(); &#125; public java.lang.Double[] array(int sz) &#123; java.lang.Double[] result = new java.lang.Double[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pdouble implements DoubleSupplier &#123; private int i; public double get() &#123; return i++; &#125; public double get(int n) &#123; return get(); &#125; @Override public double getAsDouble() &#123; return get(0); &#125; public double[] array(int sz) &#123; return primitive(new Double().array(sz)); &#125; &#125;&#125; 对于 int ，long ，double 这三个有特殊 Supplier 接口的原始数据类型来说，Pint ， Plong 和 Pdouble 实现了这些接口。 这里是对 Count 的测试，这同样给我们提供了如何使用它的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164// arrays/TestCount.java// Test counting generatorsimport java.util.*;import java.util.stream.*;import onjava.*;import static onjava.ArrayShow.*;public class TestCount &#123; static final int SZ = 5; public static void main(String[] args) &#123; System.out.println(\"Boolean\"); Boolean[] a1 = new Boolean[SZ]; Arrays.setAll(a1, new Count.Boolean()::get); show(a1); a1 = Stream.generate(new Count.Boolean()) .limit(SZ + 1).toArray(Boolean[]::new); show(a1); a1 = new Count.Boolean().array(SZ + 2); show(a1); boolean[] a1b = new Count.Pboolean().array(SZ + 3); show(a1b); System.out.println(\"Byte\"); Byte[] a2 = new Byte[SZ]; Arrays.setAll(a2, new Count.Byte()::get); show(a2); a2 = Stream.generate(new Count.Byte()) .limit(SZ + 1).toArray(Byte[]::new); show(a2); a2 = new Count.Byte().array(SZ + 2); show(a2); byte[] a2b = new Count.Pbyte().array(SZ + 3); show(a2b); System.out.println(\"Character\"); Character[] a3 = new Character[SZ]; Arrays.setAll(a3, new Count.Character()::get); show(a3); a3 = Stream.generate(new Count.Character()) .limit(SZ + 1).toArray(Character[]::new); show(a3); a3 = new Count.Character().array(SZ + 2); show(a3); char[] a3b = new Count.Pchar().array(SZ + 3); show(a3b); System.out.println(\"Short\"); Short[] a4 = new Short[SZ]; Arrays.setAll(a4, new Count.Short()::get); show(a4); a4 = Stream.generate(new Count.Short()) .limit(SZ + 1).toArray(Short[]::new); show(a4); a4 = new Count.Short().array(SZ + 2); show(a4); short[] a4b = new Count.Pshort().array(SZ + 3); show(a4b); System.out.println(\"Integer\"); int[] a5 = new int[SZ]; Arrays.setAll(a5, new Count.Integer()::get); show(a5); Integer[] a5b = Stream.generate(new Count.Integer()) .limit(SZ + 1).toArray(Integer[]::new); show(a5b); a5b = new Count.Integer().array(SZ + 2); show(a5b); a5 = IntStream.generate(new Count.Pint()) .limit(SZ + 1).toArray(); show(a5); a5 = new Count.Pint().array(SZ + 3); show(a5); System.out.println(\"Long\"); long[] a6 = new long[SZ]; Arrays.setAll(a6, new Count.Long()::get); show(a6); Long[] a6b = Stream.generate(new Count.Long()) .limit(SZ + 1).toArray(Long[]::new); show(a6b); a6b = new Count.Long().array(SZ + 2); show(a6b); a6 = LongStream.generate(new Count.Plong()) .limit(SZ + 1).toArray(); show(a6); a6 = new Count.Plong().array(SZ + 3); show(a6); System.out.println(\"Float\"); Float[] a7 = new Float[SZ]; Arrays.setAll(a7, new Count.Float()::get); show(a7); a7 = Stream.generate(new Count.Float()) .limit(SZ + 1).toArray(Float[]::new); show(a7); a7 = new Count.Float().array(SZ + 2); show(a7); float[] a7b = new Count.Pfloat().array(SZ + 3); show(a7b); System.out.println(\"Double\"); double[] a8 = new double[SZ]; Arrays.setAll(a8, new Count.Double()::get); show(a8); Double[] a8b = Stream.generate(new Count.Double()) .limit(SZ + 1).toArray(Double[]::new); show(a8b); a8b = new Count.Double().array(SZ + 2); show(a8b); a8 = DoubleStream.generate(new Count.Pdouble()) .limit(SZ + 1).toArray(); show(a8); a8 = new Count.Pdouble().array(SZ + 3); show(a8); &#125;&#125;/* Output:Boolean[false, true, false, true, false][false, true, false, true, false, true][false, true, false, true, false, true, false][false, true, false, true, false, true, false, true]Byte[0, 1, 2, 3, 4][0, 1, 2, 3, 4, 5][0, 1, 2, 3, 4, 5, 6][0, 1, 2, 3, 4, 5, 6, 7]Character[b, c, d, e, f][b, c, d, e, f, g][b, c, d, e, f, g, h][b, c, d, e, f, g, h, i]Short[0, 1, 2, 3, 4][0, 1, 2, 3, 4, 5][0, 1, 2, 3, 4, 5, 6][0, 1, 2, 3, 4, 5, 6, 7]Integer[0, 1, 2, 3, 4][0, 1, 2, 3, 4, 5][0, 1, 2, 3, 4, 5, 6][0, 1, 2, 3, 4, 5][0, 1, 2, 3, 4, 5, 6, 7]Long[0, 1, 2, 3, 4][0, 1, 2, 3, 4, 5][0, 1, 2, 3, 4, 5, 6][0, 1, 2, 3, 4, 5][0, 1, 2, 3, 4, 5, 6, 7]Float[0.0, 1.0, 2.0, 3.0, 4.0][0.0, 1.0, 2.0, 3.0, 4.0, 5.0][0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0][0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]Double[0.0, 1.0, 2.0, 3.0, 4.0][0.0, 1.0, 2.0, 3.0, 4.0, 5.0][0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0][0.0, 1.0, 2.0, 3.0, 4.0, 5.0][0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]*/ 注意到原始数组类型 int[] ，long[] ，double[] 可以直接被 Arrays.setAll() 填充，但是其他的原始类型都要求用包装器类型的数组。 通过 Stream.generate() 创建的包装数组显示了 toArray（） 的重载用法，在这里你应该提供给它要创建的数组类型的构造器。 随机生成我们可以按照 Count.java 的结构创建一个生成随机值的工具： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248// onjava/Rand.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.// Generate random values of different typespackage onjava;import java.util.*;import java.util.function.*;import static onjava.ConvertTo.*;public interface Rand &#123; int MOD = 10_000; class Boolean implements Supplier&lt;java.lang.Boolean&gt; &#123; SplittableRandom r = new SplittableRandom(47); @Override public java.lang.Boolean get() &#123; return r.nextBoolean(); &#125; public java.lang.Boolean get(int n) &#123; return get(); &#125; public java.lang.Boolean[] array(int sz) &#123; java.lang.Boolean[] result = new java.lang.Boolean[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pboolean &#123; public boolean[] array(int sz) &#123; return primitive(new Boolean().array(sz)); &#125; &#125; class Byte implements Supplier&lt;java.lang.Byte&gt; &#123; SplittableRandom r = new SplittableRandom(47); @Override public java.lang.Byte get() &#123; return (byte)r.nextInt(MOD); &#125; public java.lang.Byte get(int n) &#123; return get(); &#125; public java.lang.Byte[] array(int sz) &#123; java.lang.Byte[] result = new java.lang.Byte[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pbyte &#123; public byte[] array(int sz) &#123; return primitive(new Byte().array(sz)); &#125; &#125; class Character implements Supplier&lt;java.lang.Character&gt; &#123; SplittableRandom r = new SplittableRandom(47); @Override public java.lang.Character get() &#123; return (char)r.nextInt('a', 'z' + 1); &#125; public java.lang.Character get(int n) &#123; return get(); &#125; public java.lang.Character[] array(int sz) &#123; java.lang.Character[] result = new java.lang.Character[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pchar &#123; public char[] array(int sz) &#123; return primitive(new Character().array(sz)); &#125; &#125; class Short implements Supplier&lt;java.lang.Short&gt; &#123; SplittableRandom r = new SplittableRandom(47); @Override public java.lang.Short get() &#123; return (short)r.nextInt(MOD); &#125; public java.lang.Short get(int n) &#123; return get(); &#125; public java.lang.Short[] array(int sz) &#123; java.lang.Short[] result = new java.lang.Short[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pshort &#123; public short[] array(int sz) &#123; return primitive(new Short().array(sz)); &#125; &#125; class Integer implements Supplier&lt;java.lang.Integer&gt; &#123; SplittableRandom r = new SplittableRandom(47); @Override public java.lang.Integer get() &#123; return r.nextInt(MOD); &#125; public java.lang.Integer get(int n) &#123; return get(); &#125; public java.lang.Integer[] array(int sz) &#123; int[] primitive = new Pint().array(sz); java.lang.Integer[] result = new java.lang.Integer[sz]; for(int i = 0; i &lt; sz; i++) result[i] = primitive[i]; return result; &#125; &#125; class Pint implements IntSupplier &#123; SplittableRandom r = new SplittableRandom(47); @Override public int getAsInt() &#123; return r.nextInt(MOD); &#125; public int get(int n) &#123; return getAsInt(); &#125; public int[] array(int sz) &#123; return r.ints(sz, 0, MOD).toArray(); &#125; &#125; class Long implements Supplier&lt;java.lang.Long&gt; &#123; SplittableRandom r = new SplittableRandom(47); @Override public java.lang.Long get() &#123; return r.nextLong(MOD); &#125; public java.lang.Long get(int n) &#123; return get(); &#125; public java.lang.Long[] array(int sz) &#123; long[] primitive = new Plong().array(sz); java.lang.Long[] result = new java.lang.Long[sz]; for(int i = 0; i &lt; sz; i++) result[i] = primitive[i]; return result; &#125; &#125; class Plong implements LongSupplier &#123; SplittableRandom r = new SplittableRandom(47); @Override public long getAsLong() &#123; return r.nextLong(MOD); &#125; public long get(int n) &#123; return getAsLong(); &#125; public long[] array(int sz) &#123; return r.longs(sz, 0, MOD).toArray(); &#125; &#125; class Float implements Supplier&lt;java.lang.Float&gt; &#123; SplittableRandom r = new SplittableRandom(47); @Override public java.lang.Float get() &#123; return (float)trim(r.nextDouble()); &#125; public java.lang.Float get(int n) &#123; return get(); &#125; public java.lang.Float[] array(int sz) &#123; java.lang.Float[] result = new java.lang.Float[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125; class Pfloat &#123; public float[] array(int sz) &#123; return primitive(new Float().array(sz)); &#125; &#125; static double trim(double d) &#123; return ((double)Math.round(d * 1000.0)) / 100.0; &#125; class Double implements Supplier&lt;java.lang.Double&gt; &#123; SplittableRandom r = new SplittableRandom(47); @Override public java.lang.Double get() &#123; return trim(r.nextDouble()); &#125; public java.lang.Double get(int n) &#123; return get(); &#125; public java.lang.Double[] array(int sz) &#123; double[] primitive = new Rand.Pdouble().array(sz); java.lang.Double[] result = new java.lang.Double[sz]; for(int i = 0; i &lt; sz; i++) result[i] = primitive[i]; return result; &#125; &#125; class Pdouble implements DoubleSupplier &#123; SplittableRandom r = new SplittableRandom(47); @Override public double getAsDouble() &#123; return trim(r.nextDouble()); &#125; public double get(int n) &#123; return getAsDouble(); &#125; public double[] array(int sz) &#123; double[] result = r.doubles(sz).toArray(); Arrays.setAll(result, n -&gt; result[n] = trim(result[n])); return result; &#125; &#125; class String implements Supplier&lt;java.lang.String&gt; &#123; SplittableRandom r = new SplittableRandom(47); private int strlen = 7; // Default length public String() &#123;&#125; public String(int strLength) &#123; strlen = strLength; &#125; @Override public java.lang.String get() &#123; return r.ints(strlen, 'a', 'z' + 1) .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString(); &#125; public java.lang.String get(int n) &#123; return get(); &#125; public java.lang.String[] array(int sz) &#123; java.lang.String[] result = new java.lang.String[sz]; Arrays.setAll(result, n -&gt; get()); return result; &#125; &#125;&#125; 对于除了 int 、 long 和 double 之外的所有基本类型元素生成器，只生成数组，而不是 Count 中看到的完整操作集。这只是一个设计选择，因为本书不需要额外的功能。 下面是对所有 Rand 工具的测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189// arrays/TestRand.java// Test random generatorsimport java.util.*;import java.util.stream.*;import onjava.*;import static onjava.ArrayShow.*;public class TestRand &#123; static final int SZ = 5; public static void main(String[] args) &#123; System.out.println(\"Boolean\"); Boolean[] a1 = new Boolean[SZ]; Arrays.setAll(a1, new Rand.Boolean()::get); show(a1); a1 = Stream.generate(new Rand.Boolean()) .limit(SZ + 1).toArray(Boolean[]::new); show(a1); a1 = new Rand.Boolean().array(SZ + 2); show(a1); boolean[] a1b = new Rand.Pboolean().array(SZ + 3); show(a1b); System.out.println(\"Byte\"); Byte[] a2 = new Byte[SZ]; Arrays.setAll(a2, new Rand.Byte()::get); show(a2); a2 = Stream.generate(new Rand.Byte()) .limit(SZ + 1).toArray(Byte[]::new); show(a2); a2 = new Rand.Byte().array(SZ + 2); show(a2); byte[] a2b = new Rand.Pbyte().array(SZ + 3); show(a2b); System.out.println(\"Character\"); Character[] a3 = new Character[SZ]; Arrays.setAll(a3, new Rand.Character()::get); show(a3); a3 = Stream.generate(new Rand.Character()) .limit(SZ + 1).toArray(Character[]::new); show(a3); a3 = new Rand.Character().array(SZ + 2); show(a3); char[] a3b = new Rand.Pchar().array(SZ + 3); show(a3b); System.out.println(\"Short\"); Short[] a4 = new Short[SZ]; Arrays.setAll(a4, new Rand.Short()::get); show(a4); a4 = Stream.generate(new Rand.Short()) .limit(SZ + 1).toArray(Short[]::new); show(a4); a4 = new Rand.Short().array(SZ + 2); show(a4); short[] a4b = new Rand.Pshort().array(SZ + 3); show(a4b); System.out.println(\"Integer\"); int[] a5 = new int[SZ]; Arrays.setAll(a5, new Rand.Integer()::get); show(a5); Integer[] a5b = Stream.generate(new Rand.Integer()) .limit(SZ + 1).toArray(Integer[]::new); show(a5b); a5b = new Rand.Integer().array(SZ + 2); show(a5b); a5 = IntStream.generate(new Rand.Pint()) .limit(SZ + 1).toArray(); show(a5); a5 = new Rand.Pint().array(SZ + 3); show(a5); System.out.println(\"Long\"); long[] a6 = new long[SZ]; Arrays.setAll(a6, new Rand.Long()::get); show(a6); Long[] a6b = Stream.generate(new Rand.Long()) .limit(SZ + 1).toArray(Long[]::new); show(a6b); a6b = new Rand.Long().array(SZ + 2); show(a6b); a6 = LongStream.generate(new Rand.Plong()) .limit(SZ + 1).toArray(); show(a6); a6 = new Rand.Plong().array(SZ + 3); show(a6); System.out.println(\"Float\"); Float[] a7 = new Float[SZ]; Arrays.setAll(a7, new Rand.Float()::get); show(a7); a7 = Stream.generate(new Rand.Float()) .limit(SZ + 1).toArray(Float[]::new); show(a7); a7 = new Rand.Float().array(SZ + 2); show(a7); float[] a7b = new Rand.Pfloat().array(SZ + 3); show(a7b); System.out.println(\"Double\"); double[] a8 = new double[SZ]; Arrays.setAll(a8, new Rand.Double()::get); show(a8); Double[] a8b = Stream.generate(new Rand.Double()) .limit(SZ + 1).toArray(Double[]::new); show(a8b); a8b = new Rand.Double().array(SZ + 2); show(a8b); a8 = DoubleStream.generate(new Rand.Pdouble()) .limit(SZ + 1).toArray(); show(a8); a8 = new Rand.Pdouble().array(SZ + 3); show(a8); System.out.println(\"String\"); String[] s = new String[SZ - 1]; Arrays.setAll(s, new Rand.String()::get); show(s); s = Stream.generate(new Rand.String()) .limit(SZ).toArray(String[]::new); show(s); s = new Rand.String().array(SZ + 1); show(s); Arrays.setAll(s, new Rand.String(4)::get); show(s); s = Stream.generate(new Rand.String(4)) .limit(SZ).toArray(String[]::new); show(s); s = new Rand.String(4).array(SZ + 1); show(s); &#125;&#125;/* Output:Boolean[true, false, true, true, true][true, false, true, true, true, false][true, false, true, true, true, false, false][true, false, true, true, true, false, false, true]Byte[123, 33, 101, 112, 33][123, 33, 101, 112, 33, 31][123, 33, 101, 112, 33, 31, 0][123, 33, 101, 112, 33, 31, 0, -72]Character[b, t, p, e, n][b, t, p, e, n, p][b, t, p, e, n, p, c][b, t, p, e, n, p, c, c]Short[635, 8737, 3941, 4720, 6177][635, 8737, 3941, 4720, 6177, 8479][635, 8737, 3941, 4720, 6177, 8479, 6656][635, 8737, 3941, 4720, 6177, 8479, 6656, 3768]Integer[635, 8737, 3941, 4720, 6177][635, 8737, 3941, 4720, 6177, 8479][635, 8737, 3941, 4720, 6177, 8479, 6656][635, 8737, 3941, 4720, 6177, 8479][635, 8737, 3941, 4720, 6177, 8479, 6656, 3768]Long[6882, 3765, 692, 9575, 4439][6882, 3765, 692, 9575, 4439, 2638][6882, 3765, 692, 9575, 4439, 2638, 4011][6882, 3765, 692, 9575, 4439, 2638][6882, 3765, 692, 9575, 4439, 2638, 4011, 9610]Float[4.83, 2.89, 2.9, 1.97, 3.01][4.83, 2.89, 2.9, 1.97, 3.01, 0.18][4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99][4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99, 8.28]Double[4.83, 2.89, 2.9, 1.97, 3.01][4.83, 2.89, 2.9, 1.97, 3.01, 0.18][4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99][4.83, 2.89, 2.9, 1.97, 3.01, 0.18][4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99, 8.28]String[btpenpc, cuxszgv, gmeinne, eloztdv][btpenpc, cuxszgv, gmeinne, eloztdv, ewcippc][btpenpc, cuxszgv, gmeinne, eloztdv, ewcippc, ygpoalk][btpe, npcc, uxsz, gvgm, einn, eelo][btpe, npcc, uxsz, gvgm, einn][btpe, npcc, uxsz, gvgm, einn, eelo]*/ 注意（除了 String 部分之外），这段代码与 TestCount.java 中的代码相同，Count 被 Rand 替换。 泛型和基本数组在本章的前面，我们被提醒，泛型不能和基元一起工作。在这种情况下，我们必须从基元数组转换为包装类型的数组，并且还必须从另一个方向转换。下面是一个转换器可以同时对所有类型的数据执行操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// onjava/ConvertTo.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.package onjava;public interface ConvertTo &#123; static boolean[] primitive(Boolean[] in) &#123; boolean[] result = new boolean[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; // Autounboxing return result; &#125; static char[] primitive(Character[] in) &#123; char[] result = new char[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static byte[] primitive(Byte[] in) &#123; byte[] result = new byte[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static short[] primitive(Short[] in) &#123; short[] result = new short[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static int[] primitive(Integer[] in) &#123; int[] result = new int[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static long[] primitive(Long[] in) &#123; long[] result = new long[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static float[] primitive(Float[] in) &#123; float[] result = new float[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static double[] primitive(Double[] in) &#123; double[] result = new double[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; // Convert from primitive array to wrapped array: static Boolean[] boxed(boolean[] in) &#123; Boolean[] result = new Boolean[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; // Autoboxing return result; &#125; static Character[] boxed(char[] in) &#123; Character[] result = new Character[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static Byte[] boxed(byte[] in) &#123; Byte[] result = new Byte[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static Short[] boxed(short[] in) &#123; Short[] result = new Short[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static Integer[] boxed(int[] in) &#123; Integer[] result = new Integer[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static Long[] boxed(long[] in) &#123; Long[] result = new Long[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static Float[] boxed(float[] in) &#123; Float[] result = new Float[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125; static Double[] boxed(double[] in) &#123; Double[] result = new Double[in.length]; for(int i = 0; i &lt; in.length; i++) result[i] = in[i]; return result; &#125;&#125; primitive() 的每个版本都创建一个准确长度的适当基元数组，然后从包装类的 in 数组中复制元素。如果任何包装的数组元素是 null ，你将得到一个异常（这是合理的—否则无法选择有意义的值进行替换)。注意在这个任务中自动装箱如何发生。 下面是对 ConvertTo 中所有方法的测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// arrays/TestConvertTo.javaimport java.util.*;import onjava.*;import static onjava.ArrayShow.*;import static onjava.ConvertTo.*;public class TestConvertTo &#123; static final int SIZE = 6; public static void main(String[] args) &#123; Boolean[] a1 = new Boolean[SIZE]; Arrays.setAll(a1, new Rand.Boolean()::get); boolean[] a1p = primitive(a1); show(\"a1p\", a1p); Boolean[] a1b = boxed(a1p); show(\"a1b\", a1b); Byte[] a2 = new Byte[SIZE]; Arrays.setAll(a2, new Rand.Byte()::get); byte[] a2p = primitive(a2); show(\"a2p\", a2p); Byte[] a2b = boxed(a2p); show(\"a2b\", a2b); Character[] a3 = new Character[SIZE]; Arrays.setAll(a3, new Rand.Character()::get); char[] a3p = primitive(a3); show(\"a3p\", a3p); Character[] a3b = boxed(a3p); show(\"a3b\", a3b); Short[] a4 = new Short[SIZE]; Arrays.setAll(a4, new Rand.Short()::get); short[] a4p = primitive(a4); show(\"a4p\", a4p); Short[] a4b = boxed(a4p); show(\"a4b\", a4b); Integer[] a5 = new Integer[SIZE]; Arrays.setAll(a5, new Rand.Integer()::get); int[] a5p = primitive(a5); show(\"a5p\", a5p); Integer[] a5b = boxed(a5p); show(\"a5b\", a5b); Long[] a6 = new Long[SIZE]; Arrays.setAll(a6, new Rand.Long()::get); long[] a6p = primitive(a6); show(\"a6p\", a6p); Long[] a6b = boxed(a6p); show(\"a6b\", a6b); Float[] a7 = new Float[SIZE]; Arrays.setAll(a7, new Rand.Float()::get); float[] a7p = primitive(a7); show(\"a7p\", a7p); Float[] a7b = boxed(a7p); show(\"a7b\", a7b); Double[] a8 = new Double[SIZE]; Arrays.setAll(a8, new Rand.Double()::get); double[] a8p = primitive(a8); show(\"a8p\", a8p); Double[] a8b = boxed(a8p); show(\"a8b\", a8b); &#125;&#125;/* Output:a1p: [true, false, true, true, true, false]a1b: [true, false, true, true, true, false]a2p: [123, 33, 101, 112, 33, 31]a2b: [123, 33, 101, 112, 33, 31]a3p: [b, t, p, e, n, p]a3b: [b, t, p, e, n, p]a4p: [635, 8737, 3941, 4720, 6177, 8479]a4b: [635, 8737, 3941, 4720, 6177, 8479]a5p: [635, 8737, 3941, 4720, 6177, 8479]a5b: [635, 8737, 3941, 4720, 6177, 8479]a6p: [6882, 3765, 692, 9575, 4439, 2638]a6b: [6882, 3765, 692, 9575, 4439, 2638]a7p: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]a7b: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]a8p: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]a8b: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]*/ 在每种情况下，原始数组都是为包装类型创建的，并使用 Arrays.setAll() 填充，正如我们在 TestCouner.java 中所做的那样（这也验证了 Arrays.setAll() 是否能同 Integer ，Long ，和 Double ）。然后 ConvertTo.primitive() 将包装器数组转换为对应的基元数组，ConverTo.boxed() 将其转换回来。 数组元素修改传递给 Arrays.setAll() 的生成器函数可以使用它接收到的数组索引修改现有的数组元素: 12345678910111213141516171819202122// arrays/ModifyExisting.javaimport java.util.*;import onjava.*;import static onjava.ArrayShow.*;public class ModifyExisting &#123; public static void main(String[] args) &#123; double[] da = new double[7]; Arrays.setAll(da, new Rand.Double()::get); show(da); Arrays.setAll(da, n -&gt; da[n] / 100); // [1] show(da); &#125;&#125;/* Output:[4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99][0.0483, 0.028900000000000002, 0.028999999999999998,0.0197, 0.0301, 0.0018, 0.009899999999999999]*/ [1] Lambdas在这里特别有用，因为数组总是在lambda表达式的范围内。 数组并行我们很快就不得不面对并行的主题。例如，“并行”一词在许多Java库方法中使用。您可能听说过类似“并行程序运行得更快”这样的说法，这是有道理的—当您可以有多个处理器时，为什么只有一个处理器在您的程序上工作呢? 如果您认为您应该利用其中的“并行”，这是很容易被原谅的。要是这么简单就好了。不幸的是，通过采用这种方法，您可以很容易地编写比非并行版本运行速度更慢的代码。在你深刻理解所有的问题之前，并行编程看起来更像是一门艺术而非科学。以下是简短的版本:用简单的方法编写代码。不要开始处理并行性，除非它成为一个问题。您仍然会遇到并行性。在本章中，我们将介绍一些为并行执行而编写的Java库方法。因此，您必须对它有足够的了解，以便进行基本的讨论，并避免出现错误。 在阅读并发编程这一章之后，您将更深入地理解它(但是，唉，这还远远不够。只是这些的话，充分理解这个主题是不可能的)。在某些情况下，即使您只有一个处理器，无论您是否显式地尝试并行，并行实现是惟一的、最佳的或最符合逻辑的选择。它是一个可以一直使用的工具，所以您必须了解它的相关问题。 最好从数据的角度来考虑并行性。对于大量数据(以及可用的额外处理器)，并行可能会有所帮助。但您也可能使事情变得更糟。 在本书的其余部分，我们将遇到不同的情况: 1、所提供的惟一选项是并行的。这很简单，因为我们别无选择，只能使用它。这种情况是比较罕见的。 2、有多个选项，但是并行版本(通常是最新的版本)被设计成在任何地方都可以使用(甚至在那些不关心并行性的代码中)，如案例#1。我们将按预期使用并行版本。 3、案例1和案例2并不经常发生。相反，您将遇到某些算法的两个版本，一个用于并行使用，另一个用于正常使用。我将描述并行的一个，但不会在普通代码中使用它，因为它也许会产生所有可能的问题。 我建议您在自己的代码中采用这种方法。 [http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html](要进一步了解为什么这是一个难题，请参阅Doug Lea的文章。) parallelSetAll() 流式编程产生优雅的代码。例如，假设我们想要创建一个数值由从零开始填充的长数组： 123456789101112131415161718192021// arrays/CountUpward.javaimport java.util.stream.LongStream;public class CountUpward &#123; static long[] fillCounted(int size) &#123; return LongStream.iterate(0, i -&gt; i + 1).limit(size).toArray(); &#125; public static void main(String[] args) &#123; long[] l1 = fillCounted(20); // No problem show(l1); // On my machine, this runs out of heap space: // - long[] l2 = fillCounted(10_000_000); &#125;&#125;/* Output:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,16, 17, 18, 19]*/ 流 实际上可以存储到将近1000万，但是之后就会耗尽堆空间。常规的 setAll() 是有效的，但是如果我们能更快地处理如此大量的数字，那就更好了。我们可以使用 setAll() 初始化更大的数组。如果速度成为一个问题，Arrays.parallelSetAll() 将(可能)更快地执行初始化(请记住并行性中描述的问题)。 12345678910111213141516171819202122232425// arrays/ParallelSetAll.javaimport onjava.*;import java.util.Arrays;public class ParallelSetAll &#123; static final int SIZE = 10_000_000; static void intArray() &#123; int[] ia = new int[SIZE]; Arrays.setAll(ia, new Rand.Pint()::get); Arrays.parallelSetAll(ia, new Rand.Pint()::get); &#125; static void longArray() &#123; long[] la = new long[SIZE]; Arrays.setAll(la, new Rand.Plong()::get); Arrays.parallelSetAll(la, new Rand.Plong()::get); &#125; public static void main(String[] args) &#123; intArray(); longArray(); &#125;&#125; 数组分配和初始化是在单独的方法中执行的，因为如果两个数组都在 main() 中分配，它会耗尽内存(至少在我的机器上是这样。还有一些方法可以告诉Java在启动时分配更多的内存)。 Arrays工具类您已经看到了 java.util.Arrays 中的 fill() 和 setAll()/parallelSetAll() 。该类包含许多其他有用的 静态 程序方法，我们将对此进行研究。 概述: asList(): 获取任何序列或数组，并将其转换为一个 列表集合 （集合章节介绍了此方法）。 copyOf()：以新的长度创建现有数组的新副本。 copyOfRange()：创建现有数组的一部分的新副本。 equals()：比较两个数组是否相等。 deepEquals()：多维数组的相等性比较。 stream()：生成数组元素的流。 hashCode()：生成数组的哈希值(您将在附录中了解这意味着什么:理解equals()和hashCode())。 deepHashCode(): 多维数组的哈希值。 sort()：排序数组 parallelSort()：对数组进行并行排序，以提高速度。 binarySearch()：在已排序的数组中查找元素。 parallelPrefix()：使用提供的函数并行累积(以获得速度)。基本上，就是数组的reduce()。 spliterator()：从数组中产生一个Spliterator;这是本书没有涉及到的流的高级部分。 toString()：为数组生成一个字符串表示。你在整个章节中经常看到这种用法。 deepToString()：为多维数组生成一个字符串。你在整个章节中经常看到这种用法。对于所有基本类型和对象，所有这些方法都是重载的。 数组拷贝与使用for循环手工执行复制相比，copyOf() 和 copyOfRange() 复制数组要快得多。这些方法被重载以处理所有类型。 我们开始复制数组的整数和整数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// arrays/ArrayCopying.java// Demonstrate Arrays.copy() and Arrays.copyOf()import onjava.*;import java.util.Arrays;import static onjava.ArrayShow.*;class Sup &#123; // Superclass private int id; Sup(int n) &#123; id = n; &#125; @Override public String toString() &#123; return getClass().getSimpleName() + id; &#125;&#125;class Sub extends Sup &#123; // Subclass Sub(int n) &#123; super(n); &#125;&#125;public class ArrayCopying &#123; public static final int SZ = 15; public static void main(String[] args) &#123; int[] a1 = new int[SZ]; Arrays.setAll(a1, new Count.Integer()::get); show(\"a1\", a1); int[] a2 = Arrays.copyOf(a1, a1.length); // [1] // Prove they are distinct arrays: Arrays.fill(a1, 1); show(\"a1\", a1); show(\"a2\", a2); // Create a shorter result: a2 = Arrays.copyOf(a2, a2.length / 2); // [2] show(\"a2\", a2); // Allocate more space: a2 = Arrays.copyOf(a2, a2.length + 5); show(\"a2\", a2); // Also copies wrapped arrays: Integer[] a3 = new Integer[SZ]; // [3] Arrays.setAll(a3, new Count.Integer()::get); Integer[] a4 = Arrays.copyOfRange(a3, 4, 12); show(\"a4\", a4); Sub[] d = new Sub[SZ / 2]; Arrays.setAll(d, Sub::new); // Produce Sup[] from Sub[]: Sup[] b = Arrays.copyOf(d, d.length, Sup[].class); // [4] show(b); // This \"downcast\" works fine: Sub[] d2 = Arrays.copyOf(b, b.length, Sub[].class); // [5] show(d2); // Bad \"downcast\" compiles but throws exception: Sup[] b2 = new Sup[SZ / 2]; Arrays.setAll(b2, Sup::new); try &#123; Sub[] d3 = Arrays.copyOf(b2, b2.length, Sub[].class); // [6] &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125;&#125;/* Output: a1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] a1: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] a2:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]a2:[0, 1, 2, 3, 4, 5, 6]a2:[ 0, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0]a4:[4, 5, 6, 7, 8, 9, 10, 11][Sub0, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6][ Sub0, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6]java.lang.ArrayStoreException */ [1] 这是复制的基本方法;只需给出返回的复制数组的大小。这对于编写需要调整存储大小的算法很有帮助。复制之后，我们把a1的所有元素都设为1，以证明a1的变化不会影响a2中的任何东西。 [2] 通过更改最后一个参数，我们可以缩短或延长返回的复制数组。 [3] copyOf() 和 copyOfRange() 也可以使用包装类型。copyOfRange() 需要一个开始和结束索引。 [4] copyOf() 和 copyOfRange() 都有一个版本，该版本通过在方法调用的末尾添加目标类型来创建不同类型的数组。我首先想到的是，这可能是一种从原生数组生成包装数组的方法，反之亦然。但这没用。它的实际用途是“向上转换”和“向下转换”数组。也就是说，如果您有一个子类型(派生类型)的数组，而您想要一个基类型的数组，那么这些方法将生成所需的数组。 [5] 您甚至可以成功地“向下强制转换”，并从超类型的数组生成子类型的数组。这个版本运行良好，因为我们只是“upcast”。 [6] 这个“数组转换”将编译，但是如果类型不兼容，您将得到一个运行时异常。在这里，强制将基类型转换为派生类型是非法的，因为派生对象中可能有基对象中没有的属性和方法。 实例表明，原生数组和对象数组都可以被复制。但是，如果复制对象的数组，那么只复制引用—不复制对象本身。这称为浅拷贝(有关更多细节，请参阅附录:传递和返回对象)。 还有一个方法 System.arraycopy() ，它将一个数组复制到另一个已经分配的数组中。这将不会执行自动装箱或自动卸载—两个数组必须是完全相同的类型。 数组比较数组 提供了 equals() 来比较一维数组，以及 deepEquals() 来比较多维数组。对于所有原生类型和对象，这些方法都是重载的。 数组相等的含义：数组必须有相同数量的元素，并且每个元素必须与另一个数组中的对应元素相等，对每个元素使用 equals()(对于原生类型，使用原生类型的包装类的 equals() 方法;例如，int的Integer.equals()。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// arrays/ComparingArrays.java// Using Arrays.equals()import java.util.*;import onjava.*;public class ComparingArrays &#123; public static final int SZ = 15; static String[][] twoDArray() &#123; String[][] md = new String[5][]; Arrays.setAll(md, n -&gt; new String[n]); for (int i = 0; i &lt; md.length; i++) Arrays.setAll(md[i], new Rand.String()::get); return md; &#125; public static void main(String[] args) &#123; int[] a1 = new int[SZ], a2 = new int[SZ]; Arrays.setAll(a1, new Count.Integer()::get); Arrays.setAll(a2, new Count.Integer()::get); System.out.println(\"a1 == a2: \" + Arrays.equals(a1, a2)); a2[3] = 11; System.out.println(\"a1 == a2: \" + Arrays.equals(a1, a2)); Integer[] a1w = new Integer[SZ], a2w = new Integer[SZ]; Arrays.setAll(a1w, new Count.Integer()::get); Arrays.setAll(a2w, new Count.Integer()::get); System.out.println(\"a1w == a2w: \" + Arrays.equals(a1w, a2w)); a2w[3] = 11; System.out.println(\"a1w == a2w: \" + Arrays.equals(a1w, a2w)); String[][] md1 = twoDArray(), md2 = twoDArray(); System.out.println(Arrays.deepToString(md1)); System.out.println(\"deepEquals(md1, md2): \" + Arrays.deepEquals(md1, md2)); System.out.println(\"md1 == md2: \" + Arrays.equals(md1, md2)); md1[4][1] = \"#$#$#$#\"; System.out.println(Arrays.deepToString(md1)); System.out.println(\"deepEquals(md1, md2): \" + Arrays.deepEquals(md1, md2)); &#125;&#125;/* Output:a1 == a2: truea1 == a2: falsea1w == a2w: truea1w == a2w: false[[], [btpenpc], [btpenpc, cuxszgv], [btpenpc, cuxszgv, gmeinne], [btpenpc, cuxszgv, gmeinne, eloztdv]] deepEquals(md1, md2): true md1 == md2: false [[], [btpenpc], [btpenpc, cuxszgv], [btpenpc, cuxszgv, gmeinne], [btpenpc, #$#$#$#, gmeinne, eloztdv]] deepEquals(md1, md2): false */ 最初，a1和a2是完全相等的，所以输出是true，但是之后其中一个元素改变了，这使得结果为false。a1w和a2w是对一个封装类型数组重复该练习。 md1 和 md2 是通过 twoDArray() 以相同方式初始化的多维字符串数组。注意，deepEquals() 返回 true，因为它执行了适当的比较，而普通的 equals() 错误地返回 false。如果我们更改数组中的一个元素，deepEquals() 将检测它。 流和数组stream() 方法很容易从某些类型的数组中生成元素流。 1234567891011121314151617181920212223242526272829303132333435363738// arrays/StreamFromArray.javaimport java.util.*;import onjava.*;public class StreamFromArray &#123; public static void main(String[] args) &#123; String[] s = new Rand.String().array(10); Arrays.stream(s).skip(3).limit(5).map(ss -&gt; ss + \"!\").forEach(System.out::println); int[] ia = new Rand.Pint().array(10); Arrays.stream(ia).skip(3).limit(5) .map(i -&gt; i * 10).forEach(System.out::println); Arrays.stream(new long[10]); Arrays.stream(new double[10]); // Only int, long and double work: // - Arrays.stream(new boolean[10]); // - Arrays.stream(new byte[10]); // - Arrays.stream(new char[10]); // - Arrays.stream(new short[10]); // - Arrays.stream(new float[10]); // For the other types you must use wrapped arrays: float[] fa = new Rand.Pfloat().array(10); Arrays.stream(ConvertTo.boxed(fa)); Arrays.stream(new Rand.Float().array(10)); &#125;&#125;/* Output: eloztdv! ewcippc! ygpoalk! ljlbynx! taprwxz! 47200 61770 84790 66560 37680*/ 只有“原生类型” int、long 和 double 可以与 Arrays.stream() 一起使用;对于其他的，您必须以某种方式获得一个包装类型的数组。 通常，将数组转换为流来生成所需的结果要比直接操作数组容易得多。请注意，即使流已经“用完”(您不能重复使用它)，您仍然拥有该数组，因此您可以以其他方式使用它—-包括生成另一个流。 数组排序根据对象的实际类型执行比较排序。一种方法是为不同的类型编写对应的排序方法，但是这样的代码不能复用。 编程设计的一个主要目标是“将易变的元素与稳定的元素分开”，在这里，保持不变的代码是一般的排序算法，但是变化的是对象的比较方式。因此，使用策略设计模式而不是将比较代码放入许多不同的排序源码中。使用策略模式时，变化的代码部分被封装在一个单独的类(策略对象)中。 您将一个策略对象交给相同的代码，该代码使用策略模式来实现其算法。通过这种方式，您将使用相同的排序代码，使不同的对象表达不同的比较方式。 Java有两种方式提供比较功能。第一种方法是通过实现 java.lang.Comparable 接口的原生方法。这是一个简单的接口，只含有一个方法 compareTo()。该方法接受另一个与参数类型相同的对象作为参数，如果当前对象小于参数，则产生一个负值;如果参数相等，则产生零值;如果当前对象大于参数，则产生一个正值。 这里有一个类，它实现了 Comparable 接口并演示了可比性，而且使用Java标准库方法 Arrays.sort(): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// arrays/CompType.java// Implementing Comparable in a classimport onjava.*;import java.util.Arrays;import java.util.SplittableRandom;import static onjava.ArrayShow.*;public class CompType implements Comparable&lt;CompType&gt; &#123; private static int count = 1; private static SplittableRandom r = new SplittableRandom(47); int i; int j; public CompType(int n1, int n2) &#123; i = n1; j = n2; &#125; public static CompType get() &#123; return new CompType(r.nextInt(100), r.nextInt(100)); &#125; public static void main(String[] args) &#123; CompType[] a = new CompType[12]; Arrays.setAll(a, n -&gt; get()); show(\"Before sorting\", a); Arrays.sort(a); show(\"After sorting\", a); &#125; @Override public String toString() &#123; String result = \"[i = \" + i + \", j = \" + j + \"]\"; if (count++ % 3 == 0) result += \"\\n\"; return result; &#125; @Override public int compareTo(CompType rv) &#123; return (i &lt; rv.i ? -1 : (i == rv.i ? 0 : 1)); &#125;&#125;/* Output:Before sorting: [[i = 35, j = 37], [i = 41, j = 20], [i = 77, j = 79] , [i = 56, j = 68], [i = 48, j = 93], [i = 70, j = 7] , [i = 0, j = 25], [i = 62, j = 34], [i = 50, j = 82] , [i = 31, j = 67], [i = 66, j = 54], [i = 21, j = 6] ]After sorting: [[i = 0, j = 25], [i = 21, j = 6], [i = 31, j = 67] , [i = 35, j = 37], [i = 41, j = 20], [i = 48, j = 93] , [i = 50, j = 82], [i = 56, j = 68], [i = 62, j = 34] , [i = 66, j = 54], [i = 70, j = 7], [i = 77, j = 79] ]*/ 当您定义比较方法时，您有责任决定将一个对象与另一个对象进行比较意味着什么。这里，在比较中只使用i值和j值将被忽略。 get() 方法通过使用随机值初始化CompType对象来构建它们。在 main() 中，get() 与 Arrays.setAll() 一起使用，以填充一个 CompType类型 数组，然后对其排序。如果没有实现 Comparable接口，那么当您试图调用 sort() 时，您将在运行时获得一个 ClassCastException 。这是因为 sort() 将其参数转换为 Comparable类型。 现在假设有人给了你一个没有实现 Comparable接口 的类，或者给了你一个实现 Comparable接口 的类，但是你不喜欢它的工作方式而愿意有一个不同的对于此类型的比较方法。为了解决这个问题，创建一个实现 Comparator 接口的单独的类(在集合一章中简要介绍)。它有两个方法，compare() 和 equals()。但是，除了特殊的性能需求外，您不需要实现 equals()，因为无论何时创建一个类，它都是隐式地继承自 Object，Object 有一个equals()。您可以只使用默认的 Object equals() 来满足接口的规范。 集合类(注意复数;我们将在下一章节讨论它) 包含一个方法 reverseOrder()，它生成一个来 Comparator（比较器）反转自然排序顺序。这可以应用到比较对象： 123456789101112131415161718192021222324252627282930313233// arrays/Reverse.java// The Collections.reverseOrder() Comparatorimport onjava.*;import java.util.Arrays;import java.util.Collections;import static onjava.ArrayShow.*;public class Reverse &#123; public static void main(String[] args) &#123; CompType[] a = new CompType[12]; Arrays.setAll(a, n -&gt; CompType.get()); show(\"Before sorting\", a); Arrays.sort(a, Collections.reverseOrder()); show(\"After sorting\", a); &#125;&#125;/* Output:Before sorting: [[i = 35, j = 37], [i = 41, j = 20], [i = 77, j = 79] , [i = 56, j = 68], [i = 48, j = 93], [i = 70, j = 7], [i = 0, j = 25], [i = 62, j = 34], [i = 50, j = 82] , [i = 31, j = 67], [i = 66, j = 54], [i = 21, j = 6] ]After sorting: [[i = 77, j = 79], [i = 70, j = 7], [i = 66, j = 54] , [i = 62, j = 34], [i = 56, j = 68], [i = 50, j = 82] , [i = 48, j = 93], [i = 41, j = 20], [i = 35, j = 37] , [i = 31, j = 67], [i = 21, j = 6], [i = 0, j = 25] ]*/ 您还可以编写自己的比较器。这个比较CompType对象基于它们的j值而不是它们的i值: 1234567891011121314151617181920212223242526272829303132333435// arrays/ComparatorTest.java// Implementing a Comparator for a classimport onjava.*;import java.util.Arrays;import java.util.Comparator;import static onjava.ArrayShow.*;class CompTypeComparator implements Comparator&lt;CompType&gt; &#123; public int compare(CompType o1, CompType o2) &#123; return (o1.j &lt; o2.j ? -1 : (o1.j == o2.j ? 0 : 1)); &#125;&#125;public class ComparatorTest &#123; public static void main(String[] args) &#123; CompType[] a = new CompType[12]; Arrays.setAll(a, n -&gt; CompType.get()); show(\"Before sorting\", a); Arrays.sort(a, new CompTypeComparator()); show(\"After sorting\", a); &#125;&#125;/* Output:Before sorting:[[i = 35, j = 37], [i = 41, j = 20], [i = 77, j = 79] , [i = 56, j = 68], [i = 48, j = 93], [i = 70, j = 7] , [i = 0, j = 25], [i = 62, j = 34], [i = 50, j = 82], [i = 31, j = 67], [i = 66, j = 54], [i = 21, j = 6] ]After sorting: [[i = 21, j = 6], [i = 70, j = 7], [i = 41, j = 20] , [i = 0, j = 25], [i = 62, j = 34], [i = 35, j = 37] , [i = 66, j = 54], [i = 31, j = 67], [i = 56, j = 68] , [i = 77, j = 79], [i = 50, j = 82], [i = 48, j = 93] ]*/ Arrays.sort()的使用使用内置的排序方法，您可以对实现了 Comparable 接口或具有 Comparator 的任何对象数组 或 任何原生数组进行排序。这里我们生成一个随机字符串对象数组并对其排序: 12345678910111213141516171819202122232425262728293031323334353637383940414243// arrays/StringSorting.java// Sorting an array of Stringsimport onjava.*;import java.util.Arrays;import java.util.Collections;import static onjava.ArrayShow.*;public class StringSorting &#123; public static void main(String[] args) &#123; String[] sa = new Rand.String().array(20); show(\"Before sort\", sa); Arrays.sort(sa); show(\"After sort\", sa); Arrays.sort(sa, Collections.reverseOrder()); show(\"Reverse sort\", sa); Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER); show(\"Case-insensitive sort\", sa); &#125;&#125;/* Output:Before sort: [btpenpc, cuxszgv, gmeinne, eloztdv, ewcippc, ygpoalk, ljlbynx, taprwxz, bhmupju, cjwzmmr, anmkkyh, fcjpthl, skddcat, jbvlgwc, mvducuj, ydpulcq, zehpfmm, zrxmclh, qgekgly, hyoubzl]After sort: [anmkkyh, bhmupju, btpenpc, cjwzmmr, cuxszgv, eloztdv, ewcippc, fcjpthl, gmeinne, hyoubzl, jbvlgwc, ljlbynx, mvducuj, qgekgly, skddcat, taprwxz, ydpulcq, ygpoalk, zehpfmm, zrxmclh]Reverse sort: [zrxmclh, zehpfmm, ygpoalk, ydpulcq,taprwxz, skddcat, qgekgly, mvducuj, ljlbynx, jbvlgwc, hyoubzl, gmeinne, fcjpthl, ewcippc, eloztdv, cuxszgv, cjwzmmr, btpenpc, bhmupju, anmkkyh]Case-insensitive sort: [anmkkyh, bhmupju, btpenpc, cjwzmmr, cuxszgv, eloztdv, ewcippc, fcjpthl, gmeinne, hyoubzl, jbvlgwc, ljlbynx, mvducuj, qgekgly, skddcat, taprwxz, ydpulcq, ygpoalk, zehpfmm, zrxmclh]*/ 注意字符串排序算法中的输出。它是字典式的，所以它把所有以大写字母开头的单词放在前面，然后是所有以小写字母开头的单词。(电话簿通常是这样分类的。)无论大小写，要将单词组合在一起，请使用 String.CASE_INSENSITIVE_ORDER ，如对sort()的最后一次调用所示。 Java标准库中使用的排序算法被设计为最适合您正在排序的类型—-原生类型的快速排序和对象的归并排序。 并行排序如果排序性能是一个问题，那么可以使用 Java 8 parallelSort()，它为所有不可预见的情况(包括数组的排序区域或使用了比较器)提供了重载版本。为了查看相比于普通的sort(), parallelSort() 的优点，我们使用了用来验证代码时的 JMH： 123456789101112131415161718192021222324252627// arrays/jmh/ParallelSort.javapackage arrays.jmh;import onjava.*;import org.openjdk.jmh.annotations.*;import java.util.Arrays;@State(Scope.Thread)public class ParallelSort &#123; private long[] la; @Setup public void setup() &#123; la = new Rand.Plong().array(100_000); &#125; @Benchmark public void sort() &#123; Arrays.sort(la); &#125; @Benchmark public void parallelSort() &#123; Arrays.parallelSort(la); &#125;&#125; parallelSort() 算法将大数组拆分成更小的数组，直到数组大小达到极限，然后使用普通的 Arrays .sort() 方法。然后合并结果。该算法需要不大于原始数组的额外工作空间。 您可能会看到不同的结果，但是在我的机器上，并行排序将速度提高了大约3倍。由于并行版本使用起来很简单，所以很容易考虑在任何地方使用它，而不是Arrays.sort ()。当然，它可能不是那么简单—看看微基准测试。 binarySearch二分查找一旦数组被排序，您就可以通过使用 Arrays.binarySearch() 来执行对特定项的快速搜索。但是，如果尝试在未排序的数组上使用 binarySearch()，结果是不可预测的。下面的示例使用 Rand.Pint 类来创建一个填充随机整形值的数组，然后调用 getAsInt() (因为 Rand.Pint 是一个 IntSupplier)来产生搜索值: 12345678910111213141516171819202122232425262728293031// arrays/ArraySearching.java// Using Arrays.binarySearch()import onjava.*;import java.util.Arrays;import static onjava.ArrayShow.*;public class ArraySearching &#123; public static void main(String[] args) &#123; Rand.Pint rand = new Rand.Pint(); int[] a = new Rand.Pint().array(25); Arrays.sort(a); show(\"Sorted array\", a); while (true) &#123; int r = rand.getAsInt(); int location = Arrays.binarySearch(a, r); if (location &gt;= 0) &#123; System.out.println(\"Location of \" + r + \" is \" + location + \", a[\" + location + \"] is \" + a[location]); break; // Out of while loop &#125; &#125; &#125;&#125;/* Output:Sorted array: [125, 267, 635, 650, 1131, 1506, 1634, 2400, 2766, 3063, 3768, 3941, 4720, 4762, 4948, 5070, 5682, 5807, 6177, 6193, 6656, 7021, 8479, 8737, 9954]Location of 635 is 2, a[2] is 635*/ 在while循环中，随机值作为搜索项生成，直到在数组中找到其中一个为止。 如果找到了搜索项，Arrays.binarySearch() 将生成一个大于或等于零的值。否则，它将产生一个负值，表示如果手动维护已排序的数组，则应该插入元素的位置。产生的值是 -(插入点) - 1 。插入点是大于键的第一个元素的索引，如果数组中的所有元素都小于指定的键，则是 a.size() 。 如果数组包含重复的元素，则无法保证找到其中的那些重复项。搜索算法不是为了支持重复的元素，而是为了容忍它们。如果需要没有重复元素的排序列表，可以使用 TreeSet (用于维持排序顺序)或 LinkedHashSet (用于维持插入顺序)。这些类自动为您处理所有的细节。只有在出现性能瓶颈的情况下，才应该使用手工维护的数组替换这些类中的一个。 如果使用比较器(原语数组不允许使用比较器进行排序)对对象数组进行排序，那么在执行 binarySearch() (使用重载版本的binarySearch())时必须包含相同的比较器。例如，可以修改 StringSorting.java 来执行搜索: 1234567891011121314151617181920212223242526// arrays/AlphabeticSearch.java// Searching with a Comparatorimport onjava.*;import java.util.Arrays;import static onjava.ArrayShow.*;public class AlphabeticSearch &#123; public static void main(String[] args) &#123; String[] sa = new Rand.String().array(30); Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER); show(sa); int index = Arrays.binarySearch(sa, sa[10], String.CASE_INSENSITIVE_ORDER); System.out.println(\"Index: \" + index + \"\\n\" + sa[index]); &#125;&#125;/* Output:[anmkkyh, bhmupju, btpenpc, cjwzmmr, cuxszgv, eloztdv, ewcippc,ezdeklu, fcjpthl, fqmlgsh, gmeinne, hyoubzl, jbvlgwc, jlxpqds,ljlbynx, mvducuj, qgekgly, skddcat, taprwxz, uybypgp, vjsszkn,vniyapk, vqqakbm, vwodhcf, ydpulcq, ygpoalk, yskvett, zehpfmm,zofmmvm, zrxmclh]Index: 10 gmeinne*/ 比较器必须作为第三个参数传递给重载的 binarySearch() 。在本例中，成功是有保证的，因为搜索项是从数组本身中选择的。 parallelPrefix并行前缀没有“prefix()”方法，只有 parallelPrefix()。这类似于 Stream 类中的 reduce() 方法:它对前一个元素和当前元素执行一个操作，并将结果放入当前元素位置: 123456789101112131415161718192021222324// arrays/ParallelPrefix1.javaimport onjava.*;import java.util.Arrays;import static onjava.ArrayShow.*;public class ParallelPrefix1 &#123; public static void main(String[] args) &#123; int[] nums = new Count.Pint().array(10); show(nums); System.out.println(Arrays.stream(nums).reduce(Integer::sum).getAsInt()); Arrays.parallelPrefix(nums, Integer::sum); show(nums); System.out.println(Arrays.stream(new Count.Pint().array(6)).reduce(Integer::sum).getAsInt()); &#125;&#125;/* Output:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]45[0, 1, 3, 6, 10, 15, 21, 28, 36, 45]15*/ 这里我们对数组应用Integer::sum。在位置0中，它将先前计算的值(因为没有先前的值)与原始数组位置0中的值组合在一起。在位置1中，它获取之前计算的值(它只是存储在位置0中)，并将其与位置1中先前计算的值相结合。依次往复。 使用 Stream.reduce()，您只能得到最终结果，而使用 Arrays.parallelPrefix()，您还可以得到所有中间计算，以确保它们是有用的。注意，第二个 Stream.reduce() 计算的结果已经在 parallelPrefix() 计算的数组中。 使用字符串可能更清楚: 1234567891011121314151617181920// arrays/ParallelPrefix2.javaimport onjava.*;import java.util.Arrays;import static onjava.ArrayShow.*;public class ParallelPrefix2 &#123; public static void main(String[] args) &#123; String[] strings = new Rand.String(1).array(8); show(strings); Arrays.parallelPrefix(strings, (a, b) -&gt; a + b); show(strings); &#125;&#125;/* Output:[b, t, p, e, n, p, c, c][b, bt, btp, btpe, btpen, btpenp, btpenpc, btpenpcc]*/ 如前所述，使用流进行初始化非常优雅，但是对于大型数组，这种方法可能会耗尽堆空间。使用 setAll() 执行初始化更节省内存: 12345678910111213141516171819202122// arrays/ParallelPrefix3.java// &#123;ExcludeFromTravisCI&#125;import java.util.Arrays;public class ParallelPrefix3 &#123; static final int SIZE = 10_000_000; public static void main(String[] args) &#123; long[] nums = new long[SIZE]; Arrays.setAll(nums, n -&gt; n); Arrays.parallelPrefix(nums, Long::sum); System.out.println(\"First 20: \" + nums[19]); System.out.println(\"First 200: \" + nums[199]); System.out.println(\"All: \" + nums[nums.length - 1]); &#125;&#125;/* Output:First 20: 190First 200: 19900All: 49999995000000*/ 因为正确使用 parallelPrefix() 可能相当复杂，所以通常应该只在存在内存或速度问题(或两者都有)时使用。否则，Stream.reduce() 应该是您的首选。 本章小结Java为固定大小的低级数组提供了合理的支持。这种数组强调的是性能而不是灵活性，就像C和c++数组模型一样。在Java的最初版本中，固定大小的低级数组是绝对必要的，这不仅是因为Java设计人员选择包含原生类型(也考虑到性能)，还因为那个版本对集合的支持非常少。因此，在早期的Java版本中，选择数组总是合理的。 在Java的后续版本中，集合支持得到了显著的改进，现在集合在除性能外的所有方面都优于数组，即使这样，集合的性能也得到了显著的改进。正如本书其他部分所述，无论如何，性能问题通常不会出现在您设想的地方。 使用自动装箱和泛型，在集合中保存原生类型是毫不费力的，这进一步鼓励您用集合替换低级数组。由于泛型产生类型安全的集合，数组在这方面也不再有优势。 如本章所述，当您尝试使用泛型时，您将看到泛型对数组是相当不友好的。通常，即使可以让泛型和数组以某种形式一起工作(在下一章中您将看到)，在编译期间仍然会出现“unchecked”警告。 有几次，当我们讨论特定的例子时，我直接从Java语言设计人员那里听到我应该使用集合而不是数组(我使用数组来演示特定的技术，所以我没有这个选项)。 所有这些问题都表明，在使用Java的最新版本进行编程时，应该“优先选择集合而不是数组”。只有当您证明性能是一个问题(并且切换到一个数组实际上会有很大的不同)时，才应该重构到数组。这是一个相当大胆的声明，但是有些语言根本没有固定大小的低级数组。它们只有可调整大小的集合，而且比C/C++/java风格的数组功能多得多。例如，Python有一个使用基本数组语法的列表类型，但是具有更大的功能—您甚至可以从它继承: 123456789101112131415161718192021222324252627282930# arrays/PythonLists.pyaList=[1,2,3,4,5]print(type(aList)) #&lt;type 'list'&gt;print(aList) # [1,2,3,4,5] print(aList[4]) # 5Basic list indexing aList.append(6) # lists can be resized aList+=[7,8] # Add a list to a list print(aList) # [1,2,3,4,5,6,7,8] aSlice=aList[2:4] print(aSlice) # [3,4]class MyList(list): # Inherit from list # Define a method;'this'pointer is explicit: def getReversed(self): reversed=self[:] # Copy list using slices reversed.reverse() # Built-in list method return reversed # No'new'necessary for object creation: list2=MyList(aList) print(type(list2)) #&lt;class '__main__.MyList'&gt; print(list2.getReversed()) # [8,7,6,5,4,3,2,1] output=\"\"\" &lt;class 'list'&gt; [1, 2, 3, 4, 5] 5 [1, 2, 3, 4, 5, 6, 7, 8] [3, 4] &lt;class '__main__.MyList'&gt; [8, 7, 6, 5, 4, 3, 2, 1] \"\"\" 前一章介绍了基本的Python语法。在这里，通过用方括号包围以逗号分隔的对象序列来创建列表。结果是一个运行时类型为list的对象(print语句的输出显示为同一行中的注释)。打印列表的结果与在Java中使用Arrays.toString()的结果相同。通过将 : 操作符放在索引操作中，通过切片来创建列表的子序列。list类型有更多的内置操作，通常只需要序列类型。MyList是一个类定义;基类放在括号内。在类内部，def语句生成方法，该方法的第一个参数在Java中自动与之等价，除了在Python中它是显式的，而且标识符self是按约定使用的(它不是关键字)。注意构造函数是如何自动继承的。 虽然一切在Python中真的是一个对象(包括整数和浮点类型),你仍然有一个安全门,因为你可以优化性能关键型的部分代码编写扩展的C, c++或使用特殊的工具设计容易加速您的Python代码(有很多)。通过这种方式，可以在不影响性能改进的情况下保持对象的纯度。 PHP甚至更进一步，它只有一个数组类型，既充当int索引数组，又充当关联数组(Map)。 在经历了这么多年的Java发展之后，我们可以很有趣地推测，如果重新开始，设计人员是否会将原生类型和低级数组放在该语言中(同样在JVM上运行的Scala语言不包括这些)。如果不考虑这些，就有可能开发出一种真正纯粹的面向对象语言(尽管有这样的说法，Java并不是一种纯粹的面向对象语言，这正是因为它的底层缺陷)。关于效率的最初争论总是令人信服的，但是随着时间的推移，我们已经看到了从这个想法向更高层次的组件(如集合)的演进。此外，如果集合可以像在某些语言中一样构建到核心语言中，那么编译器就有更好的机会进行优化。 撇开““Green-fields”的推测不谈，我们肯定会被数组所困扰，当你阅读代码时就会看到它们。然而，集合几乎总是更好的选择。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"OnJava8-2","slug":"java-note/OnJava8/OnJava8-2","date":"2019-10-13T14:19:09.000Z","updated":"2021-10-23T02:19:02.847Z","comments":true,"path":"2019/10/java-note/OnJava8/OnJava8-2/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/OnJava8/OnJava8-2/","excerpt":"[TOC]第十六章 代码校验 你永远不能保证你的代码是正确的，你只能证明它是错的。 测试 如果没有测试过，它就是不能工作的。 单元测试这个过程是将集成测试构建到你创建的所有代码中，并在每次构建系统时运行这些测试。这样，构建过程不仅能检查语法的错误，同时也能检查语义的错误。“单元”是指测试一小部分代码 。通常，每个类都有测试来检查它所有方法的行为。“系统”测试则是不同的，它检查的是整个程序是否满足要求。","text":"[TOC]第十六章 代码校验 你永远不能保证你的代码是正确的，你只能证明它是错的。 测试 如果没有测试过，它就是不能工作的。 单元测试这个过程是将集成测试构建到你创建的所有代码中，并在每次构建系统时运行这些测试。这样，构建过程不仅能检查语法的错误，同时也能检查语义的错误。“单元”是指测试一小部分代码 。通常，每个类都有测试来检查它所有方法的行为。“系统”测试则是不同的，它检查的是整个程序是否满足要求。 C 风格的语言，尤其是 C++，通常会认为性能比安全更重要。用 Java 编程比 C++（一般认为大概快两倍）快的原因是 Java 的安全性保障：比如垃圾回收以及改良的类型检测等特性。通过将单元测试集成到构建过程中，你扩大了这个安全保障，因而有了更快的开发效率。当发现设计或实现的缺陷时，可以更容易、更大胆地重构你的代码。 JUnit官网 反射和注解得到了极大的改进,增加了对 lambdas 表达式的支持 在 JUnit 最简单的使用中，使用 @Test 注解标记表示测试的每个方法。JUnit 将这些方法标识为单独的测试，并一次设置和运行一个测试，采取措施避免测试之间的副作用。 @BeforeAll 注解是在任何其他测试操作之前运行一次的方法。 @AfterAll 是所有其他测试操作之后只运行一次的方法。两个方法都必须是静态的。 @BeforeEach注解是通常用于创建和初始化公共对象的方法，并在每次测试前运行。可以将所有这样的初始化放在测试类的构造函数中，尽管我认为 @BeforeEach 更加清晰。JUnit为每个测试创建一个对象，确保测试运行之间没有副作用。然而，所有测试的所有对象都是同时创建的(而不是在测试之前创建对象)，所以使用 @BeforeEach 和构造函数之间的唯一区别是 @BeforeEach 在测试前直接调用。在大多数情况下，这不是问题，如果你愿意，可以使用构造函数方法。 如果你必须在每次测试后执行清理（如果修改了需要恢复的静态文件，打开文件需要关闭，打开数据库或者网络连接，etc），那就用注解 @AfterEach。 JUnit 使用 @Test 注解发现这些方法，并将每个方法作为测试运行。在方法内部，你可以执行任何所需的操作并使用 JUnit 断言方法（以”assert”开头）验证测试的正确性（更全面的”assert”说明可以在 Junit 文档里找到）。如果断言失败，将显示导致失败的表达式和值。这通常就足够了，但是你也可以使用每个 JUnit 断言语句的重载版本，它包含一个字符串，以便在断言失败时显示。 断言语句不是必须的；你可以在没有断言的情况下运行测试，如果没有异常，则认为测试是成功的。 只要没有 @Test 注解，JUnit 就不会运行它，也不需要特定的签名。 JUnit 还包括大量的测试结构，你可以到官网上学习它们。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// validating/tests/CountedListTest.java// Simple use of JUnit to test CountedList.package validating;import java.util.*;import org.junit.jupiter.api.*;import static org.junit.jupiter.api.Assertions.*;public class CountedListTest &#123;private CountedList list; @BeforeAll static void beforeAllMsg() &#123; System.out.println(\"&gt;&gt;&gt; Starting CountedListTest\"); &#125; @AfterAll static void afterAllMsg() &#123; System.out.println(\"&gt;&gt;&gt; Finished CountedListTest\"); &#125; @BeforeEach public void initialize() &#123; list = new CountedList(); System.out.println(\"Set up for \" + list.getId()); for(int i = 0; i &lt; 3; i++) list.add(Integer.toString(i)); &#125; @AfterEach public void cleanup() &#123; System.out.println(\"Cleaning up \" + list.getId()); &#125; @Test public void insert() &#123; System.out.println(\"Running testInsert()\"); assertEquals(list.size(), 3); list.add(1, \"Insert\"); assertEquals(list.size(), 4); assertEquals(list.get(1), \"Insert\"); &#125; @Test public void replace() &#123; System.out.println(\"Running testReplace()\"); assertEquals(list.size(), 3); list.set(1, \"Replace\"); assertEquals(list.size(), 3); assertEquals(list.get(1), \"Replace\"); &#125; // A helper method to simplify the code. As // long as it's not annotated with @Test, it will // not be automatically executed by JUnit. private void compare(List&lt;String&gt; lst, String[] strs) &#123; assertArrayEquals(lst.toArray(new String[0]), strs); &#125;&#125; 测试覆盖率的幻觉测试覆盖率，同样也称为代码覆盖率，度量代码的测试百分比。百分比越高，测试的覆盖率越大。这里有很多方法 计算覆盖率，还有有帮助的文章Java代码覆盖工具。 对于没有知识但处于控制地位的人来说，很容易在没有任何了解的情况下也有概念认为 100% 的测试覆盖是唯一可接受的值。这有一个问题，因为 100% 并不意味着是对测试有效性的良好测量。你可以测试所有需要它的东西，但是只需要 65% 的覆盖率。如果需要 100% 的覆盖，你将浪费大量时间来生成剩余的代码，并且在向项目添加代码时浪费的时间更多。 当分析一个未知的代码库时，测试覆盖率作为一个粗略的度量是有用的。如果覆盖率工具报告的值特别低（比如，少于百分之40），则说明覆盖不够充分。然而，一个非常高的值也同样值得怀疑，这表明对编程领域了解不足的人迫使团队做出了武断的决定。覆盖工具的最佳用途是发现代码库中未测试的部分。但是，不要依赖覆盖率来得到测试质量的任何信息。 前置条件前置条件的概念来自于契约式设计(Design By Contract, DbC), 利用断言机制实现。我们从 Java 的断言机制开始来介绍 DBC，最后使用谷歌的 Guava 库作为前置条件。 断言（Assertions）断言通过验证在程序执行期间满足某些条件，从而增加了程序的健壮性。 如果在方法的内部，则可以使用断言检查参数的有效性。这些是确保程序正确的重要测试，但是它们不能在编译时被检查，并且它们不属于单元测试的范围。 Java 断言语法你可以通过其它程序设计架构来模拟断言的效果，因此，在 Java 中包含断言的意义在于它们易于编写。断言语句有两种形式 : 123assert boolean-expression；assert boolean-expression: information-expression; 两者似乎告诉我们 “我断言这个布尔表达式会产生 true”， 否则，将抛出 AssertionError 异常。 AssertionError 是 Throwable 的派生类，因此不需要异常说明。 不幸的是，第一种断言形式的异常不会生成包含布尔表达式的任何信息（与大多数其他语言的断言机制相反）。 下面是第一种形式的例子： 1234567891011121314151617// validating/Assert1.java// Non-informative style of assert// Must run using -ea flag:// &#123;java -ea Assert1&#125;// &#123;ThrowsException&#125;public class Assert1 &#123; public static void main(String[] args) &#123; assert false; &#125;&#125;/* Output:___[ Error Output ]___Exception in thread \"main\" java.lang.AssertionErrorat Assert1.main(Assert1.java:9)*/ 如果你正常运行程序，没有任何特殊的断言标志，则不会发生任何事情。你需要在运行程序时显式启用断言。一种简单的方法是使用 -ea 标志， 它也可以表示为: -enableassertion， 这将运行程序并执行任何断言语句。 输出中并没有包含多少有用的信息。另一方面，如果你使用 information-expression ， 将生成一条有用的消息作为异常堆栈跟踪的一部分。最有用的 information-expression 通常是一串针对程序员的文本： 1234567891011121314151617// validating/Assert2.java// Assert with an information-expression// &#123;java Assert2 -ea&#125;// &#123;ThrowsException&#125;public class Assert2 &#123; public static void main(String[] args) &#123; assert false: \"Here's a message saying what happened\"; &#125;&#125;/* Output:___[ Error Output ]___Exception in thread \"main\" java.lang.AssertionError:Here's a message saying what happenedat Assert2.main(Assert2.java:8)*/ information-expression 可以产生任何类型的对象，因此，通常将构造一个包含对象值的更复杂的字符串，它包含失败的断言。 你还可以基于类名或包名打开或关闭断言；也就是说，你可以对整个包启用或禁用断言。实现这一点的详细信息在 JDK 的断言文档中。此特性对于使用断言的大型项目来说很有用当你想打开或关闭某些断言时。但是，日志记录（Logging）或者调试（Debugging）,可能是捕获这类信息的更好工具。 你还可以通过编程的方式通过链接到类加载器对象（ClassLoader）来控制断言。类加载器中有几种方法允许动态启用和禁用断言，其中 setDefaultAssertionStatus () ,它为之后加载的所有类设置断言状态。因此，你可以像下面这样悄悄地开启断言： 12345678910111213141516171819202122232425// validating/LoaderAssertions.java// Using the class loader to enable assertions// &#123;ThrowsException&#125;public class LoaderAssertions &#123;public static void main(String[] args) &#123; ClassLoader.getSystemClassLoader(). setDefaultAssertionStatus(true); new Loaded().go(); &#125;&#125;class Loaded &#123; public void go() &#123; assert false: \"Loaded.go()\"; &#125;&#125;/* Output:___[ Error Output ]___Exception in thread \"main\" java.lang.AssertionError:Loaded.go()at Loaded.go(LoaderAssertions.java:15)atLoaderAssertions.main(LoaderAssertions.java:9)*/ 这消除了在运行程序时在命令行上使用 -ea 标志的需要，使用 -ea 标志启用断言可能同样简单。当交付独立产品时，可能必须设置一个执行脚本让用户能够启动程序，配置其他启动参数，这么做是有意义的。然而，决定在程序运行时启用断言可以使用下面的 static 块来实现这一点，该语句位于系统的主类中： 1234567static &#123; boolean assertionsEnabled = false; // Note intentional side effect of assignment: assert assertionsEnabled = true; if(!assertionsEnabled) throw new RuntimeException(\"Assertions disabled\");&#125; 如果启用断言，然后执行 assert 语句，assertionsEnabled 变为 true 。断言不会失败，因为分配的返回值是赋值的值。如果不启用断言，assert 语句不执行，assertionsEnabled 保持false，将导致异常。 Guava断言因为启用 Java 本地断言很麻烦，Guava 团队添加一个始终启用的用来替换断言的 Verify 类。他们建议静态导入 Verify 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// validating/GuavaAssertions.java// Assertions that are always enabled.import com.google.common.base.*;import static com.google.common.base.Verify.*;public class GuavaAssertions &#123; public static void main(String[] args) &#123; verify(2 + 2 == 4); try &#123; verify(1 + 2 == 4); &#125; catch(VerifyException e) &#123; System.out.println(e); &#125; try &#123; verify(1 + 2 == 4, \"Bad math\"); &#125; catch(VerifyException e) &#123; System.out.println(e.getMessage()); &#125; try &#123; verify(1 + 2 == 4, \"Bad math: %s\", \"not 4\"); &#125; catch(VerifyException e) &#123; System.out.println(e.getMessage()); &#125; String s = \"\"; s = verifyNotNull(s); s = null; try &#123; verifyNotNull(s); &#125; catch(VerifyException e) &#123; System.out.println(e.getMessage()); &#125; try &#123; verifyNotNull( s, \"Shouldn't be null: %s\", \"arg s\"); &#125; catch(VerifyException e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125;/* Output:com.google.common.base.VerifyExceptionBad mathBad math: not 4expected a non-null referenceShouldn't be null: arg s*/ 这里有两个方法，使用变量 verify() 和 verifyNotNull() 来支持有用的错误消息。注意，verifyNotNull() 内置的错误消息通常就足够了，而 verify() 太一般，没有有用的默认错误消息。 使用断言进行契约式设计契约式设计(DbC)是 Eiffel 语言的发明者 Bertrand Meyer 提出的一个概念，通过确保对象遵循某些规则来帮助创建健壮的程序。这些规则是由正在解决的问题的性质决定的，这超出了编译器可以验证的范围。虽然断言没有直接实现 DBC（Eiffel 语言也是如此），但是它们创建了一种非正式的 DbC 编程风格。DbC 假定服务供应者与该服务的消费者或客户之间存在明确指定的契约。在面向对象编程中，服务通常由对象提供，对象的边界 — 供应者和消费者之间的划分 — 是对象类的接口。当客户端调用特定的公共方法时，它们希望该调用具有特定的行为：对象状态改变，以及一个可预测的返回值。 Meyer 认为： 1.应该明确指定行为，就好像它是一个契约一样。 2.通过实现某些运行时检查来保证这种行为，他将这些检查称为前置条件、后置条件和不变项。 不管你是否同意，第一条总是对的，在大多数情况下，DbC 确实是一种有用的方法。（我认为，与任何解决方案一样，它的有用性也有界限。但如果你知道这些界限，你就知道什么时候去尝试。）尤其是，设计过程中一个有价值的部分是特定类 DbC 约束的表达式；如果无法指定约束，则你可能对要构建的内容了解得不够。 检查指令详细研究 DbC 之前，思考最简单使用断言的办法，Meyer 称它为检查指令。检查指令说明你确信代码中的某个特定属性此时已经得到满足。检查指令的思想是在代码中表达非明显性的结论，而不仅仅是为了验证测试，也同样为了将来能够满足阅读者而有一个文档。 在化学领域，你也许会用一种纯液体去滴定测量另一种液体，当达到一个特定的点时，液体变蓝了。从两个液体的颜色上并不能明显看出；这是复杂反应的一部分。滴定完成后一个有用的检查指令是能够断定液体变蓝了。 检查指令是对你的代码进行补充，当你可以测试并阐明对象或程序的状态时，应该使用它。 前置条件前置条件确保客户端(调用此方法的代码)履行其部分契约。这意味着在方法调用开始时几乎总是会检查参数（在你用那个方法做任何操作之前）以此保证它们的调用在方法中是合适的。因为你永远无法知道客户端会传递给你什么，前置条件是确保检查的一个好做法。 后置条件后置条件测试你在方法中所做的操作的结果。这段代码放在方法调用的末尾，在 return 语句之前(如果有的话)。对于长时间、复杂的方法，在返回计算结果之前需要对计算结果进行验证（也就是说，在某些情况下，由于某种原因，你不能总是相信结果)，后置条件很重要，但是任何时候你可以描述方法结果上的约束时，最好将这些约束在代码中表示为后置条件。 不变性不变性保证了必须在方法调用之间维护的对象的状态。但是，它并不会阻止方法在执行过程中暂时偏离这些保证，它只是在说对象的状态信息应该总是遵守状态规则： 1. 在进入该方法时。 2. 在离开方法之前。 此外，不变性是构造后对于对象状态的保证。 根据这个描述，一个有效的不变性被定义为一个方法，可能被命名为 invariant() ，它在构造之后以及每个方法的开始和结束时调用。方法以如下方式调用： assert invariant(); 这样，如果出于性能原因禁用断言，就不会产生开销。 放松 DbC 检查或非严格的 DbC尽管 Meyer 强调了前置条件、后置条件和不变性的价值以及在开发过程中使用它们的重要性，他承认在一个产品中包含所有 DbC 代码并不总是实际的。你可以基于对特定位置的代码的信任程度放松 DbC 检查。以下是放松检查的顺序，最安全到最不安全： 1. 不变性检查在每个方法一开始的时候是不能进行的，因为在每个方法结束的时候进行不变性检查能保证一开始的时候对象处于有效状态。也就是说，通常情况下，你可以相信对象的状态不会在方法调用之间发生变化。这是一个非常安全的假设，你可以只在代码末尾使用不变性检查来编写代码。 2. 接下来禁用后置条件检查，当你进行合理的单元测试以验证方法是否返回了适当的值时。因为不变性检查是观察对象的状态，后置条件检查仅在方法期间验证计算结果，因此可能会被丢弃，以便进行单元测试。单元测试不会像运行时后置条件检查那样安全，但是它可能已经足够了，特别是当对自己的代码有信心时。 3. 如果你确信方法主体没有把对象改成无效状态，则可以禁用方法调用末尾的不变性检查。可以通过白盒单元测试(通过访问私有字段的单元测试来验证对象状态)来验证这一点。尽管它可能没有调用 invariant() 那么稳妥，可以将不变性检查从运行时测试 “迁移” 到构建时测试(通过单元测试)，就像使用后置条件一样。 4. 禁用前置条件检查，但除非这是万不得已的情况下。因为这是最不安全、最不明智的选择，因为尽管你知道并且可以控制自己的代码，但是你无法控制客户端可能会传递给方法的参数。然而，某些情况下对性能要求很高，通过分析得到前置条件造成了这个瓶颈，而且你有某种合理的保证客户端不会违反前置条件(比如自己编写客户端的情况下)，那么禁用前置条件检查是可接受的。 你不应该直接删除检查的代码，而只需要禁用检查(添加注释)。这样如果发现错误，就可以轻松地恢复检查以快速发现问题。 DbC + 单元测试下面的例子演示了将契约式设计中的概念与单元测试相结合的有效性。它显示了一个简单的先进先出(FIFO)队列，该队列实现为一个“循环”数组，即以循环方式使用的数组。当到达数组的末尾时，将绕回到开头。 我们可以对这个队列做一些契约定义: 1. 前置条件(用于put())：不允许将空元素添加到队列中。 2. 前置条件(用于put())：将元素放入完整队列是非法的。 3. 前置条件(用于get())：试图从空队列中获取元素是非法的。 4. 后置条件用于get())：不能从数组中生成空元素。 5. 不变性：包含对象的区域不能包含任何空元素。 6. 不变性：不包含对象的区域必须只有空值。 下面是实现这些规则的一种方式，为每个 DbC 元素类型使用显式的方法调用。 首先，我们创建一个专用的 Exception： 1234567// validating/CircularQueueException.javapackage validating;public class CircularQueueException extends RuntimeException &#123; public CircularQueueException(String why) &#123; super(why); &#125;&#125; 它用来报告 CircularQueue 中出现的错误： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// validating/CircularQueue.java// Demonstration of Design by Contract (DbC)package validating;import java.util.*;public class CircularQueue &#123; private Object[] data; private int in = 0, // Next available storage space out = 0; // Next gettable object // Has it wrapped around the circular queue? private boolean wrapped = false; public CircularQueue(int size) &#123; data = new Object[size]; // Must be true after construction: assert invariant(); &#125; public boolean empty() &#123; return !wrapped &amp;&amp; in == out; &#125; public boolean full() &#123; return wrapped &amp;&amp; in == out; &#125; public boolean isWrapped() &#123; return wrapped; &#125; public void put(Object item) &#123; precondition(item != null, \"put() null item\"); precondition(!full(), \"put() into full CircularQueue\"); assert invariant(); data[in++] = item; if(in &gt;= data.length) &#123; in = 0; wrapped = true; &#125; assert invariant(); &#125; public Object get() &#123; precondition(!empty(), \"get() from empty CircularQueue\"); assert invariant(); Object returnVal = data[out]; data[out] = null; out++; if(out &gt;= data.length) &#123; out = 0; wrapped = false; &#125; assert postcondition( returnVal != null, \"Null item in CircularQueue\"); assert invariant(); return returnVal; &#125; // Design-by-contract support methods: private static void precondition(boolean cond, String msg) &#123; if(!cond) throw new CircularQueueException(msg); &#125; private static boolean postcondition(boolean cond, String msg) &#123; if(!cond) throw new CircularQueueException(msg); return true; &#125; private boolean invariant() &#123; // Guarantee that no null values are in the // region of 'data' that holds objects: for(int i = out; i != in; i = (i + 1) % data.length) if(data[i] == null) throw new CircularQueueException(\"null in CircularQueue\"); // Guarantee that only null values are outside the // region of 'data' that holds objects: if(full()) return true; for(int i = in; i != out; i = (i + 1) % data.length) if(data[i] != null) throw new CircularQueueException( \"non-null outside of CircularQueue range: \" + dump()); return true; &#125; public String dump() &#123; return \"in = \" + in + \", out = \" + out + \", full() = \" + full() + \", empty() = \" + empty() + \", CircularQueue = \" + Arrays.asList(data); &#125;&#125; in 计数器指示数组中下一个对象所在的位置。out 计数器指示下一个对象来自何处。wrapped 的flag表示 in 已经“绕着圆圈”走了，现在从后面出来了。当in和 out 重合时，队列为空(如果包装为 false )或满(如果 wrapped 为 true )。 put() 和 get() 方法调用 precondition() ，postcondition(), 和 invariant()，这些都是在类中定义的私有方法。前置precondition() 和 postcondition() 是用来阐明代码的辅助方法。 注意，precondition() 返回 void , 因为它不与断言一起使用。按照之前所说的，通常你会在代码中保留前置条件。通过将它们封装在 precondition() 方法调用中，如果你不得不做出关掉它们的可怕举动，你会有更好的选择。 postcondition() 和 constant() 都返回一个布尔值，因此可以在 assert 语句中使用它们。此外，如果出于性能考虑禁用断言，则根本不存在方法调用。invariant() 对对象执行内部有效性检查，如果你在每个方法调用的开始和结束都这样做，这是一个花销巨大的操作，就像 Meyer 建议的那样。所以， 用代码清晰地表明是有帮助的，它帮助我调试了实现。此外，如果你对代码实现做任何更改，那么 invariant() 将确保你没有破坏代码，将不变性测试从方法调用移到单元测试代码中是相当简单的。如果你的单元测试是足够的，那么你应当对不变性保持一定的信心。 dump() 帮助方法返回一个包含所有数据的字符串，而不是直接打印数据。这允许我们用这部分信息做更多事。 现在我们可以为类创建 JUnit 测试: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// validating/tests/CircularQueueTest.javapackage validating;import org.junit.jupiter.api.*;import static org.junit.jupiter.api.Assertions.*;public class CircularQueueTest &#123; private CircularQueue queue = new CircularQueue(10); private int i = 0; @BeforeEach public void initialize() &#123; while(i &lt; 5) // Pre-load with some data queue.put(Integer.toString(i++)); &#125; // Support methods: private void showFullness() &#123; assertTrue(queue.full()); assertFalse(queue.empty()); System.out.println(queue.dump()); &#125; private void showEmptiness() &#123; assertFalse(queue.full()); assertTrue(queue.empty()); System.out.println(queue.dump()); &#125; @Test public void full() &#123; System.out.println(\"testFull\"); System.out.println(queue.dump()); System.out.println(queue.get()); System.out.println(queue.get()); while(!queue.full()) queue.put(Integer.toString(i++)); String msg = \"\"; try &#123; queue.put(\"\"); &#125; catch(CircularQueueException e) &#123; msg = e.getMessage(); ∂System.out.println(msg); &#125; assertEquals(msg, \"put() into full CircularQueue\"); showFullness(); &#125; @Test public void empty() &#123; System.out.println(\"testEmpty\"); while(!queue.empty()) System.out.println(queue.get()); String msg = \"\"; try &#123; queue.get(); &#125; catch(CircularQueueException e) &#123; msg = e.getMessage(); System.out.println(msg); &#125; assertEquals(msg, \"get() from empty CircularQueue\"); showEmptiness(); &#125; @Test public void nullPut() &#123; System.out.println(\"testNullPut\"); String msg = \"\"; try &#123; queue.put(null); &#125; catch(CircularQueueException e) &#123; msg = e.getMessage(); System.out.println(msg); &#125; assertEquals(msg, \"put() null item\"); &#125; @Test public void circularity() &#123; System.out.println(\"testCircularity\"); while(!queue.full()) queue.put(Integer.toString(i++)); showFullness(); assertTrue(queue.isWrapped()); while(!queue.empty()) System.out.println(queue.get()); showEmptiness(); while(!queue.full()) queue.put(Integer.toString(i++)); showFullness(); while(!queue.empty()) System.out.println(queue.get()); showEmptiness(); &#125; &#125;/* Output:testNullPutput() null itemtestCircularityin = 0, out = 0, full() = true, empty() = false,CircularQueue =[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]0123456789in = 0, out = 0, full() = false, empty() = true,CircularQueue =[null, null, null, null, null, null, null, null, null,null]in = 0, out = 0, full() = true, empty() = false,CircularQueue =[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]10111213141516171819in = 0, out = 0, full() = false, empty() = true,CircularQueue =[null, null, null, null, null, null, null, null, null,null]testFullin = 5, out = 0, full() = false, empty() = false,CircularQueue =[0, 1, 2, 3, 4, null, null, null, null, null]01put() into full CircularQueuein = 2, out = 2, full() = true, empty() = false,CircularQueue =[10, 11, 2, 3, 4, 5, 6, 7, 8, 9]testEmpty01234get() from empty CircularQueuein = 5, out = 5, full() = false, empty() = true,CircularQueue =[null, null, null, null, null, null, null, null, null,null]*/ initialize() 添加了一些数据，因此每个测试的 CircularQueue 都是部分满的。showFullness() 和 showempty() 表明 CircularQueue 是满的还是空的，这四种测试方法中的每一种都确保了 CircularQueue 功能在不同的地方正确运行。 通过将 Dbc 和单元测试结合起来，你不仅可以同时使用这两种方法，还可以有一个迁移路径—你可以将一些 Dbc 测试迁移到单元测试中，而不是简单地禁用它们，这样你仍然有一定程度的测试。 使用Guava前置条件在非严格的 DbC 中，前置条件是 DbC 中你不想删除的那一部分，因为它可以检查方法参数的有效性。那是你没有办法控制的事情，所以你需要对其检查。因为 Java 在默认情况下禁用断言，所以通常最好使用另外一个始终验证方法参数的库。 谷歌的 Guava 库包含了一组很好的前置条件测试，这些测试不仅易于使用，而且命名也足够好。在这里你可以看到它们的简单用法。库的设计人员建议静态导入前置条件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// validating/GuavaPreconditions.java// Demonstrating Guava Preconditionsimport java.util.function.*;import static com.google.common.base.Preconditions.*;public class GuavaPreconditions &#123; static void test(Consumer&lt;String&gt; c, String s) &#123; try &#123; System.out.println(s); c.accept(s); System.out.println(\"Success\"); &#125; catch(Exception e) &#123; String type = e.getClass().getSimpleName(); String msg = e.getMessage(); System.out.println(type + (msg == null ? \"\" : \": \" + msg)); &#125; &#125; public static void main(String[] args) &#123; test(s -&gt; s = checkNotNull(s), \"X\"); test(s -&gt; s = checkNotNull(s), null); test(s -&gt; s = checkNotNull(s, \"s was null\"), null); test(s -&gt; s = checkNotNull( s, \"s was null, %s %s\", \"arg2\", \"arg3\"), null); test(s -&gt; checkArgument(s == \"Fozzie\"), \"Fozzie\"); test(s -&gt; checkArgument(s == \"Fozzie\"), \"X\"); test(s -&gt; checkArgument(s == \"Fozzie\"), null); test(s -&gt; checkArgument( s == \"Fozzie\", \"Bear Left!\"), null); test(s -&gt; checkArgument( s == \"Fozzie\", \"Bear Left! %s Right!\", \"Frog\"), null); test(s -&gt; checkState(s.length() &gt; 6), \"Mortimer\"); test(s -&gt; checkState(s.length() &gt; 6), \"Mort\"); test(s -&gt; checkState(s.length() &gt; 6), null); test(s -&gt; checkElementIndex(6, s.length()), \"Robert\"); test(s -&gt; checkElementIndex(6, s.length()), \"Bob\"); test(s -&gt; checkElementIndex(6, s.length()), null); test(s -&gt; checkPositionIndex(6, s.length()), \"Robert\"); test(s -&gt; checkPositionIndex(6, s.length()), \"Bob\"); test(s -&gt; checkPositionIndex(6, s.length()), null); test(s -&gt; checkPositionIndexes( 0, 6, s.length()), \"Hieronymus\"); test(s -&gt; checkPositionIndexes( 0, 10, s.length()), \"Hieronymus\"); test(s -&gt; checkPositionIndexes( 0, 11, s.length()), \"Hieronymus\"); test(s -&gt; checkPositionIndexes( -1, 6, s.length()), \"Hieronymus\"); test(s -&gt; checkPositionIndexes( 7, 6, s.length()), \"Hieronymus\"); test(s -&gt; checkPositionIndexes( 0, 6, s.length()), null); &#125;&#125;/* Output:XSuccessnullNullPointerExceptionnullNullPointerException: s was nullnullNullPointerException: s was null, arg2 arg3FozzieSuccessXIllegalArgumentExceptionnullIllegalArgumentExceptionnullIllegalArgumentException: Bear Left!nullIllegalArgumentException: Bear Left! Frog Right!MortimerSuccessMortIllegalStateExceptionnullNullPointerExceptionRobertIndexOutOfBoundsException: index (6) must be less thansize (6)BobIndexOutOfBoundsException: index (6) must be less thansize (3)nullNullPointerExceptionRobertSuccessBobIndexOutOfBoundsException: index (6) must not begreater than size (3)nullNullPointerExceptionHieronymusSuccessHieronymusSuccessHieronymusIndexOutOfBoundsException: end index (11) must not begreater than size (10)HieronymusIndexOutOfBoundsException: start index (-1) must not benegativeHieronymusIndexOutOfBoundsException: end index (6) must not be less than start index (7)nullNullPointerException*/ 虽然 Guava 的前置条件适用于所有类型，但我这里只演示 字符串（String） 类型。test() 方法需要一个Consumer，因此我们可以传递一个 lambda 表达式作为第一个参数，传递给 lambda 表达式的字符串作为第二个参数。它显示字符串，以便在查看输出时确定方向，然后将字符串传递给 lambda 表达式。try 块中的第二个 println() 仅在 lambda 表达式成功时才显示; 否则 catch 块将捕获并显示错误信息。注意 test() 方法消除了多少重复的代码。 每个前置条件都有三种不同的重载形式：一个什么都没有，一个带有简单字符串消息，以及带有一个字符串和替换值。为了提高效率，只允许 %s (字符串类型)替换标记。在上面的例子中，演示了checkNotNull() 和 checkArgument() 这两种形式。但是它们对于所有前置条件方法都是相同的。注意 checkNotNull() 的返回参数， 所以你可以在表达式中内联使用它。下面是如何在构造函数中使用它来防止包含 Null 值的对象构造： 1234567891011121314/ validating/NonNullConstruction.javaimport static com.google.common.base.Preconditions.*;public class NonNullConstruction &#123; private Integer n; private String s; NonNullConstruction(Integer n, String s) &#123; this.n = checkNotNull(n); this.s = checkNotNull(s); &#125; public static void main(String[] args) &#123; NonNullConstruction nnc = new NonNullConstruction(3, \"Trousers\"); &#125;&#125; checkArgument() 接受布尔表达式来对参数进行更具体的测试， 失败时抛出 IllegalArgumentException，checkState() 用于测试对象的状态（例如，不变性检查），而不是检查参数，并在失败时抛出 IllegalStateException 。 最后三个方法在失败时抛出 IndexOutOfBoundsException。checkElementIndex() 确保其第一个参数是列表、字符串或数组的有效元素索引，其大小由第二个参数指定。checkPositionIndex() 确保它的第一个参数在 0 到第二个参数(包括第二个参数)的范围内。 checkPositionIndexes() 检查 [first_arg, second_arg] 是一个列表的有效子列表，由第三个参数指定大小的字符串或数组。 所有的 Guava 前置条件对于基本类型和对象都有必要的重载。 测试驱动开发之所以可以有测试驱动开发（TDD）这种开发方式，是因为如果你在设计和编写代码时考虑到了测试，那么你不仅可以写出可测试性更好的代码，而且还可以得到更好的代码设计。 一般情况下这个说法都是正确的。 一旦我想到“我将如何测试我的代码？”，这个想法将使我的代码产生变化，并且往往是从“可测试”转变为“可用”。 纯粹的 TDD 主义者会在实现新功能之前就为其编写测试，这称为测试优先的开发。 我们采用一个简易的示例程序来进行说明，它的功能是反转 String 中字符的大小写。 让我们随意添加一些约束：String 必须小于或等于30个字符，并且必须只包含字母，空格，逗号和句号(英文)。 此示例与标准 TDD 不同，因为它的作用在于接收 StringInverter 的不同实现，以便在我们逐步满足测试的过程中来体现类的演变。 为了满足这个要求，将 StringInverter 作为接口： 123456// validating/StringInverter.javapackage validating;interface StringInverter &#123; String invert(String str);&#125; 现在我们通过可以编写测试来表述我们的要求。 以下所述通常不是你编写测试的方式，但由于我们在此处有一个特殊的约束：我们要对 *StringInverter *多个版本的实现进行测试，为此，我们利用了 JUnit5 中最复杂的新功能之一：动态测试生成。 顾名思义，通过它你可以使你所编写的代码在运行时生成测试，而不需要你对每个测试显式编码。 这带来了许多新的可能性，特别是在明确地需要编写一整套测试而令人望而却步的情况下。 JUnit5 提供了几种动态生成测试的方法，但这里使用的方法可能是最复杂的。 *DynamicTest.stream() *方法采用了： 对象集合上的迭代器 (versions) ，这个迭代器在不同组的测试中是不同的。 迭代器生成的对象可以是任何类型，但是只能有一种对象生成，因此对于存在多个不同的对象类型时，必须人为地将它们打包成单个类型。 Function，它从迭代器获取对象并生成描述测试的 String 。 Consumer，它从迭代器获取对象并包含基于该对象的测试代码。 在此示例中，所有代码将在 testVersions() 中进行组合以防止代码重复。 迭代器生成的对象是对 DynamicTest 的不同实现，这些对象体现了对接口不同版本的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// validating/tests/DynamicStringInverterTests.javapackage validating;import java.util.*;import java.util.function.*;import java.util.stream.*;import org.junit.jupiter.api.*;import static org.junit.jupiter.api.Assertions.*;import static org.junit.jupiter.api.DynamicTest.*;class DynamicStringInverterTests &#123; // Combine operations to prevent code duplication: Stream&lt;DynamicTest&gt; testVersions(String id, Function&lt;StringInverter, String&gt; test) &#123; List&lt;StringInverter&gt; versions = Arrays.asList( new Inverter1(), new Inverter2(), new Inverter3(), new Inverter4()); return DynamicTest.stream( versions.iterator(), inverter -&gt; inverter.getClass().getSimpleName(), inverter -&gt; &#123; System.out.println( inverter.getClass().getSimpleName() + \": \" + id); try &#123; if(test.apply(inverter) != \"fail\") System.out.println(\"Success\"); &#125; catch(Exception | Error e) &#123; System.out.println( \"Exception: \" + e.getMessage()); &#125; &#125; ); &#125; String isEqual(String lval, String rval) &#123; if(lval.equals(rval)) return \"success\"; System.out.println(\"FAIL: \" + lval + \" != \" + rval); return \"fail\"; &#125; @BeforeAll static void startMsg() &#123; System.out.println( \"&gt;&gt;&gt; Starting DynamicStringInverterTests &lt;&lt;&lt;\"); &#125; @AfterAll static void endMsg() &#123; System.out.println( \"&gt;&gt;&gt; Finished DynamicStringInverterTests &lt;&lt;&lt;\"); &#125; @TestFactory Stream&lt;DynamicTest&gt; basicInversion1() &#123; String in = \"Exit, Pursued by a Bear.\"; String out = \"eXIT, pURSUED BY A bEAR.\"; return testVersions( \"Basic inversion (should succeed)\", inverter -&gt; isEqual(inverter.invert(in), out) ); &#125; @TestFactory Stream&lt;DynamicTest&gt; basicInversion2() &#123; return testVersions( \"Basic inversion (should fail)\", inverter -&gt; isEqual(inverter.invert(\"X\"), \"X\")); &#125; @TestFactory Stream&lt;DynamicTest&gt; disallowedCharacters() &#123; String disallowed = \";-_()*&amp;^%$#@!~`0123456789\"; return testVersions( \"Disallowed characters\", inverter -&gt; &#123; String result = disallowed.chars() .mapToObj(c -&gt; &#123; String cc = Character.toString((char)c); try &#123; inverter.invert(cc); return \"\"; &#125; catch(RuntimeException e) &#123; return cc; &#125; &#125;).collect(Collectors.joining(\"\")); if(result.length() == 0) return \"success\"; System.out.println(\"Bad characters: \" + result); return \"fail\"; &#125; ); &#125; @TestFactory Stream&lt;DynamicTest&gt; allowedCharacters() &#123; String lowcase = \"abcdefghijklmnopqrstuvwxyz ,.\"; String upcase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ ,.\"; return testVersions( \"Allowed characters (should succeed)\", inverter -&gt; &#123; assertEquals(inverter.invert(lowcase), upcase); assertEquals(inverter.invert(upcase), lowcase); return \"success\"; &#125; ); &#125; @TestFactory Stream&lt;DynamicTest&gt; lengthNoGreaterThan30() &#123; String str = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"; assertTrue(str.length() &gt; 30); return testVersions( \"Length must be less than 31 (throws exception)\", inverter -&gt; inverter.invert(str) ); &#125; @TestFactory Stream&lt;DynamicTest&gt; lengthLessThan31() &#123; String str = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"; assertTrue(str.length() &lt; 31); return testVersions( \"Length must be less than 31 (should succeed)\", inverter -&gt; inverter.invert(str) ); &#125;&#125; 在一般的测试中，你可能认为在进行一个结果为失败的测试时应该停止代码构建。 但是在这里，我们只希望系统报告问题，但仍然继续运行，以便你可以看到不同版本的 StringInverter 的效果。 每个使用 @TestFactory 注释的方法都会生成一个 DynamicTest 对象的 Stream（通过 testVersions() ），每个 JUnit 都像常规的 @Test 方法一样执行。 现在测试都已经准备好了，我们就可以开始实现 *StringInverter *了。 我们从一个仅返回其参数的假的实现类开始： 12345// validating/Inverter1.javapackage validating;public class Inverter1 implements StringInverter &#123; public String invert(String str) &#123; return str; &#125;&#125; 接下来我们实现反转操作： 123456789101112131415// validating/Inverter2.javapackage validating;import static java.lang.Character.*;public class Inverter2 implements StringInverter &#123; public String invert(String str) &#123; String result = \"\"; for(int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); result += isUpperCase(c) ? toLowerCase(c) : toUpperCase(c); &#125; return result; &#125;&#125; 现在添加代码以确保输入不超过30个字符： 1234567891011121314151617// validating/Inverter3.javapackage validating;import static java.lang.Character.*;public class Inverter3 implements StringInverter &#123; public String invert(String str) &#123; if(str.length() &gt; 30) throw new RuntimeException(\"argument too long!\"); String result = \"\"; for(int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); result += isUpperCase(c) ? toLowerCase(c) : toUpperCase(c); &#125; return result; &#125;&#125; 最后，我们排除了不允许的字符： 12345678910111213141516171819202122// validating/Inverter4.javapackage validating;import static java.lang.Character.*;public class Inverter4 implements StringInverter &#123; static final String ALLOWED = \"abcdefghijklmnopqrstuvwxyz ,.\" + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; public String invert(String str) &#123; if(str.length() &gt; 30) throw new RuntimeException(\"argument too long!\"); String result = \"\"; for(int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); if(ALLOWED.indexOf(c) == -1) throw new RuntimeException(c + \" Not allowed\"); result += isUpperCase(c) ? toLowerCase(c) : toUpperCase(c); &#125; return result; &#125;&#125; 你将从测试输出中看到，每个版本的 Inverter 都几乎能通过所有测试。 当你在进行测试优先的开发时会有相同的体验。 DynamicStringInverterTests.java 仅是为了显示 TDD 过程中不同 StringInverter 实现的开发。 通常，你只需编写一组如下所示的测试，并修改单个 StringInverter 类直到它满足所有测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// validating/tests/StringInverterTests.javapackage validating;import java.util.*;import java.util.stream.*;import org.junit.jupiter.api.*;import static org.junit.jupiter.api.Assertions.*;public class StringInverterTests &#123; StringInverter inverter = new Inverter4(); @BeforeAll static void startMsg() &#123; System.out.println(\"&gt;&gt;&gt; StringInverterTests &lt;&lt;&lt;\"); &#125; @Test void basicInversion1() &#123; String in = \"Exit, Pursued by a Bear.\"; String out = \"eXIT, pURSUED BY A bEAR.\"; assertEquals(inverter.invert(in), out); &#125; @Test void basicInversion2() &#123; expectThrows(Error.class, () -&gt; &#123; assertEquals(inverter.invert(\"X\"), \"X\"); &#125;); &#125; @Test void disallowedCharacters() &#123; String disallowed = \";-_()*&amp;^%$#@!~`0123456789\"; String result = disallowed.chars() .mapToObj(c -&gt; &#123; String cc = Character.toString((char)c); try &#123; inverter.invert(cc); return \"\"; &#125; catch(RuntimeException e) &#123; return cc; &#125; &#125;).collect(Collectors.joining(\"\")); assertEquals(result, disallowed); &#125; @Test void allowedCharacters() &#123; String lowcase = \"abcdefghijklmnopqrstuvwxyz ,.\"; String upcase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ ,.\"; assertEquals(inverter.invert(lowcase), upcase); assertEquals(inverter.invert(upcase), lowcase); &#125; @Test void lengthNoGreaterThan30() &#123; String str = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"; assertTrue(str.length() &gt; 30); expectThrows(RuntimeException.class, () -&gt; &#123; inverter.invert(str); &#125;); &#125; @Test void lengthLessThan31() &#123; String str = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"; assertTrue(str.length() &lt; 31); inverter.invert(str); &#125;&#125; 你可以通过这种方式进行开发：一开始在测试中建立你期望程序应有的所有特性，然后你就能在实现中一步步添加功能，直到所有测试通过。 完成后，你还可以在将来通过这些测试来得知（或让其他任何人得知）当修复错误或添加功能时，代码是否被破坏了。 TDD的目标是产生更好，更周全的测试，因为在完全实现之后尝试实现完整的测试覆盖通常会产生匆忙或无意义的测试。 测试驱动 vs. 测试优先虽然我自己还没有达到测试优先的意识水平，但我最感兴趣的是来自测试优先中的“测试失败的书签”这一概念。 当你离开你的工作一段时间后，重新回到工作进展中，甚至找到你离开时工作到的地方有时会很有挑战性。 然而，以失败的测试为书签能让你找到之前停止的地方。 这似乎让你能更轻松地暂时离开你的工作，因为不用担心找不到工作进展的位置。 纯粹的测试优先编程的主要问题是它假设你事先了解了你正在解决的问题。 根据我自己的经验，我通常是从实验开始，而只有当我处理问题一段时间后，我对它的理解才会达到能给它编写测试的程度。 当然，偶尔会有一些问题在你开始之前就已经完全定义，但我个人并不常遇到这些问题。 实际上，可能用“面向测试的开发 ( Test-Oriented Development )”这个短语来描述编写测试良好的代码或许更好。 日志 日志会给出正在运行的程序的各种信息。 在调试程序中，日志可以是普通状态数据，用于显示程序运行过程（例如，安装程序可能会记录安装过程中采取的步骤，存储文件的目录，程序的启动值等）。 在调试期间，日志也能带来好处。 如果没有日志，你可能会尝试通过插入 println() 语句来打印出程序的行为。 但是，一旦你确定程序正常运行，你可能会将 println() 语句注释或者删除。 程序员在日志包可供使用之前，都只能依赖 Java 编译器移除未调用的代码。 如果 debug 是一个 *static final boolean *，你就可以这么写： 123if(debug) &#123; System.out.println(\"Debug info\");&#125; 然后，当 *debug *为 *false *时，编译器将移除大括号内的代码。 SLF4J业内普遍认为标准 Java 发行版本中的日志包 (java.util.logging) 的设计相当糟糕。 大多数人会选择其他的替代日志包。如 Simple Logging Facade for Java(SLF4J) ,它为多个日志框架提供了一个封装好的调用方式，这些日志框架包括 java.util.logging ， logback 和 *log4j *。 SLF4J 允许用户在部署时插入所需的日志框架。 SLF4J 提供了一个复杂的工具来报告程序的信息，它的效率与前面示例中的技术几乎相同。 对于非常简单的信息日志记录，你可以执行以下操作： 12345678910111213// validating/SLF4JLogging.javaimport org.slf4j.*;public class SLF4JLogging &#123; private static Logger log = LoggerFactory.getLogger(SLF4JLogging.class); public static void main(String[] args) &#123; log.info(\"hello logging\"); &#125;&#125;/* Output:2017-05-09T06:07:53.418[main] INFO SLF4JLogging - hello logging*/ 日志输出中的格式和信息，甚至输出是否正常或“错误”都取决于 SLF4J 所连接的后端程序包是怎样实现的。 在上面的示例中，它连接到的是 logback 库（通过本书的 build.gradle 文件），并显示为标准输出。 如果我们修改 build.gradle 从而使用内置在 JDK 中的日志包作为后端，则输出显示为错误输出，如下所示： Aug 16, 2016 5:40:31 PM InfoLogging mainINFO: hello logging 日志系统会检测日志消息处所在的的类名和方法名。 但它不能保证这些名称是正确的，所以不要纠结于其准确性。 日志等级SLF4J 提供了多个等级的日志消息。下面这个例子以“严重性”的递增顺序对它们作出演示： 12345678910111213141516171819202122232425// validating/SLF4JLevels.javaimport org.slf4j.*;public class SLF4JLevels &#123; private static Logger log = LoggerFactory.getLogger(SLF4JLevels.class); public static void main(String[] args) &#123; log.trace(\"Hello\"); log.debug(\"Logging\"); log.info(\"Using\"); log.warn(\"the SLF4J\"); log.error(\"Facade\"); &#125;&#125;/* Output:2017-05-09T06:07:52.846[main] TRACE SLF4JLevels - Hello2017-05-09T06:07:52.849[main] DEBUG SLF4JLevels - Logging2017-05-09T06:07:52.849[main] INFO SLF4JLevels - Using2017-05-09T06:07:52.850[main] WARN SLF4JLevels - the SLF4J2017-05-09T06:07:52.851[main] ERROR SLF4JLevels - Facade*/ 你可以按等级来查找消息。 级别通常设置在单独的配置文件中，因此你可以重新配置而无需重新编译。 配置文件格式取决于你使用的后端日志包实现。 如 logback 使用 XML ： 12345678910111213141516&lt;!-- validating/logback.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd'T'HH:mm:ss.SSS&#125;[%thread] %-5level %logger - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"TRACE\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 你可以尝试将 &lt;root level =“TRACE”&gt; *行更改为其他级别，然后重新运行该程序查看日志输出的更改情况。 如果你没有写 *logback.xml 文件，日志系统将采取默认配置。 这只是 SLF4J 最简单的介绍和一般的日志消息，但也足以作为使用日志的基础 - 你可以沿着这个进行更长久的学习和实践。你可以查阅 SLF4J 文档来获得更深入的信息。 调试使用调试器，可以展示任何时刻的程序状态，查看变量的值，一步一步运行程序，连接远程运行的程序等等。特别是当你构建较大规模的系统（bug 容易被掩埋）时，熟练使用调试器是值得的。 使用 JDB 调试Java 调试器（JDB）是 JDK 内置的命令行工具。从调试的指令和命令行接口两方面看的话，JDB 至少从概念上是 GNU 调试器（GDB，受 Unix DB 的影响）的继承者。JDB 对于学习调试和执行简单的调试任务来说是有用的，而且知道只要安装了 JDK 就可以使用 JDB 是有帮助的。然而，对于大型项目来说，你可能想要一个图形化的调试器，这在后面会描述。 假设你写了如下程序： 123456789101112131415161718192021222324252627282930313233343536373839// validating/SimpleDebugging.java// &#123;ThrowsException&#125;public class SimpleDebugging &#123; private static void foo1() &#123; System.out.println(\"In foo1\"); foo2(); &#125; private static void foo2() &#123; System.out.println(\"In foo2\"); foo3(); &#125; private static void foo3() &#123; System.out.println(\"In foo3\"); int j = 1; j--; int i = 5 / j; &#125; public static void main(String[] args) &#123; foo1(); &#125;&#125;/* OutputIn foo1In foo2In foo3__[Error Output]__Exception in thread \"main\"java.lang.ArithmeticException: /by zero at SimpleDebugging.foo3(SimpleDebugging.java:17)at SimpleDebugging.foo2(SimpleDebugging.java:11)atSimpleDebugging.foo1(SimpleDebugging.java:7)atSimpleDebugging.main(SimpleDebugging.java:20) 首先看方法 foo3()，问题很明显：除数是 0。但是假如这段代码被埋没在大型程序中（像这里的调用序列暗示的那样）而且你不知道从哪儿开始查找问题。结果呢，异常会给出足够的信息让你定位问题。然而，假设事情更加复杂，你必须更加深入程序中来获得比异常提供的更多的信息。 为了运行 JDB，你需要在编译 SimpleDebugging.java 时加上 -g 标记，从而告诉编译器生成编译信息。然后使用如下命令开始调试程序： 1javac -g .\\SimpleDebugging.java jdb SimpleDebugging 接着 JDB 就会运行，出现命令行提示。你可以输入 ? 查看可用的 JDB 命令。 这里展示了如何使用交互式追踪一个问题的调试历程： 123Initializing jdb...&gt; catch Exception &gt; 表明 JDB 在等待输入命令。命令 catch Exception 在任何抛出异常的地方设置断点（然而，即使你不显式地设置断点，调试器也会停止— JDB 中好像是默认在异常抛出处设置了异常）。接着命令行会给出如下响应： Deferring exception catch Exception. It will be set after the class is loaded. 继续输入： &gt; run 现在程序将运行到下个断点处，在这个例子中就是异常发生的地方。下面是运行 run 命令的结果： run SimpleDebugging Set uncaught java.lang.Throwable Set deferred uncaught java.lang.Throwable &gt; VM Started: In foo1 In foo2 In foo3 Exception occurred: java.lang.ArithmeticException (uncaught)”thread=main”, SimpleDebugging.foo3(),line=16 bci=15 16 int i = 5 / j 程序运行到第16行时发生异常，但是 JDB 在异常发生时就不复存在。调试器还展示了是哪一行导致了异常。你可以使用 list 将导致程序终止的执行点列出来： main[1] list 12 private static void foo3() { 13 System.out.println(“In foo3”); 14 int j = 1; 15 j–; 16 =&gt; int i = 5 / j; 17 } 18 public static void main(String[] args) { 19 foo1(); 20 } 21 } /* Output: 上述 =&gt; 展示了程序将继续运行的执行点。你可以使用命令 cont(continue) 继续运行，但是会导致 JDB 在异常发生时退出并打印出栈轨迹信息。 命令 locals 能转储所有的局部变量值： main[1] locals Method arguments: Local variables: j = 0 命令 wherei 打印进入当前线程的方法栈中的栈帧信息： main[1] wherei [1] SimpleDebugging.foo3(SimpleDebugging.java:16), pc =15 [2] SimpleDebugging.foo2(SimpleDebugging.java:10), pc = 8 [3] SimpleDebugging.foo1(SimpleDebugging.java:6), pc = 8 [4] SimpleDebugging.main(SimpleDebugging.java:19), pc = 10 wherei 后的每一行代表一个方法调用和调用返回点（由程序计数器显示数值）。这里的调用序列是 main(), foo1(), foo2() 和 foo3()。 因为命令 list 展示了执行停止的地方，所以你通常有足够的信息得知发生了什么并修复它。命令 help 将会告诉你更多关于 jdb 的用法，但是在花更多的时间学习它之前必须明白命令行调试器往往需要花费更多的精力得到结果。使用 jdb 学习调试的基础部分，然后转而学习图形界面调试器。 图形化调试器因此，尽管你可能一开始用 JDB 尝试调试，但是你将发现使用图形化调试器能更加高效、更快速地追踪 bug。IBM 的 Eclipse，Oracle 的 NetBeans 和 JetBrains 的 IntelliJ 这些集成开发环境都含有面向 Java 语言的好用的图形化调试器。 基准测试 我们应该忘掉微小的效率提升，说的就是这些 97% 的时间做的事：过早的优化是万恶之源。 ​ —— Donald Knuth 如果你发现自己正在过早优化的滑坡上，你可能浪费了几个月的时间(如果你雄心勃勃的话)。通常，一个简单直接的编码方法就足够好了。如果你进行了不必要的优化，就会使你的代码变得无谓的复杂和难以理解。 基准测试意味着对代码或算法片段进行计时看哪个跑得更快，与下一节的分析和优化截然相反，分析优化是观察整个程序，找到程序中最耗时的部分。 可以简单地对一个代码片段的执行计时吗？在像 C 这样直接的编程语言中，这个方法的确可行。在像 Java 这样拥有复杂的运行时系统的编程语言中，基准测试变得更有挑战性。为了生成可靠的数据，环境设置必须控制诸如 CPU 频率，节能特性，其他运行在相同机器上的进程，优化器选项等等。 微基准测试写一个计时工具类从而比较不同代码块的执行速度是具有吸引力的。看上去这会产生一些有用的数据。比如，这里有一个简单的 Timer 类，可以用以下两种方式使用它： 创建一个 Timer 对象，执行一些操作然后调用 Timer 的 duration() 方法产生以毫秒为单位的运行时间。 向静态的 duration() 方法中传入 Runnable。任何符合 Runnable 接口的类都有一个函数式方法 run()，该方法没有入参，且没有返回。 1234567891011121314151617// onjava/Timer.javapackage onjava;import static java.util.concurrent.TimeUnit.*;public class Timer &#123; private long start = System.nanoTime(); public long duration() &#123; return NANOSECONDS.toMillis(System.nanoTime() - start); &#125; public static long duration(Runnable test) &#123; Timer timer = new Timer(); test.run(); return timer.duration(); &#125;&#125; 这是一个很直接的计时方式。难道我们不能只运行一些代码然后看它的运行时长吗？ 有许多因素会影响你的结果，即使是生成提示符也会造成计时的混乱。这里举一个看上去天真的例子，它使用了 标准的 Java Arrays 库（后面会详细介绍）： 1234567891011121314151617181920212223// validating/BadMicroBenchmark.java// &#123;ExcludeFromTravisCI&#125;import java.util.*;import onjava.Timer;public class BadMicroBenchmark &#123; static final int SIZE = 250_000_000; public static void main(String[] args) &#123; try &#123; // For machines with insufficient memory long[] la = new long[SIZE]; System.out.println(\"setAll: \" + Timer.duration(() -&gt; Arrays.setAll(la, n -&gt; n))); System.out.println(\"parallelSetAll: \" + Timer.duration(() -&gt; Arrays.parallelSetAll(la, n -&gt; n))); &#125; catch (OutOfMemoryError e) &#123; System.out.println(\"Insufficient memory\"); System.exit(0); &#125; &#125; &#125;/* OutputsetAll: 272parallelSetAll: 301 main() 方法的主体包含在 try 语句块中，因为一台机器用光内存后会导致构建停止。 对于一个长度为 250,000,000 的 long 型（仅仅差一点就会让大部分机器内存溢出）数组，我们比较了 Arrays.setAll() 和 Arrays.parallelSetAll() 的性能。这个并行的版本会尝试使用多个处理器加快完成任务（尽管我在这一节谈到了一些并行的概念，但是在 并发编程 章节我们才会详细讨论这些 ）。然而非并行的版本似乎运行得更快，尽管在不同的机器上结果可能不同。 BadMicroBenchmark.java 中的==每一步操作都是独立的，但是如果你的操作依赖于同一资源，那么并行版本运行的速度会骤降，因为不同的进程会竞争相同的那个资源。== 123456789101112131415161718192021222324// validating/BadMicroBenchmark2.java// Relying on a common resourceimport java.util.*;import onjava.Timer;public class BadMicroBenchmark2 &#123; static final int SIZE = 5_000_000; public static void main(String[] args) &#123; long[] la = new long[SIZE]; Random r = new Random(); System.out.println(\"parallelSetAll: \" + Timer.duration(() -&gt; Arrays.parallelSetAll(la, n -&gt; r.nextLong()))); System.out.println(\"setAll: \" + Timer.duration(() -&gt; Arrays.setAll(la, n -&gt; r.nextLong()))); SplittableRandom sr = new SplittableRandom(); System.out.println(\"parallelSetAll: \" + Timer.duration(() -&gt; Arrays.parallelSetAll(la, n -&gt; sr.nextLong()))); System.out.println(\"setAll: \" + Timer.duration(() -&gt; Arrays.setAll(la, n -&gt; sr.nextLong()))); &#125;&#125;/* OutputparallelSetAll: 1147setAll: 174parallelSetAll: 86setAll: 39 SplittableRandom 是为并行算法设计的，它当然看起来比普通的 Random 在 parallelSetAll() 中运行得更快。 但是看上去还是比非并发的 setAll() 运行时间更长，有点难以置信（也许是真的，但我们不能通过一个坏的微基准测试得到这个结论）。 这只考虑了微基准测试的问题。Java 虚拟机 Hotspot 也非常影响性能。如果你在测试前没有通过运行代码给 JVM 预热，那么你就会得到“冷”的结果，不能反映出代码在 JVM 预热之后的运行速度（假如你运行的应用没有在预热的 JVM 上运行，你就可能得不到所预期的性能，甚至可能减缓速度）。 优化器有时可以检测出你创建了没有使用的东西，或者是部分代码的运行结果对程序没有影响。如果它优化掉你的测试，那么你可能得到不好的结果。 一个良好的微基准测试系统能自动地弥补像这样的问题（和很多其他的问题）从而产生合理的结果，但是创建这么一套系统是非常棘手，需要深入的知识。 JMH 的引入截止目前为止，唯一能产生像样结果的 Java 微基准测试系统就是 Java Microbenchmarking Harness，简称 JMH。本书的 build.gradle 自动引入了 JMH 的设置，所以你可以轻松地使用它。 你可以在命令行编写 JMH 代码并运行它，但是推荐的方式是让 JMH 系统为你运行测试；build.gradle 文件已经配置成只需要一条命令就能运行 JMH 测试。 JMH 尝试使基准测试变得尽可能简单。例如，我们将使用 JMH 重新编写 BadMicroBenchmark.java。这里只有 @State 和 @Benchmark 这两个注解是必要的。其余的注解要么是为了产生更多易懂的输出，要么是加快基准测试的运行速度（JMH 基准测试通常需要运行很长时间）： 123456789101112131415161718192021222324252627282930// validating/jmh/JMH1.javapackage validating.jmh;import java.util.*;import org.openjdk.jmh.annotations.*;import java.util.concurrent.TimeUnit;@State(Scope.Thread)@BenchmarkMode(Mode.AverageTime)@OutputTimeUnit(TimeUnit.MICROSECONDS)// Increase these three for more accuracy:@Warmup(iterations = 5)@Measurement(iterations = 5)@Fork(1)public class JMH1 &#123; private long[] la; @Setup public void setup() &#123; la = new long[250_000_000]; &#125; @Benchmark public void setAll() &#123; Arrays.setAll(la, n -&gt; n); &#125; public void parallelSetAll() &#123; Arrays.parallelSetAll(la, n -&gt; n); &#125;&#125; “forks” 的默认值是 10，意味着每个测试都运行 10 次。为了减少运行时间，这里使用了 @Fork 注解来减少这个次数到 1。我还使用了 @Warmup 和 @Measurement 注解将它们默认的运行次数从 20 减少到 5 次。尽管这降低了整体的准确率，但是结果几乎与使用默认值相同。可以尝试将 @Warmup、@Measurement 和 @Fork 都注释掉然后看使用它们的默认值，结果会有多大显著的差异；一般来说，你应该只能看到长期运行的测试使错误因素减少，而结果没有多大变化。 需要使用显式的 gradle 命令才能运行基准测试（在示例代码的根目录处运行）。这能防止耗时的基准测试运行其他的 gradlew 命令： gradlew validating:jmh 这会花费几分钟的时间，取决于你的机器(如果没有注解上的调整，可能需要几个小时)。控制台会显示 results.txt 文件的路径，这个文件统计了运行结果。注意，results.txt 包含这一章所有 jmh 测试的结果：JMH1.java，JMH2.java 和 JMH3.java。 因为输出是绝对时间，所以在不同的机器和操作系统上结果各不相同。重要的因素不是绝对时间，我们真正观察的是一个算法和另一个算法的比较，尤其是哪一个运行得更快，快多少。如果你在自己的机器上运行测试，你将看到不同的结果却有着相同的模式。 我在大量的机器上运行了这些测试，尽管不同的机器上得到的绝对值结果不同，但是相对值保持着合理的稳定性。我只列出了 results.txt 中适当的片段并加以编辑使输出更加易懂，而且内容大小适合页面。所有测试中的 Mode 都以 avgt 展示，代表 “平均时长”。Cnt（测试的数目）的值是 200，尽管这里的一个例子中配置的 Cnt 值是 5。Units 是 us/op，是 “Microseconds per operation” 的缩写，因此，这个值越小代表性能越高。 我同样也展示了使用 warmups、measurements 和 forks 默认值的输出。我删除了示例中相应的注解，就是为了获取更加准确的测试结果（这将花费数小时）。结果中数字的模式应该仍然看起来相同，不论你如何运行测试。 下面是 JMH1.java 的运行结果： Benchmark Score JMH1.setAll 196280.2 JMH1.parallelSetAll 195412.9 即使像 JMH 这么高级的基准测试工具，基准测试的过程也不容易，练习时需要倍加小心。这里测试产生了反直觉的结果：并行的版本 parallelSetAll() 花费了与非并行版本的 setAll() 相同的时间，两者似乎都运行了相当长的时间。 当创建这个示例时，我假设如果我们要测试数组初始化的话，那么使用非常大的数组是有意义的。所以我选择了尽可能大的数组；如果你实验的话会发现一旦数组的大小超过 2亿5000万，你就开始会得到内存溢出的异常。然而，在这么大的数组上执行大量的操作从而震荡内存系统，产生无法预料的结果是有可能的。不管这个假设是否正确，看上去我们正在测试的并非是我们想测试的内容。 考虑其他的因素： C：客户端执行操作的线程数量 P：并行算法使用的并行数量 N：数组的大小：10^(2*k)，通常来说，k=1..7 足够来练习不同的缓存占用。 Q：setter 的操作成本 这个 C/P/N/Q 模型在早期 JDK 8 的 Lambda 开发期间付出水面，大多数并行的 Stream 操作(parallelSetAll() 也基本相似)都满足这些结论：N*Q(主要工作量)对于并发性能尤为重要。并行算法在工作量较少时可能实际运行得更慢。 在一些情况下操作竞争如此激烈使得并行毫无帮助，而不管 N*Q 有多大。当 C 很大时，P 就变得不太相关（内部并行在大量的外部并行面前显得多余）。此外，在一些情况下，并行分解会让相同的 C 个客户端运行得比它们顺序运行代码更慢。 基于这些信息，我们重新运行测试，并在这些测试中使用不同大小的数组（改变 N）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// validating/jmh/JMH2.javapackage validating.jmh;import java.util.*;import org.openjdk.jmh.annotations.*;import java.util.concurrent.TimeUnit;@State(Scope.Thread)@BenchmarkMode(Mode.AverageTime)@OutputTimeUnit(TimeUnit.MICROSECONDS)@Warmup(iterations = 5)@Measurement(iterations = 5)@Fork(1)public class JMH2 &#123; private long[] la; @Param(&#123; \"1\", \"10\", \"100\", \"1000\", \"10000\", \"100000\", \"1000000\", \"10000000\", \"100000000\", \"250000000\" &#125;) int size; @Setup public void setup() &#123; la = new long[size]; &#125; @Benchmark public void setAll() &#123; Arrays.setAll(la, n -&gt; n); &#125; @Benchmark public void parallelSetAll() &#123; Arrays.parallelSetAll(la, n -&gt; n); &#125;&#125; @Param 会自动地将其自身的值注入到变量中。其自身的值必须是字符串类型，并可以转化为适当的类型，在这个例子中是 int 类型。 下面是已经编辑过的结果，包含精确计算出的加速数值： JMH2 Benchmark Size Score % Speedup setAll 1 0.001 parallelSetAll 1 0.036 0.028 setAll 10 0.005 parallelSetAll 10 3.965 0.001 setAll 100 0.031 parallelSetAll 100 3.145 0.010 setAll 1000 0.302 parallelSetAll 1000 3.285 0.092 setAll 10000 3.152 parallelSetAll 10000 9.669 0.326 setAll 100000 34.971 parallelSetAll 100000 20.153 1.735 setAll 1000000 420.581 parallelSetAll 1000000 165.388 2.543 setAll 10000000 8160.054 parallelSetAll 10000000 7610.190 1.072 setAll 100000000 79128.752 parallelSetAll 100000000 76734.671 1.031 setAll 250000000 199552.121 parallelSetAll 250000000 191791.927 1.040 可以看到当数组大小达到 10 万左右时，parallelSetAll() 开始反超，而后趋于与非并行的运行速度相同。即使它运行速度上胜了，看起来也不足以证明由于并行的存在而使速度变快。 setAll()/parallelSetAll() 中工作的计算量起很大影响吗？在前面的例子中，我们所做的只有对数组的赋值操作，这可能是最简单的任务。所以即使 N 值变大，N*Q 也仍然没有达到巨大，所以看起来像是我们没有为并行提供足够的机会（JMH 提供了一种模拟变量 Q 的途径；如果想了解更多的话，可搜索 Blackhole.consumeCPU）。 我们通过使方法 f() 中的任务变得更加复杂，从而产生更多的并行机会： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// validating/jmh/JMH3.javapackage validating.jmh;import java.util.*;import org.openjdk.jmh.annotations.*;import java.util.concurrent.TimeUnit;@State(Scope.Thread)@BenchmarkMode(Mode.AverageTime)@OutputTimeUnit(TimeUnit.MICROSECONDS)@Warmup(iterations = 5)@Measurement(iterations = 5)@Fork(1)public class JMH3 &#123; private long[] la; @Param(&#123; \"1\", \"10\", \"100\", \"1000\", \"10000\", \"100000\", \"1000000\", \"10000000\", \"100000000\", \"250000000\" &#125;) int size; @Setup public void setup() &#123; la = new long[size]; &#125; public static long f(long x) &#123; long quadratic = 42 * x * x + 19 * x + 47; return Long.divideUnsigned(quadratic, x + 1); &#125; @Benchmark public void setAll() &#123; Arrays.setAll(la, n -&gt; f(n)); &#125; @Benchmark public void parallelSetAll() &#123; Arrays.parallelSetAll(la, n -&gt; f(n)); &#125;&#125; f() 方法提供了更加复杂且耗时的操作。现在除了简单的给数组赋值外，setAll() 和 parallelSetAll() 都有更多的工作去做，这肯定会影响结果。 JMH2 Benchmark Size Score % Speedup setAll 1 0.012 parallelSetAll 1 0.047 0.255 setAll 10 0.107 parallelSetAll 10 3.894 0.027 setAll 100 0.990 parallelSetAll 100 3.708 0.267 setAll 1000 133.814 parallelSetAll 1000 11.747 11.391 setAll 10000 97.954 parallelSetAll 10000 37.259 2.629 setAll 100000 988.475 parallelSetAll 100000 276.264 3.578 setAll 1000000 9203.103 parallelSetAll 1000000 2826.974 3.255 setAll 10000000 92144.951 parallelSetAll 10000000 28126.202 3.276 setAll 100000000 921701.863 parallelSetAll 100000000 266750.543 3.455 setAll 250000000 2299127.273 parallelSetAll 250000000 538173.425 4.272 可以看到当数组的大小达到 1000 左右时，parallelSetAll() 的运行速度反超了 setAll()。==看来 parallelSetAll() 严重依赖数组中计算的复杂度。==这正是基准测试的价值所在，因为我们已经得到了关于 setAll() 和 parallelSetAll() 间微妙的信息，知道在何时使用它们。 这显然不是从阅读 Javadocs 就能得到的。 大多数时候，JMH 的简单应用会产生好的结果（正如你将在本书后面例子中所见），但是我们从这里知道，你不能一直假定 JMH 会产生好的结果。 JMH 网站上的范例可以帮助你开始。 剖析和优化有时你必须检测程序运行时间花在哪儿，从而看是否可以优化那一块的性能。剖析器可以找到这些导致程序慢的地方，因而你可以找到最轻松，最明显的方式加快程序运行速度。 剖析器收集的信息能显示程序哪一部分消耗内存，哪个方法最耗时。一些剖析器甚至能关闭垃圾回收，从而帮助限定内存分配的模式。 剖析器还可以帮助检测程序中的线程死锁。注意剖析和基准测试的区别。剖析关注的是已经运行在真实数据上的整个程序，而基准测试关注的是程序中隔离的片段，通常是去优化算法。 安装 Java 开发工具包（JDK）时会顺带安装一个虚拟的剖析器，叫做 ==VisualVM。==它会被自动安装在与 javac 相同的目录下，你的执行路径应该已经包含该目录。启动 VisualVM 的控制台命令是： &gt; jvisualvm 运行该命令后会弹出一个窗口，其中包括一些指向帮助信息的链接。 优化准则 避免为了性能牺牲代码的可读性。 不要独立地看待性能。衡量与带来的收益相比所需投入的工作量。 程序的大小很重要。性能优化通常只对运行了长时间的大型项目有价值。性能通常不是小项目的关注点。 运行起来程序比一心钻研它的性能具有更高的优先级。一旦你已经有了可工作的程序，如有必要的话，你可以使用剖析器提高它的效率。只有当性能是关键因素时，才需要在设计/开发阶段考虑性能。 不要猜测瓶颈发生在哪。运行剖析器，让剖析器告诉你。 无论何时有可能的话，显式地设置实例为 null 表明你不再用它。这对垃圾收集器来说是个有用的暗示。 ==static final 修饰的变量会被 JVM 优化从而提高程序的运行速度。==因而程序中的常量应该声明 static final。 风格检测当你在一个团队中工作时(包括尤其是开源项目)，让每个人遵循相同的代码风格是非常有帮助的。这样阅读项目的代码时，不会因为风格的不同产生思维上的中断。然而，如果你习惯了某种不同的代码风格，那么记住项目中所有的风格准则对你来说可能是困难的。幸运的是，存在可以指出你代码中不符合风格准则的工具。 一个流行的风格检测器是 Checkstyle。查看本书 示例代码 中的 gradle.build 和 checkstyle.xml 文件中配置代码风格的方式。checkstyle.xml 是一个常用检测的集合，其中一些检测被注释掉了以允许使用本书中的代码风格。 运行所有风格检测的命令是： gradlew checkstyleMain 一些文件仍然产生了风格检测警告，通常是因为这些例子展示了你在生产代码中不会使用的样例。 你还可以针对一个具体的章节运行代码检测。例如，下面命令会运行 Annotations 章节的风格检测： gradlew annotations:checkstyleMain 静态错误分析尽管 Java 的静态类型检测可以发现基本的语法错误，其他的分析工具可以发现躲避 javac 检测的更加复杂的bug。一个这样的工具叫做 Findbugs。本书 示例代码 中的 build.gradle 文件包含了 Findbugs 的配置，所以你可以输入如下命令： gradlew findbugsMain 这会为每一章生成一个名为 main.html 的报告，报告中会说明代码中潜在的问题。Gradle 命令的输出会告诉你每个报告在何处。 当你查看报告时，你将会看到很多 false positive 的情况，即代码没问题却报告了问题。我在一些文件中展示了不要做一些事的代码确实是正确的。 当我最初看到本书的 Findbugs 报告时，我发现了一些不是技术错误的地方，但能使我改善代码。如果你正在寻找 bug，那么在调试之前运行 Findbugs 是值得的，因为这将可能节省你数小时的时间找到问题。 代码重审单元测试能找到明显重要的 bug 类型，风格检测和 Findbugs 能自动执行代码重审，从而发现额外的问题。最终你走到了必须人为参与进来的地步。代码重审是一个或一群人的一段代码被另一个或一群人阅读和评估的众多方式之一。这最初看起来会使人不安，而且需要情感信任，但它的目的肯定不是羞辱任何人。它的目标是找到程序中的错误，代码重审是最成功的能做到这点的途径之一。可惜的是，它们也经常被认为是“过于昂贵的”（有时这会成为程序员避免代码被重审时感到尴尬的借口）。 代码重审可以作为结对编程的一部分，作为代码签入过程的一部分（另一个程序员自动安排上审查新代码的任务）或使用群组预排的方式，即每个人阅读代码并讨论之。后一种方式对于分享知识和营造代码文化是极其有益的。 结对编程结对编程是指两个程序员一起编程的实践活动。通常来说，一个人“驱动”（敲击键盘，输入代码），另一人（观察者或指引者）重审和分析代码，同时也要思考策略。这产生了一种实时的代码重审。通常程序员会定期地互换角色。 结对编程有很多好处，但最显著的是分享知识和防止阻塞。最佳传递信息的方式之一就是一起解决问题，我已经在很多次研讨会使用了结对编程，都取得了很好的效果（同时，研讨会上的众人可以通过这种方式互相了解对方）。而且两个人一起工作时，可以更容易地推进开发的进展，而只有一个程序员的话，可能被轻易地卡住。结对编程的程序员通常可以从工作中感到更高的满足感。有时很难向管理人员们推行结对编程，因为他们可能觉得两个程序员解决同一个问题的效率比他们分开解决不同问题的效率低。尽管短期内是这样，但是结对编程能带来更高的代码质量；除了结对编程的其他益处，如果你眼光长远的话，这会产生更高的生产力。 维基百科上这篇 结对编程的文章 可以作为你深入了解结对编程的开始。 重构技术负债是指迭代发展的软件中为了应急而生的丑陋解决方案从而导致设计难以理解，代码难以阅读的部分。特别是当你必须修改和增加新特性的时候，这会造成麻烦。 重构可以矫正技术负债。重构的关键是它能改善代码设计，结构和可读性（因而减少代码负债），但是它不能改变代码的行为。 很难向管理人员推行重构：“我们将投入很多工作不是增加新的特性，当我们完成时，外界无感知变化。但是相信我们，事情会变得更加美好”。不幸的是，管理人员意识到重构的价值时都为时已晚了：当他们提出增加新的特性时，你不得不告诉他们做不到，因为代码基底已经埋藏了太多的问题，试图增加新特性可能会使软件崩溃，即使你能想出怎么做。 重构基石在开始重构代码之前，你需要有以下三个系统的支撑： 测试（通常，JUnit 测试作为最小的根基），因此你能确保重构不会改变代码的行为。 自动构建，因而你能轻松地构建代码，运行所有的测试。通过这种方式做些小修改并确保修改不会破坏任何事物是毫不费力的。本书使用的是 Gradle 构建系统，你可以在 代码示例 的 build.gradle 文件中查看示例。 版本控制，以便你能回退到可工作的代码版本，能够一直记录重构的每一步。 本书的代码托管在 Github 上，使用的是 git 版本控制系统。 没有这三个系统的支持，重构几乎是不可能的。确实，没有这些系统，起初维护和增加代码是一个巨大的挑战。令人意外的是，有很多成功的公司竟然在没有这三个系统的情况下在相当长的时间里勉强过得去。然而，对于这样的公司来说，在他们遇到严重的问题之前，这只是个时间问题。 维基百科上的 重构文章 提供了更多的细节。 持续集成在软件开发的早期，人们只能一次处理一步，所以他们坚信他们总是在经历快乐之旅，每个开发阶段无缝进入下一个。这种错觉经常被称为软件开发中的“瀑布流模型”。很多人告诉我瀑布流是他们的选择方法，好像这是一个选择工具，而不仅是一厢情愿。 在这片童话的土地上，每一步都按照指定的预计时间准时完美结束，然后下一步开始。当最后一步结束时，所有的部件都可以无缝地滑在一起，瞧，一个装载产品诞生了！ 当然，现实中没有事能按计划或预计时间运作。相信它应该，然后当它不能时更加相信，只会使整件事变得更糟。否认证据不会产生好的结果。 除此之外，产品本身经常也不是对客户有价值的事物。有时一大堆的特性完全是浪费时间，因为创造出这些特性需求的人不是客户而是其他人。 因为受流水工作线的思路影响，所以每个开发阶段都有自己的团队。上游团队的延期传递到下游团队，当到了需要进行测试和集成的时候，这些团队被指望赶上预期时间，当他们必然做不到时，就认为他们是“差劲的团队成员”。不可能的时间安排和负相关的结合产生了自实现的预期：只有最绝望的开发者才会乐意做这些工作。 另外，商学院培养出的管理人员仍然被训练成只在已有的流程上做一些改动——这些流程都是基于工业时代制造业的想法上。注重培养创造力而不是墨守成规的商学院仍然很稀有。终于一些编程领域的人们再也忍受不了这种情况并开始进行实验。最初一些实验叫做“极限编程”，因为它们与工业时代的思想完全不同。随着实验展示的结果，这些思想开始看起来像是常识。这些实验逐渐形成了如今显而易见的观点——尽管非常小——即把生产可运作的产品交到客户手中，询问他们 (A) 是否想要它 (B) 是否喜欢它工作的方式 (C) 还希望有什么其他有用的功能特性。然后这些信息反馈给开发，从而继续产出一个新版本。版本不断迭代，项目最终演变成为客户带来真正价值的事物。 这完全颠倒了瀑布流开发的方式。你停止假设你要处理产品测试和把部署”作为最后一步”这类的事情。相反，每件事从开始到结束必须都在进行——即使一开始产品几乎没有任何特性。这么做对于在开发周期的早期发现更多问题有巨大的益处。此外，不是做大量宏大超前的计划和花费时间金钱在许多无用的特性上，而是一直都能从顾客那得到反馈。当客户不再需要其他特性时，你就完成了。这节省了大量的时间和金钱，并提高了顾客的满意度。 有许多不同的想法导向这种方式，但是目前首要的术语叫持续集成（CI）。CI 与导向 CI 的想法之间的不同之处在于 CI 是一种独特的机械式的过程，过程中涵盖了这些想法；它是一种定义好的做事方式。事实上，它定义得如此明确以至于整个过程是自动化的。 当前 CI 技术的高峰是持续集成服务器。这是一台独立的机器或虚拟机，通常是由第三方公司托管的完全独立的服务。这些公司通常免费提供基本服务，如果你需要额外的特性如更多的处理器或内存或者专门的工具或系统，你需要付费。CI 服务器起初是完全空白状态，即只是可用的操作系统的最小配置。这很重要因为你可能之前在你的开发机器上安装过一些程序，却没有在你的构建和部署系统中包含它。正如重构一样，持续集成需要分布式版本管理，自动构建和自动测试系统作为基础。通常来说，CI 服务器会绑定到你的版本控制仓库上。当 CI 服务器发现仓库中有改变时，就会拉取最新版本的代码，并按照 CI 脚本中的过程处理。这包括安装所有必要的工具和类库（记住，CI 服务器起初只有一个干净、基本的操作系统），所以如果过程中出现任何问题，你都可以发现它们。接着它会执行脚本中定义的构建和测试操作；通常脚本中使用的命令与人们在安装和测试中使用的命令完全相同。如果执行成功或失败，CI 服务器会有许多种方式汇报给你，包括在你的代码仓库上显示一个简单的标记。 使用持续集成，每次你合进仓库时，这些改变都会被从头到尾验证。通过这种方式，一旦出现问题你能立即发现。甚至当你准备交付一个产品的新版本时，都不会有延迟或其他必要的额外步骤（在任何时刻都可以交付叫做持续交付）。 本书的示例代码都是在 Travis-CI(基于 Linux 的系统) 和 AppVeyor(Windows) 上自动测试的。你可以在 Gihub仓库 上的 Readme 看到通过/失败的标记。 本章小结“它在我的机器上正常工作了。” “我们不会运载你的机器！” 代码校验不是单一的过程或技术。每种方法只能发现特定类型的 bug，作为程序员的你在开发过程中会明白每个额外的技术都能增加代码的可靠性和鲁棒性。校验不仅能在开发过程中，还能在为应用添加新功能的整个项目期间帮你发现更多的错误。现代化开发意味着比仅仅编写代码更多的内容，每种你在开发过程中融入的测试技术—— 包括而且尤其是你创建的能适应特定应用的自定义工具——都会带来更好、更快和更加愉悦的开发过程，同时也能为客户提供更高的价值和满意度体验。 第十八章 字符串 字符串操作毫无疑问是计算机程序设计中最常见的行为之一。 在 Java 大展拳脚的 Web 系统中更是如此。 字符串的不可变==String 对象是不可变的==。查看 JDK 文档你就会发现，String 类中每一个看起来会修改 String 值的方法，实际上都是创建了一个全新的 String 对象，以包含修改后的字符串内容。而最初的 String 对象则丝毫未动。 看看下面的代码： 123456789101112131415161718// strings/Immutable.javapublic class Immutable &#123; public static String upcase(String s) &#123; return s.toUpperCase(); &#125; public static void main(String[] args) &#123; String q = \"howdy\"; System.out.println(q); // howdy String qq = upcase(q); System.out.println(qq); // HOWDY System.out.println(q); // howdy &#125; &#125; /* Output: howdyHOWDY howdy*/ 当把 q 传递给 upcase() 方法时，实际传递的是引用的一个拷贝。其实，每当把 String 对象作为方法的参数时，都会复制一份引用，而该引用所指向的对象其实一直待在单一的物理位置上，从未动过。 回到 upcase() 的定义，传入其中的引用有了名字 s，只有 upcase() 运行的时候，局部引用 s 才存在。一旦 upcase() 运行结束，s 就消失了。当然了，upcase() 的返回值，其实是最终结果的引用。这足以说明，upcase() 返回的引用已经指向了一个新的对象，而 q 仍然在原来的位置。 String 的这种行为正是我们想要的。例如： 12String s = \"asdf\";String x = Immutable.upcase(s); 难道你真的希望 upcase() 方法改变其参数吗？对于一个方法而言，参数是为该方法提供信息的，而不是想让该方法改变自己的。在阅读这段代码时，读者自然会有这样的感觉。这一点很重要，正是有了这种保障，才使得代码易于编写和阅读。 + 的重载与 StringBuilderString 对象是不可变的，你可以给一个 String 对象添加任意多的别名。因为 String 是只读的，所以指向它的任何引用都不可能修改它的值，因此，也就不会影响到其他引用。 不可变性会带来一定的效率问题。为 String 对象重载的 + 操作符就是一个例子。重载的意思是，一个操作符在用于特定的类时，被赋予了特殊的意义（用于 String 的 + 与 += 是 Java 中仅有的两个重载过的操作符，Java 不允许程序员重载任何其他的操作符 [^1]）。 操作符 + 可以用来连接 String： 123456789101112// strings/Concatenation.javapublic class Concatenation &#123; public static void main(String[] args) &#123; String mango = \"mango\"; String s = \"abc\" + mango + \"def\" + 47; System.out.println(s); &#125; &#125;/* Output:abcmangodef47 */ 可以想象一下，这段代码是这样工作的：String 可能有一个 append() 方法，它会生成一个新的 String 对象，以包含“abc”与 mango 连接后的字符串。该对象会再创建另一个新的 String 对象，然后与“def”相连，生成另一个新的对象，依此类推。 这种方式当然是可行的，但是为了生成最终的 String 对象，会产生一大堆需要垃圾回收的中间对象。我猜想，Java 设计者一开始就是这么做的（这也是软件设计中的一个教训：除非你用代码将系统实现，并让它运行起来，否则你无法真正了解它会有什么问题），然后他们发现其性能相当糟糕。 想看看以上代码到底是如何工作的吗？可以用 JDK 自带的 javap 工具来反编译以上代码。命令如下： 1javap -c Concatenation 这里的 -c 标志表示将生成 JVM 字节码。我们剔除不感兴趣的部分，然后做细微的修改，于是有了以下的字节码： 12345678910111213141516171819202122public static void main(java.lang.String[]); Code: Stack=2, Locals=3, Args_size=1 0: ldc #2; //String mango 2: astore_1 3: new #3; //class StringBuilder 6: dup 7: invokespecial #4; //StringBuilder.\"&lt;init&gt;\":() 10: ldc #5; //String abc 12: invokevirtual #6; //StringBuilder.append:(String) 15: aload_1 16: invokevirtual #6; //StringBuilder.append:(String) 19: ldc #7; //String def 21: invokevirtual #6; //StringBuilder.append:(String) 24: bipush 47 26: invokevirtual #8; //StringBuilder.append:(I) 29: invokevirtual #9; //StringBuilder.toString:() 32: astore_2 33: getstatic #10; //Field System.out:PrintStream; 36: aload_2 37: invokevirtual #11; //PrintStream.println:(String) 40: return 如果你有汇编语言的经验，以上代码应该很眼熟(其中的 dup 和 invokevirtual 语句相当于Java虚拟机上的汇编语句。即使你完全不了解汇编语言也无需担心)。需要重点注意的是：编译器自动引入了 java.lang.StringBuilder 类。虽然源代码中并没有使用 StringBuilder 类，但是编译器却自作主张地使用了它，就因为它更高效。 在这里，编译器创建了一个 StringBuilder 对象，用于构建最终的 String，并对每个字符串调用了一次 append() 方法，共计 4 次。最后调用 toString() 生成结果，并存为 s (使用的命令为 astore_2)。 现在，也许你会觉得可以随意使用 String 对象，反正编译器会自动为你做性能优化。可是在这之前，让我们更深入地看看编译器能为我们优化到什么程度。下面的例子采用两种方式生成一个 String：方法一使用了多个 String 对象；方法二在代码中使用了 StringBuilder。 123456789101112131415161718// strings/WhitherStringBuilder.javapublic class WhitherStringBuilder &#123; public String implicit(String[] fields) &#123; String result = \"\"; for(String field : fields) &#123; result += field; &#125; return result; &#125; public String explicit(String[] fields) &#123; StringBuilder result = new StringBuilder(); for(String field : fields) &#123; result.append(field); &#125; return result.toString(); &#125;&#125; 现在运行 javap -c WitherStringBuilder，可以看到两种不同方法（我已经去掉不相关的细节）对应的字节码。首先是 implicit() 方法： 123456789101112131415161718192021222324252627282930public java.lang.String implicit(java.lang.String[]); 0: ldc #2 // String 2: astore_23: aload_1 4: astore_3 5: aload_3 6: arraylength 7: istore 4 9: iconst_0 10: istore 5 12: iload 5 14: iload 4 16: if_icmpge 51 19: aload_3 20: iload 5 22: aaload 23: astore 6 25: new #3 // StringBuilder 28: dup 29: invokespecial #4 // StringBuilder.\"&lt;init&gt;\"32: aload_2 33: invokevirtual #5 // StringBuilder.append:(String) 36: aload 6 38: invokevirtual #5 // StringBuilder.append:(String;) 41: invokevirtual #6 // StringBuilder.toString:() 44: astore_2 45: iinc 5, 1 48: goto 12 51: aload_2 52: areturn 注意从第 16 行到第 48 行构成了一个循环体。第 16 行：对堆栈中的操作数进行“大于或等于的整数比较运算”，循环结束时跳转到第 51 行。第 48 行：重新回到循环体的起始位置（第 12 行）。注意：StringBuilder 是在循环内构造的，这意味着每进行一次循环，会创建一个新的 StringBuilder 对象。 下面是 explicit() 方法对应的字节码： 12345678910111213141516171819202122232425262728public java.lang.String explicit(java.lang.String[]); 0: new #3 // StringBuilder 3: dup4: invokespecial #4 // StringBuilder.\"&lt;init&gt;\" 7: astore_2 8: aload_1 9: astore_3 10: aload_3 11: arraylength 12: istore 4 14: iconst_0 15: istore 5 17: iload 5 19: iload 4 21: if_icmpge 43 24: aload_3 25: iload 5 27: aaload 28: astore 6 30: aload_2 31: aload 6 33: invokevirtual #5 // StringBuilder.append:(String) 36: pop37: iinc 5, 1 40: goto 17 43: aload_2 44: invokevirtual #6 // StringBuilder.toString:() 47: areturn 可以看到，不仅循环部分的代码更简短、更简单，而且它只生成了一个 StringBuilder 对象。显式地创建 StringBuilder 还允许你预先为其指定大小。如果你已经知道最终字符串的大概长度，那预先指定 StringBuilder 的大小可以避免频繁地重新分配缓冲。 因此，当你为一个类编写 toString() 方法时，如果字符串操作比较简单，那就可以信赖编译器，它会为你合理地构造最终的字符串结果。但是，如果你要在 toString() 方法中使用循环，且可能有性能问题，那么最好自己创建一个 StringBuilder 对象，用它来构建最终结果。请参考以下示例： 12345678910111213141516171819202122232425262728293031323334// strings/UsingStringBuilder.java import java.util.*; import java.util.stream.*; public class UsingStringBuilder &#123; public static String string1() &#123; Random rand = new Random(47); StringBuilder result = new StringBuilder(\"[\"); for(int i = 0; i &lt; 25; i++) &#123; result.append(rand.nextInt(100)); result.append(\", \"); &#125; result.delete(result.length()-2, result.length()); result.append(\"]\"); return result.toString(); &#125; public static String string2() &#123; String result = new Random(47) .ints(25, 0, 100) .mapToObj(Integer::toString) .collect(Collectors.joining(\", \")); return \"[\" + result + \"]\"; &#125; public static void main(String[] args) &#123; System.out.println(string1()); System.out.println(string2()); &#125;&#125; /* Output: [58, 55, 93, 61, 61, 29, 68, 0, 22, 7, 88, 28, 51, 89, 9, 78, 98, 61, 20, 58, 16, 40, 11, 22, 4] [58, 55, 93, 61, 61, 29, 68, 0, 22, 7, 88, 28, 51, 89,9, 78, 98, 61, 20, 58, 16, 40, 11, 22, 4] */ 在方法 string1() 中，最终结果是用 append() 语句拼接起来的。如果你想走捷径，例如：append(a + &quot;: &quot; + c)，编译器就会掉入陷阱，从而为你另外创建一个 StringBuilder 对象处理括号内的字符串操作。如果拿不准该用哪种方式，随时可以用 javap 来分析你的程序。 StringBuilder 提供了丰富而全面的方法，包括 insert()、replace()、substring()，甚至还有reverse()，但是最常用的还是 append() 和 toString()。还有 delete()，上面的例子中我们用它删除最后一个逗号和空格，以便添加右括号。 string2() 使用了 Stream，这样代码更加简洁美观。可以证明，Collectors.joining() 内部也是使用的 StringBuilder，这种写法不会影响性能！ StringBuilder是 Java SE5 引入的，在这之前用的是 StringBuffer。后者是线程安全的（参见并发编程），因此开销也会大些。使用 StringBuilder 进行字符串操作更快一点。 意外递归如果你真的想要打印对象的内存地址，应该调用 Object.toString() 方法，这才是负责此任务的方法。所以，不要使用 this，而是应该调用 super.toString() 方法。 Java 中的每个类从根本上都是继承自 Object，标准集合类也是如此，它们都有 toString() 方法，并且覆盖了该方法，使得它生成的 String 结果能够表达集合自身，以及集合包含的对象。例如 ArrayList.toString()，它会遍历 ArrayList 中包含的所有对象，调用每个元素上的 toString() 方法： 1234567891011121314151617// strings/ArrayListDisplay.java import java.util.*;import java.util.stream.*; import generics.coffee.*;public class ArrayListDisplay &#123; public static void main(String[] args) &#123; List&lt;Coffee&gt; coffees = Stream.generate(new CoffeeSupplier()) .limit(10) .collect(Collectors.toList()); System.out.println(coffees); &#125; &#125;/* Output: [Americano 0, Latte 1, Americano 2, Mocha 3, Mocha 4, Breve 5, Americano 6, Latte 7, Cappuccino 8, Cappuccino 9] */ 如果你希望 toString() 打印出类的内存地址，也许你会考虑使用 this 关键字： 123456789101112131415161718// strings/InfiniteRecursion.java // Accidental recursion // &#123;ThrowsException&#125; // &#123;VisuallyInspectOutput&#125; Throws very long exceptionimport java.util.*;import java.util.stream.*;public class InfiniteRecursion &#123; @Override public String toString() &#123; return \" InfiniteRecursion address: \" + this + \"\\n\" &#125; public static void main(String[] args) &#123; Stream.generate(InfiniteRecursion::new) .limit(10) .forEach(System.out::println); &#125; &#125; 当你创建了 InfiniteRecursion 对象，并将其打印出来的时候，你会得到一串很长的异常信息。如果你将该 InfiniteRecursion 对象存入一个 ArrayList 中，然后打印该 ArrayList，同样也会抛出异常。其实，当运行到如下代码时： 1\"InfiniteRecursion address: \" + this 这里发生了自动类型转换，由 InfiniteRecursion 类型转换为 String 类型。因为编译器发现一个 String 对象后面跟着一个 “+”，而 “+” 后面的对象不是 String，于是编译器试着将 this 转换成一个 String。它怎么转换呢？正是通过调用 this 上的 toString() 方法，于是就发生了递归调用。 字符串操作以下是 String 对象具备的一些基本方法。重载的方法归纳在同一行中： 方法 参数，重载版本 作用 构造方法 默认版本，String，StringBuilder，StringBuffer，char数组，byte数组 创建String对象 length() String中字符的个数 charAt() int索引 获取String中索引位置上的char getChars()，getBytes() 待复制部分的开始和结束索引，复制的目标数组，目标数组的开始索引 复制char或byte到一个目标数组中 toCharArray() 生成一个char[]，包含String中的所有字符 equals()，equalsIgnoreCase() 与之进行比较的String 比较两个String的内容是否相同。如果相同，结果为true compareTo()，compareToIgnoreCase() 与之进行比较的String 按词典顺序比较String的内容，比较结果为负数、零或正数。注意，大小写不等价 contains() 要搜索的CharSequence 如果该String对象包含参数的内容，则返回true contentEquals() 与之进行比较的CharSequence或StringBuffer 如果该String对象与参数的内容完全一致，则返回true isEmpty() 返回boolean结果，以表明String对象的长度是否为0 regionMatches() 该String的索引偏移量，另一个String及其索引偏移量，要比较的长度。重载版本增加了“忽略大小写”功能 返回boolean结果，以表明所比较区域是否相等 startsWith() 可能的起始String。重载版本在参数中增加了偏移量 返回boolean结果，以表明该String是否以传入参数开始 endsWith() 该String可能的后缀String 返回boolean结果，以表明此参数是否是该字符串的后缀 indexOf()，lastIndexOf() 重载版本包括：char，char与起始索引，String，String与起始索引 如果该String并不包含此参数，就返回-1；否则返回此参数在String中的起始索引。lastIndexOf()是从后往前搜索 matches() 一个正则表达式 返回boolean结果，以表明该String和给出的正则表达式是否匹配 split() 一个正则表达式。可选参数为需要拆分的最大数量 按照正则表达式拆分String，返回一个结果数组 join()（Java8引入的） 分隔符，待拼字符序列。用分隔符将字符序列拼接成一个新的String 用分隔符拼接字符片段，产生一个新的String substring()（即subSequence()） 重载版本：起始索引；起始索引+终止索引 返回一个新的String对象，以包含参数指定的子串 concat() 要连接的String 返回一个新的String对象，内容为原始String连接上参数String replace() 要替换的字符，用来进行替换的新字符。也可以用一个CharSequence替换另一个CharSequence 返回替换字符后的新String对象。如果没有替换发生，则返回原始的String对象 replaceFirst() 要替换的正则表达式，用来进行替换的String 返回替换首个目标字符串后的String对象 replaceAll() 要替换的正则表达式，用来进行替换的String 返回替换所有目标字符串后的String对象 toLowerCase()，toUpperCase() 将字符的大小写改变后，返回一个新的String对象。如果没有任何改变，则返回原始的String对象 trim() 将String两端的空白符删除后，返回一个新的String对象。如果没有任何改变，则返回原始的String对象 valueOf()（static） 重载版本：Object；char[]；char[]，偏移量，与字符个数；boolean；char；int；long；float；double 返回一个表示参数内容的String intern() 为每个唯一的字符序列生成一个且仅生成一个String引用 format() 要格式化的字符串，要替换到格式化字符串的参数 返回格式化结果String 从这个表可以看出，当需要改变字符串的内容时，String 类的方法都会返回一个新的 String 对象。同时，如果内容不改变，String 方法只是返回原始对象的一个引用而已。这可以节约存储空间以及避免额外的开销。 本章稍后还将介绍正则表达式在 String 方法中的应用。 格式化输出在长久的等待之后，Java SE5 终于推出了 C 语言中 printf() 风格的格式化输出这一功能。这不仅使得控制输出的代码更加简单，同时也给与Java开发者对于输出格式与排列更强大的控制能力。 printf()C 语言的 printf() 并不像 Java 那样连接字符串，它使用一个简单的格式化字符串，加上要插入其中的值，然后将其格式化输出。 printf() 并不使用重载的 + 操作符（C语言没有重载）来连接引号内的字符串或字符串变量，而是使用特殊的占位符来表示数据将来的位置。而且它还将插入格式化字符串的参数，以逗号分隔，排成一行。例如： 1System.out.printf(\"Row 1: [%d %f]%n\", x, y); 这一行代码在运行的时候，首先将 x 的值插入到 %d_ 的位置，然后将 y 的值插入到 %f 的位置。这些占位符叫做格式修饰符，它们不仅指明了插入数据的位置，同时还指明了将会插入什么类型的变量，以及如何格式化。在这个例子中 %d 表示 x 是一个整数，%f 表示 y 是一个浮点数（float 或者 double）。 System.out.format()Java SE5 引入了 format() 方法，可用于 PrintStream 或者 PrintWriter 对象（你可以在 附录:流式 I/O 了解更多内容），其中也包括 System.out 对象。format() 方法模仿了 C 语言的 printf()。如果你比较怀旧的话，也可以使用 printf()。以下是一个简单的示例： 12345678910111213141516171819// strings/SimpleFormat.java public class SimpleFormat &#123; public static void main(String[] args) &#123; int x = 5; double y = 5.332542; // The old way: System.out.println(\"Row 1: [\" + x + \" \" + y + \"]\"); // The new way: System.out.format(\"Row 1: [%d %f]%n\", x, y); // or System.out.printf(\"Row 1: [%d %f]%n\", x, y); &#125; &#125; /* Output: Row 1: [5 5.332542] Row 1: [5 5.332542] Row 1: [5 5.332542] */ 可以看到，format() 和 printf() 是等价的，它们只需要一个简单的格式化字符串，加上一串参数即可，每个参数对应一个格式修饰符。 String 类也有一个 static format() 方法，可以格式化字符串。 Formatter 类在 Java 中，所有的格式化功能都是由 java.util.Formatter 类处理的。可以将 Formatter 看做一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。当你创建一个 Formatter 对象时，需要向其构造器传递一些信息，告诉它最终的结果将向哪里输出： 12345678910111213141516171819202122232425262728293031323334353637// strings/Turtle.java import java.io.*;import java.util.*;public class Turtle &#123; private String name; private Formatter f; public Turtle(String name, Formatter f) &#123; this.name = name; this.f = f; &#125; public void move(int x, int y) &#123; f.format(\"%s The Turtle is at (%d,%d)%n\", name, x, y); &#125; public static void main(String[] args) &#123; PrintStream outAlias = System.out; Turtle tommy = new Turtle(\"Tommy\", new Formatter(System.out)); Turtle terry = new Turtle(\"Terry\", new Formatter(outAlias)); tommy.move(0,0); terry.move(4,8); tommy.move(3,4); terry.move(2,5); tommy.move(3,3); terry.move(3,3); &#125; &#125; /* Output: Tommy The Turtle is at (0,0) Terry The Turtle is at (4,8) Tommy The Turtle is at (3,4) Terry The Turtle is at (2,5) Tommy The Turtle is at (3,3) Terry The Turtle is at (3,3) */ 格式化修饰符 %s 表明这里需要 String 参数。 所有的 tommy 都将输出到 System.out，而所有的 terry 则都输出到 System.out 的一个别名中。Formatter 的重载构造器支持输出到多个路径，不过最常用的还是 PrintStream()（如上例）、OutputStream 和 File。你可以在 附录:流式 I/O 中了解更多信息。 格式化修饰符在插入数据时，如果想要优化空格与对齐，你需要更精细复杂的格式修饰符。以下是其通用语法： 1%[argument_index$][flags][width][.precision]conversion 最常见的应用是控制一个字段的最小长度，这可以通过指定 width 来实现。Formatter对象通过在必要时添加空格，来确保一个字段至少达到设定长度。默认情况下，数据是右对齐的，不过可以通过使用 - 标志来改变对齐方向。 与 width 相对的是 precision，用于指定最大长度。width 可以应用于各种类型的数据转换，并且其行为方式都一样。precision 则不然，当应用于不同类型的数据转换时，precision 的意义也不同。在将 precision 应用于 String 时，它表示打印 string 时输出字符的最大数量。而在将 precision 应用于浮点数时，它表示小数部分要显示出来的位数（默认是 6 位小数），如果小数位数过多则舍入，太少则在尾部补零。由于整数没有小数部分，所以 precision 无法应用于整数，如果你对整数应用 precision，则会触发异常。 下面的程序应用格式修饰符来打印一个购物收据。这是 Builder 设计模式的一个简单实现，即先创建一个初始对象，然后逐渐添加新东西，最后调用 build() 方法完成构建： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// strings/ReceiptBuilder.java import java.util.*; public class ReceiptBuilder &#123; private double total = 0; private Formatter f = new Formatter(new StringBuilder()); public ReceiptBuilder() &#123; f.format( \"%-15s %5s %10s%n\", \"Item\", \"Qty\", \"Price\"); f.format( \"%-15s %5s %10s%n\", \"----\", \"---\", \"-----\"); &#125; public void add(String name, int qty, double price) &#123; f.format(\"%-15.15s %5d %10.2f%n\", name, qty, price); total += price * qty; &#125; public String build() &#123; f.format(\"%-15s %5s %10.2f%n\", \"Tax\", \"\", total * 0.06); f.format(\"%-15s %5s %10s%n\", \"\", \"\", \"-----\"); f.format(\"%-15s %5s %10.2f%n\", \"Total\", \"\", total * 1.06); return f.toString(); &#125; public static void main(String[] args) &#123; ReceiptBuilder receiptBuilder = new ReceiptBuilder(); receiptBuilder.add(\"Jack's Magic Beans\", 4, 4.25); receiptBuilder.add(\"Princess Peas\", 3, 5.1); receiptBuilder.add( \"Three Bears Porridge\", 1, 14.29); System.out.println(receiptBuilder.build()); &#125; &#125; /* Output: Item Qty Price ---- --- ----- Jack's Magic Be 4 4.25 Princess Peas 3 5.10 Three Bears Por 1 14.29 Tax 2.80 ----- Total 49.39 */ 通过传入一个 StringBuilder 对象到 Formatter 的构造器，我们指定了一个容器来构建目标 String。你也可以通过不同的构造器参数，把结果输出到标准输出，甚至是一个文件里。 正如你所见，通过相当简洁的语法，Formatter 提供了对空格与对齐的强大控制能力。在该程序中，为了恰当地控制间隔，格式化字符串被重复利用了多遍。 Formatter 转换下面的表格展示了最常用的类型转换： 类型 含义 d 整型（十进制） c Unicode字符 b Boolean值 s String f 浮点数（十进制） e 浮点数（科学计数） x 整型（十六进制） h 散列码（十六进制） % 字面值“%” 下面的程序演示了这些转换是如何工作的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// strings/Conversion.java import java.math.*;import java.util.*; public class Conversion &#123; public static void main(String[] args) &#123; Formatter f = new Formatter(System.out); char u = 'a'; System.out.println(\"u = 'a'\"); f.format(\"s: %s%n\", u); // f.format(\"d: %d%n\", u); f.format(\"c: %c%n\", u); f.format(\"b: %b%n\", u); // f.format(\"f: %f%n\", u); // f.format(\"e: %e%n\", u); // f.format(\"x: %x%n\", u); f.format(\"h: %h%n\", u); int v = 121; System.out.println(\"v = 121\"); f.format(\"d: %d%n\", v); f.format(\"c: %c%n\", v); f.format(\"b: %b%n\", v); f.format(\"s: %s%n\", v); // f.format(\"f: %f%n\", v); // f.format(\"e: %e%n\", v); f.format(\"x: %x%n\", v); f.format(\"h: %h%n\", v); BigInteger w = new BigInteger(\"50000000000000\"); System.out.println( \"w = new BigInteger(\\\"50000000000000\\\")\"); f.format(\"d: %d%n\", w); // f.format(\"c: %c%n\", w); f.format(\"b: %b%n\", w); f.format(\"s: %s%n\", w); // f.format(\"f: %f%n\", w); // f.format(\"e: %e%n\", w); f.format(\"x: %x%n\", w); f.format(\"h: %h%n\", w); double x = 179.543; System.out.println(\"x = 179.543\"); // f.format(\"d: %d%n\", x); // f.format(\"c: %c%n\", x); f.format(\"b: %b%n\", x); f.format(\"s: %s%n\", x); f.format(\"f: %f%n\", x); f.format(\"e: %e%n\", x); // f.format(\"x: %x%n\", x); f.format(\"h: %h%n\", x); Conversion y = new Conversion(); System.out.println(\"y = new Conversion()\"); // f.format(\"d: %d%n\", y); // f.format(\"c: %c%n\", y); f.format(\"b: %b%n\", y); f.format(\"s: %s%n\", y); // f.format(\"f: %f%n\", y); // f.format(\"e: %e%n\", y); // f.format(\"x: %x%n\", y); f.format(\"h: %h%n\", y); boolean z = false; System.out.println(\"z = false\"); // f.format(\"d: %d%n\", z); // f.format(\"c: %c%n\", z); f.format(\"b: %b%n\", z); f.format(\"s: %s%n\", z); // f.format(\"f: %f%n\", z); // f.format(\"e: %e%n\", z); // f.format(\"x: %x%n\", z); f.format(\"h: %h%n\", z); &#125; &#125; 被注释的代码表示，针对相应类型的变量，这些转换是无效的。如果执行这些转换，则会触发异常。 注意，程序中的每个变量都用到了 b 转换。虽然它对各种类型都是合法的，但其行为却不一定与你想象的一致。对于 boolean 基本类型或 Boolean 对象，其转换结果是对应的 true 或 false。但是，==对其他类型的参数，只要该参数不为 null，其转换结果永远都是 true。==即使是数字 0，转换结果依然为 true，而这在其他语言中（包括C），往往转换为 false。所以，将 b 应用于非布尔类型的对象时请格外小心。 还有许多不常用的类型转换与格式修饰符选项，你可以在 JDK 文档中的 Formatter 类部分找到它们。 String.format()Java SE5 也参考了 C 中的 sprintf() 方法，以生成格式化的 String 对象。String.format() 是一个 static 方法，它接受与 Formatter.format() 方法一样的参数，但返回一个 String 对象。当你只需使用一次 format() 方法的时候，String.format() 用起来很方便。例如： 1234567891011121314151617181920// strings/DatabaseException.java public class DatabaseException extends Exception &#123; public DatabaseException(int transactionID, int queryID, String message) &#123; super(String.format(\"(t%d, q%d) %s\", transactionID, queryID, message)); &#125; public static void main(String[] args) &#123; try &#123; throw new DatabaseException(3, 7, \"Write failed\"); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125; &#125; /* Output: DatabaseException: (t3, q7) Write failed */ 其实在 String.format() 内部，它也是创建了一个 Formatter 对象，然后将你传入的参数转给 Formatter。不过，与其自己做这些事情，不如使用便捷的 String.format() 方法，何况这样的代码更清晰易读。 一个十六进制转储（dump）工具在第二个例子中，我们把二进制文件转换为十六进制格式。下面的小工具使用了 String.format() 方法，以可读的十六进制格式将字节数组打印出来： 12345678910111213141516171819202122232425262728293031323334353637383940// strings/Hex.java // &#123;java onjava.Hex&#125; package onjava;import java.io.*; import java.nio.file.*; public class Hex &#123; public static String format(byte[] data) &#123; StringBuilder result = new StringBuilder(); int n = 0; for(byte b : data) &#123; if(n % 16 == 0) result.append(String.format(\"%05X: \", n)); result.append(String.format(\"%02X \", b)); n++; if(n % 16 == 0) result.append(\"\\n\"); &#125; result.append(\"\\n\"); return result.toString(); &#125; public static void main(String[] args) throws Exception &#123; if(args.length == 0) // Test by displaying this class file: System.out.println(format( Files.readAllBytes(Paths.get( \"build/classes/main/onjava/Hex.class\")))); else System.out.println(format( Files.readAllBytes(Paths.get(args[0])))); &#125; &#125; /* Output: (First 6 Lines) 00000: CA FE BA BE 00 00 00 34 00 61 0A 00 05 00 31 07 00010: 00 32 0A 00 02 00 31 08 00 33 07 00 34 0A 00 35 00020: 00 36 0A 00 0F 00 37 0A 00 02 00 38 08 00 39 0A 00030: 00 3A 00 3B 08 00 3C 0A 00 02 00 3D 09 00 3E 00 00040: 3F 08 00 40 07 00 41 0A 00 42 00 43 0A 00 44 00 00050: 45 0A 00 14 00 46 0A 00 47 00 48 07 00 49 01 00 ... */ 为了打开及读入二进制文件，我们用到了另一个工具 Files.readAllBytes()，这已经在 Files章节 介绍过了。这里的 readAllBytes() 方法将整个文件以 byte 数组的形式返回。 正则表达式注：特殊字符，如+,要写成\\\\+ +,\\,.,(, 在正则表达式中，用括号将表达式进行分组，用竖线 | 表示或操作。 很久之前，正则表达式就已经整合到标准 Unix 工具集之中，例如 sed、awk 和程序语言之中了，如 Python 和Perl（有些人认为正是正则表达式促成了 Perl 的成功）。 正则表达式是一种强大而灵活的文本处理工具。使用正则表达式，我们能够以编程的方式，构造复杂的文本模式，并对输入 String 进行搜索。一旦找到了匹配这些模式的部分，你就能随心所欲地对它们进行处理。初学正则表达式时，其语法是一个难点，但它确实是一种简洁、动态的语言。正则表达式提供了一种完全通用的方式，能够解决各种 String 处理相关的问题：匹配、选择、编辑以及验证。 基础一般来说，正则表达式就是以某种方式来描述字符串，因此你可以说：“如果一个字符串含有这些东西，那么它就是我正在找的东西。”例如，要找一个数字，它可能有一个负号在最前面，那你就写一个负号加上一个问号，就像这样： 1-? 要描述一个整数，你可以说它有一位或多位阿拉伯数字。在正则表达式中，用 \\d 表示一位数字。如果在其他语言中使用过正则表达式，那你可能就能发现 Java 对反斜线 \\ 的不同处理方式。在其他语言中，\\\\ 表示“我想要在正则表达式中插入一个普通的（字面上的）反斜线，请不要给它任何特殊的意义。”而在Java中，\\\\ 的意思是“我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。”例如，如果你想表示一位数字，那么正则表达式应该是 \\\\d。如果你想插入一个普通的反斜线，应该这样写 \\\\\\。不过换行符和制表符之类的东西只需要使用单反斜线：\\n\\t。 [^2] 要表示“一个或多个之前的表达式”，应该使用 +。所以，如果要表示“可能有一个负号，后面跟着一位或多位数字”，可以这样： 1-?\\\\d+ 应用正则表达式最简单的途径，就是利用 String 类内建的功能。例如，你可以检查一个 String 是否匹配如上所述的正则表达式： 12345678910111213141516// strings/IntegerMatch.java public class IntegerMatch &#123; public static void main(String[] args) &#123; System.out.println(\"-1234\".matches(\"-?\\\\d+\")); System.out.println(\"5678\".matches(\"-?\\\\d+\")); System.out.println(\"+911\".matches(\"-?\\\\d+\")); System.out.println(\"+911\".matches(\"(-|\\\\+)?\\\\d+\")); &#125;&#125;/* Output: true true false true */ 前两个字符串都满足对应的正则表达式，匹配成功。第三个字符串以 + 开头，这也是一个合法的符号，但与对应的正则表达式却不匹配。因此，我们的正则表达式应该描述为：“可能以一个加号或减号开头”。==在正则表达式中，用括号将表达式进行分组，用竖线 | 表示或操作==。也就是： 1(-|\\\\+)? 这个正则表达式表示字符串的起始字符可能是一个 - 或 +，或者二者都没有（因为后面跟着 ? 修饰符）。因为字符 + 在正则表达式中有特殊的意义，所以必须使用 \\\\ 将其转义，使之成为表达式中的一个普通字符。 String类还自带了一个非常有用的正则表达式工具——split() 方法，其功能是“将字符串从正则表达式匹配的地方切开。” 12345678910111213141516171819202122232425262728// strings/Splitting.java import java.util.*; public class Splitting &#123; public static String knights = \"Then, when you have found the shrubbery, \" + \"you must cut down the mightiest tree in the \" + \"forest...with... a herring!\"; public static void split(String regex) &#123; System.out.println( Arrays.toString(knights.split(regex))); &#125; public static void main(String[] args) &#123; split(\" \"); // Doesn't have to contain regex chars split(\"\\\\W+\"); // Non-word characters split(\"n\\\\W+\"); // 'n' followed by non-words &#125;&#125;/* Output:[Then,, when, you, have, found, the, shrubbery,, you,must, cut, down, the, mightiest, tree, in, the,forest...with..., a, herring!][Then, when, you, have, found, the, shrubbery, you,must, cut, down, the, mightiest, tree, in, the, forest,with, a, herring][The, whe, you have found the shrubbery, you must cutdow, the mightiest tree i, the forest...with... aherring!]*/ 首先看第一个语句，注意这里用的是普通的字符作为正则表达式，其中并不包含任何特殊字符。因此第一个 split() 只是按空格来划分字符串。 第二个和第三个 split() 都用到了 \\\\W，它的意思是一个非单词字符（如果 W 小写，\\\\w，则表示一个单词字符）。通过第二个例子可以看到，它将标点字符删除了。第三个 split() 表示“字母 n 后面跟着一个或多个非单词字符。”可以看到，在原始字符串中，与正则表达式匹配的部分，在最终结果中都不存在了。 String.split() 还有一个重载的版本，它允许你限制字符串分割的次数。 用正则表达式进行替换操作时，你可以只替换第一处匹配，也可以替换所有的匹配： 123456789101112131415161718// strings/Replacing.java public class Replacing &#123; static String s = Splitting.knights; public static void main(String[] args) &#123; System.out.println( s.replaceFirst(\"f\\\\w+\", \"located\")); System.out.println( s.replaceAll(\"shrubbery|tree|herring\",\"banana\")); &#125; &#125;/* Output: Then, when you have located the shrubbery, you must cut down the mightiest tree in the forest...with... a herring! Then, when you have found the banana, you must cut downthe mightiest banana in the forest...with... a banana! */ 第一个表达式要匹配的是，以字母 f 开头，后面跟一个或多个字母（注意这里的 w 是小写的）。并且只替换掉第一个匹配的部分，所以 “found” 被替换成 “located”。 第二个表达式要匹配的是三个单词中的任意一个，因为它们以竖线分割表示“或”，并且替换所有匹配的部分。 稍后你会看到，String 之外的正则表达式还有更强大的替换工具，例如，可以通过方法调用执行替换。而且，如果正则表达式不是只使用一次的话，非 String 对象的正则表达式明显具备更佳的性能。 String 类的正则方法 name useage matches split() replaceFirst() replaceAll 创建正则表达式我们首先从正则表达式可能存在的构造集中选取一个很有用的子集，以此开始学习正则表达式。正则表达式的完整构造子列表，请参考JDK文档 java.util.regex 包中的 Pattern类。 表达式 含义 B 指定字符B \\xhh 十六进制值为0xhh的字符 \\uhhhh 十六进制表现为0xhhhh的Unicode字符 \\t 制表符Tab \\n 换行符 \\r 回车 \\f 换页 \\e 转义（Escape） 当你学会了使用字符类（character classes）之后，正则表达式的威力才能真正显现出来。以下是一些创建字符类的典型方式，以及一些预定义的类： 表达式 含义 . 任意字符 [abc] 包含a、b或c的任何字符（和`a [^abc] 除a、b和c之外的任何字符（否定） [a-zA-Z] 从a到z或从A到Z的任何字符（范围） [abc[hij]] a、b、c、h、i、j中的任意字符（与`a [a-z&amp;&amp;[hij]] 任意h、i或j（交） \\s 空白符（空格、tab、换行、换页、回车） \\S 非空白符（[^\\s]） \\d 数字（[0-9]） \\D 非数字（[^0-9]） \\w 词字符（[a-zA-Z_0-9]） \\W 非词字符（[^\\w]） 这里只列出了部分常用的表达式，你应该将JDK文档中 java.util.regex.Pattern 那一页加入浏览器书签中，以便在需要的时候方便查询。 逻辑操作符 含义 XY Y跟在X后面 `X Y` (X) 捕获组（capturing group）。可以在表达式中用\\i引用第i个捕获组 下面是不同的边界匹配符： 边界匹配符 含义 ^ 一行的开始 $ 一行的结束 \\b 词的边界 \\B 非词的边界 \\G 前一个匹配的结束 作为演示，下面的每一个正则表达式都能成功匹配字符序列“Rudolph”： 123456789101112131415161718// strings/Rudolph.java public class Rudolph &#123; public static void main(String[] args) &#123; for(String pattern : new String[]&#123; \"Rudolph\", \"[rR]udolph\", \"[rR][aeiou][a-z]ol.*\", \"R.*\" &#125;) System.out.println(\"Rudolph\".matches(pattern)); &#125; &#125; /* Output: true true true true */ 我们的目的并不是编写最难理解的正则表达式，而是尽量编写能够完成任务的、最简单以及最必要的正则表达式。一旦真正开始使用正则表达式了，你就会发现，在编写新的表达式之前，你通常会参考代码中已经用到的正则表达式。 量词123456正则?：表示正则可以出现0次或1次 &#123;0,1&#125; 正则+：表示正则可以出现1次或1次以上 &gt;=1 &#123;1,&#125; 正则*：表示正则可以出现0次或1次或多次 &gt;= 0 &#123;0,&#125; 正则&#123;n&#125;：表示正则正好出现n次 正则&#123;n,&#125;：表示正则出现n次及以上 正则&#123;n,m&#125;：表示正则出现&#123;n,m&#125;次 量词描述了一个模式捕获输入文本的方式： 贪婪型：量词总是贪婪的，除非有其他的选项被设置。贪婪表达式会为所有可能的模式发现尽可能多的匹配。导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配。 勉强型：用问号来指定，这个量词匹配满足模式所需的最少字符数。因此也被称作懒惰的、最少匹配的、非贪婪的或不贪婪的。 占有型：目前，这种类型的量词只有在 Java 语言中才可用（在其他语言中不可用），并且也更高级，因此我们大概不会立刻用到它。当正则表达式被应用于 String 时，它会产生相当多的状态，以便在匹配失败时可以回溯。而“占有的”量词并不保存这些中间状态，因此它们可以防止回溯。它们常常用于防止正则表达式失控，因此可以使正则表达式执行起来更高效。 贪婪型 勉强型 占有型 如何匹配 X? X?? X?+ 一个或零个X X* X*? X*+ 零个或多个X X+ X+? X++ 一个或多个X X{n} X{n}? X{n}+ 恰好n次X X{n,} X{n,}? X{n,}+ 至少n次X X{n,m} X{n,m}? X{n,m}+ X至少n次，但不超过m次 应该非常清楚地意识到，表达式 X 通常必须要用圆括号括起来，以便它能够按照我们期望的效果去执行。例如： 1abc+ 看起来它似乎应该匹配1个或多个abc序列，如果我们把它应用于输入字符串abcabcabc，则实际上会获得3个匹配。然而，这个表达式实际上表示的是：匹配ab，后面跟随1个或多个c。要表明匹配1个或多个完整的字符串abc，我们必须这样表示： 1(abc)+ 你会发现，在使用正则表达式时很容易混淆，因为它是一种在 Java 之上的新语言。 CharSequence接口 CharSequence 从 CharBuffer、String、StringBuffer、StringBuilder 类中抽象出了字符序列的一般化定义： 123456interface CharSequence &#123; char charAt(int i); int length(); CharSequence subSequence(int start, int end); String toString(); &#125; 因此，这些类都实现了该接口。多数正则表达式操作都接受 CharSequence 类型参数。 Pattern 和 Matcher==注意：==获得的matcher的group()对象需要使用find()，即使是使用group(1) 1234567891011String fileName = \"input10.txt\";System.out.println(fileName);Pattern p = Pattern.compile(\"\\\\d+\");Matcher m = p.matcher(fileName);Pattern p = Pattern.compile(arg); Matcher m = p.matcher(args[0]); while(m.find()) &#123; System.out.println( \"Match \\\"\" + m.group() + \"\\\" at positions \" + m.start() + \"-\" + (m.end() - 1)); &#125; 123456String fileName = \"input10.txt\"; System.out.println(fileName); Pattern p = Pattern.compile(\"input(\\\\d+).txt\"); Matcher m = p.matcher(fileName); if (m.find()) System.out.print(m.group(1) + \" \"); 通常，比起功能有限的 String 类，我们更愿意构造功能强大的正则表达式对象。只需导入 java.util.regex包，然后用 static Pattern.compile() 方法来编译你的正则表达式即可。它会根据你的 String 类型的正则表达式生成一个 Pattern 对象。接下来，把你想要检索的字符串传入 Pattern 对象的 matcher() 方法。matcher() 方法会生成一个 Matcher 对象，它有很多功能可用（可以参考 java.util.regext.Matcher 的 JDK 文档）。例如，它的 replaceAll() 方法能将所有匹配的部分都替换成你传入的参数。 作为第一个示例，下面的类可以用来测试正则表达式，看看它们能否匹配一个输入字符串。第一个控制台参数是将要用来搜索匹配的输入字符串，后面的一个或多个参数都是正则表达式，它们将被用来在输入的第一个字符串中查找匹配。在Unix/Linux上，命令行中的正则表达式必须用引号括起来。这个程序在测试正则表达式时很有用，特别是当你想验证它们是否具备你所期待的匹配功能的时候。[^3] 1234567891011121314151617181920212223242526272829303132333435363738394041// strings/TestRegularExpression.java // Simple regular expression demonstration // &#123;java TestRegularExpression // abcabcabcdefabc \"abc+\" \"(abc)+\" &#125; import java.util.regex.*; public class TestRegularExpression &#123; public static void main(String[] args) &#123; if(args.length &lt; 2) &#123; System.out.println( \"Usage:\\njava TestRegularExpression \" + \"characterSequence regularExpression+\"); System.exit(0); &#125; System.out.println(\"Input: \\\"\" + args[0] + \"\\\"\"); for(String arg : args) &#123; System.out.println( \"Regular expression: \\\"\" + arg + \"\\\"\"); Pattern p = Pattern.compile(arg); Matcher m = p.matcher(args[0]); while(m.find()) &#123; System.out.println( \"Match \\\"\" + m.group() + \"\\\" at positions \" + m.start() + \"-\" + (m.end() - 1)); &#125; &#125; &#125;&#125;/* Output: Input: \"abcabcabcdefabc\" Regular expression: \"abcabcabcdefabc\" Match \"abcabcabcdefabc\" at positions 0-14 Regular expression: \"abc+\" Match \"abc\" at positions 0-2 Match \"abc\" at positions 3-5 Match \"abc\" at positions 6-8 Match \"abc\" at positions 12-14 Regular expression: \"(abc)+\"Match \"abcabcabc\" at positions 0-8 Match \"abc\" at positions 12-14 */ 还可以在控制台参数中加入“(abc){2,}”，看看执行结果。 Pattern12345678Matcher matcher(CharSequence input) Creates a matcher that will match the given input against this pattern.static boolean matches(String regex, CharSequence input) Compiles the given regular expression and attempts to match the given input against it.String[] split(CharSequence input) Splits the given input sequence around matches of this pattern.String[] split(CharSequence input, int limit) Splits the given input sequence around matches of this pattern. Pattern 对象表示编译后的正则表达式。从这个例子可以看到，我们使用已编译的 Pattern 对象上的 matcher() 方法，加上一个输入字符串，从而共同构造了一个 Matcher 对象。同时，Pattern 类还提供了一个static方法： 1static boolean matches(String regex, CharSequence input) 该方法用以检查 regex 是否匹配整个 CharSequence 类型的 input 参数。编译后的 Pattern 对象还提供了 split() 方法，它从匹配了 regex 的地方分割输入字符串，返回分割后的子字符串 String 数组。 通过调用 Pattern.matcher() 方法，并传入一个字符串参数，我们得到了一个 Matcher 对象。使用 Matcher 上的方法，我们将能够判断各种不同类型的匹配是否成功： funcition useage boolean matches() matches() 方法用来判断整个输入字符串是否匹配正则表达式模式 boolean lookingAt() lookingAt() 则用来判断该字符串（不必是整个字符串）的起始部分是否能够匹配模式。 boolean find() boolean find(int start) @param start the index to start searching for a match find()Matcher.find() 方法可用来在 CharSequence 中查找多个匹配。例如： 123456789101112131415161718192021222324// strings/Finding.java import java.util.regex.*; public class Finding &#123; public static void main(String[] args) &#123; Matcher m = Pattern.compile(\"\\\\w+\") .matcher( \"Evening is full of the linnet's wings\"); while(m.find()) System.out.print(m.group() + \" \"); System.out.println(); int i = 0; while(m.find(i)) &#123; System.out.print(m.group() + \" \"); i++; &#125; &#125;&#125;/* Output: Evening is full of the linnet s wingsEvening vening ening ning ing ng g is is s full full ull ll l of of f the the he e linnet linnet innet nnet net et t s s wings wings ings ngs gs s */ 模式 \\\\w+ 将字符串划分为词。find() 方法像迭代器那样向前遍历输入字符串。而第二个重载的 find() 接收一个整型参数，该整数表示字符串中字符的位置，并以其作为搜索的起点。从结果可以看出，后一个版本的 find() 方法能够根据其参数的值，不断重新设定搜索的起始位置。 组（Groups）组是用括号划分的正则表达式，可以根据组的编号来引用某个组。组号为 0 表示整个表达式，组号 1 表示被第一对括号括起来的组，以此类推。因此，下面这个表达式， 1A(B(C))D 中有三个组：组 0 是 ABCD，组 1 是 BC，组 2 是 C。 Matcher 对象提供了一系列方法，用以获取与组相关的信息： public int groupCount() 返回该匹配器的模式中的分组数目，组 0 不包括在内。 public String group() 返回前一次匹配操作（例如 find()）的第 0 组（整个匹配）。 public String group(int i) 返回前一次匹配操作期间指定的组号，如果匹配成功，但是指定的组没有匹配输入字符串的任何部分，则将返回 null。 public int start(int group) 返回在前一次匹配操作中寻找到的组的起始索引。 public int end(int group) 返回在前一次匹配操作中寻找到的组的最后一个字符索引加一的值。 下面是正则表达式组的例子： 12345678910111213141516171819202122232425262728293031323334353637// strings/Groups.javaimport java.util.regex.*; public class Groups &#123; public static final String POEM = \"Twas brillig, and the slithy toves\\n\" + \"Did gyre and gimble in the wabe.\\n\" + \"All mimsy were the borogoves,\\n\" + \"And the mome raths outgrabe.\\n\\n\" + \"Beware the Jabberwock, my son,\\n\" + \"The jaws that bite, the claws that catch.\\n\" + \"Beware the Jubjub bird, and shun\\n\" + \"The frumious Bandersnatch.\"; public static void main(String[] args) &#123; Matcher m = Pattern.compile( \"(?m)(\\\\S+)\\\\s+((\\\\S+)\\\\s+(\\\\S+))$\") .matcher(POEM); while(m.find()) &#123; for(int j = 0; j &lt;= m.groupCount(); j++) System.out.print(\"[\" + m.group(j) + \"]\"); System.out.println(); &#125; &#125; &#125;/* Output: [the slithy toves][the][slithy toves][slithy][toves] [in the wabe.][in][the wabe.][the][wabe.] [were the borogoves,][were][the borogoves,][the][borogoves,] [mome raths outgrabe.][mome][raths outgrabe.][raths][outgrabe.] [Jabberwock, my son,][Jabberwock,][my son,][my][son,] [claws that catch.][claws][that catch.][that][catch.] [bird, and shun][bird,][and shun][and][shun] [The frumious Bandersnatch.][The][frumious Bandersnatch.][frumious][Bandersnatch.] */ 这首诗来自于 Lewis Carroll 所写的 Through the Looking Glass 中的 “Jabberwocky”。可以看到这个正则表达式模式有许多圆括号分组，由任意数目的非空白符（\\\\S+）及随后的任意数目的空白符（\\\\s+）所组成。目的是捕获每行的最后3个词，每行最后以 \\$ 结束。不过，在正常情况下是将 \\$ 与整个输入序列的末端相匹配。所以我们一定要显式地告知正则表达式注意输入序列中的换行符。这可以由序列开头的==模式标记 (?m) 来完成==（模式标记马上就会介绍）。 start() 和 end()在匹配操作成功之后，start() 返回先前匹配的起始位置的索引，而 end() 返回所匹配的最后字符的索引加一的值。匹配操作失败之后（或先于一个正在进行的匹配操作去尝试）调用 start() 或 end() 将会产生 IllegalStateException。下面的示例还同时展示了 matches() 和 lookingAt() 的用法 [^4]： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// strings/StartEnd.java import java.util.regex.*; public class StartEnd &#123; public static String input = \"As long as there is injustice, whenever a\\n\" + \"Targathian baby cries out, wherever a distress\\n\" + \"signal sounds among the stars \" + \"... We'll be there.\\n\"+ \"This fine ship, and this fine crew ...\\n\" + \"Never give up! Never surrender!\"; private static class Display &#123; private boolean regexPrinted = false; private String regex; Display(String regex) &#123; this.regex = regex; &#125; void display(String message) &#123; if(!regexPrinted) &#123; System.out.println(regex); regexPrinted = true; &#125; System.out.println(message); &#125; &#125; static void examine(String s, String regex) &#123; Display d = new Display(regex); Pattern p = Pattern.compile(regex); Matcher m = p.matcher(s); while(m.find()) d.display(\"find() '\" + m.group() + \"' start = \"+ m.start() + \" end = \" + m.end()); if(m.lookingAt()) // No reset() necessary d.display(\"lookingAt() start = \" + m.start() + \" end = \" + m.end()); if(m.matches()) // No reset() necessary d.display(\"matches() start = \" + m.start() + \" end = \" + m.end()); &#125; public static void main(String[] args) &#123; for(String in : input.split(\"\\n\")) &#123; System.out.println(\"input : \" + in); for(String regex : new String[]&#123;\"\\\\w*ere\\\\w*\", \"\\\\w*ever\", \"T\\\\w+\", \"Never.*?!\"&#125;) examine(in, regex); &#125; &#125; &#125; /* Output: input : As long as there is injustice, whenever a \\w*ere\\w* find() 'there' start = 11 end = 16 \\w*ever find() 'whenever' start = 31 end = 39 input : Targathian baby cries out, wherever a distress \\w*ere\\w* find() 'wherever' start = 27 end = 35 \\w*ever find() 'wherever' start = 27 end = 35 T\\w+ find() 'Targathian' start = 0 end = 10 lookingAt() start = 0 end = 10 input : signal sounds among the stars ... We'll be there. \\w*ere\\w* find() 'there' start = 43 end = 48 input : This fine ship, and this fine crew ... T\\w+ find() 'This' start = 0 end = 4lookingAt() start = 0 end = 4 input : Never give up! Never surrender! \\w*ever find() 'Never' start = 0 end = 5 find() 'Never' start = 15 end = 20 lookingAt() start = 0 end = 5 Never.*?! find() 'Never give up!' start = 0 end = 14 find() 'Never surrender!' start = 15 end = 31 lookingAt() start = 0 end = 14 matches() start = 0 end = 31 */ 注意，find() 可以在输入的任意位置定位正则表达式，而 lookingAt() 和 matches() 只有在正则表达式与输入的最开始处就开始匹配时才会成功。matches() 只有在整个输入都匹配正则表达式时才会成功，而 lookingAt() [^5] 只要输入的第一部分匹配就会成功。 Pattern 标记Pattern 类的 compile() 方法还有另一个版本，它接受一个标记参数，以调整匹配行为： 1Pattern Pattern.compile(String regex, int flag) 其中的 flag 来自以下 Pattern 类中的常量 编译标记 效果 Pattern.CANON_EQ 当且仅当两个字符的完全规范分解相匹配时，才认为它们是匹配的。例如，如果我们指定这个标记，表达式\\u003F就会匹配字符串?。默认情况下，匹配不考虑规范的等价性 Pattern.CASE_INSENSITIVE(?i) 默认情况下，大小写不敏感的匹配假定只有US-ASCII字符集中的字符才能进行。这个标记允许模式匹配不考虑大小写（大写或小写）。通过指定UNICODE_CASE标记及结合此标记。基于Unicode的大小写不敏感的匹配就可以开启了 Pattern.COMMENTS(?x) 在这种模式下，空格符将被忽略掉，并且以#开始直到行末的注释也会被忽略掉。通过嵌入的标记表达式也可以开启Unix的行模式 Pattern.DOTALL(?s) 在dotall模式下，表达式.匹配所有字符，包括行终止符。默认情况下，.不会匹配行终止符 Pattern.MULTILINE(?m) 在多行模式下，表达式^和$分别匹配一行的开始和结束。^还匹配输入字符串的开始，而$还匹配输入字符串的结尾。默认情况下，这些表达式仅匹配输入的完整字符串的开始和结束 Pattern.UNICODE_CASE(?u) 当指定这个标记，并且开启CASE_INSENSITIVE时，大小写不敏感的匹配将按照与Unicode标准相一致的方式进行。默认情况下，大小写不敏感的匹配假定只能在US-ASCII字符集中的字符才能进行 Pattern.UNIX_LINES(?d) 在这种模式下，在.、^和$的行为中，只识别行终止符\\n 在这些标记中，Pattern.CASE_INSENSITIVE、Pattern.MULTILINE 以及 Pattern.COMMENTS（对声明或文档有用）特别有用。请注意，你可以直接在正则表达式中使用其中的大多数标记，只需要将上表中括号括起来的字符插入到正则表达式中，你希望它起作用的位置即可。 你还可以通过“或”(|)操作符组合多个标记的功能： 1234567891011121314151617181920// strings/ReFlags.java import java.util.regex.*; public class ReFlags &#123; public static void main(String[] args) &#123; Pattern p = Pattern.compile(\"^java\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE); Matcher m = p.matcher( \"java has regex\\nJava has regex\\n\" + \"JAVA has pretty good regular expressions\\n\" + \"Regular expressions are in Java\"); while(m.find()) System.out.println(m.group()); &#125; &#125;/* Output: java Java JAVA */ 在这个例子中，我们创建了一个模式，它将匹配所有以“java”、“Java”和“JAVA”等开头的行，并且是在设置了多行标记的状态下，对每一行（从字符序列的第一个字符开始，至每一个行终止符）都进行匹配。注意，group() 方法只返回已匹配的部分。 split()split()方法将输入 String 断开成 String 对象数组，断开边界由正则表达式确定： 12String[] split(CharSequence input) String[] split(CharSequence input, int limit) 这是一个快速而方便的方法，可以按照通用边界断开输入文本： 12345678910111213141516171819// strings/SplitDemo.java import java.util.regex.*; import java.util.*; public class SplitDemo &#123; public static void main(String[] args) &#123; String input = \"This!!unusual use!!of exclamation!!points\"; System.out.println(Arrays.toString( Pattern.compile(\"!!\").split(input))); // Only do the first three: System.out.println(Arrays.toString( Pattern.compile(\"!!\").split(input, 3))); &#125;&#125;/* Output: [This, unusual use, of exclamation, points] [This, unusual use, of exclamation!!points]*/ 第二种形式的 split() 方法可以限制将输入分割成字符串的数量。 替换操作正则表达式在进行文本替换时特别方便，它提供了许多方法： replaceFirst(String replacement) 以参数字符串 replacement 替换掉第一个匹配成功的部分。 replaceAll(String replacement) 以参数字符串 replacement 替换所有匹配成功的部分。 appendReplacement(StringBuffer sbuf, String replacement) 执行渐进式的替换，而不是像 replaceFirst() 和 replaceAll() 那样只替换第一个匹配或全部匹配。这是一个非常重要的方法。它允许你调用其他方法来生成或处理 replacement（replaceFirst() 和 replaceAll() 则只能使用一个固定的字符串），使你能够以编程的方式将目标分割成组，从而具备更强大的替换功能。 appendTail(StringBuffer sbuf) 在执行了一次或多次 appendReplacement() 之后，调用此方法可以将输入字符串余下的部分复制到 sbuf 中。 下面的程序演示了如何使用这些替换方法。开头部分注释掉的文本，就是正则表达式要处理的输入字符串： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// strings/TheReplacements.java import java.util.regex.*; import java.nio.file.*; import java.util.stream.*;/*! Here's a block of text to use as input to the regular expression matcher. Note that we first extract the block of text by looking for the special delimiters, then process the extracted block. !*/public class TheReplacements &#123; public static void main(String[] args) throws Exception &#123; String s = Files.lines( Paths.get(\"TheReplacements.java\")) .collect(Collectors.joining(\"\\n\")); // Match specially commented block of text above: Matcher mInput = Pattern.compile( \"/\\\\*!(.*)!\\\\*/\", Pattern.DOTALL).matcher(s); if(mInput.find()) s = mInput.group(1); // Captured by parentheses // Replace two or more spaces with a single space: s = s.replaceAll(\" &#123;2,&#125;\", \" \"); // Replace 1+ spaces at the beginning of each // line with no spaces. Must enable MULTILINE mode: s = s.replaceAll(\"(?m)^ +\", \"\"); System.out.println(s); s = s.replaceFirst(\"[aeiou]\", \"(VOWEL1)\"); StringBuffer sbuf = new StringBuffer(); Pattern p = Pattern.compile(\"[aeiou]\"); Matcher m = p.matcher(s); // Process the find information as you // perform the replacements: while(m.find()) m.appendReplacement(sbuf, m.group().toUpperCase()); // Put in the remainder of the text: m.appendTail(sbuf); System.out.println(sbuf); &#125; &#125;/* Output: Here's a block of text to use as input to the regular expression matcher. Note that we first extract the block of text by looking for the special delimiters, then process the extracted block. H(VOWEL1)rE's A blOck Of tExt tO UsE As InpUt tO thE rEgUlAr ExprEssIOn mAtchEr. NOtE thAt wE fIrst ExtrAct thE blOck Of tExt by lOOkIng fOr thE spEcIAl dElImItErs, thEn prOcEss thE ExtrActEd blOck. */ 此处使用上一章介绍过的 Files 类打开并读入文件。Files.lines() 返回一个 Stream 对象，包含读入的所有行，Collectors.joining() 在每一行的结尾追加参数字符序列，最终拼接成一个 String 对象。 mInput 匹配 /*! 和 ！*/ 之间的所有文字（注意分组的括号）。接下来，将存在两个或两个以上空格的地方，缩减为一个空格，并且删除每行开头部分的所有空格（为了使每一行都达到这个效果，而不仅仅是删除文本开头部分的空格，这里特意开启了多行模式）。这两个替换操作所使用的的 replaceAll() 是 String 对象自带的方法，在这里，使用此方法更方便。注意，因为这两个替换操作都只使用了一次 replaceAll()，所以，与其编译为 Pattern，不如直接使用 String 的 replaceAll() 方法，而且开销也更小些。 replaceFirst() 只对找到的第一个匹配进行替换。此外，replaceFirst() 和 replaceAll() 方法用来替换的只是普通字符串，所以，如果想对这些替换字符串进行某些特殊处理，这两个方法时无法胜任的。如果你想要那么做，就应该使用 appendReplacement() 方法。该方法允许你在执行替换的过程中，操作用来替换的字符串。在这个例子中，先构造了 sbuf 用来保存最终结果，然后用 group() 选择一个组，并对其进行处理，将正则表达式找到的元音字母替换成大些字母。一般情况下，你应该遍历执行所有的替换操作，然后再调用 appendTail() 方法，但是，如果你想模拟 replaceFirst()（或替换n次）的行为，那就只需要执行一次替换，然后调用 appendTail() 方法，将剩余未处理的部分存入 sbuf 即可。 同时，appendReplacement() 方法还允许你通过 \\$g 直接找到匹配的某个组，这里的 g 就是组号。然而，它只能应付一些简单的处理，无法实现类似前面这个例子中的功能。 reset()12Matcher reset() Resets this matcher.Matcher reset(CharSequence input) Resets this matcher with a new input sequence. 使用创建Matcher的Pattern重新匹配reset中传入的String 通过 reset() 方法，可以将现有的 Matcher 对象应用于一个新的字符序列： 12345678910111213141516171819// strings/Resetting.java import java.util.regex.*; public class Resetting &#123; public static void main(String[] args) throws Exception &#123; Matcher m = Pattern.compile(\"[frb][aiu][gx]\") .matcher(\"fix the rug with bags\"); while(m.find()) System.out.print(m.group() + \" \"); System.out.println(); m.reset(\"fix the rig with rags\"); while(m.find()) System.out.print(m.group() + \" \"); &#125; &#125; /* Output: fix rug bag fix rig rag */ 使用不带参数的 reset() 方法，可以将 Matcher 对象重新设置到当前字符序列的起始位置。 正则表达式与 Java I/O到目前为止，我们看到的例子都是将正则表达式用于静态的字符串。下面的例子将向你演示，如何应用正则表达式在一个文件中进行搜索匹配操作。JGrep.java 的灵感源自于 Unix 上的 grep。它有两个参数：文件名以及要匹配的正则表达式。输出的是每行有匹配的部分以及匹配部分在行中的位置。 12345678910111213141516171819202122232425262728293031// strings/JGrep.java // A very simple version of the \"grep\" program // &#123;java JGrep // WhitherStringBuilder.java 'return|for|String'&#125; import java.util.regex.*; import java.nio.file.*; import java.util.stream.*;public class JGrep &#123; public static void main(String[] args) throws Exception &#123; if(args.length &lt; 2) &#123; System.out.println( \"Usage: java JGrep file regex\"); System.exit(0); &#125; Pattern p = Pattern.compile(args[1]); // Iterate through the lines of the input file: int index = 0; Matcher m = p.matcher(\"\"); for(String line: Files.readAllLines(Paths.get(args[0]))) &#123; m.reset(line); while(m.find()) System.out.println(index++ + \": \" + m.group() + \": \" + m.start()); &#125; &#125; &#125; /* Output: 0: for: 4 1: for: 4 */ Files.readAllLines() 返回一个 List&lt;String&gt; 对象，这意味着可以用 for-in 进行遍历。虽然可以在 for 循环内部创建一个新的 Matcher 对象，但是，在循环体外创建一个空的 Matcher 对象，然后用 reset() 方法每次为 Matcher 加载一行输入，这种处理会有一定的性能优化。最后用 find() 搜索结果。 这里读入的测试参数是 JGrep.java 文件，然后搜索以 [Ssct] 开头的单词。 如果想要更深入地学习正则表达式，你可以阅读 Jeffrey E. F. Friedl 的《精通正则表达式（第2版）》。网络上也有很多正则表达式的介绍，你还可以从 Perl 和 Python 等其他语言的文档中找到有用的信息。 扫描输入到目前为止，从文件或标准输入读取数据还是一件相当痛苦的事情。一般的解决办法就是读入一行文本，对其进行分词，然后使用 Integer、Double 等类的各种解析方法来解析数据： 1234567891011121314151617181920212223242526272829303132333435363738// strings/SimpleRead.java import java.io.*;public class SimpleRead &#123; public static BufferedReader input = new BufferedReader(new StringReader( \"Sir Robin of Camelot\\n22 1.61803\")); public static void main(String[] args) &#123; try &#123; System.out.println(\"What is your name?\"); String name = input.readLine(); System.out.println(name); System.out.println(\"How old are you? \" + \"What is your favorite double?\"); System.out.println(\"(input: &lt;age&gt; &lt;double&gt;)\"); String numbers = input.readLine(); System.out.println(numbers); String[] numArray = numbers.split(\" \"); int age = Integer.parseInt(numArray[0]); double favorite = Double.parseDouble(numArray[1]); System.out.format(\"Hi %s.%n\", name); System.out.format(\"In 5 years you will be %d.%n\", age + 5); System.out.format(\"My favorite double is %f.\", favorite / 2); &#125; catch(IOException e) &#123; System.err.println(\"I/O exception\"); &#125; &#125; &#125;/* Output: What is your name? Sir Robin of Camelot How old are you? What is your favorite double? (input: &lt;age&gt; &lt;double&gt;) 22 1.61803Hi Sir Robin of Camelot. In 5 years you will be 27. My favorite double is 0.809015. */ input 字段使用的类来自 java.io，附录:流式 I/O 详细介绍了相关内容。StringReader 将 String 转化为可读的流对象，然后用这个对象来构造 BufferedReader 对象，因为我们要使用 BufferedReader 的 readLine() 方法。最终，我们可以使用 input 对象一次读取一行文本，就像从控制台读入标准输入一样。 readLine() 方法将一行输入转为 String 对象。如果每一行数据正好对应一个输入值，那这个方法也还可行。但是，如果两个输入值在同一行中，事情就不好办了，我们必须分解这个行，才能分别解析所需的输入值。在这个例子中，分解的操作发生在创建 numArray时。 终于，Java SE5 新增了 Scanner 类，它可以大大减轻扫描输入的工作负担： 12345678910111213141516171819202122232425262728293031323334// strings/BetterRead.java import java.util.*; public class BetterRead &#123; public static void main(String[] args) &#123; Scanner stdin = new Scanner(SimpleRead.input); System.out.println(\"What is your name?\"); String name = stdin.nextLine(); System.out.println(name); System.out.println( \"How old are you? What is your favorite double?\"); System.out.println(\"(input: &lt;age&gt; &lt;double&gt;)\"); int age = stdin.nextInt(); double favorite = stdin.nextDouble(); System.out.println(age); System.out.println(favorite); System.out.format(\"Hi %s.%n\", name); System.out.format(\"In 5 years you will be %d.%n\", age + 5); System.out.format(\"My favorite double is %f.\", favorite / 2); &#125;&#125;/* Output: What is your name? Sir Robin of Camelot How old are you? What is your favorite double? (input: &lt;age&gt; &lt;double&gt;) 22 1.61803 Hi Sir Robin of Camelot. In 5 years you will be 27. My favorite double is 0.809015. */ Scanner 的构造器可以接收任意类型的输入对象，包括 File、InputStream、String 或者像此例中的Readable 实现类。Readable 是 Java SE5 中新加入的一个接口，表示“具有 read() 方法的某种东西”。上一个例子中的 BufferedReader 也归于这一类。 有了 Scanner，所有的输入、分词、以及解析的操作都隐藏在不同类型的 next 方法中。普通的 next() 方法返回下一个 String。所有的基本类型（除 char 之外）都有对应的 next 方法，包括 BigDecimal 和 BigInteger。所有的 next 方法，只有在找到一个完整的分词之后才会返回。Scanner 还有相应的 hasNext 方法，用以判断下一个输入分词是否是所需的类型，如果是则返回 true。 在 BetterRead.java 中没有用 try 区块捕获IOException。因为，Scanner 有一个假设，在输入结束时会抛出 IOException，所以 Scanner 会把 IOException 吞掉。不过，通过 ioException() 方法，你可以找到最近发生的异常，因此，你可以在必要时检查它。 Scanner 分隔符默认情况下，Scanner 根据空白字符对输入进行分词，但是你可以用正则表达式指定自己所需的分隔符： 1234567891011121314151617// strings/ScannerDelimiter.java import java.util.*;public class ScannerDelimiter &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(\"12, 42, 78, 99, 42\"); scanner.useDelimiter(\"\\\\s*,\\\\s*\"); while(scanner.hasNextInt()) System.out.println(scanner.nextInt()); &#125; &#125;/* Output: 12 42 78 99 42 */ 这个例子使用逗号（包括逗号前后任意的空白字符）作为分隔符，同样的技术也可以用来读取逗号分隔的文件。我们可以用 useDelimiter() 来设置分隔符，同时，还有一个 delimiter() 方法，用来返回当前正在作为分隔符使用的 Pattern 对象。 用正则表达式扫描除了能够扫描基本类型之外，你还可以使用自定义的正则表达式进行扫描，这在扫描复杂数据时非常有用。下面的例子将扫描一个防火墙日志文件中的威胁数据： 1234567891011121314151617181920212223242526272829303132// strings/ThreatAnalyzer.java import java.util.regex.*; import java.util.*;public class ThreatAnalyzer &#123; static String threatData = \"58.27.82.161@08/10/2015\\n\" + \"204.45.234.40@08/11/2015\\n\" + \"58.27.82.161@08/11/2015\\n\" + \"58.27.82.161@08/12/2015\\n\" + \"58.27.82.161@08/12/2015\\n\" + \"[Next log section with different data format]\"; public static void main(String[] args) &#123; Scanner scanner = new Scanner(threatData); String pattern = \"(\\\\d+[.]\\\\d+[.]\\\\d+[.]\\\\d+)@\" + \"(\\\\d&#123;2&#125;/\\\\d&#123;2&#125;/\\\\d&#123;4&#125;)\"; while(scanner.hasNext(pattern)) &#123; scanner.next(pattern); MatchResult match = scanner.match(); String ip = match.group(1); String date = match.group(2); System.out.format( \"Threat on %s from %s%n\", date,ip); &#125; &#125; &#125; /* Output: Threat on 08/10/2015 from 58.27.82.161 Threat on 08/11/2015 from 204.45.234.40 Threat on 08/11/2015 from 58.27.82.161 Threat on 08/12/2015 from 58.27.82.161 Threat on 08/12/2015 from 58.27.82.161 */ 当 next() 方法配合指定的正则表达式使用时，将找到下一个匹配该模式的输入部分，调用 match() 方法就可以获得匹配的结果。如上所示，它的工作方式与之前看到的正则表达式匹配相似。 在配合正则表达式使用扫描时，有一点需要注意：它仅仅针对下一个输入分词进行匹配，如果你的正则表达式中含有分隔符，那永远不可能匹配成功。 StringTokenizer类在 Java 引入正则表达式（J2SE1.4）和 Scanner 类（Java SE5）之前，分割字符串的唯一方法是使用 StringTokenizer 来分词。不过，现在有了正则表达式和 Scanner，我们可以使用更加简单、更加简洁的方式来完成同样的工作了。下面的例子中，我们将 StringTokenizer 与另外两种技术简单地做了一个比较： 12345678910111213141516171819202122// strings/ReplacingStringTokenizer.java import java.util.*; public class ReplacingStringTokenizer &#123; public static void main(String[] args) &#123; String input = \"But I'm not dead yet! I feel happy!\"; StringTokenizer stoke = new StringTokenizer(input); while(stoke.hasMoreElements()) System.out.print(stoke.nextToken() + \" \"); System.out.println(); System.out.println(Arrays.toString(input.split(\" \"))); Scanner scanner = new Scanner(input); while(scanner.hasNext()) System.out.print(scanner.next() + \" \"); &#125;&#125; /* Output: But I'm not dead yet! I feel happy! [But, I'm, not, dead, yet!, I, feel, happy!] But I'm not dead yet! I feel happy! */ 使用正则表达式或 Scanner 对象，我们能够以更加复杂的模式来分割一个字符串，而这对于 StringTokenizer 来说就很困难了。基本上，我们可以放心地说，StringTokenizer 已经可以废弃不用了。 本章小结过去，Java 对于字符串操作的技术相当不完善。不过随着近几个版本的升级，我们可以看到，Java 已经从其他语言中吸取了许多成熟的经验。到目前为止，它对字符串操作的支持已经很完善了。不过，有时你还要在细节上注意效率问题，例如恰当地使用 StringBuilder 等。 [^1]: C++允许编程人员任意重载操作符。这通常是很复杂的过程（参见Prentice Hall于2000年编写的《Thinking in C++（第2版）》第10章），因此Java设计者认为这是很糟糕的功能，不应该纳入到Java中。起始重载操作符并没有糟糕到只能自己去重载的地步，但具有讽刺意味的是，与C++相比，在Java中使用操作符重载要容易得多。这一点可以在Python(参见www.Python.org)和C#中看到，它们都有垃圾回收机制，操作符重载也简单易懂。[^4]: input来自于Galaxy Quest中Taggart司令的一篇演讲。[^5]: 我不知道他们是如何想出这个方法名的，或者它到底指的什么。这只是代码审查很重要的原因之一。 第十九章 类型信息 RTTI（RunTime Type Information，运行时类型信息）能够在程序运行时发现和使用类型信息 RTTI 把我们从只能在编译期进行面向类型操作的禁锢中解脱了出来，并且让我们可以使用某些非常强大的程序。对 RTTI 的需要，揭示了面向对象设计中许多有趣（并且复杂）的特性，同时也带来了关于如何组织程序的基本问题。 本章将讨论 Java 是如何在运行时识别对象和类信息的。主要有两种方式： “传统的” RTTI：假定我们在编译时已经知道了所有的类型； “反射”机制：允许我们在运行时发现和使用类的信息。 为什么需要 RTTI下面看一下我们已经很熟悉的一个例子，它使用了多态的类层次结构。基类 Shape 是泛化的类型，从它派生出了三个具体类： Circle 、Square 和 Triangle（见下图所示）。 这是一个典型的类层次结构图，基类位于顶部，派生类向下扩展。面向对象编程的一个基本目的是：让代码只操纵对基类(这里即 Shape )的引用。这样，如果你想添加一个新类(比如从 Shape 派生出 Rhomboid)来扩展程序，就不会影响原来的代码。在这个例子中，Shape接口中动态绑定了 draw() 方法，这样做的目的就是让客户端程序员可以使用泛化的 Shape 引用来调用 draw()。draw() 方法在所有派生类里都会被覆盖，而且由于它是动态绑定的，所以它可以使用 Shape 引用来调用，这就是多态。 因此，我们通常会创建一个具体的对象(Circle、Square 或者 Triangle)，把它向上转型成 Shape (忽略对象的具体类型)，并且在后面的程序中使用 Shape 引用来调用在具体对象中被重载的方法（如 draw()）。 代码如下： 12345678910111213141516171819202122232425262728293031// typeinfo/Shapes.javaimport java.util.stream.*;abstract class Shape &#123; void draw() &#123; System.out.println(this + \".draw()\"); &#125; @Override public abstract String toString();&#125;class Circle extends Shape &#123; @Override public String toString() &#123; return \"Circle\"; &#125;&#125;class Square extends Shape &#123; @Override public String toString() &#123; return \"Square\"; &#125;&#125;class Triangle extends Shape &#123; @Override public String toString() &#123; return \"Triangle\"; &#125;&#125;public class Shapes &#123; public static void main(String[] args) &#123; Stream.of( new Circle(), new Square(), new Triangle()) .forEach(Shape::draw); &#125;&#125; 输出结果： 123Circle.draw()Square.draw()Triangle.draw() 基类中包含 draw() 方法，它通过传递 this 参数传递给 System.out.println()，间接地使用 toString() 打印类标识符(注意：这里将 toString() 声明为了 abstract，以此强制继承者覆盖改方法，并防止对 Shape 的实例化)。如果某个对象出现在字符串表达式中(涉及”+”和字符串对象的表达式)，toString() 方法就会被自动调用，以生成表示该对象的 String。每个派生类都要覆盖（从 Object 继承来的）toString() 方法，这样 draw() 在不同情况下就打印出不同的消息(多态)。 这个例子中，在把 Shape 对象放入 Stream&lt;Shape&gt; 中时就会进行向上转型(隐式)，但在向上转型的时候也丢失了这些对象的具体类型。对 stream 而言，它们只是 Shape 对象。 严格来说，Stream&lt;Shape&gt; 实际上是把放入其中的所有对象都当做 Object 对象来持有，只是取元素时会自动将其类型转为 Shape。这也是 RTTI 最基本的使用形式，因为在 Java 中，所有类型转换的正确性检查都是在运行时进行的。这也正是 RTTI 的含义所在：在运行时，识别一个对象的类型。 另外在这个例子中，类型转换并不彻底：Object 被转型为 Shape ，而不是 Circle、Square 或者 Triangle。这是因为目前我们只能确保这个 Stream&lt;Shape&gt; 保存的都是 Shape： 编译期，stream 和 Java 泛型系统确保放入 stream 的都是 Shape 对象（Shape 子类的对象也可视为 Shape 的对象），否则编译器会报错； 运行时，自动类型转换确保了从 stream 中取出的对象都是 Shape 类型。 接下来就是多态机制的事了，Shape 对象实际执行什么样的代码，是由引用所指向的具体对象（Circle、Square 或者 Triangle）决定的。这也符合我们编写代码的一般需求，通常，我们希望大部分代码尽可能少了解对象的具体类型，而是只与对象家族中的一个通用表示打交道（本例中即为 Shape）。这样，代码会更容易写，更易读和维护；设计也更容易实现，更易于理解和修改。所以多态是面向对象的基本目标。 但是，有时你会碰到一些编程问题，在这些问题中如果你能知道某个泛化引用的具体类型，就可以把问题轻松解决。例如，假设我们允许用户将某些几何形状高亮显示，现在希望找到屏幕上所有高亮显示的三角形；或者，我们现在需要旋转所有图形，但是想跳过圆形(因为圆形旋转没有意义)。这时我们就希望知道 Stream&lt;Shape&gt; 里边的形状具体是什么类型，而 Java 实际上也满足了我们的这种需求。使用 RTTI，我们可以查询某个 Shape 引用所指向对象的确切类型，然后选择或者剔除特例。 Class 对象要理解 RTTI 在 Java 中的工作原理，首先必须知道类型信息在运行时是如何表示的。这项工作是由称为 Class对象 的特殊对象完成的，它包含了与类有关的信息。实际上，Class 对象就是用来创建该类所有”常规”对象的。Java 使用 Class 对象来实现 RTTI，即便是类型转换这样的操作都是用 Class 对象实现的。不仅如此，Class 类还提供了很多使用 RTTI 的其它方式。 类是程序的一部分，每个类都有一个 Class 对象。换言之，每当我们编写并且编译了一个新类，就会产生一个 Class 对象（更恰当的说，是被保存在一个同名的 .class 文件中）。为了生成这个类的对象，Java 虚拟机 (JVM) 先会调用”类加载器”子系统把这个类加载到内存中。 类加载器子系统可能包含一条类加载器链，但有且只有一个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是”可信类”（包括 Java API 类）。它们通常是从本地盘加载的。在这条链中，通常不需要添加额外的类加载器，但是如果你有特殊需求（例如以某种特殊的方式加载类，以支持 Web 服务器应用，或者通过网络下载类），也可以挂载额外的类加载器。 所有的类都是第一次使用时动态加载到 JVM 中的，当程序创建第一个对类的静态成员的引用时，就会加载这个类。 其实构造器也是类的静态方法，虽然构造器前面并没有 static 关键字。所以，使用 new 操作符创建类的新对象，这个操作也算作对类的静态成员引用。 因此，Java 程序在它开始运行之前并没有被完全加载，很多部分是在需要时才会加载。这一点与许多传统编程语言不同，动态加载使得 Java 具有一些静态加载语言（如 C++）很难或者根本不可能实现的特性。 类加载器首先会检查这个类的 Class 对象是否已经加载，如果尚未加载，默认的类加载器就会根据类名查找 .class 文件（如果有附加的类加载器，这时候可能就会在数据库中或者通过其它方式获得字节码）。这个类的字节码被加载后，JVM 会对其进行验证，确保它没有损坏，并且不包含不良的 Java 代码(这是 Java 安全防范的一种措施)。 一旦某个类的 Class 对象被载入内存，它就可以用来创建这个类的所有对象。下面的示范程序可以证明这点： 1234567891011121314151617181920212223242526272829// typeinfo/SweetShop.java// 检查类加载器工作方式class Cookie &#123; static &#123; System.out.println(\"Loading Cookie\"); &#125;&#125;class Gum &#123; static &#123; System.out.println(\"Loading Gum\"); &#125;&#125;class Candy &#123; static &#123; System.out.println(\"Loading Candy\"); &#125;&#125;public class SweetShop &#123; public static void main(String[] args) &#123; System.out.println(\"inside main\"); new Candy(); System.out.println(\"After creating Candy\"); try &#123; Class.forName(\"Gum\"); &#125; catch(ClassNotFoundException e) &#123; System.out.println(\"Couldn't find Gum\"); &#125; System.out.println(\"After Class.forName(\\\"Gum\\\")\"); new Cookie(); System.out.println(\"After creating Cookie\"); &#125;&#125; 输出结果： 1234567inside mainLoading CandyAfter creating CandyLoading GumAfter Class.forName(\"Gum\")Loading CookieAfter creating Cookie 上面的代码中，Candy、Gum 和 Cookie 这几个类都有一个 static{...} 静态初始化块，这些静态初始化块在类第一次被加载的时候就会执行。也就是说，静态初始化块会打印出相应的信息，告诉我们这些类分别是什么时候被加载了。而在主方法里边，创建对象 的代码都放在了 print() 语句之间，以帮助我们判断类加载的时间点。 从输出中可以看到，Class 对象仅在需要的时候才会被加载，static 初始化是在类加载时进行的。 代码里面还有特别有趣的一行： 1Class.forName(\"Gum\"); 所有 Class 对象都属于 Class 类，而且它跟其他普通对象一样，我们可以获取和操控它的引用(这也是类加载器的工作)。forName() 是 Class 类的一个静态方法，我们可以使用 forName() 根据目标类的类名（String）得到该类的 Class 对象。上面的代码忽略了 forName() 的返回值，因为那个调用是为了得到它产生的“副作用”。从结果可以看出，forName() 执行的副作用是如果 Gum 类没有被加载就加载它，而在加载的过程中，Gum 的 static 初始化块被执行了。 还需要注意的是，如果 Class.forName() 找不到要加载的类，它就会抛出异常 ClassNotFoundException。 无论何时，只要你想在运行时使用类型信息，就必须先得到那个 Class 对象的引用。 Class.forName() 就是实现这个功能的一个便捷途径，因为使用该方法你不需要先持有这个类型 的对象。 如果你已经拥有了目标类的对象，那就可以通过调用 getClass() 方法来获取 Class 引用了，这个方法来自根类 Object，它将返回表示该对象实际类型的 Class对象的引用。 Class 包含的方法使用 getName() 来产生完整类名， 使用 getSimpleName() 产生不带包名的类名 getCanonicalName() 也是产生完整类名（除内部类和数组外，对大部分类产生的结果与 getName() 相同）。 isInterface() 用于判断某个 Class 对象代表的是否为一个接口。 Class.getInterface() 方法返回的是存放 Class 对象的数组，里面的 Class 对象表示的是那个类实现的接口。 用于 Class 引用的转型语法，即 cast() 方法 调用 getSuperclass() 方法来得到父类的 Class 对象，再用父类的 Class 对象调用该方法，重复多次，你就可以得到一个对象完整的类继承结构。 因此，通过 Class 对象，你可以得到关于该类型的所有信息。 我们可以使用 Class.isAssignableFrom() .判断是否是同类或者是超类。 Determines if the class or interface represented by this Classobject is either the same as, or is a superclass or superinterface of, the classor interface represented by the specified Class parameter. 在 try 语句里边用 forName() 方法创建了一个 FancyToy 的类对象并赋值给该引用。需要注意的是，传递给 forName() 的字符串必须使用类的全限定名（包含包名）。 Class 对象的 newInstance() 方法是实现“虚拟构造器”的一种途径，虚拟构造器可以让你在不知道一个类的确切类型的时候，创建这个类的对象。当你创建新实例时，会得到一个 Object 引用，但是这个引用指向的是 Toy 对象。当然，由于得到的是 Object 引用，目前你只能给它发送 Object 对象能够接受的调用。而如果你想请求具体对象才有的调用，你就得先获取该对象更多的类型信息，并执行某种转型。另外，使用 newInstance() 来创建的类，必须带有无参数的构造器在本章稍后部分，你将会看到如何通过 Java 的反射 API，用任意的构造器来动态的创建类的对象。 类字面常量Java还提供了另一种方法来生成类对象的引用：类字面常量。对上述程序来说，就像这样：FancyToy.class;。这样做不仅更简单，而且更安全，因为它在编译时就会受到检查（因此不必放在try语句块中）。并且它根除了对 forName() 方法的调用，所以效率更高。 类字面常量不仅不仅可以应用于普通类，也可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装器类，还有一个标准字段 TYPE。TYPE字段是一个引用，指向对应的基本数据类型的 Class 对象，如下所示： ...等价于... boolean.class Boolean.TYPE char.class Character.TYPE byte.class Byte.TYPE short.class Short.TYPE int.class Integer.TYPE long.class Long.TYPE float.class Float.TYPE double.class Double.TYPE void.class Void.TYPE 我的建议是使用 .class 的形式，以保持与普通类的一致性。 注意，有一点很有趣：当使用 .class 来创建对 Class 对象的引用时，不会自动地初始化该Class 对象。为了使用类而做的准备工作实际包含三个步骤： 加载，这是由类加载器执行的。该步骤将查找字节码（通常在 classpath 所指定的路径中查找，但这并非是必须的），并从这些字节码中创建一个 Class 对象。 链接。在链接阶段将验证类中的字节码，为 static 字段分配存储空间，并且如果需要的话，将解析这个类创建的对其他类的所有引用。 初始化。如果该类具有超类，则对其进行初始化，执行 static 初始化器和 static 初始化块。 初始化被延迟到了对 static 方法（构造器隐式地是 static 的）或者非常数 static 字段进行首次引用时才执行： 12345678910111213141516171819202122232425262728293031323334353637383940414243// typeinfo/ClassInitialization.javaimport java.util.*;class Initable &#123; static final int STATIC_FINAL = 47; static final int STATIC_FINAL2 = ClassInitialization.rand.nextInt(1000); static &#123; System.out.println(\"Initializing Initable\"); &#125;&#125;class Initable2 &#123; static int staticNonFinal = 147; static &#123; System.out.println(\"Initializing Initable2\"); &#125;&#125;class Initable3 &#123; static int staticNonFinal = 74; static &#123; System.out.println(\"Initializing Initable3\"); &#125;&#125;public class ClassInitialization &#123; public static Random rand = new Random(47); public static void main(String[] args) throws Exception &#123; Class initable = Initable.class; System.out.println(\"After creating Initable ref\"); // Does not trigger initialization: System.out.println(Initable.STATIC_FINAL); // Does trigger initialization: System.out.println(Initable.STATIC_FINAL2); // Does trigger initialization: System.out.println(Initable2.staticNonFinal); Class initable3 = Class.forName(\"Initable3\"); System.out.println(\"After creating Initable3 ref\"); System.out.println(Initable3.staticNonFinal); &#125;&#125; 输出结果： 123456789After creating Initable ref47Initializing Initable258Initializing Initable2147Initializing Initable3After creating Initable3 ref74 初始化有效地实现了尽可能的“惰性”，从对 initable 引用的创建中可以看到，仅使用 .class 语法来获得对类对象的引用不会引发初始化。但与此相反，使用 Class.forName() 来产生 Class 引用会立即就进行初始化，如 initable3。 如果一个 static final 值是“编译期常量”（如 Initable.staticFinal），那么这个值不需要对 Initable 类进行初始化就可以被读取。但是，如果只是将一个字段设置成为 static 和 final，还不足以确保这种行为。例如，对 Initable.staticFinal2 的访问将强制进行类的初始化，因为它不是一个编译期常量。 如果一个 static 字段不是 final 的，那么在对它访问时，总是要求在它被读取之前，要先进行链接（为这个字段分配存储空间）和初始化（初始化该存储空间），就像在对 Initable2.staticNonFinal 的访问中所看到的那样。 泛化的 Class 引用Class引用总是指向某个 Class 对象，而 Class 对象可以用于产生类的实例，并且包含可作用于这些实例的所有方法代码。它还包含该类的 static 成员，因此 Class 引用表明了它所指向对象的确切类型，而==该对象便是 Class 类的一个对象。== 但是，Java 设计者看准机会，将它的类型变得更具体了一些。Java 引入泛型语法之后，我们可以使用泛型对 Class 引用所指向的 Class 对象的类型进行限定。在下面的实例中，两种语法都是正确的： 1234567891011// typeinfo/GenericClassReferences.javapublic class GenericClassReferences &#123; public static void main(String[] args) &#123; Class intClass = int.class; Class&lt;Integer&gt; genericIntClass = int.class; genericIntClass = Integer.class; // 同一个东西 intClass = double.class; // genericIntClass = double.class; // 非法 &#125;&#125; 普通的类引用不会产生警告信息。你可以看到，普通的类引用可以重新赋值指向任何其他的 Class 对象，但是使用泛型限定的类引用只能指向其声明的类型。通过使用泛型语法，我们可以让编译器强制执行额外的类型检查。 那如果我们希望稍微放松一些限制，应该怎么办呢？乍一看，下面的操作好像是可以的： 1Class&lt;Number&gt; geenericNumberClass = int.class; 这看起来似乎是起作用的，因为 Integer 继承自 Number。但事实却是不行，因为 Integer 的 Class 对象并不是 Number的 Class 对象的子类（这看起来可能有点诡异，我们将在泛型这一章详细讨论）。 为了在使用 Class 引用时放松限制，我们使用了通配符，它是 Java 泛型中的一部分。通配符就是 ?，表示“任何事物”。因此，我们可以在上例的普通 Class 引用中添加通配符，并产生相同的结果： 12345678// typeinfo/WildcardClassReferences.javapublic class WildcardClassReferences &#123; public static void main(String[] args) &#123; Class&lt;?&gt; intClass = int.class; intClass = double.class; &#125;&#125; 使用 Class&lt;?&gt; 比单纯使用 Class 要好，虽然它们是等价的，并且单纯使用 Class 不会产生编译器警告信息。使用 Class&lt;?&gt; 的好处是它表示你并非是碰巧或者由于疏忽才使用了一个非具体的类引用，而是特意为之。 为了创建一个限定指向某种类型或其子类的 Class 引用，我们需要将通配符与 extends 关键字配合使用，创建一个范围限定。这与仅仅声明 Class&lt;Number&gt; 不同，现在做如下声明： 12345678910// typeinfo/BoundedClassReferences.javapublic class BoundedClassReferences &#123; public static void main(String[] args) &#123; Class&lt;? extends Number&gt; bounded = int.class; bounded = double.class; bounded = Number.class; // Or anything else derived from Number. &#125;&#125; 向 Class 引用添加泛型语法的原因只是为了提供编译期类型检查，因此如果你操作有误，稍后就会发现这点。使用普通的 Class 引用你要确保自己不会犯错，因为一旦你犯了错误，就要等到运行时你才能发现它，这并不是很方便。 下面的示例使用了泛型语法，它保存了一个类引用，稍后又用 newInstance() 方法产生类的对象： 1234567891011121314151617181920212223242526272829303132// typeinfo/DynamicSupplier.javaimport java.util.function.*;import java.util.stream.*;class CountedInteger &#123; private static long counter; private final long id = counter++; @Override public String toString() &#123; return Long.toString(id); &#125;&#125;public class DynamicSupplier&lt;T&gt; implements Supplier&lt;T&gt; &#123; private Class&lt;T&gt; type; public DynamicSupplier(Class&lt;T&gt; type) &#123; this.type = type; &#125; public T get() &#123; try &#123; return type.newInstance(); &#125; catch(InstantiationException | IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; Stream.generate( new DynamicSupplier&lt;&gt;(CountedInteger.class)) .skip(10) .limit(5) .forEach(System.out::println); &#125;&#125; 输出结果: 123451011121314 注意，这个类必须假设与它与它一起工作的任何类型都有一个无参构造器，否者运行时会抛出异常。编译期对该程序不会产生任何警告信息。 当你将泛型语法用于 Class 对象时，newInstance() 将返回该对象的确切类型，而不仅仅只是在 ToyTest.java 中看到的基类 Object。然而，这在某种程度上有些受限： 12345678910111213141516171819// typeinfo/toys/GenericToyTest.java// 测试 Class 类// &#123;java typeinfo.toys.GenericToyTest&#125;package typeinfo.toys;public class GenericToyTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;FancyToy&gt; ftClass = FancyToy.class; // Produces exact type: FancyToy fancyToy = ftClass.newInstance(); Class&lt;? super FancyToy&gt; up = ftClass.getSuperclass(); // This won't compile: // Class&lt;Toy&gt; up2 = ftClass.getSuperclass(); // Only produces Object: Object obj = up.newInstance(); &#125;&#125; 如果你手头的是超类，那编译期将只允许你声明超类引用为“某个类，它是 FancyToy 的超类”，就像在表达式 Class&lt;? super FancyToy&gt; 中所看到的那样。而不会接收 Class&lt;Toy&gt; 这样的声明。这看上去显得有些怪，因为 getSuperClass() 方法返回的是基类（不是接口），并且编译器在编译期就知道它是什么类型了（在本例中就是 Toy.class），而不仅仅只是“某个类，它是 FancyToy 的超类”。不管怎样，正是由于这种含糊性，up.newInstance 的返回值不是精确类型，而只是 Object。 cast() 方法Java 中还有用于 Class 引用的转型语法，即 cast() 方法： 12345678910111213// typeinfo/ClassCasts.javaclass Building &#123;&#125;class House extends Building &#123;&#125;public class ClassCasts &#123; public static void main(String[] args) &#123; Building b = new House(); Class&lt;House&gt; houseType = House.class; House h = houseType.cast(b); h = (House)b; // ... 或者这样做. &#125;&#125; cast() 方法接受参数对象，并将其类型转换为 Class 引用的类型。但是，如果观察上面的代码，你就会发现，与实现了相同功能的 main 方法中最后一行相比，这种转型好像做了很多额外的工作。 cast() 在无法使用普通类型转换的情况下会显得非常有用，在你编写泛型代码（你将在泛型这一章学习到）时，如果你保存了 Class 引用，并希望以后通过这个引用来执行转型，你就需要用到 cast()。但事实却是这种情况非常少见，我发现整个 Java 类库中，只有一处使用了 cast()（在 com.sun.mirror.util.DeclarationFilter 中）。 Java 类库中另一个没有任何用处的特性就是 Class.asSubclass()，该方法允许你将一个 Class 对象转型为更加具体的类型。 类型转换检测直到现在，我们已知的RTTI类型包括: 传统的类型转换，如 “(Shape)”，由 RTTI 确保转换的正确性，如果执行了一个错误的类型转换，就会抛出一个 ClassCastException 异常。 代表对象类型的 Class 对象. 通过查询 Class 对象可以获取运行时所需的信息. 在 C++ 中，经典的类型转换 “(Shape)” 并不使用 RTTI. 它只是简单地告诉编译器将这个对象作为新的类型对待. 而 Java 会进行类型检查，这种类型转换一般被称作“类型安全的向下转型”。之所以称作“向下转型”，是因为传统上类继承图是这么画的。将 Circle 转换为 Shape 是一次向上转型, 将 Shape 转换为 Circle 是一次向下转型。但是, 因为我们知道 Circle 肯定是一个 Shape，所以编译器允许我们自由地做向上转型的赋值操作，且不需要任何显示的转型操作。当你给编译器一个 Shape 的时候，编译器并不知道它到底是什么类型的 Shape——它可能是 Shape，也可能是 Shape 的子类型，例如 Circle、Square、Triangle 或某种其他的类型。在编译期，编译器只能知道它是 Shape。因此，你需要使用显式的类型转换，以告知编译器你想转换的特定类型，否则编译器就不允许你执行向下转型赋值。 （编译器将会检查向下转型是否合理，因此它不允许向下转型到实际上不是待转型类型的子类的类型上）。 RTTI 在 Java 中还有第三种形式，那就是关键字 `instanceof`。它返回一个布尔值，告诉我们对象是不是某个特定类型的实例，可以用提问的方式使用它，就像这个样子： 12if(x instanceof Dog) ((Dog)x).bark(); 在将 x 的类型转换为 Dog 之前，if 语句会先检查 x 是否是 Dog 类型的对象。进行向下转型前，如果没有其他信息可以告诉你这个对象是什么类型，那么使用 instanceof 是非常重要的，否则会得到一个 ClassCastException 异常。 一般，可能想要查找某种类型（比如要找三角形，并填充为紫色），这时可以轻松地使用 instanceof 来计数所有对象。 instanceof 有一个严格的限制：只可以将它与命名类型进行比较，而不能与 Class 对象作比较。在前面的例子中，你可能会觉得写出一大堆 instanceof 表达式很乏味，事实也是如此。但是，也没有办法让 instanceof 聪明起来，让它能够自动地创建一个 Class 对象的数组，然后将目标与这个数组中的对象逐一进行比较（稍后会看到一种替代方案）。其实这并不是那么大的限制，如果你在程序中写了大量的 instanceof，那就说明你的设计可能存在瑕疵。 使用类字面量如果我们使用类字面量重新实现 PetCreator 类的话，其结果在很多方面都会更清晰： 1234567891011121314151617181920212223242526272829// typeinfo/pets/LiteralPetCreator.java// 使用类字面量// &#123;java typeinfo.pets.LiteralPetCreator&#125;package typeinfo.pets;import java.util.*;public class LiteralPetCreator extends PetCreator &#123; // try 代码块不再需要 @SuppressWarnings(\"unchecked\") public static final List&lt;Class&lt;? extends Pet&gt;&gt; ALL_TYPES = Collections.unmodifiableList(Arrays.asList( Pet.class, Dog.class, Cat.class, Rodent.class, Mutt.class, Pug.class, EgyptianMau.class, Manx.class, Cymric.class, Rat.class, Mouse.class, Hamster.class)); // 用于随机创建的类型: private static final List&lt;Class&lt;? extends Pet&gt;&gt; TYPES = ALL_TYPES.subList(ALL_TYPES.indexOf(Mutt.class), ALL_TYPES.size()); @Override public List&lt;Class&lt;? extends Pet&gt;&gt; types() &#123; return TYPES; &#125; public static void main(String[] args) &#123; System.out.println(TYPES); &#125;&#125; 输出结果： 12345[class typeinfo.pets.Mutt, class typeinfo.pets.Pug,class typeinfo.pets.EgyptianMau, classtypeinfo.pets.Manx, class typeinfo.pets.Cymric, classtypeinfo.pets.Rat, class typeinfo.pets.Mouse, classtypeinfo.pets.Hamster] 在即将到来的 PetCount3.java 示例中，我们用所有 Pet 类型预先加载一个 Map（不仅仅是随机生成的），因此 ALL_TYPES 类型的列表是必要的。types 列表是 ALL_TYPES 类型（使用 List.subList() 创建）的一部分，它包含精确的宠物类型，因此用于随机生成 Pet。 这次，types 的创建没有被 try 块包围，因为它是在编译时计算的，因此不会引发任何异常，不像 Class.forName()。 我们现在在 typeinfo.pets 库中有两个 PetCreator 的实现。为了提供第二个作为默认实现，我们可以创建一个使用 LiteralPetCreator 的 外观模式： 12345678910111213141516171819202122232425262728293031// typeinfo/pets/Pets.java// Facade to produce a default PetCreatorpackage typeinfo.pets;import java.util.*;import java.util.stream.*;public class Pets &#123; public static final PetCreator CREATOR = new LiteralPetCreator(); public static Pet get() &#123; return CREATOR.get(); &#125; public static Pet[] array(int size) &#123; Pet[] result = new Pet[size]; for (int i = 0; i &lt; size; i++) result[i] = CREATOR.get(); return result; &#125; public static List&lt;Pet&gt; list(int size) &#123; List&lt;Pet&gt; result = new ArrayList&lt;&gt;(); Collections.addAll(result, array(size)); return result; &#125; public static Stream&lt;Pet&gt; stream() &#123; return Stream.generate(CREATOR); &#125;&#125; 这还提供了对 get()、array() 和 list() 的间接调用，以及生成 Stream&lt;Pet&gt; 的新方法。 因为 PetCount.countPets() 采用了 PetCreator 参数，所以我们可以很容易地测试 LiteralPetCreator（通过上面的外观模式）： 12345678// typeinfo/PetCount2.javaimport typeinfo.pets.*;public class PetCount2 &#123; public static void main(String[] args) &#123; PetCount.countPets(Pets.CREATOR); &#125;&#125; 输出结果： 12345Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric RatEgyptianMau Hamster EgyptianMau Mutt Mutt Cymric MousePug Mouse Cymric&#123;EgyptianMau=2, Pug=3, Rat=2, Cymric=5, Mouse=2, Cat=9,Manx=7, Rodent=5, Mutt=3, Dog=6, Pet=20, Hamster=1&#125; 输出与 PetCount.java 的输出相同。 一个动态 instanceof 函数Class.isInstance() 方法提供了一种动态测试对象类型的方法。因此，所有这些繁琐的 instanceof 语句都可以从 PetCount.java 中删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// typeinfo/PetCount3.java// 使用 isInstance() 方法import java.util.*;import java.util.stream.*;import onjava.*;import typeinfo.pets.*;public class PetCount3 &#123; static class Counter extends LinkedHashMap&lt;Class&lt;? extends Pet&gt;, Integer&gt; &#123; Counter() &#123; super(LiteralPetCreator.ALL_TYPES.stream() .map(lpc -&gt; Pair.make(lpc, 0)) .collect( Collectors.toMap(Pair::key, Pair::value))); &#125; public void count(Pet pet) &#123; // Class.isInstance() 替换 instanceof: entrySet().stream() .filter(pair -&gt; pair.getKey().isInstance(pet)) .forEach(pair -&gt; put(pair.getKey(), pair.getValue() + 1)); &#125; @Override public String toString() &#123; String result = entrySet().stream() .map(pair -&gt; String.format(\"%s=%s\", pair.getKey().getSimpleName(), pair.getValue())) .collect(Collectors.joining(\", \")); return \"&#123;\" + result + \"&#125;\"; &#125; &#125; public static void main(String[] args) &#123; Counter petCount = new Counter(); Pets.stream() .limit(20) .peek(petCount::count) .forEach(p -&gt; System.out.print( p.getClass().getSimpleName() + \" \")); System.out.println(\"n\" + petCount); &#125;&#125; 输出结果： 12345Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric RatEgyptianMau Hamster EgyptianMau Mutt Mutt Cymric MousePug Mouse Cymric&#123;Rat=2, Pug=3, Mutt=3, Mouse=2, Cat=9, Dog=6, Cymric=5,EgyptianMau=2, Rodent=5, Hamster=1, Manx=7, Pet=20&#125; 为了计算所有不同类型的 Pet，Counter Map 预先加载了来自 LiteralPetCreator.ALL_TYPES 的类型。如果不预先加载 Map，将只计数随机生成的类型，而不是像 Pet 和 Cat 这样的基本类型。 isInstance() 方法消除了对 instanceof 表达式的需要。此外，这意味着你可以通过更改 LiteralPetCreator.types 数组来添加新类型的 Pet；程序的其余部分不需要修改（就像使用 instanceof 表达式时那样）。 递归计数PetCount3.Counter 中的 Map 预先加载了所有不同的 Pet 类。 我们可以使用 Class.isAssignableFrom() 而不是预加载地图，并创建一个不限于计数 Pet 的通用工具： Determines if the class or interface represented by this Classobject is either the same as, or is a superclass or superinterface of, the classor interface represented by the specified Class parameter. 1234567891011121314151617181920212223242526272829303132333435363738394041// onjava/TypeCounter.java// 计算类型家族的实例数package onjava;import java.util.*;import java.util.stream.*;public class TypeCounter extends HashMap&lt;Class&lt;?&gt;, Integer&gt; &#123; private Class&lt;?&gt; baseType; public TypeCounter(Class&lt;?&gt; baseType) &#123; this.baseType = baseType; &#125; public void count(Object obj) &#123; Class&lt;?&gt; type = obj.getClass(); if(!baseType.isAssignableFrom(type)) throw new RuntimeException( obj + \" incorrect type: \" + type + \", should be type or subtype of \" + baseType); countClass(type); &#125; private void countClass(Class&lt;?&gt; type) &#123; Integer quantity = get(type); put(type, quantity == null ? 1 : quantity + 1); Class&lt;?&gt; superClass = type.getSuperclass(); if(superClass != null &amp;&amp; baseType.isAssignableFrom(superClass)) countClass(superClass); &#125; @Override public String toString() &#123; String result = entrySet().stream() .map(pair -&gt; String.format(\"%s=%s\", pair.getKey().getSimpleName(), pair.getValue())) .collect(Collectors.joining(\", \")); return \"&#123;\" + result + \"&#125;\"; &#125;&#125; count() 方法获取其参数的 Class，并使用 isAssignableFrom() 进行运行时检查，以验证传递的对象实际上属于感兴趣的层次结构。countClass() 首先计算类的确切类型。然后，如果 baseType 可以从超类赋值，则在超类上递归调用 countClass()。 123456789101112131415// typeinfo/PetCount4.javaimport typeinfo.pets.*;import onjava.*;public class PetCount4 &#123; public static void main(String[] args) &#123; TypeCounter counter = new TypeCounter(Pet.class); Pets.stream() .limit(20) .peek(counter::count) .forEach(p -&gt; System.out.print( p.getClass().getSimpleName() + \" \")); System.out.println(\"n\" + counter); &#125;&#125; 输出结果： 123456Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric RatEgyptianMau Hamster EgyptianMau Mutt Mutt Cymric MousePug Mouse Cymric&#123;Dog=6, Manx=7, Cat=9, Rodent=5, Hamster=1, Rat=2,Pug=3, Mutt=3, Cymric=5, EgyptianMau=2, Pet=20,Mouse=2&#125; 输出表明两个基类型以及精确类型都被计数了。 注册工厂从 Pet 层次结构生成对象的问题是，每当向层次结构中添加一种新类型的 Pet 时，必须记住将其添加到 LiteralPetCreator.java 中的条目中。在一个定期添加更多类的系统中，这可能会成为问题。 你可能会考虑向每个子类添加静态初始值设定项，因此初始值设定项会将其类添加到某个列表中。不幸的是，静态初始值设定项仅在首次加载类时调用，因此存在鸡和蛋的问题：生成器的列表中没有类，因此它无法创建该类的对象，因此类不会被加载并放入列表中。 基本上，你必须自己手工创建列表（除非你编写了一个工具来搜索和分析源代码，然后创建和编译列表）。所以你能做的最好的事情就是把列表集中放在一个明显的地方。层次结构的基类可能是最好的地方。 我们在这里所做的另一个更改是使用工厂方法设计模式将对象的创建推迟到类本身。工厂方法可以以多态方式调用，并为你创建适当类型的对象。事实证明，java.util.function.Supplier 用 T get() 描述了原型工厂方法。协变返回类型允许 get() 为 Supplier 的每个子类实现返回不同的类型。 在本例中，基类 Part 包含一个工厂对象的静态列表，列表成员类型为 Supplier&lt;Part&gt;。对于应该由 get() 方法生成的类型的工厂，通过将它们添加到 prototypes 列表向基类“注册”。奇怪的是，这些工厂本身就是对象的实例。此列表中的每个对象都是用于创建其他对象的原型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// typeinfo/RegisteredFactories.java// 注册工厂到基础类import java.util.*;import java.util.function.*;import java.util.stream.*;class Part implements Supplier&lt;Part&gt; &#123; @Override public String toString() &#123; return getClass().getSimpleName(); &#125; static List&lt;Supplier&lt;? extends Part&gt;&gt; prototypes = Arrays.asList( new FuelFilter(), new AirFilter(), new CabinAirFilter(), new OilFilter(), new FanBelt(), new PowerSteeringBelt(), new GeneratorBelt() ); private static Random rand = new Random(47); public Part get() &#123; int n = rand.nextint(prototypes.size()); return prototypes.get(n).get(); &#125;&#125;class Filter extends Part &#123;&#125;class FuelFilter extends Filter &#123; @Override public FuelFilter get() &#123; return new FuelFilter(); &#125;&#125;class AirFilter extends Filter &#123; @Override public AirFilter get() &#123; return new AirFilter(); &#125;&#125;class CabinAirFilter extends Filter &#123; @Override public CabinAirFilter get() &#123; return new CabinAirFilter(); &#125;&#125;class OilFilter extends Filter &#123; @Override public OilFilter get() &#123; return new OilFilter(); &#125;&#125;class Belt extends Part &#123;&#125;class FanBelt extends Belt &#123; @Override public FanBelt get() &#123; return new FanBelt(); &#125;&#125;class GeneratorBelt extends Belt &#123; @Override public GeneratorBelt get() &#123; return new GeneratorBelt(); &#125;&#125;class PowerSteeringBelt extends Belt &#123; @Override public PowerSteeringBelt get() &#123; return new PowerSteeringBelt(); &#125;&#125;public class RegisteredFactories &#123; public static void main(String[] args) &#123; Stream.generate(new Part()) .limit(10) .forEach(System.out::println); &#125;&#125; 输出结果： 12345678910GeneratorBeltCabinAirFilterGeneratorBeltAirFilterPowerSteeringBeltCabinAirFilterFuelFilterPowerSteeringBeltPowerSteeringBeltFuelFilter 并非层次结构中的所有类都应实例化；这里的 Filter 和 Belt 只是分类器，这样你就不会创建任何一个类的实例，而是只创建它们的子类（请注意，如果尝试这样做，你将获得 Part 基类的行为）。 因为 Part implements Supplier&lt;Part&gt;，Part 通过其 get() 方法供应其他 Part。如果为基类 Part 调用 get()（或者如果 generate() 调用 get()），它将创建随机特定的 Part 子类型，每个子类型最终都从 Part 继承，并重写相应的 get() 以生成它们中的一个。 类的等价比较当你查询类型信息时，需要注意：instanceof 的形式(即 instanceof 或 isInstance() ，这两者产生的结果相同) 和 与 Class 对象直接比较 这两者间存在重要区别。下面的例子展示了这种区别： 12345678910111213141516171819202122232425262728293031323334353637383940// typeinfo/FamilyVsExactType.java// instanceof 与 class 的差别// &#123;java typeinfo.FamilyVsExactType&#125;package typeinfo;class Base &#123;&#125;class Derived extends Base &#123;&#125;public class FamilyVsExactType &#123; static void test(Object x) &#123; System.out.println( \"Testing x of type \" + x.getClass()); System.out.println( \"x instanceof Base \" + (x instanceof Base)); System.out.println( \"x instanceof Derived \" + (x instanceof Derived)); System.out.println( \"Base.isInstance(x) \" + Base.class.isInstance(x)); System.out.println( \"Derived.isInstance(x) \" + Derived.class.isInstance(x)); System.out.println( \"x.getClass() == Base.class \" + (x.getClass() == Base.class)); System.out.println( \"x.getClass() == Derived.class \" + (x.getClass() == Derived.class)); System.out.println( \"x.getClass().equals(Base.class)) \"+ (x.getClass().equals(Base.class))); System.out.println( \"x.getClass().equals(Derived.class)) \" + (x.getClass().equals(Derived.class))); &#125; public static void main(String[] args) &#123; test(new Base()); test(new Derived()); &#125;&#125; 输出结果： 123456789101112131415161718Testing x of type class typeinfo.Basex instanceof Base truex instanceof Derived falseBase.isInstance(x) trueDerived.isInstance(x) falsex.getClass() == Base.class truex.getClass() == Derived.class falsex.getClass().equals(Base.class)) truex.getClass().equals(Derived.class)) falseTesting x of type class typeinfo.Derivedx instanceof Base truex instanceof Derived trueBase.isInstance(x) trueDerived.isInstance(x) truex.getClass() == Base.class falsex.getClass() == Derived.class truex.getClass().equals(Base.class)) falsex.getClass().equals(Derived.class)) true test() 方法使用两种形式的 instanceof 对其参数执行类型检查。然后，它获取 Class 引用，并使用 == 和 equals() 测试 Class 对象的相等性。令人放心的是，instanceof 和 isInstance() 产生的结果与 equals() 和 == 完全相同。但测试本身得出了不同的结论。与类型的概念一致，instanceof 说的是“你是这个类，还是从这个类派生的类？”。另一方面，如果使用 == 比较实际的 Class 对象，则与继承无关 —— 它要么是确切的类型，要么不是。 反射：运行时类信息如果你不知道对象的确切类型，RTTI 会告诉你。但是，有一个限制：必须在编译时知道类型，才能使用 RTTI 检测它，并对信息做一些有用的事情。换句话说，编译器必须知道你使用的所有类。 起初，这看起来并没有那么大的限制，但是假设你被赋予了一个对不在程序空间中的对象的引用。实际上，该对象的类在编译时甚至对程序都不可用。也许你从磁盘文件或网络连接中获得了大量的字节，并被告知这些字节代表一个类。由于这个类在编译器为你的程序生成代码后很长时间才会出现，你如何使用这样的类？ 在传统编程环境中，这是一个牵强的场景。但是，当我们进入一个更大的编程世界时，会有一些重要的情况发生。第一个是基于组件的编程，你可以在应用程序构建器集成开发环境中使用快速应用程序开发（RAD）构建项目。这是一种通过将表示组件的图标移动到窗体上来创建程序的可视化方法。然后，通过在程序时设置这些组件的一些值来配置这些组件。这种设计时配置要求任何组件都是可实例化的，它公开自己的部分，并且允许读取和修改其属性。此外，处理图形用户界面（GUI）事件的组件必须公开有关适当方法的信息，以便 IDE 可以帮助程序员覆盖这些事件处理方法。反射提供了检测可用方法并生成方法名称的机制。 在运行时发现类信息的另一个令人信服的动机是提供跨网络在远程平台上创建和执行对象的能力。这称为远程方法调用（RMI），它使 Java 程序的对象分布在许多机器上。这种分布有多种原因。如果你想加速一个计算密集型的任务，你可以把它分解成小块放到空闲的机器上。或者你可以将处理特定类型任务的代码（例如，多层次客户机/服务器体系结构中的“业务规则”）放在特定的机器上，这样机器就成为描述这些操作的公共存储库，并且可以很容易地更改它以影响系统中的每个人。分布式计算还支持专门的硬件，这些硬件可能擅长于某个特定的任务——例如矩阵转换——但对于通用编程来说不合适或过于昂贵。 类 Class 支持反射的概念，以及 java.lang.reflect 库，其中包含类 Field、Method 和 Constructor（每一个都实现了 Member 接口）。这些类型的对象由 JVM 在运行时创建，以表示未知类中的对应成员。然后，可以使用 Constructor 创建新对象，get() 和 set() 方法读取和修改与 Field 对象关联的字段，invoke() 方法调用与 Method 对象关联的方法。此外，还可以调用便利方法 getFields()、getMethods()、getConstructors() 等，以返回表示字段、方法和构造函数的对象数组。（你可以通过在 JDK 文档中查找类 Class 来了解更多信息。）因此，匿名对象的类信息可以在运行时完全确定，编译时不需要知道任何信息。 重要的是要意识到反射没有什么魔力。当你使用反射与未知类型的对象交互时，JVM 将查看该对象，并看到它属于特定的类（就像普通的 RTTI）。在对其执行任何操作之前，必须加载 Class 对象。因此，该特定类型的 .class 文件必须在本地计算机上或通过网络对 JVM 仍然可用。因此，RTTI 和反射的真正区别在于，使用 RTTI 时，编译器在编译时会打开并检查 .class 文件。换句话说，你可以用“正常”的方式调用一个对象的所有方法。通过反射，.class 文件在编译时不可用；它由运行时环境打开并检查。 类方法提取器通常，你不会直接使用反射工具，但它们可以帮助你创建更多的动态代码。反射是用来支持其他 Java 特性的，例如对象序列化（参见附录：对象序列化）。但是，有时动态提取有关类的信息很有用。 考虑一个类方法提取器。查看类定义的源代码或 JDK 文档，只显示在该类定义中定义或重写的方法。但是，可能还有几十个来自基类的可用方法。找到它们既单调又费时[^1]。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// typeinfo/ShowMethods.java// 使用反射展示一个类的所有方法，甚至包括定义在基类中方法// &#123;java ShowMethods ShowMethods&#125;import java.lang.reflect.*;import java.util.regex.*;public class ShowMethods &#123; private static String usage = \"usage:n\" + \"ShowMethods qualified.class.namen\" + \"To show all methods in class or:n\" + \"ShowMethods qualified.class.name wordn\" + \"To search for methods involving 'word'\"; private static Pattern p = Pattern.compile(\"\\w+\\.\"); public static void main(String[] args) &#123; if (args.length &lt; 1) &#123; System.out.println(usage); System.exit(0); &#125; int lines = 0; try &#123; Class&lt;?&gt; c = Class.forName(args[0]); Method[] methods = c.getMethods(); Constructor[] ctors = c.getConstructors(); if (args.length == 1) &#123; for (Method method : methods) System.out.println( p.matcher( method.toString()).replaceAll(\"\")); for (Constructor ctor : ctors) System.out.println( p.matcher(ctor.toString()).replaceAll(\"\")); lines = methods.length + ctors.length; &#125; else &#123; for (Method method : methods) if (method.toString().contains(args[1])) &#123; System.out.println(p.matcher( method.toString()).replaceAll(\"\")); lines++; &#125; for (Constructor ctor : ctors) if (ctor.toString().contains(args[1])) &#123; System.out.println(p.matcher( ctor.toString()).replaceAll(\"\")); lines++; &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; System.out.println(\"No such class: \" + e); &#125; &#125;&#125; 输出结果： 12345678910111213public static void main(String[])public final void wait() throws InterruptedExceptionpublic final void wait(long,int) throwsInterruptedExceptionpublic final native void wait(long) throwsInterruptedExceptionpublic boolean equals(Object)public String toString()public native int hashCode()public final native Class getClass()public final native void notify()public final native void notifyAll()public ShowMethods() Class 方法 getmethods() 和 getconstructors() 分别返回 Method 数组和 Constructor 数组。这些类中的每一个都有进一步的方法来解析它们所表示的方法的名称、参数和返回值。但你也可以像这里所做的那样，使用 toString()，生成带有整个方法签名的 String。代码的其余部分提取命令行信息，确定特定签名是否与目标 String（使用 indexOf()）匹配，并使用正则表达式（在 Strings 一章中介绍）删除名称限定符。 编译时无法知道 Class.forName() 生成的结果，因此所有方法签名信息都是在运行时提取的。如果你研究 JDK 反射文档，你将看到有足够的支持来实际设置和对编译时完全未知的对象进行方法调用（本书后面有这样的例子）。虽然最初你可能认为你永远都不需要这样做，但是反射的全部价值可能会令人惊讶。 上面的输出来自命令行： 1java ShowMethods ShowMethods 输出包含一个 public 无参数构造函数，即使未定义构造函数。你看到的构造函数是由编译器自动合成的。如果将 ShowMethods 设置为非 public 类（即只有包级访问权），则合成的无参数构造函数将不再显示在输出中。自动为合成的无参数构造函数授予与类相同的访问权。 尝试运行 java ShowMethods java.lang.String，并附加一个 char、int、String 等参数。 编程时，当你不记得某个类是否有特定的方法，并且不想在 JDK 文档中搜索索引或类层次结构时，或者如果你不知道该类是否可以对 Color 对象执行任何操作时，该工具能节省不少时间。 动态代理代理是基本的设计模式之一。它是你插入的对象，代替“真实”对象以提供其他或不同的操作—这些操作通常涉及到与“真实”对象的通信，因此代理通常充当中间对象。这是一个简单的示例，显示代理的结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// typeinfo/SimpleProxyDemo.javainterface Interface &#123; void doSomething(); void somethingElse(String arg);&#125;class RealObject implements Interface &#123; @Override public void doSomething() &#123; System.out.println(\"doSomething\"); &#125; @Override public void somethingElse(String arg) &#123; System.out.println(\"somethingElse \" + arg); &#125;&#125;class SimpleProxy implements Interface &#123; private Interface proxied; SimpleProxy(Interface proxied) &#123; this.proxied = proxied; &#125; @Override public void doSomething() &#123; System.out.println(\"SimpleProxy doSomething\"); proxied.doSomething(); &#125; @Override public void somethingElse(String arg) &#123; System.out.println( \"SimpleProxy somethingElse \" + arg); proxied.somethingElse(arg); &#125;&#125;class SimpleProxyDemo &#123; public static void consumer(Interface iface) &#123; iface.doSomething(); iface.somethingElse(\"bonobo\"); &#125; public static void main(String[] args) &#123; consumer(new RealObject()); consumer(new SimpleProxy(new RealObject())); &#125;&#125; 输出结果： 123456doSomethingsomethingElse bonoboSimpleProxy doSomethingdoSomethingSimpleProxy somethingElse bonobosomethingElse bonobo 因为consumer()接受Interface，所以它不知道获得的是RealObject还是SimpleProxy，因为两者都实现了Interface。但是，在客户端和RealObject之间插入的SimpleProxy执行操作，然后在RealObject上调用相同的方法。 当你希望将额外的操作与“真实对象”做分离时，代理可能会有所帮助，尤其是当你想要轻松地启用额外的操作时，反之亦然（设计模式就是封装变更—所以你必须改变一些东西以证明模式的合理性）。例如，如果你想跟踪对RealObject中方法的调用，或衡量此类调用的开销，该怎么办？这不是你要写入到程序中的代码，而且代理使你可以很轻松地添加或删除它。 Java的动态代理更进一步，不仅动态创建代理对象而且动态处理对代理方法的调用。在动态代理上进行的所有调用都被重定向到单个调用处理程序，该处理程序负责发现调用的内容并决定如何处理。这是SimpleProxyDemo.java使用动态代理重写的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142// typeinfo/SimpleDynamicProxy.javaimport java.lang.reflect.*;class DynamicProxyHandler implements InvocationHandler &#123; private Object proxied; DynamicProxyHandler(Object proxied) &#123; this.proxied = proxied; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println( \"**** proxy: \" + proxy.getClass() + \", method: \" + method + \", args: \" + args); if (args != null) for (Object arg : args) System.out.println(\" \" + arg); return method.invoke(proxied, args); &#125;&#125;class SimpleDynamicProxy &#123; public static void consumer(Interface iface) &#123; iface.doSomething(); iface.somethingElse(\"bonobo\"); &#125; public static void main(String[] args) &#123; RealObject real = new RealObject(); consumer(real); // Insert a proxy and call again: Interface proxy = (Interface) Proxy.newProxyInstance( Interface.class.getClassLoader(), new Class[]&#123;Interface.class&#125;, new DynamicProxyHandler(real)); consumer(proxy); &#125;&#125; 输出结果： 12345678910doSomethingsomethingElse bonobo**** proxy: class $Proxy0, method: public abstract voidInterface.doSomething(), args: nulldoSomething**** proxy: class $Proxy0, method: public abstract voidInterface.somethingElse(java.lang.String), args:[Ljava.lang.Object;@6bc7c054 bonobosomethingElse bonobo 可以通过调用静态方法Proxy.newProxyInstance()来创建动态代理，该方法需要一个类加载器（通常可以从已加载的对象中获取），希望代理实现的接口列表（不是类或抽象类），以及接口InvocationHandler的一个实现。动态代理会将所有调用重定向到调用处理程序，因此通常为调用处理程序的构造函数提供对“真实”对象的引用，以便一旦执行中介任务便可以转发请求。 invoke()方法被传递给代理对象，以防万一你必须区分请求的来源—但是在很多情况下都无需关心。但是，在invoke()内的代理上调用方法时要小心，因为通过接口的调用是通过代理重定向的。 通常执行代理操作，然后使用Method.invoke()传递必要的参数将请求转发给代理对象。这在一开始看起来是有限制的，好像你只能执行一般的操作。但是，可以过滤某些方法调用，同时传递其他方法调用: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// typeinfo/SelectingMethods.java// Looking for particular methods in a dynamic proxyimport java.lang.reflect.*;class MethodSelector implements InvocationHandler &#123; private Object proxied; MethodSelector(Object proxied) &#123; this.proxied = proxied; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (method.getName().equals(\"interesting\")) System.out.println( \"Proxy detected the interesting method\"); return method.invoke(proxied, args); &#125;&#125;interface SomeMethods &#123; void boring1(); void boring2(); void interesting(String arg); void boring3();&#125;class Implementation implements SomeMethods &#123; @Override public void boring1() &#123; System.out.println(\"boring1\"); &#125; @Override public void boring2() &#123; System.out.println(\"boring2\"); &#125; @Override public void interesting(String arg) &#123; System.out.println(\"interesting \" + arg); &#125; @Override public void boring3() &#123; System.out.println(\"boring3\"); &#125;&#125;class SelectingMethods &#123; public static void main(String[] args) &#123; SomeMethods proxy = (SomeMethods) Proxy.newProxyInstance( SomeMethods.class.getClassLoader(), new Class[]&#123;Interface.class&#125;, new MethodSelector(new Implementation())); proxy.boring1(); proxy.boring2(); proxy.interesting(\"bonobo\"); proxy.boring3(); &#125;&#125; 输出结果： 12345boring1boring2Proxy detected the interesting methodinteresting bonoboboring3 在这个示例里，我们只是在寻找方法名，但是你也可以寻找方法签名的其他方面，甚至可以搜索特定的参数值。 动态代理不是你每天都会使用的工具，但是它可以很好地解决某些类型的问题。你可以在Erich Gamma等人的设计模式中了解有关代理和其他设计模式的更多信息。 （Addison-Wesley，1995年），以及设计模式一章。 Optional类如果你使用内置的 null 来表示没有对象，每次使用引用的时候就必须测试一下引用是否为 null，这显得有点枯燥，而且势必会产生相当乏味的代码。问题在于 null 没什么自己的行为，只会在你想用它执行任何操作的时候产生 NullPointException。java.util.Optional（首次出现是在函数式编程这章）为 null 值提供了一个轻量级代理，Optional 对象可以防止你的代码直接抛出 NullPointException。 虽然 Optional 是 Java 8 为了支持流式编程才引入的，但其实它是一个通用的工具。为了证明这点，在本节中，我们会把它用在普通的类中。因为涉及一些运行时检测，所以把这一小节放在了本章。 实际上，在所有地方都使用 Optional 是没有意义的，有时候检查一下是不是 null 也挺好的，或者有时我们可以合理的假设不会出现 null，甚至有时候检查 NullPointException 异常也是可以接受的。Optional 最有用武之地的是在那些“更接近数据”的地方，在问题空间中代表实体的对象上。举个简单的例子，很多系统中都有 Person 类型，代码中有些情况下你可能没有一个实际的 Person 对象（或者可能有，但是你还没用关于那个人的所有信息）。这时，在传统方法下，你会用到一个 null 引用，并且在使用的时候测试它是不是 null。而现在，我们可以使用 Optional： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// typeinfo/Person.java// Using Optional with regular classesimport onjava.*;import java.util.*;class Person &#123; public final Optional&lt;String&gt; first; public final Optional&lt;String&gt; last; public final Optional&lt;String&gt; address; // etc. public final Boolean empty; Person(String first, String last, String address) &#123; this.first = Optional.ofNullable(first); this.last = Optional.ofNullable(last); this.address = Optional.ofNullable(address); empty = !this.first.isPresent() &amp;&amp; !this.last.isPresent() &amp;&amp; !this.address.isPresent(); &#125; Person(String first, String last) &#123; this(first, last, null); &#125; Person(String last) &#123; this(null, last, null); &#125; Person() &#123; this(null, null, null); &#125; @Override public String toString() &#123; if (empty) return \"&lt;Empty&gt;\"; return (first.orElse(\"\") + \" \" + last.orElse(\"\") + \" \" + address.orElse(\"\")).trim(); &#125; public static void main(String[] args) &#123; System.out.println(new Person()); System.out.println(new Person(\"Smith\")); System.out.println(new Person(\"Bob\", \"Smith\")); System.out.println(new Person(\"Bob\", \"Smith\", \"11 Degree Lane, Frostbite Falls, MN\")); &#125;&#125; 输出结果： 1234&lt;Empty&gt;SmithBob SmithBob Smith 11 Degree Lane, Frostbite Falls, MN Person 的设计有时候又叫“数据传输对象（DTO，data-transfer object）”。注意，所有字段都是 public 和 final 的，所以没有 getter 和 setter 方法。也就是说，Person 是不可变的，你只能通过构造器给它赋值，之后就只能读而不能修改它的值（字符串本身就是不可变的，因此你无法修改字符串的内容，也无法给它的字段重新赋值）。如果你想修改一个 Person，你只能用一个新的 Person 对象来替换它。empty 字段在对象创建的时候被赋值，用于快速判断这个 Person 对象是不是空对象。 如果想使用 Person，就必须使用 Optional 接口才能访问它的 String 字段，这样就不会意外触发 NullPointException 了。 现在假设你已经因你惊人的理念而获得了一大笔风险投资，现在你要招兵买马了，但是在虚位以待时，你可以将 Person Optional 对象放在每个 Position 上： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// typeinfo/Position.javaimport java.util.*;class EmptyTitleException extends RuntimeException &#123;&#125;class Position &#123; private String title; private Person person; Position(String jobTitle, Person employee) &#123; setTitle(jobTitle); setPerson(employee); &#125; Position(String jobTitle) &#123; this(jobTitle, null); &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String newTitle) &#123; // Throws EmptyTitleException if newTitle is null: title = Optional.ofNullable(newTitle) .orElseThrow(EmptyTitleException::new); &#125; public Person getPerson() &#123; return person; &#125; public void setPerson(Person newPerson) &#123; // Uses empty Person if newPerson is null: person = Optional.ofNullable(newPerson) .orElse(new Person()); &#125; @Override public String toString() &#123; return \"Position: \" + title + \", Employee: \" + person; &#125; public static void main(String[] args) &#123; System.out.println(new Position(\"CEO\")); System.out.println(new Position(\"Programmer\", new Person(\"Arthur\", \"Fonzarelli\"))); try &#123; new Position(null); &#125; catch (Exception e) &#123; System.out.println(\"caught \" + e); &#125; &#125;&#125; 输出结果： 123Position: CEO, Employee: &lt;Empty&gt;Position: Programmer, Employee: Arthur Fonzarellicaught EmptyTitleException 这里使用 Optional 的方式不太一样。请注意，title 和 person 都是普通字段，不受 Optional 的保护。但是，修改这些字段的唯一途径是调用 setTitle() 和 setPerson() 方法，这两个都借助 Optional 对字段进行了严格的限制。 同时，我们想保证 title 字段永远不会变成 null 值。为此，我们可以自己在 setTitle() 方法里边检查参数 newTitle 的值。但其实还有更好的做法，函数式编程一大优势就是可以让我们重用经过验证的功能（即便是个很小的功能），以减少自己手动编写代码可能产生的一些小错误。所以在这里，我们用 ofNullable() 把 newTitle 转换一个 Optional（如果传入的值为 null，ofNullable() 返回的将是 Optional.empty()）。紧接着我们调用了 orElseThrow() 方法，所以如果 newTitle 的值是 null，你将会得到一个异常。这里我们并没有把 title 保存成 Optional，但通过利 Optional 的功能，我们仍然如愿以偿的对这个字段施加了约束。 EmptyTitleException 是一个 RuntimeException，因为它意味着程序存在错误。在这个方案里边，你仍然可能会得到一个异常。但不同的是，在错误产生的那一刻（向 setTitle() 传 null 值时）就会抛出异常，而不是发生在其它时刻，需要你通过调试才能发现问题所在。另外，使用 EmptyTitleException 还有助于定位 BUG。 Person 字段的限制又不太一样：如果你把它的值设为 null，程序会自动把将它赋值成一个空的 Person 对象。先前我们也用过类似的方法把字段转换成 Option，但这里我们是在返回结果的时候使用 orElse(new Person()) 插入一个空的 Person 对象替代了 null。 在 Position 里边，我们没有创建一个表示“空”的标志位或者方法，因为 person 字段如果是空 Person 对象就表示这个 Position 是个空缺位置。之后，你可能会发现你必须添加一个显示的表示“空位”的方法，但是 YAGNI[^2] (You Aren’t Going to Need It，你永远不需要它)。 请注意，虽然你清楚你使用了 Optional，可以免受 NullPointerExceptions 的困扰，但是 Staff 类却对此毫不知情。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// typeinfo/Staff.javaimport java.util.*;public class Staff extends ArrayList&lt;Position&gt; &#123; public void add(String title, Person person) &#123; add(new Position(title, person)); &#125; public void add(String... titles) &#123; for (String title : titles) add(new Position(title)); &#125; public Staff(String... titles) &#123; add(titles); &#125; public Boolean positionAvailable(String title) &#123; for (Position position : this) if (position.getTitle().equals(title) &amp;&amp; position.getPerson().empty) return true; return false; &#125; public void fillPosition(String title, Person hire) &#123; for (Position position : this) if (position.getTitle().equals(title) &amp;&amp; position.getPerson().empty) &#123; position.setPerson(hire); return; &#125; throw new RuntimeException( \"Position \" + title + \" not available\"); &#125; public static void main(String[] args) &#123; Staff staff = new Staff(\"President\", \"CTO\", \"Marketing Manager\", \"Product Manager\", \"Project Lead\", \"Software Engineer\", \"Software Engineer\", \"Software Engineer\", \"Software Engineer\", \"Test Engineer\", \"Technical Writer\"); staff.fillPosition(\"President\", new Person(\"Me\", \"Last\", \"The Top, Lonely At\")); staff.fillPosition(\"Project Lead\", new Person(\"Janet\", \"Planner\", \"The Burbs\")); if (staff.positionAvailable(\"Software Engineer\")) staff.fillPosition(\"Software Engineer\", new Person( \"Bob\", \"Coder\", \"Bright Light City\")); System.out.println(staff); &#125;&#125; 输出结果： 1234567891011[Position: President, Employee: Me Last The Top, LonelyAt, Position: CTO, Employee: &lt;Empty&gt;, Position:Marketing Manager, Employee: &lt;Empty&gt;, Position: ProductManager, Employee: &lt;Empty&gt;, Position: Project Lead,Employee: Janet Planner The Burbs, Position: SoftwareEngineer, Employee: Bob Coder Bright Light City,Position: Software Engineer, Employee: &lt;Empty&gt;,Position: Software Engineer, Employee: &lt;Empty&gt;,Position: Software Engineer, Employee: &lt;Empty&gt;,Position: Test Engineer, Employee: &lt;Empty&gt;, Position:Technical Writer, Employee: &lt;Empty&gt;] 注意，在有些地方你可能还是要测试引用是不是 Optional，这跟检查是否为 null 没什么不同。但是在其它地方（例如本例中的 toString() 转换），你就不必执行额外的测试了，而可以直接假设所有对象都是有效的。 标记接口有时候使用一个标记接口来表示空值会更方便。标记接口里边什么都没有，你只要把它的名字当做标签来用就可以。 123// onjava/Null.javapackage onjava;public interface Null &#123;&#125; 如果你用接口取代具体类，那么就可以使用 DynamicProxy 来自动地创建 Null 对象。假设我们有一个 Robot 接口，它定义了一个名字、一个模型和一个描述 Robot 行为能力的 List&lt;Operation&gt;： 123456789101112131415161718192021222324// typeinfo/Robot.javaimport onjava.*;import java.util.*;public interface Robot &#123; String name(); String model(); List&lt;Operation&gt; operations(); static void test(Robot r) &#123; if (r instanceof Null) System.out.println(\"[Null Robot]\"); System.out.println(\"Robot name: \" + r.name()); System.out.println(\"Robot model: \" + r.model()); for (Operation operation : r.operations()) &#123; System.out.println(operation.description.get()); operation.command.run(); &#125; &#125;&#125; 你可以通过调用 operations() 来访问 Robot 的服务。Robot 里边还有一个 static 方法来执行测试。 Operation 包含一个描述和一个命令（这用到了命令模式）。它们被定义成函数式接口的引用，所以可以把 lambda 表达式或者方法的引用传给 Operation 的构造器： 12345678910111213// typeinfo/Operation.javaimport java.util.function.*;public class Operation &#123; public final Supplier&lt;String&gt; description; public final Runnable command; public Operation(Supplier&lt;String&gt; descr, Runnable cmd) &#123; description = descr; command = cmd; &#125;&#125; 现在我们可以创建一个扫雪 Robot： 123456789101112131415161718192021222324252627282930313233343536373839404142// typeinfo/SnowRemovalRobot.javaimport java.util.*;public class SnowRemovalRobot implements Robot &#123; private String name; public SnowRemovalRobot(String name) &#123; this.name = name; &#125; @Override public String name() &#123; return name; &#125; @Override public String model() &#123; return \"SnowBot Series 11\"; &#125; private List&lt;Operation&gt; ops = Arrays.asList( new Operation( () -&gt; name + \" can shovel snow\", () -&gt; System.out.println( name + \" shoveling snow\")), new Operation( () -&gt; name + \" can chip ice\", () -&gt; System.out.println(name + \" chipping ice\")), new Operation( () -&gt; name + \" can clear the roof\", () -&gt; System.out.println( name + \" clearing roof\"))); public List&lt;Operation&gt; operations() &#123; return ops; &#125; public static void main(String[] args) &#123; Robot.test(new SnowRemovalRobot(\"Slusher\")); &#125;&#125; 输出结果： 12345678Robot name: SlusherRobot model: SnowBot Series 11Slusher can shovel snowSlusher shoveling snowSlusher can chip iceSlusher chipping iceSlusher can clear the roofSlusher clearing roof 假设存在许多不同类型的 Robot，我们想让每种 Robot 都创建一个 Null 对象来执行一些特殊的操作——在本例中，即提供 Null 对象所代表 Robot 的确切类型信息。这些信息是通过动态代理捕获的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// typeinfo/NullRobot.java// Using a dynamic proxy to create an Optionalimport java.lang.reflect.*;import java.util.*;import java.util.stream.*;import onjava.*;class NullRobotProxyHandler implements InvocationHandler &#123; private String nullName; private Robot proxied = new NRobot(); NullRobotProxyHandler(Class&lt;? extends Robot&gt; type) &#123; nullName = type.getSimpleName() + \" NullRobot\"; &#125; private class NRobot implements Null, Robot &#123; @Override public String name() &#123; return nullName; &#125; @Override public String model() &#123; return nullName; &#125; @Override public List&lt;Operation&gt; operations() &#123; return Collections.emptyList(); &#125; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(proxied, args); &#125;&#125;public class NullRobot &#123; public static Robot newNullRobot(Class&lt;? extends Robot&gt; type) &#123; return (Robot) Proxy.newProxyInstance( NullRobot.class.getClassLoader(), new Class, new NullRobotProxyHandler(type)); &#125; public static void main(String[] args) &#123; Stream.of( new SnowRemovalRobot(\"SnowBee\"), newNullRobot(SnowRemovalRobot.class) ).forEach(Robot::test); &#125;&#125; 输出结果： 1234567891011Robot name: SnowBeeRobot model: SnowBot Series 11SnowBee can shovel snowSnowBee shoveling snowSnowBee can chip iceSnowBee chipping iceSnowBee can clear the roofSnowBee clearing roof[Null Robot]Robot name: SnowRemovalRobot NullRobotRobot model: SnowRemovalRobot NullRobot 无论何时，如果你需要一个空 Robot 对象，只需要调用 newNullRobot()，并传递需要代理的 Robot 的类型。这个代理满足了 Robot 和 Null 接口的需要，并提供了它所代理的类型的确切名字。 Mock 对象和桩 没看到这个有什么用？？？？ ==Mock 对象和 桩（Stub）==在逻辑上都是 Optional 的变体。他们都是最终程序中所使用的“实际”对象的代理。不过，Mock 对象和桩都是假扮成那些可以传递实际信息的实际对象，而不是像 Optional 那样把包含潜在 null 值的对象隐藏。 Mock 对象和桩之间的的差别在于程度不同。Mock 对象往往是轻量级的，且用于自测试。通常，为了处理各种不同的测试场景，我们会创建出很多 Mock 对象。而桩只是返回桩数据，它通常是重量级的，并且经常在多个测试中被复用。桩可以根据它们被调用的方式，通过配置进行修改。因此，桩是一种复杂对象，它可以做很多事情。至于 Mock 对象，如果你要做很多事，通常会创建大量又小又简单的 Mock 对象。 接口和类型interface 关键字的一个重要目标就是允许程序员隔离构件，进而降低耦合度。使用接口可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去——接口并不是对解耦的一种无懈可击的保障。比如我们先写一个接口： 123456// typeinfo/interfacea/A.javapackage typeinfo.interfacea;public interface A &#123; void f();&#125; 然后实现这个接口，你可以看到其代码是怎么从实际类型开始顺藤摸瓜的： 12345678910111213141516171819202122232425// typeinfo/InterfaceViolation.java// Sneaking around an interfaceimport typeinfo.interfacea.*;class B implements A &#123; public void f() &#123; &#125; public void g() &#123; &#125;&#125;public class InterfaceViolation &#123; public static void main(String[] args) &#123; A a = new B(); a.f(); // a.g(); // Compile error System.out.println(a.getClass().getName()); if (a instanceof B) &#123; B b = (B) a; b.g(); &#125; &#125;&#125; 输出结果： 1B 通过使用 RTTI，我们发现 a 是被当做 B 实现的。通过将其转型为 B，我们可以调用不在 A 中的方法。 这样的操作完全是合情合理的，但是你也许并不想让客户端开发者这么做，因为这给了他们一个机会，使得他们的代码与你的代码的耦合度超过了你的预期。也就是说，你可能认为 interface 关键字正在保护你，但其实并没有。另外，在本例中使用 B 来实现 A 这中情况是有公开案例可查的[^3]。 一种解决方案是直接声明，如果开发者决定使用实际的类而不是接口，他们需要自己对自己负责。这在很多情况下都是可行的，但“可能”还不够，你或许希望能有一些更严格的控制方式。 最简单的方式是让实现类只具有包访问权限，这样在包外部的客户端就看不到它了： 123456789101112131415161718192021222324252627282930313233// typeinfo/packageaccess/HiddenC.javapackage typeinfo.packageaccess;import typeinfo.interfacea.*;class C implements A &#123; @Override public void f() &#123; System.out.println(\"public C.f()\"); &#125; public void g() &#123; System.out.println(\"public C.g()\"); &#125; void u() &#123; System.out.println(\"package C.u()\"); &#125; protected void v() &#123; System.out.println(\"protected C.v()\"); &#125; private void w() &#123; System.out.println(\"private C.w()\"); &#125;&#125;public class HiddenC &#123; public static A makeA() &#123; return new C(); &#125;&#125; 在这个包中唯一 public 的部分就是 HiddenC，在被调用时将产生 A接口类型的对象。这里有趣之处在于：即使你从 makeA() 返回的是 C 类型，你在包的外部仍旧不能使用 A 之外的任何方法，因为你不能在包的外部命名 C。 现在如果你试着将其向下转型为 C，则将被禁止，因为在包的外部没有任何 C 类型可用： 1234567891011121314151617181920212223242526272829303132// typeinfo/HiddenImplementation.java// Sneaking around package hidingimport typeinfo.interfacea.*;import typeinfo.packageaccess.*;import java.lang.reflect.*;public class HiddenImplementation &#123; public static void main(String[] args) throws Exception &#123; A a = HiddenC.makeA(); a.f(); System.out.println(a.getClass().getName()); // Compile error: cannot find symbol 'C': /* if(a instanceof C) &#123; C c = (C)a; c.g(); &#125; */ // Oops! Reflection still allows us to call g(): callHiddenMethod(a, \"g\"); // And even less accessible methods! callHiddenMethod(a, \"u\"); callHiddenMethod(a, \"v\"); callHiddenMethod(a, \"w\"); &#125; static void callHiddenMethod(Object a, String methodName) throws Exception &#123; Method g = a.getClass().getDeclaredMethod(methodName); g.setAccessible(true); g.invoke(a); &#125;&#125; 输出结果： 123456public C.f()typeinfo.packageaccess.Cpublic C.g()package C.u()protected C.v()private C.w() 正如你所看到的，通过使用反射，仍然可以调用所有方法，甚至是 private 方法！如果知道方法名，你就可以在其 Method 对象上调用 setAccessible(true)，就像在 callHiddenMethod() 中看到的那样。 你可能觉得，可以通过只发布编译后的代码来阻止这种情况，但其实这并不能解决问题。因为只需要运行 javap（一个随 JDK 发布的反编译器）即可突破这一限制。下面是一个使用 javap 的命令行： 1javap -private C -private 标志表示所有的成员都应该显示，甚至包括私有成员。下面是输出： 123456789class typeinfo.packageaccess.C extendsjava.lang.Object implements typeinfo.interfacea.A &#123; typeinfo.packageaccess.C(); public void f(); public void g(); void u(); protected void v(); private void w();&#125; 因此，任何人都可以获取你最私有的方法的名字和签名，然后调用它们。 那如果把接口实现为一个私有内部类，又会怎么样呢？下面展示了这种情况： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// typeinfo/InnerImplementation.java// Private inner classes can't hide from reflectionimport typeinfo.interfacea.*;class InnerA &#123; private static class C implements A &#123; public void f() &#123; System.out.println(\"public C.f()\"); &#125; public void g() &#123; System.out.println(\"public C.g()\"); &#125; void u() &#123; System.out.println(\"package C.u()\"); &#125; protected void v() &#123; System.out.println(\"protected C.v()\"); &#125; private void w() &#123; System.out.println(\"private C.w()\"); &#125; &#125; public static A makeA() &#123; return new C(); &#125;&#125;public class InnerImplementation &#123; public static void main(String[] args) throws Exception &#123; A a = InnerA.makeA(); a.f(); System.out.println(a.getClass().getName()); // Reflection still gets into the private class: HiddenImplementation.callHiddenMethod(a, \"g\"); HiddenImplementation.callHiddenMethod(a, \"u\"); HiddenImplementation.callHiddenMethod(a, \"v\"); HiddenImplementation.callHiddenMethod(a, \"w\"); &#125;&#125; 输出结果： 123456public C.f()InnerA$Cpublic C.g()package C.u()protected C.v()private C.w() 这里对反射仍然没有任何东西可以隐藏。那么如果是匿名类呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445// typeinfo/AnonymousImplementation.java// Anonymous inner classes can't hide from reflectionimport typeinfo.interfacea.*;class AnonymousA &#123; public static A makeA() &#123; return new A() &#123; public void f() &#123; System.out.println(\"public C.f()\"); &#125; public void g() &#123; System.out.println(\"public C.g()\"); &#125; void u() &#123; System.out.println(\"package C.u()\"); &#125; protected void v() &#123; System.out.println(\"protected C.v()\"); &#125; private void w() &#123; System.out.println(\"private C.w()\"); &#125; &#125; ; &#125;&#125;public class AnonymousImplementation &#123; public static void main(String[] args) throws Exception &#123; A a = AnonymousA.makeA(); a.f(); System.out.println(a.getClass().getName()); // Reflection still gets into the anonymous class: HiddenImplementation.callHiddenMethod(a, \"g\"); HiddenImplementation.callHiddenMethod(a, \"u\"); HiddenImplementation.callHiddenMethod(a, \"v\"); HiddenImplementation.callHiddenMethod(a, \"w\"); &#125;&#125; 输出结果： 123456public C.f()AnonymousA$1public C.g()package C.u()protected C.v()private C.w() 看起来任何方式都没法阻止反射调用那些非公共访问权限的方法。对于字段来说也是这样，即便是 private 字段： 1234567891011121314151617181920212223242526272829303132333435363738// typeinfo/ModifyingPrivateFields.javaimport java.lang.reflect.*;class WithPrivateFinalField &#123; private int i = 1; private final String s = \"I'm totally safe\"; private String s2 = \"Am I safe?\"; @Override public String toString() &#123; return \"i = \" + i + \", \" + s + \", \" + s2; &#125;&#125;public class ModifyingPrivateFields &#123; public static void main(String[] args) throws Exception &#123; WithPrivateFinalField pf = new WithPrivateFinalField(); System.out.println(pf); Field f = pf.getClass().getDeclaredField(\"i\"); f.setAccessible(true); System.out.println( \"f.getInt(pf): \" + f.getint(pf)); f.setint(pf, 47); System.out.println(pf); f = pf.getClass().getDeclaredField(\"s\"); f.setAccessible(true); System.out.println(\"f.get(pf): \" + f.get(pf)); f.set(pf, \"No, you're not!\"); System.out.println(pf); f = pf.getClass().getDeclaredField(\"s2\"); f.setAccessible(true); System.out.println(\"f.get(pf): \" + f.get(pf)); f.set(pf, \"No, you're not!\"); System.out.println(pf); &#125;&#125; 输出结果： 1234567i = 1, I'm totally safe, Am I safe?f.getInt(pf): 1i = 47, I'm totally safe, Am I safe?f.get(pf): I'm totally safei = 47, I'm totally safe, Am I safe?f.get(pf): Am I safe?i = 47, I'm totally safe, No, you're not! 但实际上 final 字段在被修改时是安全的。运行时系统会在不抛出异常的情况下接受任何修改的尝试，但是实际上不会发生任何修改。 通常，所有这些违反访问权限的操作并不是什么十恶不赦的。如果有人使用这样的技术去调用标志为 private 或包访问权限的方法（很明显这些访问权限表示这些人不应该调用它们），那么对他们来说，如果你修改了这些方法的某些地方，他们不应该抱怨。另一方面，总是在类中留下后门，也许会帮助你解决某些特定类型的问题（这些问题往往除此之外，别无它法）。总之，不可否认，发射给我们带来了很多好处。 程序员往往对编程语言提供的访问控制过于自信，甚至认为 Java 在安全性上比其它提供了（明显）更宽松的访问控制的语言要优越[^4]。然而，正如你所看到的，事实并不是这样。 本章小结RTTI 允许通过匿名类的引用来获取类型信息。初学者极易误用它，因为在学会使用多态调用方法之前，这么做也很有效。有过程化编程背景的人很容易把程序组织成一系列 switch 语句，你可以用 RTTI 和 switch 实现功能，但这样就损失了多态机制在代码开发和维护过程中的重要价值。面向对象编程语言是想让我们尽可能的使用多态机制，只在非用不可的时候才使用 RTTI。 然而使用多态机制的方法调用，要求我们拥有基类定义的控制权。因为在你扩展程序的时候，可能会发现基类并未包含我们想要的方法。如果基类来自别人的库，这时 RTTI 便是一种解决之道：可继承一个新类，然后添加你需要的方法。在代码的其它地方，可以检查你自己特定的类型，并调用你自己的方法。这样做不会破坏多态性以及程序的扩展能力，因为这样添加一个新的类并不需要修改程序中的 switch 语句。但如果想在程序中增加具有新特性的代码，你就必须使用 RTTI 来检查这个特定的类型。 如果只是为了方便某个特定的类，就将某个特性放进基类里边，这将使得从那个基类派生出的所有其它子类都带有这些可能毫无意义的东西。这会导致接口更加不清晰，因为我们必须覆盖从基类继承而来的所有抽象方法，事情就变得很麻烦。举个例子，现在有一个表示乐器 Instrument 的类层次结构。假设我们想清理管弦乐队中某些乐器残留的口水，一种办法是在基类 Instrument 中放入 clearSpitValve() 方法。但这样做会导致类结构混乱，因为这意味着打击乐器 Percussion、弦乐器 Stringed 和电子乐器 Electronic 也需要清理口水。在这个例子中，RTTI 可以提供一种更合理的解决方案。可以将 clearSpitValve() 放在某个合适的类中，在这个例子中是管乐器 Wind。不过，在这里你可能会发现还有更好的解决方法，就是将 prepareInstrument() 放在基类中，但是初次面对这个问题的读者可能想不到还有这样的解决方案，而误认为必须使用 RTTI。 最后一点，RTTI 有时候也能解决效率问题。假设你的代码运用了多态，但是为了实现多态，导致其中某个对象的效率非常低。这时候，你就可以挑出那个类，使用 RTTI 为它编写一段特别的代码以提高效率。然而必须注意的是，不要太早的关注程序的效率问题，这是个诱人的陷阱。最好先让程序能跑起来，然后再去看看程序能不能跑得更快，下一步才是去解决效率问题（比如使用 Profiler）[^5]。 我们已经看到，反射，因其更加动态的编程风格，为我们开创了编程的新世界。但对有些人来说，反射的动态特性却是一种困扰。对那些已经习惯于静态类型检查的安全性的人来说，Java 中允许这种动态类型检查（只在运行时才能检查到，并以异常的形式上报检查结果）的操作似乎是一种错误的方向。有些人想的更远，他们认为引入运行时异常本身就是一种指示，指示我们应该避免这种代码。我发现这种意义的安全是一种错觉，因为总是有些事情是在运行时才发生并抛出异常的，即使是在那些不包含任何 try 语句块或异常声明的程序中也是如此。因此，我认为一致性错误报告模型的存在使我们能够通过使用反射编写动态代码。当然，尽力编写能够进行静态检查的代码是有价值的，只有你有这样的能力。但是我相信动态代码是将 Java 与其它诸如 C++ 这样的语言区分开的重要工具之一。 [^1]: 特别是在过去。但现在 Java 的 HTML 文档有了很大的提升，要查看基类的方法已经变得很容易了。[^2]: 这是极限编程（XP，Extreme Programming）的原则之一：“Try the simplest thing that could possibly work，实现尽最大可能的简单。”[^3]: 最著名的例子是 Windows 操作系统，Windows 为开发者提供了公开的 API，但是开发者还可以找到一些非公开但是可以调用的函数。为了解决问题，很多程序员使用了隐藏的 API 函数。这就迫使微软公司要像维护公开 API 一样维护这些隐藏的 API，消耗了巨大的成本和精力。[^4]: 比如，Python 中在元素前面添加双下划线 __，就表示你想隐藏这个元素。如果你在类或者包外面调用了这个元素，运行环境就会报错。[^5]: 译者注：Java Profiler 是一种 Java 性能分析工具，用于在 JVM 级别监视 Java 字节码的构造和执行。主流的 Profiler 有 JProfiler、YourKit 和 Java VisualVM 等。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"maven","slug":"java-note/maven/maven","date":"2019-10-13T07:09:35.000Z","updated":"2021-10-23T02:49:43.147Z","comments":true,"path":"2019/10/java-note/maven/maven/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/maven/maven/","excerpt":"[TOC]maven[菜鸟教程-maven][https://www.runoob.com/maven/maven-tutorial.html]Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。","text":"[TOC]maven[菜鸟教程-maven][https://www.runoob.com/maven/maven-tutorial.html]Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。 Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。 maven中的概念POMPOM是项目对象模型(Project Object Model)的简称,它是Maven项目中的文件,使用XML表示,名称叫做pom.xml。 Maven 功能Maven 能够帮助开发者完成以下工作： 构建 文档生成 报告 依赖 SCMs 发布 分发 邮件列表 约定配置Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示： 目录 目的 ${basedir} 存放pom.xml和所有的子目录 ${basedir}/src/main/java 项目的java源代码 ${basedir}/src/main/resources 项目的资源，比如说property文件，springmvc.xml ${basedir}/src/test/java 项目的测试类，比如说Junit代码 ${basedir}/src/test/resources 测试用的资源 ${basedir}/src/main/webapp/WEB-INF web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面 ${basedir}/target 打包输出目录 ${basedir}/target/classes 编译输出目录 ${basedir}/target/test-classes 测试编译输出目录 Test.java Maven只会自动运行符合该命名规则的测试类 ~/.m2/repository Maven默认的本地仓库目录位置 Maven 特点 项目设置遵循统一的规则。 任意工程中共享。 依赖管理包括自动更新。 一个庞大且不断增长的库。 可扩展，能够轻松编写 Java 或脚本语言的插件。 只需很少或不需要额外配置即可即时访问新功能。 基于模型的构建 − Maven能够将任意数量的项目构建到预定义的输出类型中，如 JAR，WAR 或基于项目元数据的分发，而不需要在大多数情况下执行任何脚本。 项目信息的一致性站点 − 使用与构建过程相同的元数据，Maven 能够生成一个网站或PDF，包括您要添加的任何文档，并添加到关于项目开发状态的标准报告中。 发布管理和发布单独的输出 − Maven 将不需要额外的配置，就可以与源代码管理系统（如 Subversion 或 Git）集成，并可以基于某个标签管理项目的发布。它也可以将其发布到分发位置供其他项目使用。Maven 能够发布单独的输出，如 JAR，包含其他依赖和文档的归档，或者作为源代码发布。 向后兼容性 − 您可以很轻松的从旧版本 Maven 的多个模块移植到 Maven 3 中。 子项目使用父项目依赖时，正常情况子项目应该继承父项目依赖，无需使用版本号， 并行构建 − 编译的速度能普遍提高20 - 50 %。 更好的错误报告 − Maven 改进了错误报告，它为您提供了 Maven wiki 页面的链接，您可以点击链接查看错误的完整描述。 Maven 环境配置Maven 是一个基于 Java 的工具，所以要做的第一件事情就是安装 JDK。 Java 开发环境配置 Maven 仓库在 Maven 的术语中，仓库是一个位置（place）。 Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。 在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。 Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。 Maven 仓库有三种类型： 本地（local） 中央（central） 远程（remote） 本地仓库Maven 的本地仓库，在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建。 运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。 默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/respository/ 的仓库目录。 Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。 1234567&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;D:/maven/MyLocalRepository&lt;/localRepository&gt; &lt;/settings&gt; 当你运行 Maven 命令，Maven 将下载依赖的文件到你指定的路径中。 中央仓库Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。 中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。 中央仓库的关键概念： 这个仓库由 Maven 社区管理。 不需要配置。 需要通过网络才能访问。 要浏览中央仓库的内容，maven 社区提供了一个 URL：http://search.maven.org/#browse。使用这个仓库，开发人员可以搜索所有可以获取的代码库。 远程仓库如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。 举例说明，使用下面的 pom.xml，Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件。 1234567891011121314151617181920212223242526&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.companyname.projectgroup&lt;/groupId&gt; &lt;artifactId&gt;project&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.companyname.common-lib&lt;/groupId&gt; &lt;artifactId&gt;common-lib&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;companyname.lib1&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib1&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;companyname.lib2&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib2&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; Maven 依赖搜索顺序当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库： 步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。 步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。 步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。 步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。 Maven 阿里云(Aliyun)仓库Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库。 第一步:修改 maven 根目录下的 conf 文件夹中的 setting.xml 文件，在 mirrors 节点上，添加内容如下： 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 第二步: pom.xml文件里添加： 123456789101112&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; maven配置文件D:\\apache-maven-3.6.1\\conf\\settings.xml 设置镜像阿里mirrors 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 配置maven的jdk 1234567891011&lt;profile&gt; &lt;id&gt;jdk18&lt;/id&gt; &lt;activation&gt; &lt;activaByDefault&gt;true&lt;/activaByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; maven使用spring单元测试test写在src/test/mapper/目录下 推荐Spring的项目就可以使用spring的单元测试，可以依赖注入我们需要的组件 1.导入springTest模块(meven导包) 2.@ContextConfiguration指定spring配置文件内容,@RunWith(SpringJUnit4ClassRunner.class) 3.直接autoWrited要使用的组件即可 1234567** * 测试dao工作层 * @author test */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:applicationContext.xml\"&#125;)public class MapperTest &#123; maven的pom.xml结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!--maven的pom.xml结构--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--组织名称 一般是公司名称的倒写，像包名--&gt; &lt;groupId&gt;com.sz&lt;/groupId&gt; &lt;!--项目，模块名称--&gt; &lt;artifactId&gt;helloworld1&lt;/artifactId&gt; &lt;!--版本号--&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目名--&gt; &lt;name&gt;helloworld1&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;!--属性的定义--&gt; &lt;!--项目构建使用字符编码--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!--编译源代码的版本--&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;!--目标代码的版本--&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;!--依赖集 你所需要的jar包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--要什么jar全部到maven中央仓库去找仓库中进行搜索即可--&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;!--这是一个依赖--&gt; &lt;dependency&gt; &lt;!--通过坐标来描述--&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; maven目录结构测试类一般是放在src/test/java,而不是放在src/main/java下.maven在编译的时候,src/main/java下是不引用test的jar,而编译src/test/java下的测试这会引用test的jar maven中classpath路径在Maven工程中，classpath的路径指java resources路径下的目录，即 src/main/java、 src/main/resource、src/test/java 、src/test/resource 四个目录所以在配置路径时需要注意文件名是否重名，导致加载文件失败 Maven 的 Snapshot 版本与 Release 版本1、Snapshot 版本代表不稳定、尚处于开发中的版本。 2、Release 版本则代表稳定的版本。 安装maven注意点maven配置文件 maven本地仓库位置","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"maven","slug":"maven","permalink":"https://codeofli.github.io/tags/maven/"}]},{"title":"mybatis","slug":"java-note/mybatis/mybatis","date":"2019-10-12T02:40:06.000Z","updated":"2021-10-23T02:19:04.200Z","comments":true,"path":"2019/10/java-note/mybatis/mybatis/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/mybatis/mybatis/","excerpt":"[TOC]入门mybatis约定：输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个如果输入参数 ：是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx} 如果是对象类型，则必须是对象的属性 #{属性名}输出参数： 如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个， 再resultType都写成org.lanqiao.entity.Student 即 resultType=”org.lanqiao.entity.Student”","text":"[TOC]入门mybatis约定：输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个如果输入参数 ：是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx} 如果是对象类型，则必须是对象的属性 #{属性名}输出参数： 如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个， 再resultType都写成org.lanqiao.entity.Student 即 resultType=”org.lanqiao.entity.Student” 注意事项：如果使用的 事务方式为 jdbc,则需要 手工commit提交，即session.commit(); conf.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 通过environment的default值和environment的id值指定Mybatis数据库的运行环境 --&gt; &lt;environments default=\"development\"&gt; &lt;!-- development environment --&gt; &lt;environment id=\"development\"&gt; &lt;!-- 事务提交方式： JDBC：使用JDBC方式提交事务（commit rollback close） MANAGED:将事务交给其他组件去托管（spring，jobss）默认自动关闭 设置不关闭： &lt;transactionManager type=\"MANAGED\" /&gt; property name=\"closeConnection\" value=\"false\" /&gt; --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据源类型 UNPOOLED:传统jdbc方式(每次访问数据，均需要打开和关闭等数据库操作，但是打开和关闭都是很浪费资源和性能的） POLLED：使用数据库连接池 JNDI：从tomcat中获取一个内置数据库连接池（数据库连接池-数据源） --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置数据库信息 --&gt; &lt;property name=\"driver\" value=\"oracle.jdbc.OracleDriver\" /&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@localhost:1521:MLDN\" /&gt; &lt;property name=\"username\" value=\"scott\" /&gt; &lt;property name=\"password\" value=\"tigger\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- test environment--&gt; &lt;environment id=\"test\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置数据库信息 --&gt; &lt;property name=\"driver\" value=\"oracle.jdbc.OracleDriver\" /&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@111:11:11:1521:MLDN\" /&gt; &lt;property name=\"username\" value=\"scott\" /&gt; &lt;property name=\"password\" value=\"tigger\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 加载映射文件 --&gt; &lt;mapper resource=\"pers/nicolas/entity/studentMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper.xml1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace：该mapper.xml映射文件的唯一标识 --&gt;&lt;mapper namespace=\"pers.nicolas.entity.studnetMapper\"&gt; &lt;!-- 后续通过namespace.Id 定位该SQL语句--&gt; &lt;!-- parameterType：输入参数的类型 resultType：查询结果的返回类型 --&gt; &lt;select id=\"queryStudentBysno\" parameterType=\"int\" resultType=\"pers.nicolas.entity.Student\"&gt; select * from student where stuno = #&#123;stuno&#125;&lt;!-- 不能有分号！！！无效字符 --&gt; &lt;/select&gt; &lt;insert id=\"addStudent\" parameterType=\"pers.nicolas.entity.Student\" &gt; insert into student(stuno,stuname,stuage,graname) values(#&#123;stuNo&#125;,#&#123;stuName&#125;,#&#123;stuAge&#125;,#&#123;graName&#125;) &lt;/insert&gt; &lt;delete id=\"deleteStudentBySno\" parameterType=\"int\"&gt; delete from student where stuno=#&#123;stuno&#125; &lt;/delete&gt; &lt;update id=\"updateStudentBySno\" parameterType=\"pers.nicolas.entity.Student\"&gt; update student set stuno=#&#123;stuNo&#125;, stuname = #&#123;stuName&#125;, stuage=#&#123;stuAge&#125;,graname=#&#123;graName&#125; &lt;/update&gt; &lt;select id=\"queryAllStudents\" resultType=\"pers.nicolas.entity.Student\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; mybatis约定：输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个 如果输入参数 ：是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx} 如果是对象类型，则必须是对象的属性 #{属性名} 输出参数： 如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个， 再resultType都写成org.lanqiao.entity.Student 即 resultType=”org.lanqiao.entity.Student” 注意事项：如果使用的 事务方式为 jdbc,则需要 手工commit提交，即session.commit(); mapper动态代理方式的crud又称（MyBatis接口开发） 原则：约定优于配置 硬编码方式 abc.java Configuration conf = new Configuration(); con.setName(“myProject”) ; 配置方式： abc.xml myProject 约定：默认值就是myProject 具体实现的步骤：1.基础环境：mybatis.jar/ojdbc.jar、conf.xml、mapper.xml2.（不同之处） 约定的目标： 省略掉statement,即根据约定 直接可以定位出SQL语句 a.接口，接口中的方法必须遵循以下约定： 1.方法名和mapper.xml文件中标签的id值相同 2 .方法的 输入参数 和mapper.xml文件中标签的 parameterType类型一致 (如果mapper.xml的标签中没有 parameterType，则说明方法没有输入参数) 3.方法的返回值 和mapper.xml文件中标签的 resultType类型一致 （无论查询结果是一个 还是多个（student、List），在mapper.xml标签中的resultType中只写 一个（Student）；如果没有resultType，则说明方法的返回值为void） 除了以上约定，要实现 接口中的方法 和 Mapper.xml中SQL标签一一对应，还需要以下1点： namespace的值 ，就是 接口的全类名（ 接口 - mapper.xml 一一对应） 匹配的过程：（约定的过程）1.根据 接口名 找到 mapper.xml文件（根据的是namespace=接口全类名）2.根据 接口的方法名 找到 mapper.xml文件中的SQL标签 （方法名=SQL标签Id值） 以上2点可以保证： 当我们调用接口中的方法时，程序能自动定位到 某一个Mapper.xml文件中的sqL标签 习惯：SQL映射文件（mapper.xml） 和 接口放在同一个包中 （注意修改conf.xml中加载mapper.xml文件的路径） 以上，可以通过接口的方法-&gt;SQL语句 执行： StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; studentMapper.方法(); 通过session对象获取接口（session.getMapper(接口.class);），再调用该接口中的方法，程序会自动执行该方法对应的SQL。 配置别名https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases 1234&lt;typeAliases&gt; &lt;typeAlias alias=\"Problem\" type=\"com.yoj.web.bean.Problem\"/&gt; &lt;package name=\"com.yoj.web.bean\"/&gt;&lt;/typeAliases&gt; 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子： 1234@Alias(\"author\")public class Author &#123; ...&#125; 类型处理器（类型转换器）1.MyBatis自带一些常见的类型处理器 int - number 2.自定义MyBatis类型处理器 1java -数据库(jdbc类型) 示例：实体类Student : boolean stuSex true:男 false：女 表student： number stuSex 1:男 0：女自定义类型转换器（boolean -number）步骤：a.创建转换器：需要实现TypeHandler接口 通过阅读源码发现，此接口有一个实现类 BaseTypeHandler ，因此 要实现转换器有2种选择： i.实现接口TypeHandler接口 ii.继承BaseTypeHandlerb.配置conf.xml 需要注意的问题： INTEGER(需要大写) 1insert into student(stuno,stuname,stuage,graname,stusex) values(#&#123;stuNo&#125;,#&#123;stuName&#125;,#&#123;stuAge&#125;,#&#123;graName&#125; ,#&#123;stuSex ,javaType=boolean ,jdbcType=INTEGER &#125; ) 注意#{stuNo} 中存放的是 属性值，需要严格区分大小写。 resultMap可以实现2个功能：1.类型转换2.属性-字段的映射关系 select * from student where stuno = #{stuno} 12345678&lt;resultMap type=\"student\" id=\"studentMapping\"&gt; &lt;!-- 分为主键id 和非主键 result--&gt; &lt;id property=\"id\" column=\"stuno\" /&gt; &lt;result property=\"stuName\" column=\"stuname\" /&gt; &lt;result property=\"stuAge\" column=\"stuage\" /&gt; &lt;result property=\"graName\" column=\"graname\" /&gt; &lt;result property=\"stuSex\" column=\"stusex\" javaType=\"boolean\" jdbcType=\"INTEGER\"/&gt; &lt;/resultMap&gt; mybatis调用存储过程123456789&lt;select id=\"queryCountByGradeWithProcedure\" statementType=\"CALLABLE\" parameterType=\"HashMap\" &gt; &#123; CALL queryCountByGradeWithProcedure( #&#123;gName,jdbcType=VARCHAR,mode=IN&#125;, #&#123;scount,jdbcType=INTEGER,mode=OUT&#125; ) &#125; &lt;/select&gt; 其中 通过statementType=”CALLABLE”设置SQL的执行方式是存储过程。 存储过程的输入参数gName需要通过HashMap来指定在使用时，通过hashmap的put方法传入输入参数的值；通过hashmap的Get方法 获取输出参数的值。要注意Jar问题：ojdbc6.jar不能在 调存储过程时 打回车、tab，但是ojdbc7.jar可以。 如果报错： No enum constant org.apache.ibatis.type.JdbcType.xx，则说明mybatis不支持xx类型，需要查表。 存储过程 无论输入参数是什么值，语法上都需要 用map来传递该值； 只要 是 ，则增删改都需要手工commit ; mapper.xml-&gt;mapper接口-&gt;测试方法 输入和输出参数输入参数parameterType1.类型为 简单类型（8个基本类型+String）#{}、${}的区别a.#{任意值}${value} ，其中的标识符只能是value b.#{}自动给String类型加上’’ （自动类型转换） ${} 原样输出，但是适合于 动态排序（动态字段） select stuno,stuname,stuage from student where stuname = #{value} select stuno,stuname,stuage from student where stuname = ‘${value}’ 动态排序：select stuno,stuname,stuage from student order by ${value} asc c.#{}可以防止SQL注入 ${}不防止 ${}、#{}相同之处：a.都可以 获取对象的值 （嵌套类型对象） i.获取对象值：模糊查询，方式一： 1select stuno,stuname,stuage from student where stuage= #&#123;stuAge&#125; or stuname like #&#123;stuName&#125; 1234Student student = new Student(); student.setStuAge(24); student.setStuName(\"%w%\"); List&lt;Student&gt; students = studentMapper.queryStudentBystuageOrstuName(student) ;//接口的方法-&gt;SQL 模糊查询，方式二： student.setStuName(“w”); select stuno,stuname,stuage from student where stuage= #{stuAge} or stuname like ‘%${stuName}%’ ii.嵌套类型对象 2.对象类型#{属性名}${属性名} 输入对象为HashMap：where stuage= #{stuAge} 用map中key的值 匹配 占位符#{stuAge}，如果匹配成功 就用map的value替换占位符 输出参数resultType输出参数resultType1.简单类型（8个基本+String）2.输出参数为实体对象类型3.输出参数为实体对象类型的集合 ：虽然输出类型为集合，但是resultType依然写 集合的元素类型（resyltType=”Student”）4.输出参数类型为HashMap –HashMap本身是一个集合，可以存放多个元素， 但是根据提示发现 返回值为HashMap时 ，查询的结果只能是1个学生（no,name）；–&gt;结论：一个HashMap 对应一个学生的多个元素（多个属性） 【一个map，一个学生】 二维数组{ {1,zs,23,xa}, -一个HashMap对象 {2,ls,24,bj}, {3,ww,25,tj}} resultTyperesultMap:实体类的属性、数据表的字段： 类型、名字不同时（stuno,id）注意：当属性名 和字段名 不一致时，除了使用resultMap以外，还可以使用resultType+HashMap: a.resultMap b.resultType+HashMapselect 表的字段名 “类的属性名” from… 来制定字段名 和属性名的对应关系 select id “stuNo”,name “stuName” from student where id = #{id} 注意: 如果如果10个字段，但发现 某一个字段结果始终为默认值（0，0.0，null），则可能是 表的字段 和 类的属性名字写错。 //查询全部String statement = “select stuno,stuname from student”; //根据年龄查询学生 String statement = “select stuno,stuname from student where stuage = #{stuage}”; //根据姓名和年龄查询学生 String statement = “select stuno,stuname from student where stuage = #{stuage} and stuage = #{stuage} “; select stuno,stuname from student where stuname = #{stuName}and stuage = #{stuAge} 查询使用了类型转换器 1.如果类中属性和表中字段类型能够合理识别（String-varchar2），则可以使用resultType，(boolean-number)否则使用resultMap； 2.如果类中属性名和表中字段名能够合理识别（stuNo-stuno），则可以使用resultType，（stuno-id）否则使用resultMap； 1234&lt;!-- 别名作为HashMap的Key --&gt; &lt;select id=\"queryStudentOutByHashMap\" resultMap=\"HashMap\"&gt; select stuno \"no\", stuname \"name\" from student &lt;/select&gt; 1234567891011&lt;!--resultMap --&gt; &lt;select id=\"queryStudentById\" parameterType=\"int\" resultMap=\"queryStudentByIdMap\"&gt; select id,name from student where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap type=\"Student\" id=\"queryStudentByIdMap\"&gt; &lt;!-- 将类中属性和表中字段对应起来 --&gt; &lt;!-- 分为主键id和非主键 result --&gt; &lt;id property=\"stuNo\" column=\"id\"/&gt; &lt;result property=\"stuName\" column=\"name\"/&gt; &lt;/resultMap&gt; 12345&lt;!--resultType HashMap方式起别名--&gt; &lt;select id=\"queryStudentByIdWithHashMap\" parameterType=\"int\" resultType=\"Student\"&gt; select id \"stuNo\",name \"stuName\" from student where id = #&#123;id&#125; &lt;/select&gt; 动态sql官网地址 wherewhere 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除。 如果 where 元素没有按正常套路出牌，我们可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为： 123&lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"&gt; ...&lt;/trim&gt; 123456789101112&lt;!-- where标签 --&gt;&lt;select id=\"queryStudentBySqlTag\" parameterType=\"student\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"stuName != null and stuName !='' \"&gt; and stuName = #&#123;stuName&#125; &lt;/if&gt; &lt;if test=\"stuAge != null and stuAge !=0 \"&gt; and stuAge = #&#123;stuAge&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 简单类型的数组:无论编写代码时，传递的是什么参数名(stuNos)，在mapper.xml中 必须用array代替该数组 集合：无论编写代码时，传递的是什么参数名(stuNos)，在mapper.xml中 必须用list代替该数组 对象数组：Student[] students = {student0,student1,student2} 每个studentx包含一个学号属性注意的几点： parameterType=”Object[]” #{student.stuNo} SQL片段： java：方法 数据库：存储过程、存储函数 Mybatis :SQL片段 a.提取相似代码b.引用 if标签12345678910&lt;!-- 添加虚拟前缀 --&gt;&lt;select id=\"queryStudentBySqlTag\" parameterType=\"student\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student where 1=1 &lt;if test=\"stuName != null and stuName !='' \"&gt; and stuName = #&#123;stuName&#125; &lt;/if&gt; &lt;if test=\"stuAge != null and stuAge !=0 \"&gt; and stuAge = #&#123;stuAge&#125; &lt;/if&gt; &lt;/select&gt; foreach Tag12345678910111213&lt;!-- foreach迭代 使用对象属性--&gt; &lt;select id=\"queryStudentInGrade\" parameterType=\"grade\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"stuNos != null and stuNos.size &gt; 0\"&gt; &lt;foreach collection=\"stuNos\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 12345678910111213&lt;!-- foreach迭代 使用list集合--&gt; &lt;select id=\"queryStudentWithList\" parameterType=\"list\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"list != null and list.size &gt; 0\"&gt; &lt;foreach collection=\"list\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 12345678910111213&lt;!-- foreach迭代 使用简单数组--&gt; &lt;select id=\"queryStudentWithArray\" parameterType=\"int[]\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"array != null and array.length &gt; 0\"&gt; &lt;foreach collection=\"array\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 12345678910111213&lt;!-- foreach迭代 使用对象数组--&gt; &lt;select id=\"queryStudentWithObjectArray\" parameterType=\"Object[]\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"array != null and array.length &gt; 0\"&gt; &lt;foreach collection=\"array\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 1public List&lt;Student&gt; queryStudentWithObjectArray(Student[] stuNos); sql片段1234567891011121314151617&lt;sql id=\"ObjectArraySql\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"array != null and array.length &gt; 0\"&gt; &lt;foreach collection=\"array\" open=\"and stuno in(\" close=\")\" item=\"student\" separator=\",\"&gt; #&#123;student.stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt;&lt;select id=\"queryStudentWithObjectArray\" parameterType=\"Object[]\" resultType=\"student\"&gt; &lt;!-- 同一文件映射文件下可以省略当前namespace：namesapceId --&gt; &lt;include refid=\"pers.nicolas.mapper.StudentMapper.ObjectArraySql\"&gt;&lt;/include&gt; &lt;/select&gt; 查询关联查询：一对一:a.业务扩展类 核心：用resultType指定类(该类扩展了连接查询的所有属性)的属性 包含 多表查询的所有字段 b.resultMap i.通过 属性成员 将2个类建立起联系 -&gt;一对一：association 2. 1234567891011&lt;resultMap type=\"student\" id=\"student_card_map\"&gt; &lt;!-- 学生的信息 --&gt; &lt;id property=\"stuNo\" column=\"stuNo\"/&gt; &lt;result property=\"stuName\" column=\"stuName\" /&gt; &lt;result property=\"stuAge\" column=\"stuAge\" /&gt; &lt;!-- 一对一时，对象成员使用 association映射;javaType指定该属性的类型--&gt; &lt;association property=\"card\" javaType=\"StudentCard\" &gt; &lt;id property=\"cardId\" column=\"cardId\"/&gt; &lt;result property=\"cardInfo\" column=\"cardInfo\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 一对一：association一对多：collection 一对多：表：student studentclass (关联：classid)类：student studentClass (关联：List students ) 123456789101112131415161718192021222324&lt;!-- 利用resultMap实现一对多 --&gt; &lt;select id=\"queryClassAndStudents\" parameterType=\"int\" resultMap=\"class_student_map\"&gt; select s.*,c.* from student s inner join studentclass c on s.classid = c.classid where c.classid = #&#123;classId&#125; &lt;/select&gt; &lt;!-- 类与表一一对应 --&gt; &lt;resultMap type=\"StudentClass\" id=\"class_student_map\"&gt; &lt;id property=\"classId\" column=\"classId\" /&gt; &lt;result property=\"className\" column=\"className\" /&gt; &lt;!-- 一对多；属性类型javaType；（集合）属性的元素类型ofType --&gt; &lt;collection property=\"students\" ofType=\"Student\"&gt; &lt;id property=\"stuNo\" column=\"stuno\" /&gt; &lt;result property=\"stuName\" column=\"stuname\" /&gt; &lt;result property=\"stuAge\" column=\"stuAge\" /&gt; &lt;result property=\"graName\" column=\"graname\" /&gt; &lt;result property=\"stuSex\" column=\"stusex\" /&gt; &lt;association property=\"card\" javaType=\"StudentCard\"&gt; &lt;id property=\"cardId\" column=\"cardid\" /&gt; &lt;result property=\"cardInfo\" column=\"cardInfo\" /&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt; 一对多 （MyBatis:多对一，多对多的本质就是 一对多的变化） 多对一可以传入多个参数**column=”{prop1=col1,prop2=col2}” 123456789&lt;association property=\"userSolved\" javaType=\"INTEGER\" select=\"com.yoj.web.dao.SolutionMapper.querySolved\" column=\"&#123;userId = user_id,problemId = problem_id&#125;\"&gt;&lt;/association&gt;&lt;association property=\"userSubmitted\" javaType=\"INTEGER\" select=\"com.yoj.web.dao.SolutionMapper.querySubmitted\" column=\"&#123;userId = user_id,problemId = problem_id&#125;\"&gt;&lt;/association&gt;&lt;/resultMap&gt; 12@Select(\"SELECT solution_id FROM solution WHERE problem_id = #&#123;problemId&#125; and user_id = #&#123;userId&#125; and result = 0 LIMIT 1\")Integer querySolved(Map&lt;String, Object&gt; map); 关联的嵌套 Select 查询可以传入多个参数column=”{prop1=col1,prop2=col2}” 注意接收属性为Map 123456789&lt;association property=\"userSolved\" javaType=\"INTEGER\" select=\"com.yoj.web.dao.SolutionMapper.querySolved\" column=\"&#123;userId = user_id,problemId = problem_id&#125;\"&gt;&lt;/association&gt;&lt;association property=\"userSubmitted\" javaType=\"INTEGER\" select=\"com.yoj.web.dao.SolutionMapper.querySubmitted\" column=\"&#123;userId = user_id,problemId = problem_id&#125;\"&gt;&lt;/association&gt;&lt;/resultMap&gt; 12345@Select(\"SELECT solution_id FROM solution WHERE problem_id = #&#123;problemId&#125; and user_id = #&#123;userId&#125; and result = 0 LIMIT 1\")Integer querySolved(Map&lt;String,Object&gt; map);@Select(\"SELECT solution_id FROM solution WHERE problem_id = #&#123;problemId&#125; and user_id = #&#123;userId&#125; LIMIT 1\")Integer querySubmitted(Map&lt;String,Object&gt; map); 属性 描述 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 column=&quot;{prop1=col1,prop2=col2}&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 select 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 column=&quot;{prop1=col1,prop2=col2}&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 fetchType 可选的。有效值为 lazy 和 eager。 指定属性后，将在映射中忽略全局配置参数 lazyLoadingEnabled，使用属性的值。 示例： 1234567891011&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;association property=\"author\" column=\"author_id\" javaType=\"Author\" select=\"selectAuthor\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;select id=\"selectAuthor\" resultType=\"Author\"&gt; SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;&lt;/select&gt; 就是这么简单。我们有两个 select 查询语句：一个用来加载博客（Blog），另外一个用来加载作者（Author），而且博客的结果映射描述了应该使用 selectAuthor 语句加载它的 author 属性。 其它所有的属性将会被自动加载，只要它们的列名和属性名相匹配。 这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为“N+1 查询问题”。 概括地讲，N+1 查询问题是这样子的： 你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。 对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。 这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。 好消息是，MyBatis 能够对这样的查询进行延迟加载，因此可以将大量语句同时运行的开销分散开来。 然而，如果你加载记录列表之后立刻就遍历列表以获取嵌套的数据，就会触发所有的延迟加载查询，性能可能会变得很糟糕。 模糊查询使用#{}，${}容易sql注入 使用concat函数拼接 1234567891011&lt;select id=\"getProblemList\" parameterType=\"com.yoj.web.bean.Problem\" resultMap=\"ProblemList\"&gt; select problem_id,title,#&#123;userId&#125; as user_id from problem &lt;where&gt; &lt;if test=\"problemId != null\"&gt; and problem_id LIKE CONCAT('%',#&#123;problemId&#125;,'%') &lt;/if&gt; &lt;if test=\"title != null\"&gt; and title LIKE CONCAT('%',#&#123;title&#125;,'%') &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 日志：Log4ja.Log4j: log4j.jar (mybatis.zip中lib中包含此jar)b.开启日志，conf.xml 1234&lt;settings&gt; &lt;!-- 开启日志，并指定使用的具体日志 --&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt;&lt;/settings&gt; 如果不指定，Mybatis就会根据以下顺序 寻找日志SLF4J →Apache Commons Logging →Log4j 2 → Log4j →JDK logging c.编写配置日志输出文件 log4j.properties，内容 1234log4j.rootLogger=DEBUG, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 日志级别：​ DEBUG&lt;INFO&lt;WARN&lt;ERROR如果设置为info，则只显示 info及以上级别的信息；建议：在开发时设置debug，在运行时设置为info或以上。 可以通过日志信息，相信的阅读mybatis执行情况（ 观察mybatis实际执行sql语句 以及SQL中的参数 和返回结果） 延迟加载（懒加载）：一对一、一对多、多对一、多对多一对多：班级-学生 ，如果不采用延迟加载 （立即加载），查询时会将 一 和多 都查询，班级、班级中的所有学生。如果想要 暂时只查询1的一方， 而多的一方 先不查询 而是在需要的时候再去查询 –&gt;延迟加载 一对一：学生、学生证 mybatis中使用延迟加载，需要先配置：123456&lt;settings&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 关闭立即加载 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;/settings&gt; 如果增加了mapper.xml ,要修改conf.xml配置文件（将新增的mapper.xml加载进去） 通过debug可以发现， 如果程序只需要学生，则只向数据库发送了查询学生的SQL；当我们后续 需要用到学生证的时候，再第二次发送 查询学生证的SQL。 123456789101112131415161718192021222324252627&lt;mapper namespace=\"pers.nicolas.mapper.StudentCardMapper\"&gt; &lt;!-- 后续通过namespace.Id 定位该SQL语句 --&gt; &lt;!-- parameterType：输入参数的类型 resultType：查询结果的返回类型 --&gt; &lt;!-- 根据cardId查学生证信息--&gt; &lt;select id=\"qeuryCardById\" parameterType=\"int\" resultType=\"studentCard\"&gt; select * from studentcard where cardid = #&#123;cardId&#125; &lt;/select&gt;&lt;!-- 延迟加载 --&gt; &lt;select id=\"queryStudentWithLazyLoad\" resultMap=\"student_card_lazyload_map\"&gt; &lt;!-- 先查学生 --&gt; select * from student &lt;/select&gt; &lt;resultMap type=\"student\" id=\"student_card_lazyload_map\"&gt; &lt;id property=\"stuNo\" column=\"stuno\" /&gt; &lt;result property=\"stuName\" column=\"stuname\" /&gt; &lt;result property=\"stuAge\" column=\"stuAge\" /&gt; &lt;result property=\"graName\" column=\"graname\" /&gt; &lt;result property=\"stuSex\" column=\"stusex\" /&gt; &lt;!-- 延迟加载： 在加载学生时，并不立即加载学生证信息 通过调用sql column外键传参 --&gt; &lt;association property=\"card\" javaType=\"StudentCard\" select=\"pers.nicolas.mapper.StudentCardMapper.qeuryCardById\" column=\"cardid\"&gt; &lt;/association&gt; &lt;/resultMap&gt; 一对多：和一对一的延迟加载配置方法相同 延迟加载的步骤：先查班级，按需查询学生1.开启延迟加载conf.xml配置settings2.配置mapper.xml 写2个Mapper: 班级mapper.xml 123456789101112 &lt;select id=\"queryClassAndStudents\" resultMap=\"class_student_lazyLoad_map\"&gt; select c.* from studentclass c&lt;/select&gt;&lt;resultMap type=\"studentClass\" id=\"class_student_lazyLoad_map\"&gt; &lt;!-- 因为 type的主类是班级，因此先配置班级的信息--&gt; &lt;id property=\"classId\" column=\"classId\"/&gt; &lt;result property=\"className\" column=\"className\"/&gt; &lt;!-- 配置成员属性学生，一对多;属性类型：javaType，属性的元素类型ofType --&gt; &lt;!-- 2222222再查班级对应的学生 --&gt; &lt;collection property=\"students\" ofType=\"student\" select=\"org.lanqiao.mapper.StudentMapper.queryStudentsByClassId\" column=\"classid\"&gt;​ &lt;/collection&gt;​1234&lt;/resultMap&gt;​ 即查询 学生的sql是通过 select属性指定，并且通过column指定外键 ​1234567学生mapper.xml&lt;!-- 一对多,延迟加载需要的： 查询班级中的所有学生 --&gt;&lt;select id=\"queryStudentsByClassId\" parameterType=\"int\" resultType=\"student\"&gt; select * from student where classId = #&#123;classId&#125;&lt;/select&gt; 查询缓存一级缓存 ：同一个SqlSession对象 ​ MyBatis默认开启一级缓存，如果用同样的SqlSession对象查询相同的数据，​ 则只会在第一次 查询时 向数据库发送SQL语句，并将查询的结果 放入到 SQLSESSION中（作为缓存存在）； 后续再次查询该同样的对象时， 则直接从缓存中查询该对象即可（即省略了数据库的访问） 二级缓存​ MyBatis默认情况没有开启二级缓存，需要手工打开。​ a.conf.xml 12&lt;!-- 开启二级缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; ​ b.在具体的mapper.xml中声明开启(studentMapper.xml中) 123&lt;mapper namespace=\"org.lanqiao.mapper.StudentMapper\"&gt; &lt;!-- 声明次namespace开启二级缓存 --&gt;&lt;cache/&gt; 根据异常提示：NotSerializableException可知，MyBatis的二级缓存 是将对象 放入硬盘文件中 序列化：内存-&gt;硬盘 反序列化：硬盘-&gt;内存准备缓存的对象，必须实现了序列化接口 （如果开启的缓存Namespace=”org.lanqiao.mapper.StudentMapper”），可知序列化对象为Student，因此需要将Student序列化 （序列化Student类，以及Student的级联属性、和父类） 触发将对象写入二级缓存的时机：SqlSession对象的close()方法。 Mybatis自带二级缓存：【同一个namespace】生成的mapper对象回顾：namespace的值 就是 接口的全类名（包名.类名）， 通过接口可以产生代理对象（studentMapper对象） –&gt;namespace决定了studentMapper对象的产生结论：只要产生的xxxMapper对象 来自于同一个namespace，则 这些对象 共享二级缓存。注意：二级缓存 的范围是同一个namespace, 如果有多个xxMapper.xml的namespace值相同，则通过这些xxxMapper.xml产生的xxMapper对象 仍然共享二级缓存。 禁用 ：select标签中useCache=”false” 清理：a.与清理一级缓存的方法相同 commit(); （一般执行增删改时 会清理掉缓存；设计的原因 是为了防止脏数据）在二级缓存中，commit()不能是查询自身的commit。 commit会清理一级和二级缓存；但是 清理二级缓存时，不能是查询自身的commit； b. 在select标签中 增加属性 flushCache=”true” 命中率： 1:zs :0% 2: 50% 3: 2/3 0.666 4: 3/4 0.75 三方提供的二级缓存：ehcache、memcache 要想整合三方提供的二级缓存 （或者自定义二级缓存），必须实现org.apache.ibatis.cache.Cache接口，该接口的默认实现类是PerpetualCache 整合ehcache二级缓存：a.ehcache-core.jarmybatis-Ehcache.jarslf4j-api.jar b.编写ehcache配置文件 Ehcache.xml 12345678910111213141516171819202122232425&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"&gt; &lt;!--当二级缓存的对象 超过内存限制时（缓存对象的个数&gt;maxElementsInMemory），存放入的硬盘文件 --&gt; &lt;diskStore path=\"E:\\Ehcache\"/&gt; &lt;!-- maxElementsInMemory:设置 在内存中缓存 对象的个数 maxElementsOnDisk：设置 在硬盘中缓存 对象的个数 eternal：设置缓存是否 永远不过期 overflowToDisk：当内存中缓存的对象个数 超过maxElementsInMemory的时候，是否转移到硬盘中 timeToIdleSeconds：当2次访问 超过该值的时候，将缓存对象失效 timeToLiveSeconds：一个缓存对象 最多存放的时间（生命周期） diskExpiryThreadIntervalSeconds：设置每隔多长时间，通过一个线程来清理硬盘中的缓存 memoryStoreEvictionPolicy：当超过缓存对象的最大值时，处理的策略；LRU，FIFO,LFU --&gt; &lt;defaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"1000000\" eternal=\"false\" overflowToDisk=\"false\" timeToIdleSeconds=\"100\" timeToLiveSeconds=\"100\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; c.开启EhCache二级缓存 在xxxMapper.xml中开启 12345&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt; &lt;!-- 通过property覆盖Ehcache.xml中的值 --&gt; &lt;property name=\"maxElementsInMemory\" value=\"2000\"/&gt; &lt;property name=\"maxElementsOnDisk\" value=\"3000\"/&gt; &lt;/cache&gt; 逆向工程表、类、接口、mapper.xml四者密切相关，因此 当知道一个的时候 其他三个应该可以自动生成。表-&gt;其他三个 实现步骤： a. 导入依赖 mybatis-generator-core.jar、mybatis.jar、ojdbc.jar 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; b. 逆向工程的配置文件generator.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;!-- suppressAllComments属性值： true:自动生成实体类、SQL映射文件时没有注释 false:自动生成实体类、SQL映射文件，并附有注释 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\" /&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库连接信息 --&gt; &lt;jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\" connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:ORCL\" userId=\"scott\" password=\"tigger\"&gt; &lt;/jdbcConnection&gt; &lt;!-- forceBigDecimals属性值： true:把数据表中的DECIMAL和NUMERIC类型， 解析为JAVA代码中的java.math.BigDecimal类型 false(默认):把数据表中的DECIMAL和NUMERIC类型， 解析为解析为JAVA代码中的Integer类型 --&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject属性值:实体类的生成位置 targetPackage属性值：实体类所在包的路径 --&gt; &lt;javaModelGenerator targetPackage=\"org.lanqiao.entity\" targetProject=\".\\src\"&gt; &lt;!-- trimStrings属性值： true：对数据库的查询结果进行trim操作 false(默认)：不进行trim操作 --&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject属性值:SQL映射文件的生成位置 targetPackage属性值：SQL映射文件所在包的路径 --&gt; &lt;sqlMapGenerator targetPackage=\"org.lanqiao.mapper\" targetProject=\".\\src\"&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成动态代理的接口 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"org.lanqiao.mapper\" targetProject=\".\\src\"&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName=\"Student\"&gt; &lt;/table&gt; &lt;table tableName=\"studentCard\"&gt; &lt;/table&gt; &lt;table tableName=\"studentClass\"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; c. 执行 12345678File file = new File(\"src/generator.xml\"); // 配置文件 List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(file); DefaultShellCallback callback = new DefaultShellCallback(true); // 逆向工程核心类 MyBatisGenerator generator = new MyBatisGenerator(config, callback, warnings); generator.generate(null); 123456789101112131415161718192021import java.io.File;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;public class MybatisGeneratorTest &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(\"mybatis-generator.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; 常用方法取到最后生成的主键1&lt;!--取到最后生成的主键--&gt;&lt;insert id=\"insertSelective\" useGeneratedKeys=\"true\" keyColumn=\"problem_id\" keyProperty=\"problemId\" parameterType=\"com.yoj.web.bean.Problem\"&gt; [用Criteria实现多条件查询](https://blog.csdn.net/qjlhlh/article/details/6599557) 逆向工程产生的bean（entity class）的扩展类中的静态内部类。 mybatis注解版插入时返回主键id1234567@Mapperpublic interface UserMapper&#123; @Insert(\"insert into tbl_user (name, age) values (#&#123;name&#125;, #&#123;age&#125;)\") @Options(useGeneratedKeys=true, keyProperty=\"userId\", keyColumn=\"id\") void insertUser(User user);&#125; 调用其他方法1234567891011121314@Select(\"SELECT * FROM solution ORDER BY solution_id DESC\")@Results(&#123; @Result(id = true, column = \"solution_id\", property = \"solutionId\"), @Result(column = \"problem_id\", property = \"problem\", one = @One(select = \"com.yoj.web.dao.ProblemMapper.queryProblemTitleAndIdById\", fetchType = FetchType.EAGER)), @Result(column = \"language\", property = \"language\"), @Result(column = \"code\", property = \"code\"), @Result(column = \"result\", property = \"result\"), @Result(column = \"runtime\", property = \"runtime\"), @Result(column = \"memory\", property = \"memory\"), @Result(column = \"error_message\", property = \"errorMessage\"), @Result(column = \"submit_time\", property = \"submitTime\"), @Result(column = \"user_id\", property = \"user\", one = @One(select = \"com.yoj.web.dao.UserMapper.getUserById\", fetchType = FetchType.EAGER))&#125;)List&lt;Solution&gt; getAllWithUserAndProblemName(); other自动映射当自动映射查询结果时，MyBatis 会获取结果中返回的列名并在 Java 类中查找相同名字的属性（忽略大小写）。 这意味着如果发现了 ID 列和 id 属性，MyBatis 会将列 ID 的值赋给 id 属性。 通常数据库列使用大写字母组成的单词命名，单词间用下划线分隔；而 Java 属性一般遵循驼峰命名法约定。为了在这两种命名方式之间启用自动映射，需要将 mapUnderscoreToCamelCase 设置为 true。 批量操作https://blog.csdn.net/mahoking/article/details/46811865 批量增加操作 1234567&lt;!-- 批量增加操作 --&gt;&lt;insert id=\"batchInsertUsers\" parameterType=\"java.util.List\"&gt; insert into mhc_user(userName,password) values &lt;foreach collection=\"list\" item=\"item\" index=\"index\" separator=\",\"&gt; (#&#123;item.userName&#125;,#&#123;item.password&#125;) &lt;/foreach&gt;&lt;/insert&gt; 插入后取到最后生成的主键1&lt;!--取到最后生成的主键--&gt;&lt;insert id=\"insertSelective\" useGeneratedKeys=\"true\" keyColumn=\"problem_id\" keyProperty=\"problemId\" parameterType=\"com.yoj.web.bean.Problem\"&gt;","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"https://codeofli.github.io/tags/mybatis/"}]},{"title":"javaWeb","slug":"java-note/javaWeb/javaWeb","date":"2019-10-12T02:39:06.000Z","updated":"2021-10-23T02:19:04.195Z","comments":true,"path":"2019/10/java-note/javaWeb/javaWeb/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/javaWeb/javaWeb/","excerpt":"[TOC]基础知识JSP:动态网页静态、动态：1.不用 和 是否有“动感”混为一谈2.是否 随着 时间、地点、用户操作 的 改变而改变 动态网页 需要使用到 服务端脚本语言（JSP） 2架构CS：Client ServerCS不足：a.如果 软件升级， 那么全部软件都需要升级b.维护麻烦：需要维护每一台 客户端软件c.每一台客户端 都需要安装 客户端软件","text":"[TOC]基础知识JSP:动态网页静态、动态：1.不用 和 是否有“动感”混为一谈2.是否 随着 时间、地点、用户操作 的 改变而改变 动态网页 需要使用到 服务端脚本语言（JSP） 2架构CS：Client ServerCS不足：a.如果 软件升级， 那么全部软件都需要升级b.维护麻烦：需要维护每一台 客户端软件c.每一台客户端 都需要安装 客户端软件 BS ：Broswer Server客户端可以通过 浏览器 直接访问服务端 注意：bs和cs各有优势。 3.tomcat解压后目录：bin:可执行文件（startup.bat shutdown.bat）conf:配置文件（server.xml）lib：tomcat依赖的jar文件log:日志文件（记录出错等信息）temp:临时文件webapps：可执行的项目（将我们开发的项目 放入该目录）work:存放由jsp翻译成的java,以及编辑成的class文件(jsp -&gt;java -&gt;class) 4.配置tomcata.配置jdk (必须配置JAVA_HOME)java_home classPath pathb.配置catalina_home 双击bin/startup.bat启动tomacat，常见错误： 可能与其他服务的端口号冲突tomcat端口号默认8080 （此端口号较为常见，容易冲突），建议修改此端口 （8888） 修改端口号： 5.访问tomcathttp://localhost:8888/ 常见状态码：200：一切正常300/301: 页面重定向 （跳转）404:资源不存在403：权限不足 （如果访问a目录，但是a目录设置 不可见）500：服务器内部错误（代码有误）其他编码：积累 jsp：在html中嵌套的java代码 在项目/WEB-INF/web.xml中设置 默认的 初始页面 123&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 6.虚拟路径a.方式一将web项目配置到 webapps以外的目录conf/server.xml中配置host标签中： 1&lt;Context docBase=\"D:\\study\\JspProject\" path=\"/JspProject\" /&gt; docBase：实际路径path：虚拟路径 （绝对路径、相对路径【相对于webapps】）重启 b.方式二D:\\study\\apache-tomcat-8.5.30\\conf\\Catalina\\localhost中新建 “项目名.xml”中新增一行： 1&lt;Context docBase=\"D:\\study\\JspProject\" path=\"/JspProject\" /&gt; 7.虚拟主机通过www.test.com访问本机a. conf/server.xml 1&lt;Engine name=\"Catalina\" defaultHost=\"www.test.com\"&gt; 123&lt;Host appBase=\"D:\\study\\JspProject\" name=\"www.test.com\"&gt; &lt;Context docBase=\"D:\\study\\JspProject\" path=\"/\"/&gt; &lt;/Host&gt; b.C:\\Windows\\System32\\drivers\\etc\\host增加 1127.0.0.1 www.test.com 流程： 1www.test.com -&gt; host找映射关系 -&gt;server.xml找Engine的defaultHost -&gt;通过\"/\"映射到 D:\\study\\JspProject为了后续学习，将以上恢复成默认 7.JSP执行流程jsp- java(Servlet文件) -classD:\\study\\apache-tomcat-8.5.30\\work\\Catalina\\localhost\\JspProject\\org\\apache\\jsp Jsp 和Servlet 可以相互转换 因为第一请求服务端 会有翻译 和编译的过程，因此比较慢； 后续访问 可以直接访问class,因此速度较快。但是 如果 服务端修改了代码，则再次访问时 会重新的翻译、编译。 使用Eclipse开发Web项目(JSP项目) tomcat 在Eclipse中创建的Web项目：浏览器可以直接访问 WebContent中的文件，例如http://localhost:8888/MyJspProject/index1.jsp其中的index1.jsp就在WebContent目录中；但是WEB-INF中的文件 无法通过客户端（浏览器）直接访问，只能通过请求转发来访问 注意： 并不是 任何的内部跳转都能访问WEB-INF；原因是 跳转有2种方式：请求转发 、重定向 3.配置tomcat运行时环境 JSP&lt;=&gt;Servlet 将tomcat/lib中的servlet-api.jar加入项目的构建路径 右键项目-&gt;Build Path -&gt; Add library -&gt;Server Runtime 4.部署tomcat在servers面板 新建一个 tomcat实例 ， 再在该实例中 部署项目（右键-add）之后运行 注意：一般建议 将eclipse中的tomcat与 本地tomcat的配置信息保持一致： 将eclipse中的tomcat设置为托管模式： 【第一次】创建tomcat实例之后， 双击，选择Server Location的第二项 5.统一字符集编码 a.编码分类：设置jsp文件的编码（jsp文件中的pageEncoding属性）： jsp -&gt; java设置浏览器读取jsp文件的编码（jsp文件中content属性）一般将上述设置成 一致的编码，推荐使用UTF-8文本编码： i.将整个eclipse中的文件 统一设置 （推荐） ii.设置 某一个项目 iii.设置单独文件 JSPJAVA serve pages JSP的页面元素 HTML JAVA代码（脚本Scriptlet） 指令 注释 脚本Scriptleti. 1&lt;% 局部变量、java语句 %&gt; ii. 1&lt;%! 全局变量、定义方法 %&gt; iii. 1&lt;%=输出表达式 %&gt; 一般而言，修改web.xml、配置文件、java 需要重启tomcat服务 但是如果修改 Jsp\\html\\css\\js ，不需要重启 注意: out.println()不能回车； 要想回车：“”，即out.print() &lt;%= %&gt; 可以直接解析html代码 指令page指令 &lt;%@ page ....%&gt;page指定的属性：language: jsp页面使用的脚本语言import: 导入类pageEncoding: jsp文件自身编码 jsp -&gt;javacontentType:浏览器解析jsp的编码 12&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.Date\" %&gt; 注释HTML注释 1&lt;!-- --&gt; 可以被客户 通过浏览器查看源码 所观察到 JAVA注释 1// /*...*/ JSP注释 1&lt;%-- --%&gt; JSP九大内置对象自带的，不需要new 也能使用的对象 request：请求对象存储“客户端向服务端发送的请求信息”request对象的常见方法： name description String getParameter(String name) 根据请求的字段名key （input标签的name属性值） ，返回字段值value （input标签的value属性值） String[] getParameterValues(String name) 根据请求的字段名key ，返回多个字段值value （checkbox） void setCharacterEncoding (“编码格式utf-8”) ：设置post方式的请求编码 （tomcat7以前默认iso-8859-1，tomcat8以后改为了utf-8） getRequestDispatcher(“b.jsp”).forward(request,response) 请求转发 的方式跳转页面 A - &gt; B ServletContext getServerContext() 获取项目的ServletContext对象 response :响应对象提供的方法 function description void addCookie( Cookie cookie ); 服务端向客户端增加cookie对象 void sendRedirect(String location ) throws IOException; 页面跳转的一种方式（重定向） void setContetType(String type) 设置服务端响应的编码（设置服务端的contentType类型） session 会话对象1import javax.servlet.http.HttpSession; session(服务端) , Cookie（客户端，不是内置对象）:Cookie是由 服务端生成的 ，再发送给客户端保存。 相当于 本地缓存的作用： 客户端(hello.mp4,zs/abc)-&gt;服务端(hello.mp4；zs/abc) 作用：提高访问服务端的效率，但是安全性较差。 Cookie 不是内置对象，要使用必须new 但是，服务端会 自动生成一个(服务端自动new一个cookie) name=JSESIONID的cookie 并返回给客户端 Cookie： name=value 1javax.servlet.http.Cookie function description public Cookie(String name,String value) String getName() 获取name String getValue() 获取value void setMaxAge(int expiry) 最大有效期 （秒） 服务端准备Cookie： 1response.addCookie(Cookie cookie) 页面跳转（转发，重定向） 1客户端获取cookie: request.getCookies(); 服务端增加cookie :response对象；客户端获取对象：request对象 不能直接获取某一个单独对象，只能一次性将 全部的cookie拿到 通过F12可以发现 除了自己设置的Cookie对象外，还有一个name为 JsessionId的cookie 建议 cookie只保存 英文数字，否则需要进行编码、解码 使用Cookie实现 记住用户名 功能 4.session :会话a.浏览网站：开始-关闭b.购物： 浏览、付款、退出c.电子邮件：浏览、写邮件、退出 开始-结束 session机制客户端第一次请求服务端时，（jsessionId-sessionId）服务端会产生一个session对象（用于保存该客户的信息）；并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);服务端由会 产生一个cookie，并且 该cookie的name=JsessionId,value=服务端sessionId的值；然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JsessionId)；因此，客户端的cookie就可以和服务端的session一一对应（JsessionId- sessionId） 客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JsessionId 去服务端的session中匹配sessionId,如果匹配成功（cookie jsessionId和sesion sessionId），说明此用户 不是第一次访问,无需登录； 例子：客户端： 顾客（客户端）服务端: 存包处 - 商场(服务端) 顾客第一次存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙）。 如果是新顾客（没钥匙） ，分配一个钥匙 给该顾客； 钥匙 会和 柜子 一一对应； 第二/n次 存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙） 如果是老顾客（有钥匙），则不需要分配；该顾客手里的钥匙 会 和柜子 自动一一对应。 session: session存储在服务端 session是在 同一个用户（客户）请求时 共享 实现机制：第一次客户请求时 产生一个sessionId 并复制给 cookie的JsessionId然后发给客户端。最终 通过session的sessionId-cookie的JsessionId session方法 function description String getId() 获取sessionId boolean isNew() 判断是否是 新用户（第一次访问） void invalidate() 使session失效 （退出登录、注销） void setAttribute(String name, Object value) Object getAttribute(); void setMaxInactiveInterval(秒) 设置最大有效 非活动时间 int getMaxInactiveInterval() 获取最大有效 非活动时间 示例：登录 客户端在第一次请求服务端时，如果服务端发现 此请求没有 JsessionId,则会创建一个 name=JSESIONID的cookie 并返回给客户端 cookie和session的区别： session cookie 保存的位置 服务端 客户端 安全性 较安全 较不安全 保存的内容 Object String application全局对象String getContextPath() 虚拟路径String getRealPath(String name): 绝对路径（虚拟路径 相对的绝对路径） 其他五种不常用对象 Object description pageContext JSP页面容器 config 配置对象（服务器配置信息） page 当前JSP页面对象（相当于java中的this） exception 异常对象 out 输出对象，向客户端输出内容 get与post请求方式的区别：get提交方式 http://localhost:8888/MyJspProject/show.jsp?uname=aa&amp;upwd=123&amp;uage=22&amp;uhobbies=%E7%AF%AE%E7%90%83 1连接/文件?参数名1=参数值1 &amp; 参数名2=参数值2 &amp; 参数名1=参数值1 method=”get” 和 地址栏 、超链接(&lt;a href=&quot;xx&quot;&gt;)请求方式 默认都属于get提交方式 get方式 在地址栏显示 请求信息 (但是地址栏能够容纳的 信息有限，4-5KB；如果请求数据存在大文件，图片等 会出现地址栏无法容纳全部的数据而出错) ；post不会显示 文件上传操作，必须是post推荐使用post 8.统一请求的编码 requestget方式请求 如果出现乱码，解决： 统一每一个变量的 编码 （不推荐） 12new String( 旧编码，新编码); name = new String(name.getBytes(\"iso-8859-1\"),\"utf-8\"); 修改server.xml ，一次性的 更改tomcat默认get提交方式的编码 （utf-8）建议 使用tomcat时， 首先在server.xml中 统一get方式的编码.. URIEncoding=&quot;UTF-8&quot; tomcat7 (iso-8859-1) tomcat8（utf-8） post 1request.setCharacterEncoding(\"utf-8\") 请求转发和重定向请求转发 1request.getRequestDispatcher(\"b.jsp\").forward(request,response) 重定向 1reponse.sendRedirect(\"b.jsp\") 请求转发 重定向 地址栏是否改变 不变(check.jsp) 改变(success.jsp) 是否保留第一次请求时的数据 保留 不保留 请求的次数 1 2 跳转发生的位置 服务端 客户端发出的第二次跳转 转发、重定向： 转发： 张三（客户端） -&gt; 【 服务窗口 A （服务端 ） -&gt; 服务窗口B 】 重定向： 张三（客户端） -&gt; 服务窗口 A （服务端 ） -&gt;去找B ​ 张三（客户端） -&gt; 服务窗口 B （服务端 ） -&gt;结束 四种范围对象（小-&gt;大） object description scope pageContext JSP页面容器 （page对象）； 当前页面有效 request 请求对象 同一次请求有效 session 会话对象 同一次会话有效 application 全局对象 全局有效（整个项目有效） 以上4个对象共有的方法： function description Object getAttribute(String name) 根据属性名，获取属性值 void setAttribute(String name,Object obj) 设置属性值（新增，修改） void removeAttribute(String name) 根据属性名，删除对象 pageContext 当前页面有效 (页面跳转后无效) request 同一次请求有效；其他请求无效 （请求转发后有效；重定向后无效） session 同一次会话有效 （无论怎么跳转，都有效；关闭/切换浏览器后无效 ； 从 登陆-&gt;退出 之间 全部有效） application 全局变量；整个项目运行期间 都有效 (切换浏览器 仍然有效)；关闭服务、其他项目 无效 -&gt;多个项目共享、重启后仍然有效 ：JNDI 以上的4个范围对象，通过 setAttribute()复制，通过getAttribute()取值； 以上范围对象，尽量使用最小的范围。因为 对象的范围越大，造成的性能损耗越大。 ServletJava类必须符合一定的 规范： a.必须继承 javax.servlet.http.HttpServlet b.重写其中的service()之类的方法 123service(): 接受并识别和处理相应的所有提交的方法； doGet(): 接受并处理所有get提交方式的请求 doPost(): 接受并处理所有post提交方式的请求 Servlet要想使用，必须配置Serlvet2.5：web.xml 123456789101112&lt;web-app&gt; ... &lt;servlet&gt; &lt;servlet-name&gt;WelcomeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.lanqiao.servlet.WelcomeServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;WelcomeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/WelcomeServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Servlet3.0： @WebServlet 1@WebServlet( value=\"/WelcomeServlet\" ,loadOnStartup=1,initParams= &#123;@WebInitParam(name=\"serveltparaname30\",value=\"servletparavalue30\") &#125; ) Serlvet2.5：web.xml: 项目的根目录：WebContent 、src &lt;a href=&quot;WelcomeServlet&quot;&gt;所在的jsp是在 WebContent目录中，因此 发出的请求WelcomeServlet 是去请求项目的根目录。 Servlet流程： 请求 -&gt;&lt;url-pattern&gt; -&gt; 根据&lt;servlet-mapping&gt;中的&lt;servlet-name&gt; 去匹配 &lt;servlet&gt;中的&lt;servlet-name&gt;，然后寻找到，求中将请求交由该执行。 2个/:jsp:/ localhost:8888web.xml: / http://localhost:8888/项目名/ 编写Servlet步骤：1import javax.servlet.http.HttpServlet; 1.编写一个类继承HttpServlet 1public class LoginServlet extends HttpServlet &#123; 2.重写相应方法(doGet()、doPost()) 3.配置Servlet 编写web.xml 中的servlet映射关系 Servlet3.0，与Servlet2.5的区别： Servlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 匹配流程： 请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类 注解:@WebServlet(“url-pattern的值”) 注意:url-pattern 要带斜杆 2.借助于Eclipse快速生成Servlet直接新建Servlet即可！（继承、重写、web.xml 可以借助Eclipse自动生成） 3.项目根目录：WebContent、src（所有的构建路径）例如：WebContent中有一个文件index.jspsrc中有一个Servlet.java 如果: index.jsp中请求&lt;a href=&quot;abc&quot;&gt;...&lt;/a&gt;，则 寻找范围：既会在src根目录中找 也会在WebContent根目录中找 如果：index.jsp中请求&lt;a href=&quot;a/abc&quot;&gt;&lt;/a&gt;，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc web.xml中的 /:代表项目根路径http://localhost:8888/Servlet25Project/jsp中的/: 服务器根路径http://localhost:8888/ 构建路径、WebContent:根目录 Servlet生命周期 5个阶段 加载、初始化： init() ，该方法会在 Servlet被加载并实例化的以后 执行服务 ：service() -&gt;doGet() doPost init(): 默认第一次访问 Servlet时会被执行 （只执行这一次） 可以修改为 Tomcat启动时自动执行 销毁 ：destroy()Servlet被系统回收时执行 卸载 i.Servlet2.5： web.xml 1234&lt;servlet&gt; ... &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 其中的“1”代表第一个。 ii.Servlet3.0 1@WebServlet( value=\"/WelcomeServlet\" ,loadOnStartup=1 ) service() -&gt;doGet() doPost ：调用几次，则执行几次 destroy()：关闭tomcat服务时，执行一次。 5 Servlet API ： 由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包即Servlet API可以适用于 任何 通信协议。我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。 6.Servlet继承关系 ServletConfig:接口ServletContext getServletContext():获取Servlet上下文对象 applicationString getInitParameter(String name):在当前Servlet范围内，获取名为name的参数值（初始化参数） a.ServletContext中的常见方法(application)：getContextPath():相对路径getRealPath()：绝对路径setAttribute() 、getAttribute()—&gt;String getInitParameter(String name);在当前Web容器范围内，获取名为name的参数值（初始化参数） Servlet3.0方式 给当前Servlet设置初始值： 1@WebServlet( .... , initParams= &#123;@WebInitParam(name=\"serveltparaname30\",value=\"servletparavalue30\") &#125; ) 注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置） HttpServletRequest中的方法：(同request)，例如setAttrite()、getCookies()、getMethod()HttpServletResponse中的方法：同response Servlet使用层面： Eclipse中在src创建一个Servlet，然后重写doGet() doPost()就可以 （doGet() doPost()只需要编写一个）。 使用idea创建一个Maven java Web项目https://blog.csdn.net/qq_37856300/article/details/85776785 数据库连接JDBCJava Data Base Connectivity maven dependency 123456&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt; 可以为多种关系型数据库DBMS 提供统一的访问方式，用Java来操作数据库JDBC API 主要功能：三件事，具体是通过以下类/接口实现： 1234DriverManager ： 管理jdbc驱动 Connection： 连接（通过DriverManager产生） Statement（PreparedStatement） ：增删改查 （通过Connection产生 ） CallableStatement ： 调用数据库中的 存储过程/存储函数 （通过Connection产生 ） Result ：返回的结果集 （上面的Statement等产生 ） Connection产生操作数据库的对象： 123Connection产生Statement对象：createStatement() Connection产生PreparedStatement对象：prepareStatement() Connection产生CallableStatement对象：prepareCall(); Statement操作数据库： 12增删改：executeUpdate() 查询：executeQuery(); ResultSet：保存结果集 select * from xxx 123next():光标下移，判断是否有下一条数据；true/false previous(): true/false getXxx(字段名|位置):获取具体的字段值 PreparedStatement操作数据库： 1public interface PreparedStatement extends Statement 因此 12增删改：executeUpdate() 查询：executeQuery(); –此外赋值操作 setXxx(); PreparedStatement与Statement在使用时的区别： Statement: 12sql executeUpdate(sql) PreparedStatement: 1234sql(可能存在占位符?) 在创建PreparedStatement 对象时，将sql预编译 prepareStatement(sql) executeUpdate() setXxx()替换占位符 推荐使用PreparedStatement：原因如下：1.编码更加简便（避免了字符串的拼接） 123456789101112String name = \"zs\" ; int age = 23 ; stmt: String sql =\" insert into student(stuno,stuname) values('\"+name+\"', \"+age+\" ) \" ; stmt.executeUpdate(sql); pstmt: String sql =\" insert into student(stuno,stuname) values(?,?) \" ; pstmt = connection.prepareStatement(sql);//预编译SQL pstmt.setString(1,name); pstmt.setInt(2,age); 2.提高性能(因为 有预编译操作，预编译只需要执行一次)需要重复增加100条数 12345678910111213stmt: String sql =\" insert into student(stuno,stuname) values('\"+name+\"', \"+age+\" ) \" ; for(100) stmt.executeUpdate(sql); pstmt: String sql =\" insert into student(stuno,stuname) values(?,?) \" ; pstmt = connection.prepareStatement(sql);//预编译SQL pstmt.setString(1,name); pstmt.setInt(2,age); for( 100)&#123; pstmt.executeUpdate(); &#125; 3.安全（可以有效防止sql注入）sql注入： 将客户输入的内容 和 开发人员的SQL语句 混为一体 stmt:存在被sql注入的风险(例如输入 用户名：任意值 ‘ or 1=1 – 密码：任意值)分析： 12345select count(*) from login where uname='任意值 ' or 1=1 --' and upwd ='任意值' ; select count(*) from login where uname='任意值 ' or 1=1 ; select count(*) from login ; select count(*) from login where uname='\"+name+\"' and upwd ='\"+pwd+\"' pstmt:有效防止sql注入 推荐使用pstmt 3.jdbc访问数据库的具体步骤：a.导入驱动，加载具体的驱动类b.与数据库建立连接c.发送sql，执行d.处理结果集 （查询） 数据库驱动 驱动jar 具体驱动类 连接字符串 Oracle ojdbc-x.jar oracle.jdbc.OracleDriver jdbc:oracle:thin:@localhost:1521:ORCL MySQL mysql-connector-java-x.jar com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/数据库实例名 SqlServer sqljdbc-x.jar com.microsoft.sqlserver.jdbc.SQLServerDrive jdbc:microsoft:sqlserver:localhost:1433;databasename=数据库实例名 使用jdbc操作数据库时，如果对数据库进行了更换，只需要替换：驱动、具体驱动类、连接字符串、用户名、密码 jdbc总结（模板、八股文）： 12345678910111213141516171819202122try&#123; a.导入驱动包、加载具体驱动类Class.forName(\"具体驱动类\"); b.与数据库建立连接connection = DriverManager.getConnection(...); c.通过connection，获取操作数据库的对象（Statement\\preparedStatement\\callablestatement） stmt = connection.createStatement(); d.(查询)处理结果集rs = pstmt.executeQuery() while(rs.next())&#123; rs.getXxx(..) ;&#125; &#125;catch(ClassNotFoundException e ) &#123; ...&#125; catch(SQLException e) &#123;... &#125; catch(Exception e) &#123;... &#125; finally &#123; //打开顺序，与关闭顺序相反 if(rs!=null)rs.close() if(stmt!=null) stmt.close(); if(connection!=null)connection.close(); &#125; –jdbc中，除了Class.forName() 抛出ClassNotFoundException，其余方法全部抛SQLException 2.CallableStatement:调用 存储过程、存储函数connection.prepareCall(参数：存储过程或存储函数名)参数格式：存储过程（无返回值return，用out参数替代）： { call 存储过程名(参数列表) }存储函数（有返回值return）： { ? = call 存储函数名(参数列表) } 12345create or replace procedure addTwoNum ( num1 in number,num2 in number,result out number ) -- 1 + 2 -&gt;3 as begin result := num1+num2 ; end ; 强调：如果通过sqlplus 访问数据库，只需要开启：OracleServiceSID通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：OracleServiceSID、XxxListener JDBC调用存储过程的步骤：a.产生 调用存储过程的对象（CallableStatement） cstmt = connection.prepareCall( “…” ) ;b.通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);c.通过 registerOutParameter(…)处理输出参数类型d.cstmt.execute()执行e.接受 输出值（返回值）getXxx() 调存储函数： 12345678create or replace function addTwoNumfunction ( num1 in number,num2 in number) -- 1 + 2 return number as result number ; begin result := num1+num2 ; return result ; end ; JDBC调用存储函数：与调存储过程的区别：在调用时，注意参数：”{? = call addTwoNumfunction (?,?) }” 3.处理CLOB/BLOB类型处理稍大型数据： a.存储路径 E:\\JDK_API_zh_CN.CHM 通过JDBC存储文件路径，然后 根据IO操作处理 例如：JDBC将 E:\\JDK_API_zh_CN.CHM 文件 以字符串形式“E:\\JDK_API_zh_CN.CHM”存储到数据库中 获取：1.获取该路径“E:\\JDK_API_zh_CN.CHM” 2.IO b. CLOB：大文本数据 （小说-&gt;数据） BLOB：二进制 clob:大文本数据 字符流 Reader Writer存1.先通过pstmt 的? 代替小说内容 （占位符）2.再通过pstmt.setCharacterStream(2, reader, (int)file.length()); 将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型 取：1.通过Reader reader = rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据 保存到Reader对象中 将Reader通过Writer输出即可。 blob:二进制 字节流 InputStream OutputStream与CLOB步骤基本一致，区别：setBinaryStream(…) getBinaryStream(…) 4.JSP访问数据库 JSP就是在html中嵌套的java代码，因此 java代码可以写在jsp中（&lt;% … %&gt;） 导包操作：java项目 ：1 Jar复制到工程中 2.右键该Jar :build path -&gt;add to build Path Web项目：jar复制到WEB-INF/lib 核心：就是将 java中的JDBC代码，复制到 JSP中的&lt;% … %&gt; 注意：如果jsp出现错误：The import Xxx cannot be resolved 尝试解决步骤： a.(可能是Jdk、tomcat版本问题) 右键项目-&gt;build path，将其中 报错的 libary或Lib 删除后 重新导入 b.清空各种缓存：右键项目-&gt;Clean tomcat… clean （Project -clean或者 进tomcat目录 删除里面work的子目录） c.删除之前的tomcat，重新解压缩、配置tomcat，重启计算机 d.如果类之前没有包，则将该类加入包中 JavaBean刚才我们将 jsp中 登录操作的代码 转移到了LoginDao.java；其中LoginDao类 就称之为JavaBean。JavaBean的作用：a.减轻的jsp复杂度 b.提高代码复用（以后任何地方的 登录操作，都可以通过调用LoginDao实现） JavaBean（就是一个Java类）的定义：满足一下2点 ，就可以称为JavaBean a.public 修饰的类 ,public 无参构造 b.所有属性(如果有) 都是private，并且提供set/get (如果boolean 则get 可以替换成is) 使用层面，Java分为2大类：a.封装业务逻辑的JavaBean (LoginDao.java封装了登录逻辑) 逻辑 可以将jsp中的JDBC代码，封装到Login.java类中 （Login.java） b.封装数据的JavaBean （实体类，Student.java Person.java ） 数据 对应于数据库中的一张表 Login login = new Login(uname,upwd) ;//即用Login对象 封装了2个数据（用户名 和密码） 封装数据的JavaBean 对应于数据库中的一张表 (Login(name,pwd))封装业务逻辑的JavaBean 用于操作 一个封装数据的JavaBean 可以发现，JavaBean可以简化 代码(jsp-&gt;jsp+java)、提供代码复用(LoginDao.java) 1234567891011public void sleep(String name,String place, int time) &#123; &#125; public void sleep(Person per) &#123; per.getName() per.getPlace() ... &#125; 数据库连接池(DBCP)maven dependncy 123456&lt;!-- https://mvnrepository.com/artifact/commons-dbcp/commons-dbcp --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334353637383940datasource.connection.driver_class=com.mysql.jdbc.Driverdatasource.connection.url=jdbc:mysql://localhost:3306/jsd06_stu?useUnicode=true&amp;characterEncoding=utf-8datasource.connection.username=rootdatasource.connection.password=1234#连接池保持的最小连接数,default : 3（建议使用）datasource.connection.minPoolSize=3#连接池中拥有的最大连接数，如果获得新连接时会使连接总数超过这个值则不会再获取新连接，而是等待其他连接释放，所以这个值有可能会设计地很大,default : 15（建议使用）datasource.connection.maxPoolSize=15#连接的最大空闲时间，如果超过这个时间，某个数据库连接还没有被使用，则会断开掉这个连接。如果为0，则永远不会断开连接,即回收此连接。default : 0 单位 s（建议使用）datasource.connection.maxIdleTime=0#连接池在无空闲连接可用时一次性创建的新数据库连接数,default : 3（建议使用）datasource.connection.acquireIncrement=3#连接池为数据源缓存的PreparedStatement的总数。由于PreparedStatement属于单个Connection,所以这个数量应该根据应用中平均连接数乘以每个连接的平均PreparedStatement来计算。同时maxStatementsPerConnection的配置无效。default : 0（不建议使用）datasource.connection.maxStatements=0#连接池为数据源单个Connection缓存的PreparedStatement数，这个配置比maxStatements更有意义，因为它缓存的服务对象是单个数据连接，如果设置的好，肯定是可以提高性能的。为0的时候不缓存。default : 0（看情况而论）datasource.connection.maxStatementsPerConnection=0#连接池初始化时创建的连接数,default : 3（建议使用）datasource.connection.initialPoolSize=3#用来配置测试空闲连接的间隔时间。测试方式还是上面的两种之一，可以用来解决MySQL8小时断开连接的问题。因为它保证连接池会每隔一定时间对空闲连接进行一次测试，从而保证有效的空闲连接能每隔一定时间访问一次数据库，将于MySQL8小时无会话的状态打破。为0则不测试。default : 0(建议使用)datasource.connection.idleConnectionTestPeriod=0#连接池在获得新连接失败时重试的次数，如果小于等于0则无限重试直至连接获得成功。default : 30（建议使用）datasource.connection.acquireRetryAttempts=30#如果为true，则当连接获取失败时自动关闭数据源，除非重新启动应用程序。所以一般不用。default : false（不建议使用）datasource.connection.breakAfterAcquireFailure=false#性能消耗大。如果为true，在每次getConnection的时候都会测试，为了提高性能,尽量不要用。default : false（不建议使用）datasource.connection.testConnectionOnCheckout=false#配置当连接池所有连接用完时应用程序getConnection的等待时间。为0则无限等待直至有其他连接释放或者创建新的连接，不为0则当时间到的时候如果仍没有获得连接，则会抛出SQLException。其实就是acquireRetryAttempts*acquireRetryDelay。default : 0（与上面两个，有重复，选择其中两个都行）datasource.connection.checkoutTimeout=30000#如果为true，则在close的时候测试连接的有效性。default : false（不建议使用）datasource.connection.testConnectionOnCheckin=false#配置一个表名，连接池根据这个表名用自己的测试sql语句在这个空表上测试数据库连接,这个表只能由c3p0来使用，用户不能操作。default : null（不建议使用）datasource.connection.automaticTestTable=c3p0TestTable#连接池在获得新连接时的间隔时间。default : 1000 单位ms（建议使用）datasource.connection.acquireRetryDelay=1000#为0的时候要求所有的Connection在应用程序中必须关闭。如果不为0，则强制在设定的时间到达后回收Connection，所以必须小心设置，保证在回收之前所有数据库操作都能够完成。这种限制减少Connection未关闭情况的不是很适用。建议手动关闭。default : 0 单位 s（不建议使用）datasource.connection.unreturnedConnectionTimeout=0#这个配置主要是为了快速减轻连接池的负载，比如连接池中连接数因为某次数据访问高峰导致创建了很多数据连接，但是后面的时间段需要的数据库连接数很少，需要快速释放，必须小于maxIdleTime。其实这个没必要配置，maxIdleTime已经配置了。default : 0 单位 s（不建议使用）datasource.connection.maxIdleTimeExcessConnections=0#配置连接的生存时间，超过这个时间的连接将由连接池自动断开丢弃掉。当然正在使用的连接不会马上断开，而是等待它close再断开。配置为0的时候则不会对连接的生存时间进行限制。default : 0 单位 s（不建议使用）datasource.connection.maxConnectionAge=0 获取数据库连接 1.使用BasicDataSource直接设置 1234567891011121314151617181920212223242526272829public class DBUtil &#123; private static BasicDataSource ds = new BasicDataSource(); static &#123; Properties p = new Properties(); try &#123; p.load(DBUtil.class.getClassLoader().getResourceAsStream(\"db.properties\")); ds.setDriverClassName(p.getProperty(\"driverClassName\")); ds.setUrl(p.getProperty(\"url\")); ds.setUsername(p.getProperty(\"username\")); ds.setPassword(p.getProperty(\"password\")); ds.setInitialSize(Integer.parseInt(p.getProperty(\"minPoolSize\"))); ds.setMaxActive(Integer.parseInt(p.getProperty(\"maxPoolSize\"))); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; return ds.getConnection(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null; &#125;&#125; 2.使用BasicDataSourceFactory生产DataSource [官方配置文件属性解释][http://commons.apache.org/proper/commons-dbcp/configuration.html] 1BasicDataSourceFactory.createDataSource(p) Creates and configures aBasicDataSourceinstance based on the given properties. 注意：properties文件可能存在多余的空格导致难以发现 12345678910driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/java_web?useUnicode=true&amp;characterEncoding=utf-8username=rootpassword=123456#连接池保持的最小连接数,default : 3（建议使用）#minPoolSize=3initialSize=3#连接池中拥有的最大连接数，如果获得新连接时会使连接总数超过这个值则不会再获取新连接，而是等待其他连接释放，所以这个值有可能会设计地很大,default : 15（建议使用）#maxPoolSizemaxActive=15 12345678910111213141516171819202122232425262728public class MyDBUtil &#123; private static DataSource dataSource; private static Properties p = new Properties(); static &#123; // 加载配置文件 try &#123; p.load(MyDBUtil.class.getClassLoader().getResourceAsStream(\"db.properties\")); // 创建一个对象并返回 dataSource = BasicDataSourceFactory.createDataSource(p); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; return dataSource.getConnection(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null; &#125;&#125; DBUtil.javaexecuteQuery:中间插入解析函数 定义： 123456789101112131415161718192021222324252627282930/** * @param 接口规定解析方法 */public interface ParseResultSet &#123; Object parse(ResultSet rs);&#125;/** * @param sql * @param parseResultSet 解析ResultSet的函数 * @param args */public static Object executeQuery(String sql, ParseResultSet parseResultSet, Object... args) &#123; Connection conn = DBUtil.getConnection(); PreparedStatement pstmt = null; ResultSet rs = null; Object parse = null; try &#123; pstmt = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; pstmt.setObject(i + 1, args[i]); &#125; rs = pstmt.executeQuery(); parse = parseResultSet.parse(rs); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; DBUtil.closeAll(rs, pstmt, conn); return parse;&#125; 调用： 123456789101112131415161718public boolean queryByNameAndPwd(String username, String password) &#123; String sql = \"SELECT COUNT(*) FROM user WHERE username=? AND `password` = ?\"; Integer result = (Integer) DBUtil.executeQuery(sql, new DBUtil.ParseResultSet() &#123; @Override public Object parse(ResultSet rs) &#123; int result = 0; try &#123; if (rs.next()) &#123; result = rs.getInt(1); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return result; &#125; &#125;, username, password); return result &gt; 0;&#125; executeUpdate 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package util;import java.io.IOException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Properties;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSourceFactory;/** * @author 11623 * */public class DBUtil &#123; private static DataSource dataSource; private static Properties p = new Properties(); static &#123; // 加载配置文件 try &#123; p.load(DBUtil.class.getClassLoader().getResourceAsStream(\"db.properties\")); // 创建一个对象并返回 dataSource = BasicDataSourceFactory.createDataSource(p); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; return dataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static int executeUpdate(String sql, Object... args) &#123; Connection conn = DBUtil.getConnection(); PreparedStatement pstmt = null; int num = 0; try &#123; pstmt = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; pstmt.setObject(i + 1, args[i]); &#125; num = pstmt.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); // exception: roll back try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; close(pstmt, conn); &#125; return num; &#125; public static void close(PreparedStatement pstmt, Connection conn) &#123; if (pstmt != null) &#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void closeAll(ResultSet rs, PreparedStatement pstmt, Connection conn) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; close(pstmt, conn); &#125; /** * @param 接口规定解析方法 */ public interface ParseResultSet &#123; Object parse(ResultSet rs); &#125; /** * @param sql * @param parseResultSet 解析ResultSet的回调函数 * @param args */ public static Object executeQuery(String sql, ParseResultSet parseResultSet, Object... args) &#123; Connection conn = DBUtil.getConnection(); PreparedStatement pstmt = null; ResultSet rs = null; Object parse = null; try &#123; pstmt = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; pstmt.setObject(i + 1, args[i]); &#125; rs = pstmt.executeQuery(); parse = parseResultSet.parse(rs); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; DBUtil.closeAll(rs, pstmt, conn); return parse; &#125; public static void main(String[] args) &#123; System.out.println(dataSource);// System.out.println(MyDBUtil.dataSource.getInitialSize());// System.out.println(MyDBUtil.dataSource.getMaxActive()); &#125;&#125; EL和JSTLELExpression Language 为了消JSP中的Java代码 ,JSP自带语法 语法： 1$&#123;EL表达式&#125; a.EL不需要导包b.在el中调用属性，其实是调用的getXxx()方法 1$&#123;范围.对象.属性.属性的属性 &#125; 1$&#123;requestScope.loginMsg&#125; 操作符：操作：属性，不是对象.: 使用方便[] : 如果是常量属性，需要使用双引号/单引号 引起来;比点操作符更加强大 []强大之处：a.可以容纳一些 特殊符号 （. ? -）b.[]可以容纳 变量属性 （可以动态赋值） 12String x = \"a\"; $&#123;requestScope.a&#125;等价于$&#123;requestScope[\"a\"]&#125;等价于$&#123;$&#123;requestScope[x]&#125; c.可以处理数组 1$&#123;requestScope.arr[0] &#125; 普通对象、map中的变量 通过EL获取JSP 九大内置对象 123$&#123;pageContext &#125; $&#123;pageContext.request &#125; $&#123;pageContext.sessoin &#125; JSTL：比EL更加强大需要引入2个jar ：jstl.jar standard.jar 123456&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 引入tablib : 1&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt; 其中prefix=&quot;c&quot;:前缀 核心标签库： 通用标签库、条件标签库 迭代标签库 通用标签库&lt;c:set&gt;赋值i:在某个作用域之中（4个范围对象），给某个变量赋值 1234567&lt;%-- request.setAttribute(\"name\", \"zhangsan\") ; --%&gt; &lt;c:set var=\"name\" value=\"zhangsan\" scope=\"request\"/&gt; $&#123;requestScope.name &#125; &lt;c:set var=\"变量名\" value=\"变量值\" scope=\"4个范围对象的作用域\"/&gt; ii:给普通对象赋值在某个作用域之中（4个范围对象），给某个对象的属性复制 （此种写法，不能指定scope属性） 1&lt;c:set target=\"$&#123;requestScope.student&#125;\" property=\"sname\" value=\"zxs\" /&gt; 给map对象赋值 12&lt;c:set target=\"$&#123;requestScope.countries&#125;\" property=\"cn\" value=\"中国\" /&gt; &lt;c:set target=\"对象\" property=\"对象的属性\" value=\"赋值\" /&gt; 注意 &lt;c:set&gt;可以给不存在的变量赋值 （但不能给不存在的对象赋值） &lt;c:out&gt;：显示true:&lt;c:out value=’百度‘ default=”当value为空的，显示的默认值” escapeXml=”true” /&gt;false： &lt;c:out value=’百度‘ escapeXml=”false” /&gt; &lt;c:remove &gt;：删除属性&lt;c:remove var=”a” scope=”request”/&gt; 选择if(boolean)单重选择&lt;c:if test=”” &gt; if else if… esle if… else /switch 123456&lt;c:choose&gt; &lt;c:when test=\"...\"&gt; &lt;/c:when&gt; &lt;c:when test=\"...\"&gt; &lt;/c:when&gt; &lt;c:when test=\"...\"&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; 在使用 test=”” 一定要注意后面是否有空格例如：test=”${10&gt;2 }” true test=”${10&gt;2 } “ 非true 循环（迭代标签库）1for(int i=0;i&lt;5;i++) 123&lt;c:forEach var=\"name\" items=\"$&#123;requestScope.names &#125;\" &gt; -$&#123;name &#125;- &lt;/c:forEach&gt; 可以在foreach便签中items属性作用域（requestScope）中保存的对象 1234&lt;!--for(String str:names)--&gt; &lt;c:forEach var=\"student\" items=\"$&#123;requestScope.students &#125;\" &gt; $&#123;student.sname &#125;-$&#123;student.sno &#125; &lt;/c:forEach&gt; 设计和架构MVC设计模式M：Model ，模型 ：一个功能。用JavaBean实现。 V: View，视图： 用于展示、以及与用户交互。使用html js css jsp jquery等前端技术实现 C:Controller，控制器 ：接受请求，将请求跳转到模型进行处理；模型处理完毕后，再将处理的结果 返回给 请求处 。 可以用jsp实现， 但是一般建议使用 Servlet实现控制器。 JSP-&gt;Java(Servlet)-&gt;JSP 三层优化1.加入接口 建议面向接口开发： 先接口-再实现类 –service、dao加入接口 –接口与实现类的命名规范 接口：interface， 起名 I实体类Service IStudentService IStudentDao 实现类：implements 起名 实体类ServiceImpl StudentServiceImpl StudentDaoImpl 接口： I实体类层所在包名 IStudentService、IStudentDao 接口所在的包： xxx.service xx.dao 123456 实现类： 实体类层所在包名Impl StudentServiceImpl、StudentDaoImpl 实现类所在的包：xxx.service.impl xx.dao.impl 以后使用接口/实现类时，推荐写法： 接口 x = new 实现类(); IStudentDao studentDao = new StudentDaoImpl(); 2.DBUtil 通用的数据库帮助类，可以简化Dao层的代码量 帮助类 一般建议写在 xxx.util包 A{ 123a()&#123; B.connection &#125; } B{ static Connection connection =.. b{ 1&#125; } 方法重构： 将多个方法 的共同代码 提炼出来，单独写在一个方法中，然后引入该方法即可 123456789101112131415161718192021a() &#123; .. c(); .. &#125; b() &#123; .. c(); .. &#125; c() &#123; [.. .. ... ..] &#125; Web调试：与java代码的调试 区别：启动方式不同 index.jsp -&gt;index_jsp.java -&gt;index_jsp.class jsp-&gt;java-&gt;classjsp翻译成的Java 以及编译后的class文件 存在于tomcat中的work目录中 10000 过滤器、上传文件、分页过滤器实现一个Filter接口init()、destroy() 原理、执行时机 同Servlet配置过滤器，类似servlet通过doFilter()处理拦截，并且通过chain.doFilter(request, response);放行 filter映射 只拦截 访问MyServlet的请求 1&lt;url-pattern&gt;/MyServlet&lt;/url-pattern&gt; 拦截一切请求（每一次访问 都会被拦截） 1&lt;url-pattern&gt;/*&lt;/url-pattern&gt; 通配符 123456dispatcher请求方式： REQUEST：拦截HTTP请求 get post FORWARD：只拦截 通过 请求转发方式的请求 INCLUDE:只拦截拦截通过 request.getRequestDispatcher(\"\").include() 、通过&lt;jsp:include page=\"...\" /&gt;此种方式发出的请求 ERROR：只拦截&lt;error-page&gt;发出的请求 过滤器中doFilter方法参数：ServletRequest在Servlet中的方法参数：HttpServletRequest 过滤器链可以配置多个过滤器，过滤器的先后顺序 是由 &lt;filter-mapping&gt;的位置 决定 上传文件 引入2个jar 12apache: commons-fileupload.jar组件 commons-fileupload.jar依赖 commons-io.jar pom.xml 12345678910111213&lt;!--文件上传jar--&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; 2.文件上传一般是存在服务器的upload目录下,文件名陈存在数据库中,为了防止上传文件重名,一般我们用UUID,(绝不会重复) 3.index.jsp页面的代码如下:前台jsp： 123456&lt;div&gt; &lt;form action=\"/UploadServlet\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件：&lt;input type=\"file\" name=\"photo\" value=\"\"&gt;&lt;br&gt; &lt;input type=\"submit\" name=\"修改\" value=\"上传头像\"&gt; &lt;/form&gt;&lt;/div&gt; 表单提交方式必须为post在表单中必须增加一个属性 entype=&quot;multipart/form-data&quot; 后台servlet： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.net.ssl.HttpsURLConnection;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import java.util.List;@WebServlet(\"/pictureServlet\")public class PictureServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); response.setContentType(\"text/plain;charset=utf-8\"); //此处将新建的文件直接保存到项目的绝对路径中。File没有读写能力。 File savePath = new File(\"E:\\\\javaEE\\\\Project\\\\Picture\\\\web\\\\images\"); DiskFileItemFactory factory = new DiskFileItemFactory();//jar包的类 ServletFileUpload upload = new ServletFileUpload(factory);//jar包的类 try &#123; List&lt;FileItem&gt; items = upload.parseRequest(request); //将前端的表单数据封装成list。 //form表单必须加enctype=\"multipart/form-data\"，在使用包含文件上传控件的表单时，必须使用该值。 for (FileItem item:items)&#123; if(item.isFormField())&#123; //说明普通表单项 &#125;else &#123; //说明上传文件项 //获取上传文件的名称 String name = item.getName(); //获取相对路径 String path = request.getContextPath()+\"/images/\"+name; //将相对路径保存到数据库 Test test = new Test(); test.update(path); //使用绝对路径完成文件上传 item.write(new File(savePath,name)); //删除临时文件 item.delete(); &#125; &#125; &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; ​ 注意的问题： 上传的目录 upload ： 1.如果修改代码，则在tomcat重新启动时 会被删除 原因：当修改代码的时候,tomcat会重新编译一份class 并且重新部署（重新创建各种目录） 122.如果不修改代码，则不会删除 原因： 没有修改代码，class仍然是之前的class 因此，为了防止 上传目录丢失： a.虚拟路径 b.直接更换上传目录 到非tomcat目录 限制上传： 类型、 大小 注意 对文件的限制条件 写再parseRequest之前 2.下载：不需要依赖任何jar a.请求（地址a form），请求Servlet b.Servlet通过文件的地址 将文件转为输入流 读到Servlet中 c.通过输出流 将 刚才已经转为输入流的文件 输出给用户 注意：下载文件 需要设置2个 响应头：response.addHeader(“content-Type”,”application/octet-stream” );//MIME类型:二进制文件（任意文件）response.addHeader(“content-Disposition”,”attachement;filename=”+fileName );//fileName包含了文件后缀：abc.txt 1.下载时 ，文件名乱码问题：edge： URLEncoder.encode(fileName,”UTF-8”) firefox：给文件名 加：前缀 =?UTF-8?B? String构造方法Base64.encode后缀 ?=示例： 1response.addHeader(\"content-Disposition\",\"attachment;filename==?UTF-8?B?\"+ new String( Base64.encodeBase64(fileName.getBytes(\"UTF-8\")) ) +\"?=\" );//fileName包含了文件后缀：abc.txt 分页5变量（属性） 1.数据总数 （select count(*) from xxx ， 查数据库）2.页面大小（页面容量，每页显示的数据条数） （用户自定义）3.总页数 （自动计算） 800:10= 80页 总页数= 数据总数 /页面大小 12345802:10= 800/10 +1 ； 总页数= 数据总数 /页面大小 + 1; --&gt;通式 总页数= 数据总数 % 页面大小==0 ?数据总数 /页面大小:数据总数 /页面大小 + 1; 注意：自动计算的时机：当 数据总数 和 页面大小都被赋值以后，自动计算总页数。 4.当前页码 （用户自定义） 5.实体类对象集合（当前页的数据集合）：依赖于数据库 (查数据库) 假设： 每页显示10条（页面大小=10） 1select * from student where id&gt;=起始 and id&lt;=终止; 页数 起止 起止等价写法1 1-10 (页数-1)10+1-页数102 11-203 21-30 某一页的数据 起止： 1(页数-1)*10+1-页数*10 1select * from student where sno&gt;=(页数-1)*10+1 and sno&lt;=页数*10; 此种分页SQL 严格依赖sno的数据， 一旦sno出现了间隙（裂缝），则无法满足每页10条 -&gt;将此SQL 转换： 1.有rownum 2不能有rownum&gt;xx转换的核心： 将rownum从伪列 转换为 一个 临时表的 普通列。 123456select *from ( select rownum r,t.*from (select s.* from student s order by sno asc) t ) where r&gt;=(页数-1)*10+1 and r&lt;=页数*10; 优化： 123456select *from ( select rownum r,t.*from (select s.* from student s order by sno asc) t where rownum&lt;=页数*页面大小 ) where r&gt;=(页数-1)*页面大小+1 ; dao和DBUtil的区别：dao 是处理特定 类的 数据库操作类：DBUtil是通用 数据库操作类 分页实现要实现分页，必须知道 某一页的 数据 从哪里开始 到哪里结束 页面大小：每页显示的数据量 假设每页显示10条数据 mysql分页mysql:从0开始计数0 0 91 10 19 n n*10 (n+1)*10-1 MYSQL实现分页的sqllimit 开始,多少条第1页 1select * from student limit 0,10 ; 第2页 1select * from student limit 10,10 ; mysql的分页语句： 1select * from student limit （页数-1）*页面大小,页面大小 oracle分页sql server/oracle:从1开始计数 : (n-1)*10+1 --- n*10 第n页 开始 结束1 1 102 11 203 21 30n (n-1)10+1 n10 1select *from student where sno &gt;=(n-1)*10+1 and sno &lt;=n*10 ; --此种写法的前提：必须是Id连续 ，否则 无法满足每页显示10条数据 1select rownum,t.*from student t where rownum &gt;=(n-1)*10+1 and rownum &lt;=n*10 order by sno; 如果根据sno排序则rownum会混乱（解决方案：分开使用-&gt;先只排序，再只查询rownum） .rownum不能查询&gt;的数据 12345select s.* from student s order by sno asc; select rownum, t.* from (select s.* from student s order by sno asc) t where rownum &gt;=(n-1)*10+1 and rownum &lt;=n*10 ; oracle的分页查询语句： 123456select *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t 10000 ) where r&gt;=(n-1)*10+1 and &lt;=n*10 ; 优化： 123456789101112131415select *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t where rownum&lt;=n*10 ) where r&gt;=(n-1)*10+1 ; select *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t where rownum&lt;=页数*页面大小 ) where r&gt;=(页数-1)*页面大小+1 ; SQLServer分页 3种分页sqlrow_number() over(字段) ; sqlserver2003:top –此种分页SQL存在弊端（如果id值不连续，则不能保证每页数据量相等）select top 页面大小 * from student where id not in( select top (页数-1)*页面大小 id from student order by sno asc ) sqlserver2005之后支持： 123select *from ( select row_number() over (sno order by sno asc) as r,* from student 1where r&lt;=n*10 123) where r&gt;=(n-1)*10+1 and ; SQLServer此种分页sql与oralce分页sql的区别： 1.rownum ，row_number() 2.oracle需要排序（为了排序，单独写了一个子查询），但是在sqlserver 中可以省略该排序的子查询 因为sqlserver中可以通过over直接排序 sqlserver2012之后支持： 1234offset fetch next only select * from student oreder by sno offset (页数-1)*页面大小+1 rows fetch next 页面大小 rows only ; (n-1)10+1 — n10 mysql从0开始计数，Oracle/sqlserver 从1开始计数 分页实现5个变量（属性）1.数据总数(查数据库) 1select count(*).. 2.页面大小（每页显示的数据条数）20 (用户自定义)3.总页数 （程序自动计算） 总页数 = 100/20 =数据总数/页面大小 总页数 = 103/20 = 数据总数/页面大小+1 —&gt; 1总页数 = 数据总数%页面大小==0 ? 数据总数/页面大小:数据总数/页面大小+1 ; 4.当前页（页码） （用户自定义）5.当前页的对象集合（实体类集合）：每页所显示的所有数据 （10个人信息）List&lt;Student&gt; (查数据库,分页sql) web路径 web路径：1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名;就是http//localhost/端口号/crud/… 1234&lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath()); %&gt; $&#123;APP_PATH&#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css --&gt;","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"}]},{"title":"javaSE","slug":"java-note/javaSE/javaSE","date":"2019-10-12T02:32:06.000Z","updated":"2021-10-23T02:19:04.194Z","comments":true,"path":"2019/10/java-note/javaSE/javaSE/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/javaSE/javaSE/","excerpt":"[TOC]java控制台执行可以直接编译＋运行 1java Create.java字符串String特点String内容不可改变 字符串常量就是String的匿名对象 所谓的直接赋值实际上就是相当于将一个匿名对象设置了一个名字而已 String类的匿名对象是由系统自动设置，而不是有用户自己定义的String当做参数传递没有改变，是因为新的String通过赋值指向了新的对象，所以对传入的String没有影响","text":"[TOC]java控制台执行可以直接编译＋运行 1java Create.java字符串String特点String内容不可改变 字符串常量就是String的匿名对象 所谓的直接赋值实际上就是相当于将一个匿名对象设置了一个名字而已 String类的匿名对象是由系统自动设置，而不是有用户自己定义的String当做参数传递没有改变，是因为新的String通过赋值指向了新的对象，所以对传入的String没有影响 修改类StringBuffer StringBuffer的内容可以修改 方法： public StringBuffer reverse() append insert delete 线程安全的，都是同步方法和String一样都实现了CharSequence接口StringBulid 是StringBuffer基本一样 线程不安全的 两种实例化方式直接赋值new构造方法 其内容不会保存在对象池中 使用new关键字，在堆上开辟一个内存 手动入池 public native String intern(); 容易找出空间浪费，不建议使用 常用类数字类大数类大整数类BigIntegerString构造方法 public BigInteger(String val) 大浮点数BigDecimal构造方法 String构造方法 double构造方法可实现准确的四舍五入操作 public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 除以1实现四舍五入 divide(new BigDecimal(1),scale,BigDecimal.ROUND_HALF_UP) round(new MathContext(setPrecision, RoundingMode.HALF_UP)) MathContext构造方法默认四舍五入 setScale(newScale, RoundingMode.HALF_UP) 小数位后保留 Math类 Math类里面提供的方法都是static方法，Math类里面都没有普通方法四舍五入round public static long round(double a) 如果负数进行四舍五入时，大于-0.5才为-1 JDBC1、加载数据库驱动 E:\\app\\test\\product\\11.2.0\\dbhome_1\\jdbc\\lib\\ojdbc6.jar Oracle驱动类：oracle.jdbc.dirver.OracleDrive 连接oracle 驱动程序下载oracle自带有 加载驱动类class.forName(“oracle.jdbc.dirver.OracleDrive”) 2、建立数据库连接 DriverManager.getConnection(url, user, password) 数据库链接地址（URL） oracle jdbc：oracle:连接方式：主机名称：端口号：数据库的SID（Security Identifier） 连接本机的mldn数据库： jdbc:oracle:thin:@localhost:1521:mldnjava之中所有的数据库操作类和接口在java.sql数据库驱动程序有数据库生成商提供JDBC在实现数据库驱动连接对象使用工厂设计设计模式，而DriverManager就是工厂类 所以客服端调用连接时，隐藏子类的具体连接实现 正则表达式Pattern类 获得此类对象必须通过Compile()方法，编译正则表达式 Matcher类Pattern类获得 1package java.util.regex; name description public int start() 字符串的正则运用matches()：正则验证 replaceAll(String regex, String replacement):全部替换 replaceFirst(String regex, String replacement)：替换首个 split(String regex) ：全部拆分 split(String regex, int limit)：部分拆分 正则标记都在Pattern类定义单个字符（匹配数量1） 字符：由一个字符组成 \\转移字符’&#39; ‘\\t’制表符 \\n换行符字符集（数量1） [abc]表示字符a、b和c中的任意一个（或的关系） [ ^abc]表示不是abc中任意一个（^非的关系） **[x-y] x的ascii到y的ascii码之间的值** [a-z]所有小写字母**（也可以[e-i])** [a-zA-Z]任意字母 [0-9]任意一位数字简化字符表达式（数量1） . :任意一位字符 \\d： =[0-9] \\D : = [ ^0-9] \\s: 任意空白字符，如’\\t’,’\\n’ \\S:任意非空白字符 \\w : =[a-zA-Z_0-9] \\W : = [ ^a-zA-Z_0-9]边界表达式（不要在java中用，javaScript中用） ^:正则开始 $:正则结束数量表达式 正则？：表示正则可以出现0次或1次 {0,1} 正则+：表示正则可以出现1次或1次以上 &gt;=1 {1,} 正则：表示正则可以出现0次或1次或多次 &gt;= 0 {0,} 正则{n}：表示正则正好出现n次 正则{n,}：表示正则出现n次及以上 正则{n,m}：表示正则出现{n,m}次逻辑表达式 正则1正则2：判断第一个完成以后再判断第二个正则 正则1|正则2：两个正则的或（正则）：*将多个正则作为一组**，可以为这一组单独设置次数注解 Annotation3个最常用的基础注解 声明覆写操作@Override 明确告诉编译器覆写，如果没有覆写成功则会报错 声明过期操作@desperated 压制警告@SupperssWarming 多线程实现 Thread实现 Runnable接口实现，能多继承 Thread类有Runnable的构造函数 Callable泛型接口实现，能有返回值 Thread类没有Callable的构造函数 FutureTask类负责接收call方法的返回值（接收Callable构造），实现RunnableFuture接口，RunnableFuture接口实现了Runnable接口、Future接口的get方法（负责接收返回值） 需要重写run方法，start开始 不用run方法是因为需要判断线程是否重复启动，并且需要不同操作系统提供start0的资源调配方法休眠Sleep（Thread） 几个线程一起休眠感觉是一起结束（时间长)，当是结束之后还是要抢占资源（时间短）,顺序是不固定的优先级 优先级越高，越有可能抢占到资源，越有可能执行同步synchronized 同步代码块 同步方法public synchronized 返回值等待wait(Object类） notify唤醒 对象克隆如果没有实现Cloneable的接口会上抛一个异常Cloneable接口 没有方法和全局常量 此为标识接口，表示一种能力需要覆写Object类的clone方法 protected native Object clone() throws CloneNotSupportedException; 反射“反”通过对象找到类的出处java.lang.Class反射的源头 三种实例化方式第一种：调用Object类中的getClass() 需要对象实例化第二种：类.class属性 不需要对象实例化，需要import Spring、Hibernate第三种：Class提供的forName()方法 不需要import导入类，类用String描述 1public static Class&lt;?&gt; forName(String className) 123456// 通过Class.forName方式Class feeClass = null;try &#123; feeClass = Class.forName(\"pojo.Fee\");&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); 获取属性1234// 获取属性 Field[] field01 = clazz.getFields(); // 返回属性为public的字段 Field[] field02 = clazz.getDeclaredFields(); // 返回所有的属性 Field field03 = clazz.getDeclaredField(\"id\"); // 获取属性为id的字段 Field方法:12String name = field.getName();Class&lt;?&gt; type = field.getType(); 123456789// 获取对象属性Fields[] fields = clazz.getDeclaredFields();for(Field field: fields)&#123; String name = field.getName(); field.setAccessible(true); // 私有属性必须设置访问权限 Object resultValue = field.get(obj); // 这里可以编写你的业务代码 System.out.println(name + \": \" + resultValue);&#125; 获取方法123// 获取普通方法 Method[] Method01 = clazz.getDeclaredMethods(); // 返回public方法 Method method = clazz.getDeclaredMethod(\"getId\", null); // 返回getId这个方法，如果没有参数，就默认为null Method使用 1method.invoke(obj, new Object[]&#123;&#125;); obj: 调用方法的对象 the object the underlying method is invoked from 1Method method = clazz.getMethod(methodName, new Class[]&#123;&#125;); 方法名+参数列表找到指定方法 1234567891011121314Object obj = clazz.newInstance();// 获取对象属性Fields[] fields = clazz.getDeclaredFields();for(Field field: fields)&#123; String fieldName = field.getName(); String upperChar = fieldName.substring(0,1).toUpperCase(); String anotherStr = fieldName.substring(1).; String methodName = \"get\" + upperChar + anotherStr; Method method = clazz.getMethod(methodName, new Class[]&#123;&#125;); method.setAccessiable(true); Object resultValue = method.invoke(obj, new Object[]&#123;&#125;); // 这里可以编写你的业务代码 System.out.println(fieldName + \": \" + resultValue);&#125; 反射对象实例化 Class类的无参构造方法：public T newInstance() new是耦合的主要元凶，当出现高耦合时大多数时能用反射降低 工厂模式构造方法调用 最好保留无参构造方法，以便构造 取得指定构造方法 public Constructor getConstructor(Class... parameterTypes) public类型构造方法 public Constructor getDeclaredConstructor(Class… parameterTypes) 所有构造方法 取得一些构造方法 函数式编程（Lambda）、流式编程函数式接口java.util.function 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。这主要是因为基本类型会产生一小部分接口。 如果你了解命名模式，顾名思义就能知道特定接口的作用。 以下是基本命名准则： 如果只处理对象而非基本类型，名称则为 Function，Consumer，Predicate 等。参数类型通过泛型添加。 如果接收的参数是基本类型，则由名称的第一部分表示，如 LongConsumer，DoubleFunction，IntPredicate 等，但基本 Supplier 类型例外。 如果返回值为基本类型，则用 To 表示，如 ToLongFunction &lt;T&gt; 和 IntToLongFunction。 如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 UnaryOperator，两个参数使用 BinaryOperator。 如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。 如果接收的两个参数类型不同，则名称中有一个 Bi。 下表描述了 java.util.function 中的目标类型（包括例外情况）： 特征 函数式方法名 示例 无参数； 无返回值 Runnable (java.lang) run() Runnable 无参数； 返回类型任意 Supplier get() getAs类型() Supplier&lt;T&gt; BooleanSupplier IntSupplier LongSupplier DoubleSupplier 无参数； 返回类型任意 Callable (java.util.concurrent) call() Callable&lt;V&gt; 1 参数； 无返回值 Consumer accept() Consumer&lt;T&gt; IntConsumer LongConsumer DoubleConsumer 2 参数 Consumer BiConsumer accept() BiConsumer&lt;T,U&gt; 2 参数 Consumer； 1 引用； 1 基本类型 Obj类型Consumer accept() ObjIntConsumer&lt;T&gt; ObjLongConsumer&lt;T&gt; ObjDoubleConsumer&lt;T&gt; 1 参数； 返回类型不同 Function apply() To类型 和 类型To类型 applyAs类型() Function&lt;T,R&gt; IntFunction&lt;R&gt; LongFunction&lt;R&gt; DoubleFunction&lt;R&gt; ToIntFunction&lt;T&gt; ToLongFunction&lt;T&gt; ToDoubleFunction&lt;T&gt; IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 1 参数； 返回类型相同 UnaryOperator apply() UnaryOperator&lt;T&gt; IntUnaryOperator LongUnaryOperator DoubleUnaryOperator 2 参数类型相同； 返回类型相同 BinaryOperator apply() BinaryOperator&lt;T&gt; IntBinaryOperator LongBinaryOperator DoubleBinaryOperator 2 参数类型相同; 返回整型 Comparator (java.util) compare() Comparator&lt;T&gt; 2 参数； 返回布尔型 Predicate test() Predicate&lt;T&gt; BiPredicate&lt;T,U&gt; IntPredicate LongPredicate DoublePredicate 参数基本类型； 返回基本类型 类型To类型Function applyAs类型() IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 2 参数类型不同 Bi操作 (不同方法名) BiFunction&lt;T,U,R&gt; BiConsumer&lt;T,U&gt; BiPredicate&lt;T,U&gt; ToIntBiFunction&lt;T,U&gt; ToLongBiFunction&lt;T,U&gt; ToDoubleBiFunction&lt;T&gt; 此表仅提供些常规方案。通过上表，你应该或多或少能自行推导出更多行的函数式接口。 可以看出，在创建 java.util.function 时，设计者们做出了一些选择。 例如，为什么没有 IntComparator，LongComparator 和 DoubleComparator 呢？有 BooleanSupplier 却没有其他表示 Boolean 的接口；有通用的 BiConsumer 却没有用于 int，long 和 double 的 BiConsumers 变体（我对他们放弃的原因表示同情）。这些选择是疏忽还是有人认为其他组合的使用情况出现得很少（他们是如何得出这个结论的）？ 流常用处理方法匹配，遍历中遇到function返回true中断 anyMatch anyMatch(Predicate)：如果流中的任意一个元素根据提供的 Predicate 返回 true 时，结果返回为 true。这个操作将会在第一个 true 之后短路；也就是不会在发生 true 之后继续执行计算。 forEach 遍历，全部遍历，不能中断 itearte 自定义序列 根据第一的seed参数应用于第二个function产生序列 1public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) &#123; Returns an infinite sequential ordered Stream produced by iterativeapplication of a function f to an initial elementseed, producing a Stream consisting ofseed, f(seed), f(f(seed)), etc. 1234List&lt;String&gt; list = java.util.Arrays.asList(\"a\",\"b\",\"c\");Stream.iterate(0, i -&gt; i + 1).limit(list.size()).forEach(i -&gt; &#123; System.out.println(String.valueOf(i) + list.get(i));&#125;); 流元素排序sorted()的默认比较器 12Stream&lt;T&gt; sorted();Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator); 1sorted(Comparator.reverseOrder()) 共享设计模式在JVM的底层实际上会存在有一个对象池（不一定只保存String），当String通过直接赋值创建一个String类对象时，会将此匿名对象如此保存，而后若果有新的String通过直接复制并且赋值内容和之前入池的相同，则不会开辟新的堆内存，而是使用之前对象池的引用。 4种代码块1、普通代码块 代码块写在了方法里面 改变变量作用域，能防止重名？（但是什么没有）2、构造块 代码写在了类里 构造块优先于构造块执行，每次构造执行一次（没什么用）3、静态代码块 非主类 主类 静态块在主方法前运行 为了静态变量的初始化，一个类只执行一次（也没什么用）4、同步代码块 多线程同步使用尽量不要使用代码块 io流transientjava语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程。 Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"}]},{"title":"jquery","slug":"js-note/jquery/jquery","date":"2019-10-12T02:25:41.000Z","updated":"2021-10-23T02:19:04.229Z","comments":true,"path":"2019/10/js-note/jquery/jquery/","link":"","permalink":"https://codeofli.github.io/2019/10/js-note/jquery/jquery/","excerpt":"[TOC]jQuery入口函数jQuery与JavaScript加载模式对比 多个window.onload只会执行一次, 后面的会覆盖前面的 12345678&lt;script&gt; window.onload = function () &#123; alert(\"hello lnj1\"); // 不会显示 &#125; window.onload = function () &#123; alert(\"hello lnj2\"); // 会显示 &#125;&lt;/script&gt;","text":"[TOC]jQuery入口函数jQuery与JavaScript加载模式对比 多个window.onload只会执行一次, 后面的会覆盖前面的 12345678&lt;script&gt; window.onload = function () &#123; alert(\"hello lnj1\"); // 不会显示 &#125; window.onload = function () &#123; alert(\"hello lnj2\"); // 会显示 &#125;&lt;/script&gt; 多个$(document).ready()会执行多次,后面的不会覆盖前面的 12345678&lt;script&gt; $(document).ready(function () &#123; alert(\"hello lnj1\"); //会显示 &#125;); $(document).ready(function () &#123; alert(\"hello lnj2\"); // 会显示 &#125;);&lt;/script&gt; 不会覆盖的本质(了解,后面jQuery原理会详细讲解) jQuery框架本质是一个闭包,每次执行我们都会给ready函数传递一个新的函数,不同函数内部的数据不会相互干扰 1234567891011121314151617181920212223242526&lt;script&gt; // 相当于这样写 var test1 = function () &#123; alert(\"hello lnj1\"); &#125; var test2 = function () &#123; alert(\"hello lnj2\"); &#125; $(document).ready(test1); $(document).ready(test2);&lt;/script&gt;&lt;script&gt; var test3 = function () &#123; var abc = \"123\";// 因为在同一个函数中,所以456覆盖123// var abc = \"456\"; alert(abc); &#125; test3(); var test4 = function () &#123; // 因为在不同函数中,所以不会影响 var abc = \"456\"; alert(abc); &#125; test4();&lt;/script&gt; window.onload $(document).ready() 执行时机 必须等待网页全部加载完毕(包括 图片等),然后再执行包裹代码 只需要等待网页中的DOM结构 加载完毕,就能执行包裹的代码 执行次数 只能执行一次,如果第二次,那么 第一次的执行会被覆盖 可以执行多次,第N次都不会被上 一次覆盖 简写方案 无 $(function () { }); 为什么我们能访问$符号? 因为$符号jQuery框架对外暴露的一个全局变量 JavaScript中如何定义一个全局变量? 所有全局变量是 window 对象的属性 1234567891011 function test () &#123; var customValue = 998; alert(customValue);// 1.没有如下代码customValue就不是一个全局变量,函数执行完毕之后// customValue会被自动释放,test函数以外的地方访问不到customValue// 2.加上如下代码之后customValue就会变成一个全局变量,函数执行完毕也不// 会被释放,test函数以外的地方可以访问customValue// window.customValue = customValue; &#125; test(); alert(customValue); 所以jQuery框架源码实现 1window.jQuery = window.$ = jQuery; 所以想要使用jQuery框架只有两种方式,一种是通过$,一种是通过jQuery jQuery入口函数的其它编写方式如下 12345&lt;script&gt; jQuery(function () &#123; alert(\"hello lnj\"); &#125;);&lt;/script&gt; 123456789101112131415161718&lt;script&gt; // 方式一 $(document).ready(function () &#123; alert(\"hello lnj\"); &#125;); // 方式二 $(function () &#123; alert(\"hello lnj\"); &#125;); // 方式三 jQuery(document).ready(function () &#123; alert(\"hello lnj\"); &#125;); // 方式四 jQuery(function () &#123; alert(\"hello lnj\"); &#125;);&lt;/script&gt; 解决$符号冲突问题 为什么是window.jQuery = window.$ = jQuery;,而不是window.jQuery = jQuery; jQuery框架之所以提供了jQuery访问还提供$访问,就是为了提升开发者的编码效率 $符号冲突怎么办? 很多js的框架都提供了类似jQuery这样的便捷访问方式,所以很有可能某一天我们在使用多个框架的时,多个框架作者提供的便捷访问方式冲突(A框架通过$访问,B框架也通过$访问) ***释放$使用权 当便捷访问符号发生冲突时,我们可以释放$使用权, 释放之后只能使用jQuery 12345678&lt;script&gt; // 在使用jQuery之前指定自定义符号 jQuery.noConflict(); // 使用 jQuery jQuery(\"div p\").hide(); // 使用其他库的 $() $(\"content\").style.display = 'none';&lt;/script&gt; 自定义便捷访问符号 当便捷访问符号发生冲突时,我们可以自定义便捷访问符号 12345678&lt;script&gt; // 在使用jQuery之前指定自定义符号 var nj = jQuery.noConflict(); // 和使用$一样通过自定义符号调用jQuery nj(function () &#123; alert(\"hello lnj\"); &#125;);&lt;/script&gt; 核心函数和静态方法jQuery核心函数 从jQuery文档中可以看出,jQuery核心函数一共3大类4小类 jQuery(callback) 当DOM加载完成后执行传入的回调函数 12345&lt;script&gt; $(function () &#123; alert(\"123\"); &#125;);&lt;/script&gt; jQuery([sel,[context]]) 接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素,并包装成jQuery对象 1234567891011&lt;script&gt; $(function () &#123; // 利用jquery获取所有div,得到的是一个jQuery对象 var $box = $(\"div\"); console.log($box); // 利用js原生语法获取所有div,得到的是一个js对象 var box = document.getElementsByTagName(\"div\"); console.log(box); &#125;);&lt;/script&gt; 原生JS对象和jQuery对象相互转换 1234567891011121314151617181920212223&lt;script&gt; $(function () &#123; var $box = $(\"#box\");// $box.text(\"新的数据\");// jQuery对象不能使用原生js对象的方法// $box.innerText = \"新的数据\";// 将jQuery对象转换为原生js对象// 注意: 不是eq(0),eq函数返回的是jQuery类型对象,get函数返回的是原生类型对象// var box = $box.get(0); var box = $box[0]; box.innerText = \"新的数据\"; var box2 = document.getElementById(\"box\");// 原生js对象不能使用jQuery对象的方法// box2.text(\"新的数据2\");// 原生js对象只能使用原生的js方法// box2.innerText = \"新的数据2\";// 将原生js对象转换为jQuery对象 var $box2 = $(box); $box2.text(\"新的数据2\"); &#125;);&lt;/script&gt; Tips:为了方便开发者之间沟通和阅读,一般情况下所有jQuery操作相关的变量前面加上$ jQuery(html,[ownerDoc]) 根据 HTML 标记字符串，动态创建DOM 元素 123456789&lt;script&gt; $(function () &#123; var $eles = $(\"&lt;p&gt;我是span&lt;/p&gt;&lt;u&gt;我是u&lt;/u&gt;\"); // 无论是jQuery找到的还是创建的,我们最终拿到的永远都是jQuery对象 console.log($eles); // 将创建好的DOM元素添加到body中 $(\"body\").append($eles); &#125;);&lt;/script&gt; jQuery对象 jQuery对象的本质是什么? jQuery对象的本质是一个伪数组 12345var $div = $(\"div\");console.log($div);var arr = [1, 3, 5];console.log(arr); 什么是伪数组? 有0到length-1的属性 并且有length属性 1var obj = &#123;0:\"lnj\", 1:\"33\", 2:\"male\", length: 3&#125; jQuery静态方法 什么是静态方法? 静态方法对应的是对象方法,对象方法用实例对象调用,而静态方法用类名调用 1234567891011121314151617 &lt;script&gt; window.onload = function () &#123; function AClass()&#123;&#125; AClass.staticMethof = function()&#123; alert('静态方法'); &#125; AClass.prototype.instaceMethod = function()&#123; alert('实例方法'); &#125; //静态方法用类名直接调用 AClass.staticMethof(); //实例方法必须用类的实例对象调用 var instace = new AClass(); instace.instaceMethod(); &#125;&lt;/script&gt; jQuery.holdReady(hold) 暂停或者恢复jQuery.ready()事件 传入true或false 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;04-jQuery静态方法&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; // 使用$直接调用,是静态方法 $.holdReady(true); $(function () &#123; $(\"#first\").click(function () &#123; alert(\"我是你想要的弹窗\"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=\"first\"&gt;点击测试弹出&lt;/button&gt;&lt;button id=\"second\"&gt;解除延迟&lt;/button&gt;&lt;script&gt; $(\"#second\").click(function()&#123; $.holdReady(false); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $.each(object,[callback]) 遍历对象或数组 优点统一遍历对象和数组的方式 回调参数的顺序更符合我们的思维模式 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; $(function () &#123; // 3.1遍历数组 var arr = [1, 3, 5, 7, 9]; // 3.1.1通过原生方法遍历数组 // 第一个回调函数参数是遍历到的元素 // 第二个回调函数参数是当前遍历的索引 // 返回值: 没有返回值 var res = arr.forEach(function (ele, idx) &#123; console.log(idx, ele); &#125;); console.log(res); // 3.1.2通过jQuery静态方法遍历数组 // 第一个回调函数参数是当前遍历的索引 // 第二个回调函数参数是遍历到的元素 // 返回值: 被遍历的数组 var $res2 = $.each(arr, function (idx, ele) &#123; console.log(idx, ele); &#125;); console.log($res2); // 3.2遍历对象 var obj = &#123;name: \"lnj\", age:\"33\", gender:\"male\"&#125;; // 3.2.1js对象没有forEach方法,所以通过forin方法遍历对象 for(var key in obj)&#123; console.log(key, obj[key]); &#125; // 3.2.2通过jQuery静态方法遍历对象 $.each(obj,function (key, value) &#123; console.log(key, value); &#125;); &#125;); &lt;/script&gt; $.map(arr|obj,callback) 遍历对象或数组,将回调函数的返回值组成一个新的数组返回 1234567891011121314151617181920212223242526272829303132333435363738$(function () &#123; // 4.1遍历数组 var arr = [1, 3, 5, 7, 9]; // 4.1.1通过原生方法遍历数组 // 第一个回调函数参数是遍历到的元素 // 第二个回调函数参数是当前遍历的索引 // 第三个回调函数参数是当前被遍历的数组 // 返回值: 将回调函数返回值收集起来组成一个新的数组 var res = arr.map(function (ele, idx, arr) &#123; console.log(idx, ele, arr); return ele + idx; &#125;); console.log(res); // 4.1.2通过jQuery静态方法遍历数组 // 第一个回调函数参数是遍历到的元素 // 第二个回调函数参数是当前遍历的索引 // 返回值: 将回调函数返回值收集起来组成一个新的数组 var $res2 = $.map(arr, function (ele,idx) &#123; console.log(idx, ele); return ele + idx; &#125;); console.log($res2); // 4.2遍历对象 var obj = &#123;name: \"lnj\", age:\"33\", gender:\"male\"&#125;; /* obj.map(function (ele, idx, obj) &#123; // 报错,原生JS没有map方法 console.log(idx, ele, obj); &#125;); */ var $res = $.map(obj, function (value, key) &#123; console.log(key, value); return key + value; &#125;); console.log($res);&#125;); $.trim(str) 去掉字符串起始和结尾的空格。 12345678&lt;script&gt; $(function () &#123; var str = \" lnj \"; console.log(\"---\"+str+\"---\"); var $res = $.trim(str); console.log(\"---\"+$res+\"---\"); &#125;);&lt;/script&gt; $.isArray(obj) 判断是否是数组 123456789101112&lt;script&gt; $(function () &#123; // 对象 var obj = &#123;name:\"lnj\",age: \"33\", gender:\"male\"&#125;; // 真数组 var arr = [1, 3, 5, 7, 9]; var $res = $.isArray(obj); console.log($res);// false var $res2 = $.isArray(arr); console.log($res2);// true &#125;);&lt;/script&gt; $.isFunction(obj) 判断是否是函数 jQuery框架本质是一个匿名函数 12345678910111213141516171819&lt;script&gt; $(function () &#123; var obj = &#123;name:\"lnj\",age: \"33\", gender:\"male\"&#125;; var arr = [1, 3, 5, 7, 9]; var fn = function () &#123;&#125; var $res = $.isFunction(obj); console.log($res);// false $res = $.isFunction(arr); console.log($res); $res = $.isFunction(fn); console.log($res); // 通过该方法验证了我们前面所说的,jQuery框架本质是一个匿名函数 (function(window,undefined)&#123; xxxx.... &#125;)(window); $res = $.isFunction($); console.log($res); &#125;);&lt;/script&gt; $.isWindow(obj) 判断是否是window对象 12345678910111213&lt;script&gt; $(function () &#123; var obj = window; var arr = [1, 3, 5, 7, 9]; var arrlike = &#123;0:\"zs\", 1:\"ls\", length:2&#125;; var $res = $.isWindow(obj); console.log($res); // true $res = $.isWindow(arr); console.log($res); // false $res = $.isWindow(arrlike); console.log($res); // false &#125;);&lt;/script&gt; 为什么要讲解以上极度简单的工具方法? 江哥提示: 这是为后面放大招做铺垫,一定要认真记住以上方法哦 基础选择器 视频参考第十章-CSS选择器 选择器 名称 描述 返回 示例 #id id选择器 根据给定的id匹配一个元素 单个元素 $(“#box”);选取id为box元素 .class 类选择器 根据给定的类名匹配元素 集合元素 $(“.box”);选取所有类名为box元素 element 元素选择器 根据给定的元素名称匹配元素 集合元素 $(“p”);选取所有元素 * 通配符选择器 匹配所有元素 集合元素 $(“*”);选取所有元素 selector1,selector2,selectorN 并集选择器 将所有选择器匹配到的元素合并后一起返回 集合元素 $(“div,p,.box”);选取所有元素,所有元素和所有类名为box元素 层次选择器 选择器 名称 描述 返回 示例 $(“ancestor descendant”) 后代选择器 选取ancestor元素的所有descendant后代标签(不光是儿子,包括孙子/重孙子等) 集合元素 $(“div span”);选取元素里所有的元素 $(“parent &gt; child”) 子元素选择器 找到选取parent 元素中所有直接子元素child(只有儿子,不包括孙子/重孙子等) 集合元素 $(“div&gt;span”);选取元素下元素名称是的子元素 $(“prev + next”) 相邻兄弟选择器 选取prev元素后面紧跟的那个next元素 集合元素 $(“.one+div”);选取类名为one的下一个同级的元素 $(“prev ~ siblings”) 通用兄弟选择器 选取prev元素后面的所有next元素 集合元素 $(“#two~div”);选取id名为two元素后面所有同级的元素 序选择器 视频参考第十章-CSS选择器 如上内容不再一一赘述,观看第十章-CSS选择器,使用时查询文档即可 做开发是脑力活,我们需要掌握的是解决问题的方法,而不是死记硬背 属性选择器 视频参考第十章-CSS选择器 如上内容不再一一赘述,观看第十章-CSS选择器,使用时查询文档即可 做开发是脑力活,我们需要掌握的是解决问题的方法,而不是死记硬背 内容过滤选择器 选择器 描述 返回 :empty 选取不包含子元素或文本为空的元素 集合元素 :parent 选取含有子元素或文本的元素 集合元素 :contains(text) 选取含有文本内容为text的元素 集合元素 :has(selector) 选取含有选择器所匹配的元素的元素 集合元素 :empty 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中不包含文本内容或子元素的元素 var $res = $(\"div:empty\"); console.log($res.length); // 找到1个元素 $res.each(function (idx,ele) &#123; console.log(idx, ele); // one &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;zs&lt;/div&gt;&lt;!--包含内容不会被找到--&gt;&lt;div class=\"three\"&gt;&lt;!--包含子元素不会被找到--&gt; &lt;span&gt;lnj&lt;/span&gt;&lt;/div&gt;&lt;span class=\"five\"&gt;&lt;/span&gt;&lt;!--不是指定元素不会被找到--&gt;&lt;/body&gt;&lt;/html&gt; :parent 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中包含文本内容或子元素的元素 var $res = $(\"div:parent\"); console.log($res.length); $res.each(function (idx, ele) &#123; console.log(idx, ele); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;zs&lt;/div&gt;&lt;!--有文本内容会被找到--&gt;&lt;div class=\"three\"&gt;&lt;!--有子元素会被找到--&gt; &lt;span&gt;lnj&lt;/span&gt;&lt;/div&gt;&lt;span class=\"five\"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; :contains(text) 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中包含文本内容为lnj的元素 var $res = $(\"div:contains('lnj')\"); console.log($res.length);// 找到2个元素 $res.each(function (idx, ele) &#123; console.log(idx, ele);// one,three,four &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt;lnj&lt;/div&gt;&lt;div class=\"two\"&gt;zs&lt;/div&gt;&lt;div class=\"three\"&gt;lnj&lt;/div&gt;&lt;div class=\"four\"&gt;&lt;!--子元素中包含该文本也会被找到--&gt; &lt;span&gt;lnj&lt;/span&gt;&lt;/div&gt;&lt;span class=\"five\"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; :has(selector) 和:parent区别,parent只要有子元素就会被找到,:has(selector)不仅要有子元素,而且子元素还必须满足我们的条件 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中包含后代元素为span的元素 var $res = $(\"div:has('span')\"); console.log($res.length); $res.each(function (idx, ele) &#123; console.log(idx, ele); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt; &lt;!--后代中包含span元素会被找到--&gt; &lt;span&gt;jjj&lt;/span&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;&lt;!--后代中不包含span元素不会被找到--&gt; &lt;p&gt;zs&lt;/p&gt;&lt;/div&gt;&lt;div class=\"three\"&gt;&lt;!--后代中包含span元素会被找到--&gt; &lt;p&gt; &lt;span&gt;lnj&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 属性相关##属性和属性节点 什么是属性? 属性就是对象身上的变量 只要对象身上都可以添加属性(无论是自定义对象,还是DOM对象) 123456789&lt;script&gt; // 1.自定义一个对象 var obj = &#123;&#125;; console.log(obj); // 2.动态给自定义对象添加属性 obj.name = \"lnj\"; // name就是对象obj的一个属性 obj.age = 33; // age就是对象obj的一个属性 console.log(obj);&lt;/script&gt; image.png 什么是属性节点? 在html中编写的所有标签，里面的属性都是属性节点 &lt;span class = &#39;box&#39; nj = &#39;666&#39;&gt;&lt;/span&gt; // 这里的class和nj就是属性节点 image.png 如果操作属性? 添加或修改属性(没有就会添加,有就会修改) 对象.属性名称 = 值; 对象[&quot;属性名称&quot;] = 值; 获取属性 对象.属性名称 对象[&quot;属性名称&quot;] 如何操作属性节点? 获取属性节点 DOM对象.getAttribute(&quot;属性节点名称&quot;) 设置属性节点 DOM对象.setAttribute(&quot;属性节点名称&quot;, &quot;值&quot;); jQuery中的attr和prop方法 attr(name|pro|key,val|fn)方法 用于设置或获取属性节点的值 12345678910111213141516&lt;script&gt; $(function () &#123; // 1.获取指定属性节点值 var $res = $(\".span1\").attr(\"nj\"); console.log($res); // 2.设置属性节点 $(\".span1\").attr(\"nj\", \"666\"); $(\".span2\").attr(\"id\", \"box1 box2\"); // 3.注意点: // 3.1.获取属性节点时,只会获取找到所有元素中第一个元素的属性节点 $res = $(\"span\").attr(\"class\"); console.log($res); $(\"span\").attr(\"class\", \"lnj\"); &#125;);&lt;/script&gt; removeAttr(name)方法 用于删除指定属性节点 12345678&lt;script&gt; $(function () &#123; // 1.设置属性节点时,会给所有找到元素设置属性节点 $(\"span\").attr(\"test\", \"jonathan\"); // 2.删除属性节点时,会删除所有找到元素的属性节点 $(\"span\").removeAttr(\"test\"); &#125;);&lt;/script&gt; prop(n|p|k,v|f)方法 用于设置或者获取元素的属性值 12345678910&lt;script&gt; $(function () &#123; // 1.设置属性 // 1.1.设置属性时,会设置所有找到元素的属性 $(\"span\").prop(\"demo\", \"lnj\"); // 2.获取属性 // 2.1.获取属性时,只会获取找到第一个元素的属性 console.log($(\"span\").prop(\"demo\")); &#125;);&lt;/script&gt; removeProp(name)方法 123456&lt;script&gt; $(function () &#123; // 删除所有找到元素的demo属性 $(\"span\").removeProp(\"demo\"); &#125;);&lt;/script&gt; attr方法和prop方法区别 既然所有的DOM对象，都有一个attributes属性,而prop可以操作属性,所以也可以操作属性节点 官方推荐在操作属性节点时,具有 true 和 false 两个属性的属性节点，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr() 因为如果具有 true 和 false 两个属性的属性节点,如果没有编写默认attr返回undefined,而prop返回false 12345678910111213141516171819&lt;script&gt; $(function () &#123; // 1.可以通过prop获取属性节点 console.log($(\"input\").prop(\"class\")); // 2.可以通过prop设置属性节点 $(\"input\").prop(\"class\", \"tag\"); // 3.如果没有默认值,那么attr获取返回undefined// console.log($(\"input[type=checkbox]\").attr(\"checked\")); // 4.如果没有默认值,那么prop获取返回false console.log($(\"input[type=checkbox]\").prop(\"checked\")); // 5.通过attr设置选中// $(\"input[type=checkbox]\").attr(\"checked\", true); // 6.通过prop设置选中 $(\"input[type=checkbox]\").prop(\"checked\", true) &#125;);&lt;/script&gt; jQuery增删Class jQuery CSS类相关方法都是用于操作DOM对象的class属性节点的值 addClass(class|fn) 给元素添加一个或多个类 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;08-jQueryCSS类&lt;/title&gt; &lt;style&gt; .class1&#123; width: 200px; height: 200px; background-color: red; &#125; .class2&#123; border: 5px solid #000; &#125; &lt;/style&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.添加一个类// $(\"div\").addClass(\"class1\"); // 2.再添加一个类// $(\"div\").addClass(\"class2\"); // 3.一次性添加多个类(用空格隔开) $(\"div\").addClass(\"class1 class2\"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加&lt;/button&gt;&lt;button&gt;删除&lt;/button&gt;&lt;button&gt;切换&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; removeClass([class|fn]) 删除元素的一个或多个类 12345678910111213&lt;script&gt; $(function () &#123; $(\"button\").eq(1).click(function () &#123; // 4.删除一个类// $(\"div\").removeClass(\"class2\"); // 5.再删除一个类// $(\"div\").removeClass(\"class1\"); // 6.一次性删除多个类(用空格隔开) $(\"div\").removeClass(\"class1 class2\"); &#125;); &#125;);&lt;/script&gt; toggleClass(class|fn[,sw]) 添加或删除一个类(存在就删除不存在就添加) 12345678910&lt;script&gt; $(function () &#123; $(\"button\").eq(2).click(function () &#123; // 7.切换一个类// $(\"div\").toggleClass(\"class2\"); // 8.切换多个类 $(\"div\").toggleClass(\"class1 class2\"); &#125;); &#125;); &lt;/script&gt; jQuery代码/文本/值 html([val|fn]) 添加或获取元素中的HTML 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;09-jQuery代码文本值&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var $btns = $(\"button\"); var $div = $(\"div\"); $btns.eq(0).click(function () &#123; // 1.添加html, 相当于innerHTML// $div.html(\"&lt;p&gt;我是p标签&lt;/p&gt;\");// $div.html(\"&lt;p&gt;&lt;span&gt;我是span标签&lt;/span&gt;&lt;/p&gt;\"); $div.html(\"我是文本\"); &#125;); $btns.eq(1).click(function () &#123; // 2.获取html console.log($div.html()); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加html&lt;/button&gt;&lt;button&gt;获取html&lt;/button&gt;&lt;button&gt;添加文本&lt;/button&gt;&lt;button&gt;获取文本&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text([val|fn]) 添加或获取元素中的文本 text方法能做的html方法都能做,所以一般使用html方法即可 12345678910111213&lt;script&gt; $(function () &#123; $btns.eq(2).click(function () &#123; // 3.添加文本, 相当于innerText // 如下内容不会被转换为标签// $div.text('&lt;p&gt;我是段落&lt;/p&gt;'); $div.text('我是文本'); &#125;); $btns.eq(3).click(function () &#123; // 4.获取文本 console.log($div.text()); &#125;);&lt;/script&gt; val([val|fn|arr]) 添加或获取元素value属性的值 123456789101112&lt;script&gt; $(function () &#123; $btns.eq(4).click(function () &#123; // 4.添加value值 $(\"input\").val(\"我是一个输入框\"); &#125;); $btns.eq(5).click(function () &#123; // 4.获取value值 console.log($(\"input\").val()); &#125;); &#125;);&lt;/script&gt; CSS操作jQuery操作CSS样式 css(name|pro|[,val|fn])方法 用于设置或获取元素CSS样式 格式1:DOM元素.css(&quot;样式名称&quot;, &quot;值&quot;); 格式2:DOM元素.css({&quot;样式名称1&quot;:&quot;值1&quot;,&quot;样式名称2&quot;:&quot;值2&quot;}); 1234567891011121314151617181920212223 &lt;script&gt; $(function () &#123; $(\"button\").click(function () &#123; // 1.单个样式设置// $(\"div\").css(\"width\", \"100px\");// $(\"div\").css(\"height\", \"100px\");// $(\"div\").css(\"background\", \"red\"); // 2.链式设置样式// $(\"div\").css(\"width\", \"100px\").css(\"height\", \"100px\").css(\"background\", \"red\"); // 3.传入对象一次性设置样式 $(\"div\").css(&#123; \"width\":\"100px\", \"height\":\"100px\", \"background\":\"blue\" &#125;); // 4.获取指定样式的值 console.log($(\"div\").css(\"width\")); &#125;); &#125;); &lt;/script&gt; jQuery操作元素尺寸 width([val|fn])方法 设置或获取元素宽度(相当于获取width属性值) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;11-jQuery操作位置和尺寸&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .father&#123; width: 250px; height: 250px; background-color: red; margin-left: 50px; position: relative; &#125; .son&#123; width: 100px; height: 100px; background-color: blue; position: absolute; left: 50px; top: 50px; &#125; &lt;/style&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.获取元素宽度(不包括padding和border)// alert($('.son').width()); &#125;); $(\"button\").eq(1).click(function () &#123; // 2.设置元素宽度(不包括padding和border)// $(\".son\").width(\"50px\"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;button&gt;获取&lt;/button&gt;&lt;button&gt;设置&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; height([val|fn])方法 设置或获取元素宽度(相当于获取height属性值) 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) innerHeight()/innerWidth() 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) outerHeight/outerWidth() 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) jQuery操作元素位置 offset([coordinates]) 获取或设置元素相对窗口的偏移位 123456789101112&lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.获取距离窗口的偏移位(从border开始) alert($('.son').offset().left); // 100 &#125;); $(\"button\").eq(1).click(function () &#123; // 2.设置距离窗口的偏移位 $('.son').offset(&#123;left:10, top:10&#125;); &#125;); &#125;);&lt;/script&gt; position() 获取相对于它最近的具有相对位置(position:relative或position:absolute)的父级元素的距离 123456789101112&lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.获取匹配元素相对父元素的偏移 alert($('.son').position().left);// 50 &#125;); $(\"button\").eq(1).click(function () &#123; // 2.无效,不能设置相对定位元素的偏移位 $('.son').position(&#123;left:10, top:10&#125;) &#125;); &#125;);&lt;/script&gt; scrollTop([val]) 设置或获取匹配元素相对滚动条顶部的偏移。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;12-jQuery操作位置&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .scroll&#123; margin-top: 100px; margin-left: 100px; width: 100px; height: 200px; border: 1px solid #000; overflow: auto; &#125; &lt;/style&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 7.获取匹配元素相对滚动条顶部的偏移// alert($('.scroll').scrollTop());// alert($('html').scrollTop()); // 兼容所有浏览器写法 alert($('html').scrollTop()+$('body').scrollTop()); &#125;); $(\"button\").eq(1).click(function () &#123; // 8.设置匹配元素相对滚动条顶部的偏移// $('.scroll').scrollTop(100);// $('html').scrollTop(100); // 兼容所有浏览器写法 $('html,body').scrollTop(100); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"scroll\"&gt; 我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字&lt;/div&gt;&lt;button&gt;获取&lt;/button&gt;&lt;button&gt;设置&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; scrollLeft([val]) 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) AJAX1jQuery.ajax([settings]) 参数 描述 settings 可选。用于配置 Ajax 请求的键值对集合。可以通过 $.ajaxSetup() 设置任何选项的默认值。 参数 options 类型：Object可选。AJAX 请求设置。所有选项都是可选的。 async 类型：Boolean默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 beforeSend(XHR) 类型：Function发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。XMLHttpRequest 对象是唯一的参数。这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。 cache 类型：Boolean默认值: true，dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。jQuery 1.2 新功能。 complete(XHR, TS) 类型：Function请求完成后回调函数 (请求成功或失败之后均调用)。参数： XMLHttpRequest 对象和一个描述请求类型的字符串。这是一个 Ajax 事件。 contentType 类型：String默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。默认值适合大多数情况。如果你明确地传递了一个 content-type 给 $.ajax() 那么它必定会发送给服务器（即使没有数据要发送）。 context 类型：Object这个对象用于设置 Ajax 相关回调函数的上下文。也就是说，让回调函数内 this 指向这个对象（如果不设定这个参数，那么 this 就指向调用本次 AJAX 请求时传递的 options 参数）。比如指定一个 DOM 元素作为 context 参数，这样就设置了 success 回调函数的上下文为这个 DOM 元素。就像这样：$.ajax({ url: &quot;test.html&quot;, context: document.body, success: function(){ $(this).addClass(&quot;done&quot;); }}); data 类型：String发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 dataFilter 类型：Function给 Ajax 返回的原始数据的进行预处理的函数。提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。函数返回的值将由 jQuery 进一步处理。 dataType 类型：String预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。在 1.4 中，JSON 就会生成一个 JavaScript 对象，而 script 则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值:”xml”: 返回 XML 文档，可用 jQuery 处理。”html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。”script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）”json”: 返回 JSON 数据 。”jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。”text”: 返回纯文本字符串 error 类型：Function默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。这是一个 Ajax 事件。 global 类型：Boolean是否触发全局 AJAX 事件。默认值: true。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的 Ajax 事件。 ifModified 类型：Boolean仅在服务器数据改变时获取新数据。默认值: false。使用 HTTP 包 Last-Modified 头信息判断。在 jQuery 1.4 中，它也会检查服务器指定的 ‘etag’ 来确定数据没有被修改过。 jsonp 类型：String在一个 jsonp 请求中重写回调函数的名字。这个值用来替代在 “callback=?” 这种 GET 或 POST 请求中 URL 参数里的 “callback” 部分，比如 {jsonp:’onJsonPLoad’} 会导致将 “onJsonPLoad=?” 传给服务器。 jsonpCallback 类型：String为 jsonp 请求指定一个回调函数名。这个值将用来取代 jQuery 自动生成的随机函数名。这主要用来让 jQuery 生成度独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存 GET 请求的时候，指定这个回调函数名。 password 类型：String用于响应 HTTP 访问认证请求的密码 processData 类型：Boolean默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。 scriptCharset 类型：String只有当请求时 dataType 为 “jsonp” 或 “script”，并且 type 是 “GET” 才会用于强制修改 charset。通常只在本地和远程的内容编码不同时使用。 success 类型：Function请求成功后的回调函数。参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。这是一个 Ajax 事件。 traditional 类型：Boolean如果你想要用传统的方式来序列化数据，那么就设置为 true。请参考工具分类下面的 jQuery.param 方法。 timeout 类型：Number设置请求超时时间（毫秒）。此设置将覆盖全局设置。 type 类型：String默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 url 类型：String默认值: 当前页地址。发送请求的地址。 username 类型：String用于响应 HTTP 访问认证请求的用户名。 xhr 类型：Function需要返回一个 XMLHttpRequest 对象。默认在 IE 下是 ActiveXObject 而其他情况下是 XMLHttpRequest 。用于重写或者提供一个增强的 XMLHttpRequest 对象。这个参数在 jQuery 1.3 以前不可用。 回调函数如果要处理 $.ajax() 得到的数据，则需要使用回调函数：beforeSend、error、dataFilter、success、complete。 beforeSend在发送请求之前调用，并且传入一个 XMLHttpRequest 作为参数。 error在请求出错时调用。传入 XMLHttpRequest 对象，描述错误类型的字符串以及一个异常对象（如果有的话） dataFilter在请求成功之后调用。传入返回的数据以及 “dataType” 参数的值。并且必须返回新的数据（可能是处理过的）传递给 success 回调函数。 success当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。 complete当请求完成之后调用这个函数，无论成功或失败。传入 XMLHttpRequest 对象，以及一个包含成功或错误代码的字符串。 otherjquery中val()和value区分1.jQuery中的val()方法用来获取或设定输入框或选择框的值。 获取值：$(“##text”).val() 设置值：$(“##text”).val(“value”) 也可以来获取或设置select标签的值 select1 select2 获取值：$(“##select”).val() 设置值：$(“##select”).val(“select1”) 2.jQuery中没有value方法，可以通过attr方法获取或设置标签中的value属性的值","categories":[{"name":"js","slug":"js","permalink":"https://codeofli.github.io/categories/js/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://codeofli.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://codeofli.github.io/tags/js/"}]},{"title":"springBoot高级","slug":"java-note/SpringBootHigh/springBoot-high","date":"2019-10-09T07:43:44.000Z","updated":"2021-10-23T02:19:02.860Z","comments":true,"path":"2019/10/java-note/SpringBootHigh/springBoot-high/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/SpringBootHigh/springBoot-high/","excerpt":"spring boot高级[TOC]一.Spring Boot与缓存1、JSR107Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。•CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。","text":"spring boot高级[TOC]一.Spring Boot与缓存1、JSR107Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。•CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。 •CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。 •Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。 •Entry是一个存储在Cache中的key-value对。 •Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。 Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（**Cache**）组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @**CacheEvict** 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存。 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 一、搭建基本环境 1、导入数据库文件 创建出department和employee表 2、创建javaBean封装数据 3、整合MyBatis操作数据库 1.配置数据源信息 2.使用注解版的MyBatis； 1）、@MapperScan指定需要扫描的mapper接口所在的包 2、快速体验缓存==注意：cache注解（CachePut、Cacheable、@CachePut）的key保持一致，这样才能在cachemap中拿到同一个数据== @CacheConfig注解抽取缓存的公共配置 123@CacheConfig(cacheNames=\"emp\",cacheManager = \"employeeCacheManager\") //抽取缓存的公共配置@Servicepublic class EmployeeService &#123; 步骤： ==1、开启基于注解的缓存 @EnableCaching== 123456789@EnableCaching@MapperScan(value = \"com.yoj.web.dao\")@SpringBootApplicationpublic class YojApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(YojApplication.class, args); &#125;&#125; 2、标注缓存注解即可 @Cacheable @CacheEvict @CachePut 123456/* * 默认使用的是ConcurrentMapCacheManager==ConcurrentMapCache；将数据保存在 ConcurrentMap&lt;Object, Object&gt;中 * 开发中使用缓存中间件；redis、memcached、ehcache； * * */ service层使用cache注解 缓存中能使用的spel表达式 Cache* SpEL available metadata 名字 位置 描述 示例 methodName root object 当前被调用的方法名 #root.methodName method root object 当前被调用的方法 #root.method.name target root object 当前被调用的目标对象 #root.target targetClass root object 当前被调用的目标对象类 #root.targetClass args root object 当前被调用的方法的参数列表 #root.args[0] caches root object 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache #root.caches[0].name argument name evaluation context 方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的形式，0代表参数的索引； #iban 、 #a0 、 #p0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache put’的表达式 ’cache evict’的表达式beforeInvocation=false） #result @Cacheable注解原理： 1、自动配置类；CacheAutoConfiguration 2、缓存的配置类(11) 1234567891011org.springframework.boot.autoconfigure.cache.GenericCacheConfigurationorg.springframework.boot.autoconfigure.cache.JCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.EhCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.HazelcastCacheConfigurationorg.springframework.boot.autoconfigure.cache.InfinispanCacheConfigurationorg.springframework.boot.autoconfigure.cache.CouchbaseCacheConfigurationorg.springframework.boot.autoconfigure.cache.RedisCacheConfigurationorg.springframework.boot.autoconfigure.cache.CaffeineCacheConfigurationorg.springframework.boot.autoconfigure.cache.GuavaCacheConfigurationorg.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration 3、哪个配置类默认生效：SimpleCacheConfiguration； 4、给容器中注册了一个CacheManager：ConcurrentMapCacheManager 5、可以获取和创建ConcurrentMapCache类型的缓存组件；他的作用将数据保存在ConcurrentMap中； 运行流程：(ConcurrentMapCacheManager.class) @Cacheable： 1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取； （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。 123456789101112131415@Override@Nullablepublic Cache getCache(String name) &#123; Cache cache = this.cacheMap.get(name); if (cache == null &amp;&amp; this.dynamic) &#123; synchronized (this.cacheMap) &#123; cache = this.cacheMap.get(name); if (cache == null) &#123; cache = createConcurrentMapCache(name); this.cacheMap.put(name, cache); &#125; &#125; &#125; return cache;&#125; 2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数； 123protected Object lookup(Object key) &#123; return this.store.get(key);&#125; key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key； 12345678public abstract class CacheAspectSupport extends AbstractCacheInvokerprotected Object generateKey(@Nullable Object result) &#123; if (StringUtils.hasText(this.metadata.operation.getKey())) &#123; EvaluationContext evaluationContext = createEvaluationContext(result); return evaluator.key(this.metadata.operation.getKey(), this.metadata.methodKey, evaluationContext); &#125; return this.metadata.keyGenerator.generate(this.target, this.metadata.method, this.args);&#125; SimpleKeyGenerator生成key的默认策略； 如果没有参数；key=new SimpleKey()； 如果有一个参数：key=参数的值 如果有多个参数：key=new SimpleKey(params)； 12345678910111213141516public class SimpleKeyGenerator implements KeyGenerator &#123; /*** Generate a key based on the specified parameters.*/public static Object generateKey(Object... params) &#123; if (params.length == 0) &#123; return SimpleKey.EMPTY; &#125; if (params.length == 1) &#123; Object param = params[0]; if (param != null &amp;&amp; !param.getClass().isArray()) &#123; return param; &#125; &#125; return new SimpleKey(params);&#125; 3、没有查到缓存就调用目标方法； 4、将目标方法返回的结果，放进缓存中 123public void put(Object key, @Nullable Object value) &#123; this.store.put(key, toStoreValue(value));&#125; @Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存， 如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据； ==核心：== 1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件 2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator 几个属性： cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存； key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值 编写SpEL； #i d;参数id的值 #a0 #p0 #root.args[0] getEmp[2] ： **key = &quot;#root.methodName+&apos;[&apos;+#id+&apos;]&apos;&quot;**1@Cacheable(cacheNames = &#123;\"emp\"&#125;,key = \"#root.methodName+'['+#id+']'\") keyGenerator：key的生成器；可以自己指定key的生成器的组件id key/keyGenerator：二选一使用;123456789101112131415@Configurationpublic class MyCacheConfig &#123; @Bean(\"myKeyGenerator\") public KeyGenerator keyGenerator()&#123; return new KeyGenerator()&#123; @Override public Object generate(Object target, Method method, Object... params) &#123; return method.getName()+\"[\"+ Arrays.asList(params).toString()+\"]\"; &#125; &#125;; &#125;&#125;//调用 @Cacheable(cacheNames = &#123;\"emp\"&#125;,keyGenerator = \"myKeyGenerator\") cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 condition：指定符合条件的情况下才缓存； ,condition = &quot;#id&gt;0&quot; condition = &quot;#a0&gt;1&quot;：第一个参数的值 &gt;1的时候才进行缓存 unless==:否定缓存==；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断 unless = &quot;#result == null&quot; unless = &quot;#a0==2&quot;:如果第一个参数的值是2，结果不缓存； sync：是否使用异步模式,启用sync就不能使用unless属性了 1234567891011121314151617181920212223242526272829303132333435363738@CacheConfig(cacheNames=\"emp\"/*,cacheManager = \"employeeCacheManager\"*/) //抽取缓存的公共配置@Servicepublic class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; /** * 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法； * CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字； * * @param id * @return * */ @Cacheable(value = &#123;\"emp\"&#125;/*,keyGenerator = \"myKeyGenerator\",condition = \"#a0&gt;1\",unless = \"#a0==2\"*/) public Employee getEmp(Integer id)&#123; System.out.println(\"查询\"+id+\"号员工\"); Employee emp = employeeMapper.getEmpById(id); return emp; &#125; // @Caching 定义复杂的缓存规则 @Caching( cacheable = &#123; @Cacheable(/*value=\"emp\",*/key = \"#lastName\") &#125;, put = &#123; @CachePut(/*value=\"emp\",*/key = \"#result.id\"), @CachePut(/*value=\"emp\",*/key = \"#result.email\") &#125; ) public Employee getEmpByLastName(String lastName)&#123; return employeeMapper.getEmpByLastName(lastName); &#125;&#125; @CachePut注解@CachePut：既调用方法，又更新缓存数据；同步更新缓存 修改了数据库的某个数据，同时更新缓存； 运行时机：1、先调用目标方法2、将目标方法的结果缓存起来 12345678910111213141516171819202122/** * 测试步骤： * 1、查询1号员工；查到的结果会放在缓存中； * key：1 value：lastName：张三 * 2、以后查询还是之前的结果 * 3、更新1号员工；【lastName:zhangsan；gender:0】 * 将方法的返回值也放进缓存了； * key：传入的employee对象 值：返回的employee对象； * 4、查询1号员工？ * 应该是更新后的员工； * key = \"#employee.id\":使用传入的参数的员工id； * key = \"#result.id\"：使用返回后的id * @Cacheable的key是不能用#result * 为什么是没更新前的？【1号员工没有在缓存中更新】 * */@CachePut(/*value = \"emp\",*/key = \"#result.id\")public Employee updateEmp(Employee employee)&#123; System.out.println(\"updateEmp:\"+employee); employeeMapper.updateEmp(employee); return employee;&#125; @CacheEvict注解evict：驱逐，逐出 @CacheEvict：缓存清除 key：指定要清除的数据 -allEntries = true：指定清除这个缓存中所有的数据 beforeInvocation = false：缓存的清除是否在方法之前执行默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除 beforeInvocation = true：代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除 123456@CacheEvict(value=\"emp\",beforeInvocation = true/*key = \"#id\",*/)public void deleteEmp(Integer id)&#123; System.out.println(\"deleteEmp:\"+id); //employeeMapper.deleteEmpById(id); int i = 10/0;&#125; @Caching注解定义复杂的缓存规则 12345678910111213// @Caching 定义复杂的缓存规则 @Caching( cacheable = &#123; @Cacheable(/*value=\"emp\",*/key = \"#lastName\") &#125;, put = &#123; @CachePut(/*value=\"emp\",*/key = \"#result.id\"), @CachePut(/*value=\"emp\",*/key = \"#result.email\") &#125; ) public Employee getEmpByLastName(String lastName)&#123; return employeeMapper.getEmpByLastName(lastName); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package com.atguigu.springboot01cache.service;import com.atguigu.springboot01cache.bean.Employee;import com.atguigu.springboot01cache.mapper.EmployeeMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.*;import org.springframework.stereotype.Service;@CacheConfig(cacheNames = \"emp\"/*,cacheManager = \"employeeCacheManager\"*/) //抽取缓存的公共配置@Servicepublic class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; /** * 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法； * CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字； * &lt;p&gt; * &lt;p&gt; * &lt;p&gt; * 原理： * 1、自动配置类；CacheAutoConfiguration * 2、缓存的配置类 * org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration * org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration * org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration * org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration * org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration * org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration * org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration * org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration * org.springframework.boot.autoconfigure.cache.GuavaCacheConfiguration * org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】 * org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration * 3、哪个配置类默认生效：SimpleCacheConfiguration； * &lt;p&gt; * 4、给容器中注册了一个CacheManager：ConcurrentMapCacheManager * 5、可以获取和创建ConcurrentMapCache类型的缓存组件；他的作用将数据保存在ConcurrentMap中； * &lt;p&gt; * 运行流程： * * @param id * @return * @Cacheable： 1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取； * （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。 * 2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数； * key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key； * SimpleKeyGenerator生成key的默认策略； * 如果没有参数；key=new SimpleKey()； * 如果有一个参数：key=参数的值 * 如果有多个参数：key=new SimpleKey(params)； * 3、没有查到缓存就调用目标方法； * 4、将目标方法返回的结果，放进缓存中 * @Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存， 如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据； * &lt;p&gt; * 核心： * 1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件 * 2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator * &lt;p&gt; * &lt;p&gt; * 几个属性： * cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存； * &lt;p&gt; * key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值 * 编写SpEL； #i d;参数id的值 #a0 #p0 #root.args[0] * getEmp[2] * &lt;p&gt; * keyGenerator：key的生成器；可以自己指定key的生成器的组件id * key/keyGenerator：二选一使用; * &lt;p&gt; * &lt;p&gt; * cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 * &lt;p&gt; * condition：指定符合条件的情况下才缓存； * ,condition = \"#id&gt;0\" * condition = \"#a0&gt;1\"：第一个参数的值》1的时候才进行缓存 * &lt;p&gt; * sync：是否使用异步模式 */ @Cacheable(value = &#123;\"emp\"&#125;/*,keyGenerator = \"myKeyGenerator\",condition = \"#a0&gt;1\",unless = \"#a0==2\"*/) public Employee getEmp(Integer id) &#123; System.out.println(\"查询\" + id + \"号员工\"); Employee emp = employeeMapper.getEmpById(id); return emp; &#125; /** * @CachePut：既调用方法，又更新缓存数据；同步更新缓存 修改了数据库的某个数据，同时更新缓存； * 运行时机： * 1、先调用目标方法 * 2、将目标方法的结果缓存起来 * &lt;p&gt; * 测试步骤： * 1、查询1号员工；查到的结果会放在缓存中； * key：1 value：lastName：张三 * 2、以后查询还是之前的结果 * 3、更新1号员工；【lastName:zhangsan；gender:0】 * 将方法的返回值也放进缓存了； * key：传入的employee对象 值：返回的employee对象； * 4、查询1号员工？ * 应该是更新后的员工； * key = \"#employee.id\":使用传入的参数的员工id； * key = \"#result.id\"：使用返回后的id * @Cacheable的key是不能用#result 为什么是没更新前的？【1号员工没有在缓存中更新】 */ @CachePut(value = \"emp\", key = \"#result.id\") public Employee updateEmp(Employee employee) &#123; System.out.println(\"updateEmp:\" + employee); employeeMapper.updateEmp(employee); return employee; &#125; /** * @CacheEvict：缓存清除 key：指定要清除的数据 * allEntries = true：指定清除这个缓存中所有的数据 * beforeInvocation = false：缓存的清除是否在方法之前执行 * 默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除 * &lt;p&gt; * beforeInvocation = true： * 代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除 */ @CacheEvict(value = \"emp\", beforeInvocation = true/*key = \"#id\",*/) public void deleteEmp(Integer id) &#123; System.out.println(\"deleteEmp:\" + id); //employeeMapper.deleteEmpById(id); int i = 10 / 0; &#125; // @Caching 定义复杂的缓存规则 @Caching( cacheable = &#123; @Cacheable(/*value=\"emp\",*/key = \"#lastName\") &#125;, put = &#123; @CachePut(/*value=\"emp\",*/key = \"#result.id\"), @CachePut(/*value=\"emp\",*/key = \"#result.email\") &#125; ) public Employee getEmpByLastName(String lastName) &#123; return employeeMapper.getEmpByLastName(lastName); &#125;&#125; 3.整合redis作为缓存 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 原理：CacheManager===Cache 缓存组件来实际给缓存中存取数据 1）、引入redis的starter，容器中保存的是 RedisCacheManager； 2）、RedisCacheManager 帮我们创建 RedisCache 来作为缓存组件；RedisCache通过操作redis缓存数据的 3）、默认保存数据 kv 都是Object；利用序列化保存；如何保存为json 1、引入了redis的starter，cacheManager变为 RedisCacheManager； 2、默认创建的 RedisCacheManager 操作redis的时候使用的是 RedisTemplate&lt;Object, Object&gt; 3、RedisTemplate&lt;Object, Object&gt; 是 默认使用jdk的序列化机制 4）、自定义CacheManager； 1、安装redis：使用docker；启动redis，默认端口6379 123456[root@MiWiFi-R3A-srv ~]# docker run -d -p 6379:6379 --name myredis redisba86c7f5d285b74828df3ec4f0179cfcd3682dc58f2cfabe354a63336d94919e#开启持久化docker run -d -p 6379:6379 --name persistent-redis redis --appendonly yesdocker run --name=\"redis-2\" -d -p 6378:6379 -v /home/fr/redis:/opt royfans/redis:v1 /usr/local/redis/bin/redis-server /usr/local/redis/redis.conf --appendonly yes ==注意==：如果不开启持久化，会导致一段时间不用缓存之后，连接不上redis start with persistent storage 123docker run -v /myredis/conf/redis.conf:/home/ubuntu/redis/redis.conf -d -p 6379:6379 --name config-redis redis --appendonly yes$ docker run --name some-redis -d redis redis-server --appendonly yes 1$ docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name myredis redis redis-server /usr/local/etc/redis/redis.conf Where /myredis/conf/ is a local directory containing your redis.conf file. Using this method means that there is no need for you to have a Dockerfile for your redis container. 123456这个问题我们在项目中遇到同样的问题，目前已经解决了。最终得到的答案是： 服务器不稳定造成的。您可以尝试这样解决：1.推荐使用生产环境的服务器，并且将redis 绑定生产环境的ip;因为云服务器的ip 地址是很稳定的，而本地服务的ip地址经常是变动的；经 过测试，这种每过10分就会重新请求连接，还会发生重试失败的情况，就是因为服务器不稳定造成的；2.如果你在生产环境中，使用docker 部署，建议 不要在docker容器中 安装redis; 因为docker 容器 默认分配的ip 地址，也可能是变化的； 您可以直接将redis 安装在 服务器目录下，即可； redis desktop manager连接 ![1565350310934](redis desktop manager连接.png) 2、引入redis的starter1.引入spring-boot-starter-data-redis 12345&lt;!--引入redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 3、配置redis12#指定主机端口号spring.redis.host=192.168.31.39 4、测试缓存3.使用RestTemplate操作redis 1.redisTemplate.opsForValue();//操作字符串 2.redisTemplate.opsForHash();//操作hash 3.redisTemplate.opsForList();//操作list 4.redisTemplate.opsForSet();//操作set 5.redisTemplate.opsForZSet();//操作有序set 4.配置缓存、CacheManagerCustomizers 5.测试使用缓存、切换缓存、 CompositeCacheManager ==stringRedisTemplate== //操作k-v都是字符串的 1234567891011121314151617181920212223@AutowiredStringRedisTemplate stringRedisTemplate; //操作k-v都是字符串的/** * Redis常见的五大数据类型 * String（字符串）、List（列表）、Set（集合）、Hash（散列）、ZSet（有序集合） * stringRedisTemplate.opsForValue()[String（字符串）] * stringRedisTemplate.opsForList()[List（列表）] * stringRedisTemplate.opsForSet()[Set（集合）] * stringRedisTemplate.opsForHash()[Hash（散列）] * stringRedisTemplate.opsForZSet()[ZSet（有序集合）] */@Testpublic void test01()&#123; //给redis中保存数据 //stringRedisTemplate.opsForValue().append(\"msg\",\"hello\"); //获取数据 // String msg = stringRedisTemplate.opsForValue().get(\"msg\"); // System.out.println(msg); //保存list集合数据 stringRedisTemplate.opsForList().leftPush(\"mylist\",\"1\"); stringRedisTemplate.opsForList().leftPush(\"mylist\",\"2\");&#125; ==redisTemplate== k-v都是对象 12345678910111213141516 @Autowired RedisTemplate redisTemplate; //k-v都是对象的 @Autowired RedisTemplate&lt;Object,Object&gt; empRedisTemplate; //自定义缓存规则配置的redisTemplate//测试保存对象 @Test public void test02()&#123; Employee empById = employeeMapper.getEmpById(1); //默认如果保存对象，使用jdk序列化机制，序列化后的数据保存到redis中 //redisTemplate.opsForValue().set(\"emp-01\",empById); //1、将数据以json的方式保存 //(1)自己将对象转为json //(2)redisTemplate默认的序列化规则；改变默认的序列化规则； empRedisTemplate.opsForValue().set(\"emp-01\",empById); &#125; 5.使用Json格式序列化对象1.使用setKey和value的Serializer方法 123redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class)); redisTemplate.setKeySerializer(new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class)); redisTemplate.opsForValue().set(\"emp-02\",empById); 123456789101112@Configurationpublic class MyRedisConfig &#123; @Bean public RedisTemplate&lt;Object, Object&gt; empRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; serializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(serializer); return template; &#125; 2.0配置redis的CacheManager1234spring: cache: redis: timeToLive: 1000000 #毫秒 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.springboot01cache.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.CacheManager;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializationContext;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.time.Duration;@Configurationpublic class MyRedisConfig &#123;// @Bean// public RedisTemplate&lt;Object, Object&gt; empRedisTemplate(RedisConnectionFactory redisConnectionFactory)// throws UnknownHostException &#123;// RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();// template.setConnectionFactory(redisConnectionFactory);// Jackson2JsonRedisSerializer&lt;Employee&gt; serializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);// template.setDefaultSerializer(serializer);// return template;// &#125; private Duration timeToLive = Duration.ZERO; public void setTimeToLive(Duration timeToLive) &#123; this.timeToLive = timeToLive; &#125; @Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题） RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(timeToLive) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; &#125;&#125; 4.注意1.@CachePut 获取就是返回的值所有想要存入缓存的都是返回的值 my_redis设置缓存时间1stringRedisTemplate.opsForValue().set(email, checkCode,60*10,TimeUnit.SECONDS);//向redis里存入数据和设置缓存时间 删除缓存byKey1stringRedisTemplate.delete(user.getEmail()); 检查时间1stringRedisTemplate.hasKey(\"546545\");//检查key是否存在，返回boolean值 问题redis一段时间之后不连接就连不上==内存原因，设置maxmemory和替换算法== 在Linux上，如果开了redis的守护进程，kill -9和redis-cli shutdown 命令是无法杀掉 redis 进程的 ，杀掉就会重新启动一个新的进程 最后在网上找到这个命令： 1/etc/init.d/redis-server stop 二.Spring Boot与消息JMS、AMQP、RabbitMQ 一、概述1.大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力 2.消息服务中两个重要概念： ​ 消息代理（message broker）和目的地（destination） 当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地。 3.消息队列主要有两种形式的目的地 1.队列（queue）：点对点消息通信（point-to-point） 2.主题（topic）：发布（publish）/订阅（subscribe）消息通信 4.点对点式： –消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列 –消息只有唯一的发送者和接受者，但并不是说只能有一个接收者 5.发布订阅式： –发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息 6.JMS（Java Message Service）JAVA消息服务： –基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现 7.AMQP（Advanced Message Queuing Protocol） –高级消息队列协议，也是一个消息代理的规范，兼容JMS –RabbitMQ是AMQP的实现 JMS AMQP 定义 Java api 网络线级协议 跨语言 否 是 跨平台 否 是 Model 提供两种消息模型： （1）、Peer-2-Peer （2）、Pub/sub 提供了五种消息模型： （1）、direct exchange （2）、fanout exchange （3）、topic change （4）、headers exchange （5）、system exchange 本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分； 支持消息类型 多种消息类型： TextMessage MapMessage BytesMessage StreamMessage ObjectMessage Message （只有消息头和属性） byte[] 当实际应用时，有复杂的消息，可以将消息序列化后发送。 综合评价 JMS 定义了JAVA API层面的标准；在java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差； AMQP定义了wire-level层的协议标准；天然具有跨平台、跨语言特性。 8.Spring支持 –spring-jms提供了对JMS的支持 –spring-rabbit提供了对AMQP的支持 –需要ConnectionFactory的实现来连接消息代理 –提供JmsTemplate、RabbitTemplate来发送消息 –@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息 –@EnableJms、@EnableRabbit开启支持 9.Spring Boot自动配置 –JmsAutoConfiguration –RabbitAutoConfiguration 二、RabbitMQ简介RabbitMQ简介： RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。 核心概念 Message 消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 Publisher 消息的生产者，也是一个向交换器发布消息的客户端应用程序。 Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别 三、Spring Boot与检索 四.Spring Boot与任务异步任务、定时任务、邮件任务一、异步任务在Java应用中，绝大多数情况下都是通过同步的方式来实现交互处理的；但是在处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用多线程来完成此类任务，其实，在Spring 3.x之后，就已经内置了@Async来完美解决这个问题。 两个注解： @EnableAysnc、@Aysnc springbootApplication添加@EnableAysnc注解 12345678@EnableAsync //开启异步注解功能@SpringBootApplicationpublic class Springboot04TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04TaskApplication.class, args); &#125;&#125; 编写异步方法，同时执行，并不会等3s才有success 1234567891011121314@Servicepublic class AsyncService &#123; //告诉Spring这是一个异步方法 @Async public void hello()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"处理数据中...\"); &#125;&#125; 二、定时任务@EnableScheduling //开启基于注解的定时任务 123456789@EnableScheduling //开启基于注解的定时任务@SpringBootApplicationpublic class Springboot04TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04TaskApplication.class, args); &#125;&#125; 编写定时方法 1234567891011121314151617181920@Servicepublic class ScheduledService &#123; /** * second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）. * 0 * * * * MON-FRI * 【0 0/5 14,18 * * ?】 每天14点整，和18点整，每隔5分钟执行一次 * 【0 15 10 ? * 1-6】 每个月的周一至周六10:15分执行一次 * 【0 0 2 ? * 6L】每个月的最后一个周六凌晨2点执行一次 * 【0 0 2 LW * ?】每个月的最后一个工作日凌晨2点执行一次 * 【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次； */// @Scheduled(cron = \"0 * * * * MON-SAT\")// @Scheduled(cron = \"0,1,2,3,4 * * * * MON-SAT\") // @Scheduled(cron = \"0-4 * * * * MON-SAT\") @Scheduled(cron = \"0/4 * * * * MON-SAT\") //每4秒执行一次 public void hello()&#123; System.out.println(\"hello ... \"); &#125;&#125; 两个注解：@EnableScheduling、@Scheduled cron表达式： 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 , - * / 星期 0-7或SUN-SAT 0,7是SUN , - * ? / L C # 特殊字符 代表含义 , 枚举 - 区间 * 任意 / 步长 ? 日/星期冲突匹配 L 最后 W 工作日 C 和calendar联系后计算过的值 # 星期，4#2，第2个星期四 三、邮件任务•邮件发送需要引入spring-boot-starter-mail •Spring Boot 自动配置MailSenderAutoConfiguration •定义MailProperties内容，配置在application.yml中 •自动装配JavaMailSender •测试邮件发送 1.导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 2.配置信息 1)首先在qq邮箱开通相关的服务 拿到的授权码即为password application.properties配置 123456789101112131415161718## QQ邮箱配置spring.mail.host=smtp.qq.com#发送的QQ邮箱spring.mail.username=1162314270@qq.com# 如果是qq邮箱,这个地方是授权码 ,不是密码spring.mail.password=wfqdmurtsvsgiecfspring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.ssl.enable=truespring.mail.default-encoding=utf-8spring.mail.properties.mail.smtp.ssl.trust=smtp.qq.com#SSL证书Socket工厂spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#使用SMTPS协议465端口spring.mail.properties.mail.smtp.socketFactory.port=465spring.mail.properties.mail.smtp.auth=true#503错误，我的没有这个错#spring.mail.properties.mail.smtp.ssl.enable=true 123456789101112131415161718192021222324252627282930313233343536373839404142@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot04TaskApplicationTests &#123; @Autowired JavaMailSenderImpl mailSender; @Test public void contextLoads() &#123; SimpleMailMessage message = new SimpleMailMessage(); //邮件设置 message.setSubject(\"通知-今晚开会\"); message.setText(\"今晚7:30开会\"); message.setTo(\"407820388@qq.com\"); message.setFrom(\"1162314270@qq.com\"); mailSender.send(message); &#125; @Test public void test02() throws Exception&#123; //1、创建一个复杂的消息邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); //邮件设置 helper.setSubject(\"通知-今晚开会\"); helper.setText(\"&lt;b style='color:red'&gt;今天 7:30 开会&lt;/b&gt;\",true); helper.setTo(\"407820388@qq.com\"); helper.setFrom(\"1162314270@qq.com\"); //上传文件 helper.addAttachment(\"1.jpg\",new File(\"E:\\\\pictures\\\\desktop view.png\")); helper.addAttachment(\"2.jpg\",new File(\"E:\\\\pictures\\\\e.png\")); mailSender.send(mimeMessage); &#125;&#125; 实现邮箱激活链接学习来自 https://www.cnblogs.com/smfx1314/p/10332330.html 12345678910public class User &#123; /** * 状态：0代表未激活，1代表激活 */ private Integer status; /** * 利用UUID生成一段数字，发动到用户邮箱，当用户点击链接时 * 在做一个校验如果用户传来的code跟我们发生的code一致，更改状态为“1”来激活用户 */ private String code; 说明： 用户状态status：0代表未激活，1代表激活，注册的时候，默认是0，只有激活邮箱激活码可以更改为1 邮箱激活码code：利用UUID生成一段数字，发动到用户邮箱，当用户点击链接时，在做一个校验，如果用户传来的code跟我们发送的code一致，更改状态为“1”来激活用户 123456789101112131415161718192021222324252627public interface UserDao &#123; /** * 用户注册，注册的时候默认状态为0：未激活，并且调用邮件服务发送激活码到邮箱 * @param user */ void register(User user); /** * 点击邮箱中的激活码进行激活，根据激活码查询用户，之后再进行修改用户状态为1进行激活 * @param code * @return */ User checkCode(String code); /** * 激活账户，修改用户状态为“1”进行激活 * @param user */ void updateUserStatus(User user); /** * 登录，根据用户状态为“1”来查询 * @param user * @return */ User loginUser(User user);&#125; UUIDUtils 随机生成激活码12345public class UUIDUtils &#123; public static String getUUID()&#123; return UUID.randomUUID().toString().replace(\"-\",\"\"); &#125;&#125; UserController控制类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Controller@RequestMapping(\"/user\")public class UserController &#123; @Autowired private UserService userService; /** * 注册 * @param user * @return */ @RequestMapping(value = \"/registerUser\") public String register(User user)&#123; user.setStatus(0); String code = UUIDUtils.getUUID()+ UUIDUtils.getUUID(); user.setCode(code); userService.register(user); return \"success\"; &#125; /** *校验邮箱中的code激活账户 * 首先根据激活码code查询用户，之后再把状态修改为\"1\" */ @RequestMapping(value = \"/checkCode\") public String checkCode(String code)&#123; User user = userService.checkCode(code); System.out.println(user); //如果用户不等于null，把用户状态修改status=1 if (user !=null)&#123; user.setStatus(1); //把code验证码清空，已经不需要了 user.setCode(\"\"); System.out.println(user); userService.updateUserStatus(user); &#125; return \"login\"; &#125; /** * 跳转到登录页面 * @return login */ @RequestMapping(value = \"/loginPage\") public String login()&#123; return \"login\"; &#125; /** * 登录 */ @RequestMapping(value = \"/loginUser\") public String login(User user, Model model)&#123; User u = userService.loginUser(user); if (u !=null)&#123; return \"welcome\"; &#125; return \"login\"; &#125;&#125; 1234567891011121314@Repository@Mapperpublic interface UserMapper &#123; //根据激活码code查询用户 @Select(\"select * from user where code = #&#123;code&#125;\") User checkCode(String code); // 激活账户，修改用户状态 @Update(\"update user set status=1,code=null WHERE user_id = #&#123;userId&#125;\") void updateUserStatus(Integer userId); // 根据用户名，返回激活状态的用户 @Select(\"SELECT * FROM `user` WHERE username = #&#123;username&#125; and status = 1 LIMIT 1\") User getActiveUserByName(String username); public class EmailSender { @Value(&quot;${spring.mail.username}&quot;) private String from; @Autowired EmailCache emailCache; @Autowired JavaMailSenderImpl mailSender; /** * @Description: 发送注册邮件和验证码,send email is take long time so add async * @Param: [email] * @return: java.lang.String null:发送邮件失败 * @Author: lmz * @Date: 2019/10/20 */ @Async public String sendResetPasswordEmail(String email) { String checkCode = String.valueOf(new Random().nextInt(899999) + 100000); try{ //发送邮件 sendEmailMessage(email, &quot;YOJ重置验证码&quot;, &quot;您的重置验证码为：&quot; + checkCode); }catch (Exception e){ e.printStackTrace(); return null; } //设置缓存 emailCache.setEmailCheckCode(email,checkCode); return checkCode; } /** * @Description: 发送注册邮件和验证码 * @Param: [email] * @return: java.lang.String null:发送邮件失败 * @Author: lmz * @Date: 2019/10/20 */ @Async public String sendRegisterEmail(String email) { //删除缓存EmailSender 12345678910111213141516171819202122232425262728293031public class EmailSender &#123; @Value(\"$&#123;spring.mail.username&#125;\") private String from; @Autowired EmailCache emailCache; @Autowired JavaMailSenderImpl mailSender; /** * 发送HTML邮件 * @param to 收件者 * @param subject 邮件主题 * @param content 文本内容 */ public void sendHtmlMail(String to,String subject,String content) &#123; MimeMessage message = mailSender.createMimeMessage(); MimeMessageHelper helper = null; try &#123; helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(subject); helper.setTo(to); helper.setText(content, true); mailSender.send(message); //日志信息 log.info(\"邮件已经发送。\"); &#125; catch (MessagingException e) &#123; log.error(\"发送邮件时发生异常！\", e); &#125; &#125;&#125; } 五.Spring Boot与安全一、安全Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。 几个类： WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式 “认证”和“授权”•应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是Spring Security 的两个目标。 •“认证”（Authentication），是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）。 •“授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立。 •这个概念是通用的而不只在Spring Security中。 二、Web&amp;安全1.登陆/注销 –HttpSecurity配置登陆、注销功能 2.Thymeleaf提供的SpringSecurity标签支持 –需要引入thymeleaf-extras-springsecurity5（版本要一致） –sec:authentication=“name”获得当前用户的用户名 –sec:authorize=“hasRole(‘ADMIN’)”当前用户必须拥有ADMIN权限时才会显示标签内容 3.remember me –表单添加remember-me的checkbox –配置启用remember-me功能 4.CSRF（Cross-site request forgery）跨站请求伪造 HttpSecurity启用功能，会为表单添加csrfCSRF 使用SpringSecurity官方文档 1、引入SpringSecurity；1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 2、编写SpringSecurity的配置类；使用之间需要PasswordEncoder的bean存在 使用springboot，权限管理使用spring security，使用内存用户验证，但无响应报错：java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id “null”解决方法：这是因为Spring boot 2.0.3引用的security 依赖是 spring security 5.X版本，此版本需要提供一个PasswordEncorder的实例，否则后台汇报错误：java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id “null”并且页面毫无响应。因此，需要创建PasswordEncorder的实现类。 1234567891011121314151617package springboot05security.nicolas.config;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component;@Componentpublic class MyPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; return s.equals(charSequence.toString()); &#125;&#125; 自定义securityConfig需要继承WebSecurityConfigurerAdapter 3、控制请求的访问权限：configure(HttpSecurity http) {http.authorizeRequests().antMatchers(“/“).permitAll().antMatchers(“/level1/**”).hasRole(“VIP1”)} 4、定义认证规则：configure(AuthenticationManagerBuilder auth){auth.inMemoryAuthentication().withUser(“zhangsan”).password(“123456”).roles(“VIP1”,”VIP2”)} 123456789101112131415161718192021//定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //super.configure(auth); auth.inMemoryAuthentication() .withUser(\"zhangsan\").password(\"123456\").roles(\"VIP1\", \"VIP2\") .and() .withUser(\"lisi\").password(\"123456\").roles(\"VIP2\", \"VIP3\") .and() .withUser(\"wangwu\").password(\"123456\").roles(\"VIP1\", \"VIP3\"); /**有以下几种形式，使用第3种*/ //inMemoryAuthentication 从内存中获取 //auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(\"user1\").password(new BCryptPasswordEncoder().encode(\"123123\")).roles(\"USER\"); //jdbcAuthentication从数据库中获取，但是默认是以security提供的表结构 //usersByUsernameQuery 指定查询用户SQL //authoritiesByUsernameQuery 指定查询权限SQL //auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery(query).authoritiesByUsernameQuery(query); //注入userDetailsService，需要实现userDetailsService接口 auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); ==使用注入userDetailsService，需要实现userDetailsService接口== 1234567891011121314151617@Servicepublic class UserService implements UserDetailsService &#123; @Autowired UserMapper userMapper; @Autowired PrivilegeService privilegeService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User user = userMapper.getUserByName(username); if(user == null)&#123; throw new UsernameNotFoundException(\"没有该用户\"); &#125; return new UserDetailsImpl(user, privilegeService.queryByUserId(user.getUserId())); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@ToStringpublic class UserDetailsImpl implements UserDetails&#123; private User user; private String username; private String password; //包含着用户对应的所有Privilege，在使用时调用者给对象注入Privileges private List&lt;Privilege&gt; privilege; @Autowired private com.yoj.web.service.PrivilegeService PrivilegeService; public void setPrivilege(List&lt;Privilege&gt; privilege) &#123; this.privilege = privilege; &#125; //无参构造 public UserDetailsImpl() &#123; &#125; //用User构造 public UserDetailsImpl(User user) &#123; this.username = user.getUserName(); this.password = user.getPassword(); this.user = user; &#125; //用User和List&lt;Privilege&gt;构造 public UserDetailsImpl(User user,List&lt;Privilege&gt; Privileges) &#123; this.user = user; this.username = user.getUserName(); this.password = user.getPassword(); this.privilege = Privileges; &#125; public List&lt;Privilege&gt; getPrivilege() &#123; return privilege; &#125; @Override //返回用户所有角色的封装，一个Privilege对应一个GrantedAuthority public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for(Privilege Privilege : privilege) &#123; authorities.add(new SimpleGrantedAuthority(Privilege.getRight())); &#125; return authorities; &#125; @Override public String getPassword() &#123; return password; &#125; @Override public String getUsername() &#123; return username; &#125; @Override //判断账号是否已经过期，默认没有过期 public boolean isAccountNonExpired() &#123; return true; &#125; @Override //判断账号是否被锁定，默认没有锁定 public boolean isAccountNonLocked() &#123; return true; &#125; @Override //判断信用凭证是否过期，默认没有过期 public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override //判断账号是否可用，默认可用 public boolean isEnabled() &#123; return true; &#125;&#125; 5、开启自动配置的登陆功能：1、/login来到登陆页2、重定向到/login?error表示登陆失败3、更多详细规定4、默认post形式的 /login代表处理登陆5、一但定制loginPage；那么 loginPage的post请求就是登陆 123456@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin().usernameParameter(\"user\").passwordParameter(\"pwd\") .loginPage(\"/userlogin\"); configure(HttpSecurity http){http.formLogin();} 6、注销：http.logout();注意logout时需要表单中的按钮 1、访问 /logout 表示用户注销，清空session2、注销成功会返回 /login?logout 页面； 1http.logout().logoutSuccessUrl(\"/\");//注销成功以后来到首页 123&lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"注销\"/&gt;&lt;/form&gt; 7、记住我：Remeberme() 123456&lt;form th:action=\"@&#123;/userlogin&#125;\" method=\"post\"&gt; 用户名:&lt;input name=\"user\"/&gt;&lt;br&gt; 密码:&lt;input name=\"pwd\"&gt;&lt;br/&gt; &lt;input type=\"checkbox\" name=\"remember\"&gt; 记住我&lt;br/&gt; &lt;input type=\"submit\" value=\"登陆\"&gt;&lt;/form&gt; 8获取UserDetails 12UserDetailsImpl userDetails = (UserDetailsImpl) SecurityContextHolder.getContext().getAuthentication().getPrincipal(); System.out.println(userDetails); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); //定制请求的授权规则 http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"VIP1\") .antMatchers(\"/level2/**\").hasRole(\"VIP2\") .antMatchers(\"/level3/**\").hasRole(\"VIP3\"); //开启自动配置的登陆功能，效果，如果没有登陆，没有权限就会来到登陆页面 //http.formLogin(); //1、/login来到登陆页 //2、重定向到/login?error表示登陆失败 //3、更多详细规定 //4、默认post形式的 /login代表处理登陆 //5、一但定制loginPage；那么 loginPage的post请求就是登陆 http.formLogin().usernameParameter(\"user\").passwordParameter(\"pwd\") .loginPage(\"/userlogin\"); //开启自动配置的注销功能。// http.logout(); //1、访问 /logout 表示用户注销，清空session //2、注销成功会返回 /login?logout 页面； http.logout().logoutSuccessUrl(\"/\");//注销成功以后来到首页 //开启记住我功能// http.rememberMe(); //登陆成功以后，将cookie发给浏览器保存，以后访问页面带上这个cookie，只要通过检查就可以免登录 //点击注销会删除cookie http.rememberMe().rememberMeParameter(\"remember\"); &#125; //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //super.configure(auth); auth.inMemoryAuthentication() .withUser(\"zhangsan\").password(\"123456\").roles(\"VIP1\", \"VIP2\") .and() .withUser(\"lisi\").password(\"123456\").roles(\"VIP2\", \"VIP3\") .and() .withUser(\"wangwu\").password(\"123456\").roles(\"VIP1\", \"VIP3\"); /**有以下几种形式，使用第3种*/ //inMemoryAuthentication 从内存中获取 //auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(\"user1\").password(new BCryptPasswordEncoder().encode(\"123123\")).roles(\"USER\"); //jdbcAuthentication从数据库中获取，但是默认是以security提供的表结构 //usersByUsernameQuery 指定查询用户SQL //authoritiesByUsernameQuery 指定查询权限SQL //auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery(query).authoritiesByUsernameQuery(query); //注入userDetailsService，需要实现userDetailsService接口 auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); &#125;&#125; 定义认证用户信息获取来源，密码校验规则等 Thymeleaf Extras Springsecurity注意：thymeleaf和springsecurity版本一致，Thymeleaf Extras Springsecurity5 123456&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity5 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819div sec:authorize=\"!isAuthenticated()\"&gt; &lt;h2 align=\"center\"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href=\"@&#123;/userlogin&#125;\"&gt;请登录&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt;&lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;h2&gt;&lt;span sec:authentication=\"name\"&gt;&lt;/span&gt;，您好,您的角色有： &lt;span sec:authentication=\"principal.authorities\"&gt;&lt;/span&gt;&lt;/h2&gt; &lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"注销\"/&gt; &lt;/form&gt;&lt;/div&gt;&lt;hr&gt;&lt;div sec:authorize=\"hasRole('VIP1')\"&gt; &lt;h3&gt;普通武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/1&#125;\"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/2&#125;\"&gt;武当长拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/3&#125;\"&gt;全真剑法&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 在Spring Security中使用AJAX向后台传送数据本文链接：https://blog.csdn.net/bnrmaster/article/details/52939212 环境：spring 4.2.3 spring security 4.1.3 表现： 2016-10-26 22:44:02 [http-apr-9080-exec-10] DEBUG org.springframework.security.web.csrf.CsrfFilter - Invalid CSRF token found for XXX2016-10-26 22:44:02 [http-apr-9080-exec-10] DEBUG org.springframework.security.web.header.writers.HstsHeaderWriter - Not injecting HSTS header since it did not match the requestMatcher org.springframework.security.web.header.writers.HstsHeaderWriter$SecureRequestMatcher@c3339ef2016-10-26 22:44:02 [http-apr-9080-exec-10] DEBUG org.springframework.security.web.context.SecurityContextPersistenceFilter - SecurityContextHolder now cleared, as request processing completed 前台使用AJAX向后台传输数据时候控制台报出上述错误，再未集成Spring Security时不会出现此现象 解决方法： 如果前端使用的JSP 可以在前端页面的标签中增加两个标签 如下 1234567&lt;html&gt;&lt;head&gt; &lt;meta name=\"_csrf\" content=\"$&#123;_csrf.token&#125;\"/&gt; &lt;!-- default header name is X-CSRF-TOKEN --&gt; &lt;meta name=\"_csrf_header\" content=\"$&#123;_csrf.headerName&#125;\"/&gt; &lt;!-- ... --&gt;&lt;/head&gt; 如果前端使用的是Thymeleaf分两种情况 1.前端无form表单,也要再头部增加两个meta标签，形式为 1234567&lt;html&gt;&lt;head&gt; &lt;meta name=\"_csrf\" th:content=\"$&#123;_csrf.token&#125;\" content=\"\"/&gt; &lt;!-- default header name is X-CSRF-TOKEN --&gt; &lt;meta name=\"_csrf_header\" th:content=\"$&#123;_csrf.headerName&#125;\" content=\"\"/&gt; &lt;!-- ... --&gt;&lt;/head&gt; 2.前端有form表单 Spring Security为Thymeleaf中的表单中自动添加一个 (xxxx为crrf.token) 添加完meta之后不妨运行下，在页面代码中搜索_csrf，可以看看附近代码的样子，应该就会明白了 这样在使用AJAX时，需要增加一个头部 12345678910111213141516var token = $(\"meta[name='_csrf']\").attr(\"content\");var header = $(\"meta[name='_csrf_header']\").attr(\"content\"); $.ajax(&#123; type: \"POST\", url: \"myposturl\", data: entID, contentType:\"application/json; charset=utf-8\", headers : &#123;header:token&#125;, async:false, success:function(data)&#123; //do something &#125;, error: function () &#123; //deal width error &#125; &#125;); 实际上，这里的header使用为值”X-CSRF-TOKEN” 这样就可以成功向后台请求了 spring security reference 123456789101112131415161718var csrfHeader = $(\"meta[name='_csrf_header']\").attr(\"content\");var csrfToken = $(\"meta[name='_csrf']\").attr(\"content\");var headers = &#123;&#125;;headers[csrfHeader] = csrfToken;console.log(problem);$.ajax(&#123; url: \"/p/add\", type: \"POST\", headers : headers, data: problem, success(res)&#123; // $(\"id\").add(res); console.log(res); &#125;, error(res)&#123; console.log(res); &#125;&#125;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;CSRF Protected JavaScript Page&lt;/title&gt; &lt;meta name=\"description\" content=\"This is the description for this page\" /&gt; &lt;sec:csrfMetaTags /&gt; &lt;script type=\"text/javascript\" language=\"javascript\"&gt; var csrfParameter = $(\"meta[name='_csrf_parameter']\").attr(\"content\"); var csrfHeader = $(\"meta[name='_csrf_header']\").attr(\"content\"); var csrfToken = $(\"meta[name='_csrf']\").attr(\"content\"); // using XMLHttpRequest directly to send an x-www-form-urlencoded request var ajax = new XMLHttpRequest(); ajax.open(\"POST\", \"https://www.example.org/do/something\", true); ajax.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded data\"); ajax.send(csrfParameter + \"=\" + csrfToken + \"&amp;name=John&amp;...\"); // using XMLHttpRequest directly to send a non-x-www-form-urlencoded request var ajax = new XMLHttpRequest(); ajax.open(\"POST\", \"https://www.example.org/do/something\", true); ajax.setRequestHeader(csrfHeader, csrfToken); ajax.send(\"...\"); // using JQuery to send an x-www-form-urlencoded request var data = &#123;&#125;; data[csrfParameter] = csrfToken; data[\"name\"] = \"John\"; ... $.ajax(&#123; url: \"https://www.example.org/do/something\", type: \"POST\", data: data, ... &#125;); // using JQuery to send a non-x-www-form-urlencoded request var headers = &#123;&#125;; headers[csrfHeader] = csrfToken; $.ajax(&#123; url: \"https://www.example.org/do/something\", type: \"POST\", headers: headers, ... &#125;); &lt;script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 六、Spring Boot与分布式 七、Spring Boot与监控管理 八、Spring Boot与部署 七.开发热部署一、热部署在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，如何能实现热部署。 •1、模板引擎 –在Spring Boot中开发情况下禁用模板引擎的cache –页面模板改变ctrl+F9可以重新编译当前页面并生效 2、Spring Loaded Spring官方提供的热部署程序，实现修改类文件的热部署 –下载Spring Loaded（项目地址https://github.com/spring-projects/spring-loaded） –添加运行时参数； -javaagent:C:/springloaded-1.2.5.RELEASE.jar –noverify 3、JRebel –收费的一个热部署软件 –安装插件使用即可 4、Spring Boot Devtools（推荐）–引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; –IDEA使用ctrl+F9 –或做一些小调整 Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下才会自动编译（前提是你已经设置了Auto-Compile）。 •设置自动编译（settings-compiler-make project automatically） •ctrl+shift+alt+/（maintenance） •勾选compiler.automake.allow.when.app.running","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://codeofli.github.io/tags/spring/"},{"name":"springBoot","slug":"springBoot","permalink":"https://codeofli.github.io/tags/springBoot/"}]},{"title":"hexo","slug":"hexo/hexo","date":"2019-09-27T14:19:09.000Z","updated":"2021-10-31T05:30:41.826Z","comments":true,"path":"2019/09/hexo/hexo/","link":"","permalink":"https://codeofli.github.io/2019/09/hexo/hexo/","excerpt":"[TOC]hexo官方文档安装hexonpm安装hexo1npm install -g hexo-clihttps://blog.csdn.net/xuezhisdc/article/details/53130328如：E:\\Program Files\\nodejs\\my_node\\node_global\\hexo.cmd","text":"[TOC]hexo官方文档安装hexonpm安装hexo1npm install -g hexo-clihttps://blog.csdn.net/xuezhisdc/article/details/53130328如：E:\\Program Files\\nodejs\\my_node\\node_global\\hexo.cmd 可查看是否完成安装，使用 1hexo v 开始构建条件 npm+git 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） 1234deploy: type: git repository: git@github.com:Li-MingZhong/Li-MingZhong.github.io.git(自己仓库的ssh链接) branch: master 在生成以及部署文章之前，需要安装一个扩展： 1npm install hexo-deployer-git --save 新建一篇博客，在cmd执行命令：hexo new post “博客名” 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署(即自动提交）了 注意：提交到Github先修改url 1234# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://codeofli.github.io# url: http://localhost:4000 修改配置文件，最好clean一下，反正配置文件未生效 1hexo clean 最后 1hexo d -g 然后提交 使用启动 12hexo shexo serve md解析头格式在 source 文件夹下的所有 md 文件或者 html 文件都会被渲染 在sourece/_post目录下相应的md添加相应的头信息由hexo解析。 1234567891011121314---title: mybatis(网页显示和文章标题)p: java-note/mybatis/mybatis（java-note/mybatis/mybatis.md(省略了.md)在_post路径下的位置，需要创建对于文件夹）,不需要p参数也能被解析date: 2019-11-12 10:40:06 (创建时间)categories: java tags: [java,mybatis]--- 案例 1234567891011---title: mybatisdate: 2021-10-24 10:40:06categories: javatags: [java,mybatis]--- [命令][https://hexo.io/zh-cn/docs/commands]generate1$ hexo generate 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 -b, --bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, --force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, --concurrency 最大同时生成文件的数量，默认无限制 该命令可以简写为 1$ hexo g new1hexo n -p js-note/vue/vue 'vue' 能挂载图片和创建路径 1$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 1$ hexo new \"post title with whitespace\" 参数 描述 -p, --path 自定义新文章的路径 -r, --replace 如果存在同名文章，将其替换 -s, --slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 --path 参数来覆盖上述行为、自行决定文件的目录： 1hexo new page --path about/me \"About me\" 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot; 注意！title 是必须指定的！如果你这么做并不能达到你的目的： 1hexo new page --path about/me 此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 &quot;page&quot;。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。 解决markdown插入图片问题hexo默认无法自动处理文章插入本地图片，需要通过扩展插件支持。 图片路径问题1.配置_config.yml里面的post_asset_folder:false这个选项设置为true。 2.安装hexo-asset-image 1npm install hexo-asset-image --save 3.运行hexo n &quot;xxxx&quot;来生成md博文，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹，把图片放入该文件夹。 1hexo n \"xxxx\" 4.使用![xxx](xxx/xxx.png)直接插入图片即可。 配置typora进行本地图片的粘贴及正常显示 设置typora,图像 注意1.图片名中间不能有空格 注意测试时配置文件_config.yml中url使用localhost 1234# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'# url: https://codeofli.github.iourl: http://localhost:4000 hexo设置多标签和多分类分类↓↓↓↓categories: 一级分类-二级分类 例如 categories: java-SpringMVC标签↓↓↓↓tags: [标签1,标签2，…] 例如 tags: [java,SpringMVC] hexo clean12PS E:\\Codes\\other\\hexo\\my-blog&gt; hexo cleanINFO Deleted database. hexo会记录以前的配置信息和tags之类的，所以，清楚标签之后，hexo clear一下 设置跳过的渲染文件skip_render: 1skip_render: [README.md, \"**/*.js\",\"**/source/**\",\"**/other/**\",\"**/src/**\"] markdwon解析错误1.一个#后面没有内容，解析失败 next主题[]: next主题优化 4.添加动态背景5. 修改标签样式9.文章阴影设置10. 添加文章版权信息12. 添加打赏13. 添加页面宠物18.增加阅读次数/时长和访客数19.加入网易云音乐播放器","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"mysql","slug":"mysql/mysql","date":"2019-03-27T14:19:09.000Z","updated":"2021-10-30T03:47:54.284Z","comments":true,"path":"2019/03/mysql/mysql/","link":"","permalink":"https://codeofli.github.io/2019/03/mysql/mysql/","excerpt":"[TOC]六、DML语言的学习 ★ 插入语句 修改语句 删除语句 七、DDL语言的学习 库和表的管理 √ 常见数据类型介绍 √ 常见约束 √ 八、TCL语言的学习 事务和事务处理 九、视图的讲解 √ 十、变量 十一、存储过程和函数 十二、流程控制结构","text":"[TOC]六、DML语言的学习 ★ 插入语句 修改语句 删除语句 七、DDL语言的学习 库和表的管理 √ 常见数据类型介绍 √ 常见约束 √ 八、TCL语言的学习 事务和事务处理 九、视图的讲解 √ 十、变量 十一、存储过程和函数 十二、流程控制结构 数据库简介数据库的好处1.持久化数据到 本地 2.可以实现结构化查询，方便管理数据库相关概念1、DB：数据库，保存一组有组织的数据的容器 2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据 3、SQL:结构化查询语言，用于和DBMS通信的语言数据库存储数据的特点1、将数据放到表中，表再放到库中 2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。 3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。 4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性” 5、表中的数据是按行存储的，每一行类似于java中的“对象”。MySQL产品的介绍和安装MySQL服务的启动和停止1234方式一：计算机——右击管理——服务方式二：通过管理员身份运行net start 服务名（启动服务）net stop 服务名（停止服务） MySQL服务的登录和退出12方式一：通过mysql自带的客户端只限于root用户 123456方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C MySQL（数据库操作）的常见命令创建数据库 1CREATE DATABASE IF NOT EXISTS yoj DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 创建数据库，该命令的作用： \\1. 如果数据库不存在则创建，存在则不创建。 \\2. 创建yoj数据库，并设定编码集为utf8 删除数据库。 1DROP DATABASE dbName; 创建数据库。 1create database yoj; 12345678910111213141516171.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名( 列名 列类型, 列名 列类型， 。。。);6.查看表结构desc 表名; 12345677.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V MySQL的语法规范12345671.不区分大小写,但建议关键字大写，表名、列名小写2.每条命令最好用分号结尾3.每条命令根据需要，可以进行缩进 或换行4.注释 单行注释：#注释文字 单行注释：-- 注释文字 多行注释：/* 注释文字 */ ​ SQL的语言分类12345678DQL（Data Query Language）：数据查询语言 select DML(Data Manipulate Language):数据操作语言 insert 、update、deleteDDL（Data Define Languge）：数据定义语言 create、drop、alterTCL（Transaction Control Language）：事务控制语言 commit、rollback DQL语言的学习进阶1：基础查询12语法：SELECT 要查询的东西【FROM 表名】; 1234类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数 起别名 1234567#起别名#方式一：使用asSELECT last_name AS 姓,first_name AS 名 FROM employees;#方拾二：省略as(使用空格)SELECT last_name 姓,first_name 名 FROM employees;#包含特殊字符使用\"\"('')标注为字符串SELECT last_name \"姓 X\",first_name 名 FROM employees; mysql+号 只有一个功能：运算符 123# +#只要有一方为null，则+和拼接都为nullSELECT CONCAT(first_name,' ',last_name) `name` FROM employees; 进阶2：条件查询条件查询：根据条件过滤原始表的数据，查询到想要的数据 语法： select 要查询的字段|表达式|常量值|函数 from 表 where 条件 ;12345678910111213141516171819202122232425262728293031分类：一、条件表达式 示例：salary&gt;10000 条件运算符： &gt; &lt; &gt;= &lt;= = != &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false or(||)：两个条件只要有一个成立，结果为true，否则为false not(!)：如果条件成立，则not后为false，否则为true三、模糊查询like1 % &gt;= 0 个字符示例：last_name like 'a%'2 _ 一个字符3特殊字符：使用转义字符SELECT last_name FROM employees WHERE last_name LIKE '_\\_%' ;SELECT last_name FROM employees WHERE last_name LIKE '_$_%' ESCAPE '$';between and 等价于并简化了 &gt;= &lt;= 语句in 判断某字段的值是否属于in列表中的某一项，in中列表值类型必须一致或兼容SELECT * FROM employees WHERE job_id IN('IT_PROT','AD_VP');is null| is not null只能判断null值，= 和&lt;&gt; 不能判断null值安全等于&lt;=&gt;既能判断是否为null，也能判断其他类型 进阶 3：排序查询123456789语法：select 要查询的东西from 表where 条件 order by 排序的字段|表达式|函数|别名 【asc|desc】,次要排序内容(通前面格式一致)#默认升序 进阶4：常见函数 调用 select 函数名（实参列表）【form 表】 函数可以嵌套 一、单行函数 1、字符函数 concat拼接（字符串） substr截取子串 upper转换成大写 lower转换成小写 trim去前后指定的空格和字符 ltrim去左边空格 rtrim去右边空格 replace替换 lpad左填充 rpad右填充 instr返回子串第一次出现的索引，如果找不到返回0 length 获取**字节**个数 2、数学函数 round 四舍五入 rand 随机数 floor向下取整 ceil向上取整；返回&gt;=该参数的最小整数 **mod取余 mod(a,b) = a-a/b*b（有效解决负数问题）** truncate截断3、日期函数 now当前系统日期+时间 curdate当前系统日期 curtime当前系统时间 str_to_date 将字符转换成日期 date_format将日期转换成字符 year(),month()… 4、流程控制函数 if (条件表达式，成立值，false值)处理双分支 ，和三元运算符相当 case语句 处理多分支 情况1：处理等值判断 1234567891011121314case 要判断的字段或表达式when 常量1 then 要显示的值1或语句1;when 常量2 then 要显示的值2或语句2;···else 要显示的值n或语句n;endSELECT salary init,department_id,CASE department_idWHEN 30 THEN salary*1.1WHEN 40 THEN salary*1.2WHEN 50 THEN salary*1.3ELSE salaryEND AS `new`FROM employees; 情况2：处理条件判断123456789101112131415casewhen 常量1 then 要显示的值1或语句1;when 常量2 then 要显示的值2或语句2;···else 要显示的值n或语句n;end#相当于多重if语句SELECT salary,CASEWHEN salary &gt; 20000 THEN 'a'WHEN salary &gt; 15000 THEN 'b'WHEN salary &gt; 10000 THEN 'b'ELSE 'd'END AS gradeFROM employees; 5、其他函数 version版本 database当前库 user当前连接用户 二、分组函数 又称统计函数 123456789101112131415sum 求和max 最大值min 最小值avg 平均值count 计数特点：1、以上五个分组函数都忽略null值，除了count(*)2、sum和avg一般用于处理数值型max、min、count可以处理任何数据类型3、都可以搭配distinct使用，用于统计去重后的结果4、count的参数可以支持：字段、*、常量值，一般放1建议使用 count(*) 进阶5：分组查询语法： select 查询的字段，分组函数 from 表 group by 分组的字段特点：1、可以按单个字段分组 2、和分组函数一同查询的字段最好是分组后的字段 3、分组筛选 针对的表 位置 关键字分组前筛选： 原始表 group by的前面 where分组后筛选： 分组后的结果集 group by的后面 having 4、可以按多个字段分组，字段之间用逗号隔开 5、可以支持排序6、having后可以支持别名 注意：group by的select语句中 的select显示字段一般除了聚合函数就只能为group by后的字段 group by能用于多列去重 123SELECT solution_id,s.problem_id,user_id,user_name,score FROM solution s,contest_problem cp where s.contest_id = 19 AND s.problem_id = cp.problem_id AND s.contest_id = cp.contest_id AND result = 0 GROUP BY s.problem_id,user_id 进阶6：多表连接查询12笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件 一、传统模式下的连接 ：等值连接——非等值连接 12341.等值连接的结果 = 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能 二、sql99语法：通过join关键字实现连接 123456789101112131415161718含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on 连接条件【inner|left outer|right outer|cross】join 表3 on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！ 三、自连接 案例：查询员工名和直接上级的名称 sql99 123SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.`manager_id`=m.`employee_id`; sql92 123SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`; 进阶7：子查询含义： 12一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询 特点： 123456789101112131415161、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询 结果集只有一行 一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 非法使用子查询的情况： a、子查询的结果为一组值 b、子查询的结果为空 ② 多行子查询 结果集有多行 一般搭配多行操作符使用：any、all、in、not in in： 属于子查询结果中的任意一个就行 any和all往往可以用其他查询代替 12SELECT solution_id,problem_id,user_id,MIN(runtime) as runtime FROM solution WHERE contest_id = 19 AND result = 0 GROUP BY problem_id,user_id 进阶8：分页查询应用场景： 1实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句 语法： 1234567select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数; 特点： 123456781.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from 表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page 进阶9：联合查询引入： union 联合、合并 语法： 12345select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点： 1231、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重 DML语言插入语法： insert into 表名(字段名，…) values(值1，…); 特点： 123451、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 修改修改单表语法： 12update 表名 set 字段=新值,字段=新值【where 条件】 修改多表语法： 1234update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件 删除方式1：delete语句 单表的删除： ★ delete from 表名 【where 筛选条件】 多表的删除： delete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件; 方式2：truncate语句 1truncate table 表名 两种方式的区别【面试题】 1.truncate不能加where条件，而delete可以加where条件 2.truncate的效率高一丢丢 3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始 4.truncate删除不能回滚，delete删除可以回滚 DDL语句###库和表的管理库的管理： 1234一、创建库create database 库名二、删除库drop database 库名 表的管理： #1.创建表 12345CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME ); DESC studentinfo;2.修改表 alter12345678910111213141516语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO] studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email; ​​ #3.删除表​​ DROP TABLE [IF EXISTS] studentinfo; ​ ###常见类型12345678整型： 小数： 浮点型 定点型字符型：日期型：Blob类型： ###常见约束123456NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY ##数据库事务###含义 通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态 ###特点 （ACID） 原子性：要么都执行，要么都回滚 一致性：保证数据的状态操作前和操作后保持一致 隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰 持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改 相关步骤： 1231、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务 ###事务的分类：隐式事务，没有明显的开启和结束事务的标志 12比如insert、update、delete语句本身就是一个事务 显式事务，具有明显的开启和结束事务的标志 1234567891、开启事务取消自动提交事务的功能2、编写事务的一组逻辑操作单元（多条sql语句）insertupdatedelete3、提交事务或回滚事务 ###使用到的关键字12345678set autocommit=0;start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点 ###事务的隔离级别: 事务并发问题如何发生？ 1当多个事务同时操作同一个数据库的相同数据时 事务的并发问题有哪些？ 123脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据 如何避免事务的并发问题？ 12345通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读 设置隔离级别： 1set session|global transaction isolation level 隔离级别名; 查看隔离级别： 1select @@tx_isolation; ##视图含义：理解成一张虚拟的表 视图和表的区别： 12345 使用方式 占用物理空间视图 完全相同 不占用，仅仅保存的是sql逻辑表 完全相同 占用 视图的好处： 121、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性 ###视图的创建 语法： CREATE VIEW 视图名 AS 查询语句;###视图的增删改查 1、查看视图的数据 ★ 123456789SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name='Partners';2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES('虚竹',90);3、修改视图的数据UPDATE my_v4 SET last_name ='梦姑' WHERE last_name='虚竹'; 4、删除视图的数据 DELETE FROM my_v4;###某些视图不能更新 包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all 常量视图 Select中包含子查询 join from一个不能更新的视图 where子句的子查询引用了from子句中的表###视图逻辑的更新 #方式一： CREATE OR REPLACE VIEW test_v7 AS SELECT last_name FROM employees WHERE employee_id&gt;100; #方式二: ALTER VIEW test_v7 AS SELECT employee_id FROM employees; SELECT * FROM test_v7;###视图的删除 DROP VIEW test_v1,test_v2,test_v3;###视图结构的查看 DESC test_v7; SHOW CREATE VIEW test_v7; ##存储过程 含义：一组经过预先编译的sql语句的集合好处： 1231、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率3、减少了传输次数 分类： 1234561、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个 ###创建存储过程语法： 12345create procedure 存储过程名(in|out|inout 参数名 参数类型,...)begin 存储过程体end 类似于方法： 1234修饰符 返回类型 方法名(参数类型 参数名,...)&#123; 方法体;&#125; 注意 1234567891011121314151617181、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)BEGIN sql语句1; sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出 #调用存储过程 call 存储过程名(实参列表)##函数 ###创建函数 学过的函数：LENGTH、SUBSTR、CONCAT等语法： 12345CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN 函数体END ###调用函数 SELECT 函数名（实参列表） ###函数和存储过程的区别 123 关键字 调用语法 返回值 应用场景函数 FUNCTION SELECT 函数() 只能是一个 一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程 PROCEDURE CALL 存储过程() 可以有0个或多个 一般用于更新 ##流程控制结构 ###系统变量一、全局变量 作用域：针对于所有会话（连接）有效，但不能跨重启 123456789查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE '%char%';查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0; 二、会话变量 作用域：针对于当前会话（连接）有效 12345678910查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE '%char%';查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation='read-uncommitted';SET SESSION tx_isolation='read-committed'; ###自定义变量一、用户变量 声明并初始化： 123SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值; 赋值： 1234方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值; 123方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表; 使用： 1select @变量名; 二、局部变量 声明： 1declare 变量名 类型 【default 值】; 赋值： 1234方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值; 123方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表; 使用： 1select 变量名 二者的区别： 1作用域 定义位置 语法 用户变量 当前会话 会话的任何地方 加@符号，不用指定类型局部变量 定义它的BEGIN END中 BEGIN END的第一句话 一般不用加@,需要指定类型 ###分支一、if函数 语法：if(条件，值1，值2) 特点：可以用在任何位置 二、case语句 语法： 123456789101112131415情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要） 特点： 可以用在任何位置 三、if elseif语句 语法： 12345if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if; 特点： 只能用在begin end中！！！！！！！！！！！！！！！ 三者比较： 应用场合 if函数 简单双分支 case结构 等值判断 的多分支 if结构 区间判断 的多分支 ###循环 语法： 123【标签：】WHILE 循环条件 DO 循环体END WHILE 【标签】; 特点： 12345只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！ sql优化SQL优化之limit 1 在某些情况下,如果明知道查询结果只有一个,SQL语句中使用LIMIT 1会提高查询效率。 1SELECT * FROM t_user WHERE email=? LIMIT 1; SQL的常见命令1234567891011show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名( 字段名 字段类型, 字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据 1create database db_name 修改字段编码123alter database name character set utf8;#修改数据库成utf8的.alter table type character set utf8;#修改表用utf8.alter table type modify type_name varchar(50) CHARACTER SET utf8;#修改字段用utf8 mysqldump数据导出MySQL mysqldump数据导出详解mysqldump是导出数据过程中使用非常频繁的一个工具 mysqldump备份： mysqldump -u用户名 -p密码 -h主机 数据库 a -w “sql条件” –lock-all-tables &gt; 路径 案例： mysqldump -uroot -p1234 -hlocalhost db1 a -w “id in (select id from b)” –lock-all-tables &gt; c:\\aa.txt mysqldump还原： mysqldump -u用户名 -p密码 -h主机 数据库 &lt; 路径 案例： mysql -uroot -p1234 db1 &lt; c:\\aa.txt mysqldump按条件导出： mysqldump -u用户名 -p密码 -h主机 数据库 a –where “条件语句” –no-建表&gt; 路径 mysqldump -uroot -p1234 dbname a –where “tag=’88’” –no-create-info&gt; c:\\a.sql mysqldump按导入： 1mysqldump -u用户名 -p密码 -h主机 数据库 &lt; 路径 1.导出所有数据库 该命令会导出包括系统数据库在内的所有数据库 1mysqldump -uroot -proot --all-databases &gt;/tmp/all.sql 2.导出db1、db2两个数据库的所有数据 1mysqldump -uroot -proot --databases db1 db2 &gt;/tmp/user.sql 3.导出db1中的a1、a2表 注意导出指定表只能针对一个数据库进行导出，且导出的内容中和导出数据库也不一样，导出指定表的导出文本中没有创建数据库的判断语句，只有删除表-创建表-导入数据 1mysqldump -uroot -proot --databases db1 --tables a1 a2 &gt;/tmp/db1.sql 4.条件导出，导出db1表a1中id=1的数据 如果多个表的条件相同可以一次性导出多个表 字段是整形 1mysqldump -uroot -proot --databases db1 --tables a1 --where='id=1' &gt;/tmp/a1.sql mymysql命令行执行sql文件说明：result.sql文件中是多条插入数据的sql语句。现将这些sql语句导入到数据库中，（不用打开文件拷贝然后粘贴执行，如果数据量大的话这种操作非常繁琐，应使用以下方法）。注：提前将文件拷贝至当前目录下。如果文件不在当前目录，在source 后应加上文件的绝对路径1、登录mysql mysql -u root -p ;12、输入密码，选择数据库 use my_database;13、执行sql文件。 source result.sql ; 修改时区方法一：通过mysql命令行模式下动态修改 1show variables like \"%time_zone%\"; 查看时区 12345678+``------------------+--------+| Variable_name | Value |+``------------------+--------+| system_time_zone | CST || time_zone | SYSTEM |+``------------------+--------+2 ``rows` `in` `set` `(0.00 sec)#time_zone说明mysql使用system的时区，system_time_zone说明system使用CST时区 修改时区 123&gt; set global time_zone = '+8:00'; ##修改mysql全局时区为北京时间，即我们所在的东8区&gt; set time_zone = '+8:00'; ##修改当前会话时区&gt; flush privileges; #立即生效 my othermysql jdbc 参数MySQL Connector/J Driver 驱动程序包名：mysql-connector-java-x.x.xx-bin.jar 驱动程序类名: com.mysql.jdbc.Driver JDBC URL: jdbc:mysql://:/ 默认端口3306，如果服务器使用默认端口则port可以省略 MySQL Connector/J Driver 允许在URL中添加额外的连接属性 jdbc:mysql://:/?property1=value1&amp;property2=value2 注意： 需要操作记录为了避免乱码应该加上属性 useUnicode=true&amp;characterEncoding=utf8 ，比如 1jdbc:mysql://192.168.177.129:3306/report?useUnicode=true&amp;characterEncoding=utf8 mysql环境变量如果添加到环境变量中还是无效，建议将mysql环境变量放在path路径的最前面 windows的path路径是通过path文本从前往后找，如果在最后有可能解析path失败 mysql执行脚本命令12345678910show databases; create database xxx;mysql&gt; use yoj;show tables;##需要先选择数据库source xxx.sql(sql文件的目录); mysql注意null的判断都必须用is， = 没有用1DELETE FROM solution where submit_time is Null mysql导入数据时的外键约束问题 这个问题可通过FOREIGN_KEY_CHECKS解决，用法如下： 1、set FOREIGN_KEY_CHECKS=0; #在导入的脚本命令行最前面设置为不检查外键约束 2、。。。。。。。。。。。。 #导入数据的命令行 3、set FOREIGN_KEY_CHECKS=1; #在导入后恢复检查外键约束 mysql 索引https://blog.csdn.net/liutong123987/article/details/79384395 索引不仅能提高查询速度，还可以添加排序速度，如果order by 后面的语句用到了索引，那么将会提高排序的速度。 主键具备索引的功能了。 当你创建或设置主键的时候,mysql会自动添加一个与主键对应的唯一索引,不需要再做额外的添加。 索引类型Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。 FULLTEXT即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。 全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%”这类针对文本的模糊查询效率较低的问题。 HASH 由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。 HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。 BTREEBTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。 RTREE RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。 相对于BTREE，RTREE的优势在于范围查找。 ps. 此段详细内容见此片博文：Mysql几种索引类型的区别及适用情况 三、索引种类普通索引：仅加速查询 唯一索引：加速查询 + 列值唯一（可以有null） 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并 全文索引：对文本的内容进行分词，进行搜索 count(*)和count(1)如果你要统计行数就用count(*)或者count(1)，推荐前者 如果要统计某个字段不为NULL值的个数就用count(字段) 1.当mysql确认括号内的表达式值不可能为空时，实际上就是在统计行数 2.如果mysql知道某列col不可能为NULL值，那么mysql内部会将count(col)表达式优化为count(*) 这2句话出自&lt;&lt;高性能MySQL&gt;&gt;一书 也就是说count(1)和count(主键字段)还是要优化到count(*)的 update使用select结果,count(distinct xx)1UPDATE user SET solved = (SELECT COUNT(DISTINCT problem_id) FROM solution WHERE user_id = #&#123;userId&#125;) WHERE user_id = #&#123;userId&#125; varchar()的长度问题根据不同的字符集，解析中文占的位数是不一样的，如果是utf8的字符集，varchar(20)可以存放20个中文，这里中文跟英文存放的位数是一样的。但如果是latin字符集，中文估计解析不了，变成乱码 mysql 导入时自己制定库名在到处的sql文件中添加 123DROP DATABASE IF EXISTS `ssm_crud`;CREATE DATABASE ssm_crud;USE ssm_crud; 修改用户的密码方法1： 用SET PASSWORD命令首先登录MySQL。 12格式：mysql&gt; set password for 用户名@localhost = password('新密码'); 例子：mysql&gt; 1set password for root@localhost = password('123'); 将表结构查询为表格1234567891011121314151617181920SELECT COLUMN_NAME 列名, COLUMN_TYPE 数据类型, DATA_TYPE 字段类型, CHARACTER_MAXIMUM_LENGTH 长度, IF(IS_NULLABLE = &apos;YES&apos;,&apos;是&apos;,&apos;否&apos;) AS &apos;是否为空&apos;, COLUMN_DEFAULT 默认值, IF(COLUMN_KEY=&apos;PRI&apos;,&apos;是&apos;,&apos;否&apos;) AS &apos;主键&apos;, IF(COLUMN_KEY=&apos;MUL&apos;,&apos;是&apos;,&apos;否&apos;) AS &apos;外键&apos;, COLUMN_COMMENT 备注, COLUMN_KEYFROM INFORMATION_SCHEMA.COLUMNSwhere-- yoj为数据库名称，到时候只需要修改成你要导出表结构的数据库即可table_schema =&apos;yoj&apos;AND-- user为表名，到时候换成你要导出的表的名称-- 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称table_name = &apos;problem&apos;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://codeofli.github.io/tags/mysql/"}]}]}