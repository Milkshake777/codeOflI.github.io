{"meta":{"title":"nicolas","subtitle":"Yesterday you said tomorow.","description":"Yesterday you said tomorow.","author":"nicolas lee","url":"https://codeofli.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-10-09T02:10:12.000Z","updated":"2019-11-14T01:56:35.177Z","comments":true,"path":"categories/index.html","permalink":"https://codeofli.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-07T02:31:20.000Z","updated":"2019-11-14T01:56:35.162Z","comments":true,"path":"about/index.html","permalink":"https://codeofli.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-09T02:17:04.000Z","updated":"2019-11-14T01:56:35.177Z","comments":true,"path":"tags/index.html","permalink":"https://codeofli.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-09T02:11:44.000Z","updated":"2019-11-14T01:56:35.162Z","comments":true,"path":"about/index-1.html","permalink":"https://codeofli.github.io/about/index-1.html","excerpt":"","text":""}],"posts":[{"title":"Docker实用篇","slug":"docker/Docker实用篇","date":"2021-10-26T02:40:06.000Z","updated":"2022-03-02T01:21:40.696Z","comments":true,"path":"2021/10/docker/Docker实用篇/","link":"","permalink":"https://codeofli.github.io/2021/10/docker/Docker实用篇/","excerpt":"Docker实用篇1.初识Docker1.1.什么是Docker微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 1.1.1.应用部署的环境问题大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：","text":"Docker实用篇1.初识Docker1.1.什么是Docker微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 1.1.1.应用部署的环境问题大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题： 依赖关系复杂，容易出现兼容性问题 开发、测试、生产环境有差异 例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。 1.1.2.Docker解决依赖兼容问题而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？ Docker为了解决依赖的兼容问题的，采用了两个手段： 将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包 将每个应用放到一个隔离容器去运行，避免互相干扰 这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。 虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？ 1.1.3.Docker解决操作系统环境差异要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下： 结构包括： 计算机硬件：例如CPU、内存、磁盘等 系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。 系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。 应用于计算机交互的流程如下： 1）应用调用操作系统应用（函数库），实现各种功能 2）系统函数库是对内核指令集的封装，会调用内核指令 3）内核指令操作计算机硬件 Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异： 此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了： Docker如何解决不同系统环境的问题？ Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包 Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行 如图： 1.1.4.小结Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？ Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像 Docker应用运行在容器中，使用沙箱机制，相互隔离 Docker如何解决开发、测试、生产环境有差异的问题？ Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行 Docker是一个快速交付应用、运行应用的技术，具备下列优势： 可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统 运行时利用** 形成隔离容器**，各个应用互不干扰 启动、移除都可以通过一行命令完成，方便快捷 1.2.Docker和虚拟机的区别Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。 两者有什么差异呢？ 虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。 Docker仅仅是封装函数库，并没有模拟完整的操作系统，如图： 对比来看： 小结： Docker和虚拟机的差异： docker是一个系统进程；虚拟机是在操作系统中的操作系统 docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般 1.3.Docker架构1.3.1.镜像和容器Docker中有几个重要的概念： 镜像（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。 容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器进程做隔离，对外不可见。 一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的文件。只有运行时，才会加载到内存，形成进程。 而镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。 容器呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。 例如你下载了一个QQ，如果我们将QQ在磁盘上的运行文件及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。 1.3.2.DockerHub开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。 DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。 国内也有类似于DockerHub 的公开服务，比如 网易云镜像服务、阿里云镜像库等。 我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像： 1.3.3.Docker架构我们要使用Docker来操作镜像、容器，就必须要安装Docker。 Docker是一个CS架构的程序，由两部分组成： 服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等 客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。 如图： 1.3.4.小结镜像： 将应用程序及其依赖、环境、配置打包在一起 容器： 镜像运行起来就是容器，一个镜像可以运行多个容器 Docker结构： 服务端：接收命令或远程请求，操作镜像或容器 客户端：发送命令或者请求到Docker服务端 DockerHub： 一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry 1.4.安装Docker企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考课前资料中的文档： 2.Docker的基本操作0.centos启动dockerDocker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 1234# 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld 通过命令启动docker： 12345systemctl start docker # 启动docker服务systemctl stop docker # 停止docker服务systemctl restart docker # 重启docker服务 然后输入命令，可以查看docker版本： 1docker -v 如: 12[root@VM-0-5-centos ~]# docker -vDocker version 20.10.8, build 3967b7d 2.1.镜像操作1docker --help 可查看docker中的所有命令 1docker images --help 2.1.1.镜像名称首先来看下镜像的名称组成： 镜名称一般分两部分组成：[repository]:[tag]。 在没有指定tag时，默认是latest，代表最新版本的镜像 如图： 这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。 2.镜像命令/操作常见的镜像操作命令如图： 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rm image-id 删除指定的本地镜像 https://hub.docker.com/ 2.1.3.案例1-拉取、查看镜像需求：从DockerHub中拉取一个nginx镜像并查看 1）首先去镜像仓库搜索nginx镜像，比如DockerHub: 2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx 3）通过命令：docker images 查看拉取到的镜像 123[root@VM-0-5-centos ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest dd34e67e3371 13 days ago 133MB 2.1.4.案例2-保存、导入镜像需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来 1）利用docker xx –help命令查看docker save和docker load的语法 例如，查看save命令用法，可以输入命令： 1docker save --help 结果： 命令格式： 1docker save -o [保存的目标文件名称] [镜像名称] 2）使用docker save导出镜像到磁盘 运行命令： 1docker save -o nginx.tar nginx:latest 结果如图： 3）使用docker load加载镜像 先删除本地的nginx镜像： 1docker rmi nginx:latest 然后运行命令，加载本地文件： 1docker load -i nginx.tar 结果： 1234567891011[root@VM-0-5-centos ~]# docker load -i nginx.tarf68ef921efae: Loading layer [==================================================&gt;] 72.53MB/72.53MBd1279c519351: Loading layer [==================================================&gt;] 64.86MB/64.86MB678bbd796838: Loading layer [==================================================&gt;] 3.072kB/3.072kB009f1d338b57: Loading layer [==================================================&gt;] 4.096kB/4.096kB8f736d52032f: Loading layer [==================================================&gt;] 3.584kB/3.584kBfb04ab8effa8: Loading layer [==================================================&gt;] 7.168kB/7.168kBLoaded image: nginx:latest[root@VM-0-5-centos ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest dd34e67e3371 13 days ago 133MB 2.1.5.练习需求：去DockerHub搜索并拉取一个Redis镜像 目标： 1）去DockerHub搜索Redis镜像 2）查看Redis镜像的名称和版本 3）利用docker pull命令拉取镜像 4）利用docker save命令将 redis:latest打包为一个redis.tar包 5）利用docker rmi 删除本地的redis:latest 6）利用docker load 重新加载 redis.tar文件 2.2.容器操作2.2.1.容器相关命令容器操作的命令如图： 容器保护三个状态： 运行：进程正常运行 暂停：进程暂停，CPU不再运行，并不释放内存 停止：进程终止，回收进程占用的内存、CPU等资源 其中： docker run：创建并运行一个容器，处于运行状态 docker pause：让一个运行的容器暂停 docker unpause：让一个容器从暂停状态恢复运行 docker stop：停止一个运行的容器 docker start：让一个停止的容器再次运行 docker rm：删除一个容器 2.2.2.案例-创建并运行一个容器https://hub.docker.com/_/nginx 在官方镜像中都有介绍How to use this image。 创建并运行nginx容器的命令： 1docker run --name containerName -p 80:80 -d nginx 命令解读： docker run ：创建并运行一个容器 –name : 给容器起一个名字，比如叫做mn -p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 -d：后台运行容器 nginx：镜像名称，例如nginx 这里的-p参数，是将容器端口映射到宿主机端口。 默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。 现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了： 1docker run --name mn -p 80:80 -d nginx 123[root@VM-0-5-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8c282135b883 nginx \"/docker-entrypoint.…\" 41 seconds ago Up 41 seconds 0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp mn 1docker logs -f mn 2.2.3.案例-进入容器，修改文件需求：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您” 提示：进入容器要用到docker exec命令。 步骤： 1）进入容器。进入我们刚刚创建的nginx容器的命令为： 1docker exec -it mn bash 命令解读： docker exec ：进入容器内部，执行一个命令 -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 mn ：要进入的容器的名称 bash：进入容器后执行的命令，bash是一个linux终端交互命令 2）进入nginx的HTML所在目录 /usr/share/nginx/html 容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样： nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。 查看DockerHub网站中的nginx页面(Hosting some simple static content)，可以知道nginx的html目录位置在/usr/share/nginx/html 我们执行命令，进入该目录： 1cd /usr/share/nginx/html 查看目录下文件： 12root@8c282135b883:/usr/share/nginx/html# ls50x.html index.html 3）修改index.html的内容 容器内没有vi命令，无法直接修改，我们用下面的命令来修改： 1sed -i -e 's#Welcome to nginx#传智教育欢迎您#g' -e 's#&lt;head&gt;#&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;#g' index.html 在浏览器访问自己的虚拟机地址，例如我的是：http://192.168.150.101，即可看到结果： 1exit 退出 2.2.4创建并运行一个redis容器，并且支持数据持久化步骤一：到DockerHub搜索Redis镜像步骤二：查看Redis镜像文档中的帮助信息步骤三：利用docker run 命令运行一个Redis容器 1docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 123[root@VM-0-5-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3721e348e496 redis \"docker-entrypoint.s…\" 18 seconds ago Up 17 seconds 0.0.0.0:6379-&gt;6379/tcp, :::6379-&gt;6379/tcp redis 进入redis容器，并执行redis-cli客户端命令，存入num=666步骤一：进入redis容器 1docker exec -it redis bash 步骤二：执行redis-cli客户端命令 1redis-cli 也可以直接用 12[root@VM-0-5-centos ~]# docker exec -it redis redis-cli127.0.0.1:6379&gt; 得： 12root@3721e348e496:/data# redis-cli127.0.0.1:6379&gt; 步骤三：设置数据num=666 1set num 666 得： 1234127.0.0.1:6379&gt; set num 666OK127.0.0.1:6379&gt; get num\"666\" 2.2.5.小结docker run命令的常见参数有哪些？ –name：指定容器名称 -p：指定端口映射 -d：让容器后台运行 查看容器日志的命令： docker logs 添加 -f 参数可以持续查看日志 查看容器状态： docker ps docker ps -a 查看所有容器，包括已经停止的 3.数据卷（容器数据管理）在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。 这就是因为容器与数据（容器内文件）耦合带来的后果。 要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。 2.3.1.什么是数据卷数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录。 一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。 这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了 2.3.2.数据集操作命令数据卷操作的基本语法如下： 1docker volume [COMMAND] docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作： create 创建一个volume inspect 显示一个或多个volume的信息 ls 列出所有的volume prune 删除未使用的volume rm 删除一个或多个指定的volume 1234567891011121314[root@VM-0-5-centos ~]# docker volume --help Usage: docker volume COMMANDManage volumesCommands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumesRun 'docker volume COMMAND --help' for more information on a command. 2.3.3.创建和查看数据卷需求：创建一个数据卷，并查看数据卷在宿主机的目录位置 ① 创建数据卷 1docker volume create html ② 查看所有数据 1docker volume ls 结果： 1234[root@VM-0-5-centos ~]# docker volume lsDRIVER VOLUME NAMElocal 5511e44a3bb854589933ef3f2096ce5a7df5ec43b2f7279a036cb6af723c1ce4local html ③ 查看数据卷详细信息卷 1docker volume inspect html 结果： 123456789101112[root@VM-0-5-centos ~]# docker volume inspect html[ &#123; \"CreatedAt\": \"2021-08-31T11:07:21+08:00\", \"Driver\": \"local\", \"Labels\": &#123;&#125;, \"Mountpoint\": \"/var/lib/docker/volumes/html/_data\", \"Name\": \"html\", \"Options\": &#123;&#125;, \"Scope\": \"local\" &#125;] 可以看到，我们创建的html这个数据卷关联的宿主机目录为/var/lib/docker/volumes/html/_data目录。 小结： 数据卷的作用： 将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全 数据卷操作： docker volume create：创建数据卷 docker volume ls：查看所有数据卷 docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置 docker volume rm：删除指定数据卷 docker volume prune：删除所有未使用的数据卷 4.挂载数据卷我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下： 12345docker run \\ --name mn \\ -v html:/root/html \\ -p 8080:80 nginx \\ 这里的-v就是挂载数据卷的命令： -v html:/root/html ：把html数据卷挂载到容器内的/root/html这个目录中 注：如果数据卷html不存在，docker会去创建一个 2.3.5.案例-给nginx挂载数据卷需求：创建一个nginx容器，修改容器内的html目录内的index.html内容 分析：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。 提示：运行容器时使用 -v 参数挂载数据卷 步骤： ① 创建容器并挂载数据卷到容器内的HTML目录 1docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx ② 进入html数据卷所在位置，并修改HTML内容 123456# 查看html数据卷的位置docker volume inspect html# 进入该目录cd /var/lib/docker/volumes/html/_data# 修改文件vi index.html 2.3.6.案例-给MySQL挂载本地目录容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下： 带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录 直接挂载模式：宿主机目录 —&gt; 容器内目录 如图： 语法： 目录挂载与数据卷挂载的语法是类似的： -v [宿主机目录]:[容器内目录] -v [宿主机文件]:[容器内文件] 需求：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器 实现思路如下： 1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像 1docker load -i mysql.tar 2）创建目录/tmp/mysql/data 12mkdir -p mysql/datamkdir -p mysql/conf 1234567891011121314[root@VM-0-5-centos tmp]# mkdir --help Usage: mkdir [OPTION]... DIRECTORY...Create the DIRECTORY(ies), if they do not already exist.Mandatory arguments to long options are mandatory for short options too. -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask -p, --parents no error if existing, make parent directories as needed -v, --verbose print a message for each created directory -Z set SELinux security context of each created directory to the default type --context[=CTX] like -Z, or if CTX is specified then set the SELinux or SMACK security context to CTX --help display this help and exit --version output version information and exit 3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf 4）去DockerHub查阅资料，创建并运行MySQL容器，要求： ① 挂载/tmp/mysql/data到mysql容器内数据存储目录 ② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件 ③ 设置MySQL密码 1docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 1234567docker run \\ --name some-mysql \\ -p 3306:3306 \\ -v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf \\ -v /tmp/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123 \\ -d mysql:5.7.25 2.3.7.小结docker run的命令中通过 -v 参数挂载文件或目录到容器中： -v volume名称:容器内目录 -v 宿主机文件:容器内文件 -v 宿主机目录:容器内目录 数据卷挂载与目录直接挂载的 数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找 目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看 3.Dockerfile自定义镜像常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。 而要自定义镜像，就必须先了解镜像的结构才行。 3.1.镜像结构镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。 我们以MySQL为例，来看看镜像的组成结构： 简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。 我们要构建镜像，其实就是实现上述打包的过程。 3.2.Dockerfile语法构建自定义的镜像时，并不需要一个个文件去拷贝，打包。 我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。 而描述上述信息的文件就是Dockerfile文件。 Dockerfile就是一个文本文件，其中包含一个个的指令(Instruction)，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。 更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder 3.3.构建Java项目3.3.1.基于Ubuntu构建Java项目需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目 步骤1：新建一个空文件夹docker-demo 1mkdir docker-demo 步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录 步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录 步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录 12345[root@VM-0-5-centos docker-demo]# lltotal 96896-rw-r--r-- 1 root root 25620395 Aug 31 15:41 docker-demo.jar-rw-r--r-- 1 root root 494 Aug 31 15:40 Dockerfile-rw-r--r-- 1 root root 73596928 Aug 31 15:41 jdk8.tar.gz 其中的内容如下： 12345678910111213141516171819202122# 指定基础镜像FROM ubuntu:16.04# 配置环境变量，JDK的安装目录ENV JAVA_DIR=/usr/local# 拷贝jdk和java项目的包COPY ./jdk8.tar.gz $JAVA_DIR/COPY ./docker-demo.jar /tmp/app.jar# 安装JDKRUN cd $JAVA_DIR \\ &amp;&amp; tar -xf ./jdk8.tar.gz \\ &amp;&amp; mv ./jdk1.8.0_144 ./java8# 配置环境变量ENV JAVA_HOME=$JAVA_DIR/java8ENV PATH=$PATH:$JAVA_HOME/bin# 暴露端口EXPOSE 8090# 入口，java项目的启动命令ENTRYPOINT java -jar /tmp/app.jar 步骤5：进入docker-demo 将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下 步骤6：运行命令： 1docker build -t javaweb:1.0 . 1docker run --name web -p 8090:8090 -d javaweb:1.0 最后访问 http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip 3.3.2.基于java8构建Java项目虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。 例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。 需求：基于java:8-alpine镜像，将一个Java项目构建为镜像 实现思路如下： ① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile ② 拷贝课前资料提供的docker-demo.jar到这个目录中 ③ 编写Dockerfile文件： a ）基于java:8-alpine作为基础镜像 b ）将app.jar拷贝到镜像中 c ）暴露端口 d ）编写入口ENTRYPOINT 内容如下： 1234FROM java:8-alpineCOPY ./app.jar /tmp/app.jarEXPOSE 8090ENTRYPOINT java -jar /tmp/app.jar ④ 使用docker build命令构建镜像 1docker build -t javaweb:2.0 . ⑤ 使用docker run创建容器并运行 3.4.小结小结： Dockerfile的本质是一个文件，通过指令描述镜像的构建过程 Dockerfile的第一行必须是FROM，从一个基础镜像来构建 基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine 4.Docker-ComposeDocker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！ 4.1.初识DockerComposeCompose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下： 12345678910111213version: \"3.8\" services: mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - \"/tmp/mysql/data:/var/lib/mysql\" - \"/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf\" web: build: . ports: - \"8090:8090\" 上面的Compose文件就描述一个项目，其中包含两个容器： mysql：一个基于mysql:5.7.25镜像构建的容器，并且挂载了两个目录 web：一个基于docker build临时构建的镜像容器，映射端口时8090 DockerCompose的详细语法参考官网：https://docs.docker.com/compose/compose-file/ 其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。 4.2.安装DockerCompose参考课前资料 Centos7安装Docker.md 4.3.部署微服务集群需求：将之前学习的cloud-demo微服务集群利用DockerCompose部署 实现思路： ① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件 ② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名 https://www.bilibili.com/video/BV1LQ4y127n4?p=59 ③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar ④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中 ⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署 4.3.1.compose文件查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录： 内容如下： 123456789101112131415161718192021222324version: \"3.2\"services: nacos: image: nacos/nacos-server environment: MODE: standalone ports: - \"8848:8848\" mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - \"$PWD/mysql/data:/var/lib/mysql\" - \"$PWD/mysql/conf:/etc/mysql/conf.d/\" userservice: build: ./user-service orderservice: build: ./order-service gateway: build: ./gateway ports: - \"10010:10010\" 可以看到，其中包含5个service服务： nacos：作为注册中心和配置中心 image: nacos/nacos-server： 基于nacos/nacos-server镜像构建 environment：环境变量 MODE: standalone：单点模式启动 ports：端口映射，这里暴露了8848端口 mysql：数据库 image: mysql:5.7.25：镜像版本是mysql:5.7.25 environment：环境变量 MYSQL_ROOT_PASSWORD: 123：设置数据库root账户的密码为123 volumes：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据 userservice、orderservice、gateway：都是基于Dockerfile临时构建的 查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表： 查看微服务目录，可以看到都包含Dockerfile文件： 内容如下： 123FROM java:8-alpineCOPY ./app.jar /tmp/app.jarENTRYPOINT java -jar /tmp/app.jar 4.3.2.修改微服务配置因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。 如下所示： 1234567891011spring: datasource: url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false username: root password: 123 driver-class-name: com.mysql.jdbc.Driver application: name: orderservice cloud: nacos: server-addr: nacos:8848 # nacos服务地址 4.3.3.打包接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。 可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改： 12345678910&lt;build&gt; &lt;!-- 服务打包的最终名称 --&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 打包后： 4.3.4.拷贝jar包到部署目录编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。 user-service： order-service： gateway： 4.3.5.部署最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。 上传到任意目录： 部署： 进入cloud-demo目录，然后运行下面的命令： 1docker-compose up -d 查看日志，发现userservice服务未发现nacos 123[root@localhost cloud-demo]# docker-compose logs -fuserservice_1 | com.alibaba.nacos.api.exception.NacosException: failed to req API:/nacos/v1/ns/instance/list after all servers([nacos:8848]) tried: java.net.ConnectException: Connection refused (Connection refused) 原因是服务建立时，nacos还未安装好，重启服务即可 1234[root@localhost cloud-demo]# docker-compose restart gateway userservice orderserviceRestarting cloud-demo_userservice_1 ... doneRestarting cloud-demo_orderservice_1 ... doneRestarting cloud-demo_gateway_1 ... done 1docker-compose logs -f userservice 未发现错误 用浏览器访问http://192.168.194.128:10010/user/1?authorization=admin正常 5.Docker镜像仓库常见镜像仓库服务 镜像仓库（ Docker Registry ）有公共的和私有的两种形式：公共仓库：例如Docker官方的 Docker Hub，国内也有一些云服务商提供类似于 Docker Hub 的公开服务，比如 网易云镜像服务、DaoCloud 镜像服务、阿里云镜像服务等。除了使用公开仓库外，用户还可以在本地搭建私有 Docker Registry。企业自己的镜像最好是采用私有Docker Registry来实现。 5.1.搭建私有镜像仓库参考课前资料《CentOS7安装Docker.md》 5.2.推送、拉取镜像推送镜像到私有镜像服务必须先tag，步骤如下： ① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/ 1docker tag nginx:latest 192.168.194.128:8080/nginx:1.0 ② 推送镜像 1docker push 192.168.194.128:8080/nginx:1.0 ③ 拉取镜像 1docker pull 192.168.194.128:8080/nginx:1.0","categories":[{"name":"Docker","slug":"Docker","permalink":"https://codeofli.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://codeofli.github.io/tags/Docker/"}]},{"title":"RabbitMQ","slug":"java-note/SpringCloud/RabbitMQ/RabbitMQ","date":"2021-10-25T02:40:06.000Z","updated":"2022-03-02T01:21:40.380Z","comments":true,"path":"2021/10/java-note/SpringCloud/RabbitMQ/RabbitMQ/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/RabbitMQ/RabbitMQ/","excerpt":"RabbitMQ1.初识MQ1.1.同步和异步通讯微服务间通讯有同步和异步两种方式：同步通讯：就像打电话，需要实时响应。异步通讯：就像发邮件，不需要马上回复。两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。1.1.1.同步通讯","text":"RabbitMQ1.初识MQ1.1.同步和异步通讯微服务间通讯有同步和异步两种方式：同步通讯：就像打电话，需要实时响应。异步通讯：就像发邮件，不需要马上回复。两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。1.1.1.同步通讯 我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题： 总结： 同步调用的优点： 时效性较强，可以立即得到结果 同步调用的问题： 耦合度高 性能和吞吐能力下降 有额外的资源消耗 有级联失败问题 1.1.2.异步通讯 )) 我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。 在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。 订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。 为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。 Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。 好处： 吞吐量提升：无需等待订阅者处理完成，响应更快速 故障隔离：服务没有直接调用，不存在级联失败问题 调用间没有阻塞，不会造成无效的资源占用 耦合度极低，每个服务都可以灵活插拔，可替换 流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件 缺点： 架构复杂了，业务没有明显的流程线，不好管理 需要依赖于Broker的可靠、安全、性能 好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。 1.2.技术对比：MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。 比较常见的MQ实现： ActiveMQ RabbitMQ RocketMQ Kafka 几种常见MQ的对比： RabbitMQ ActiveMQ RocketMQ Kafka 公司/社区 Rabbit Apache 阿里 Apache 开发语言 Erlang Java Java Scala&amp;Java 协议支持 AMQP，XMPP，SMTP，STOMP OpenWire,STOMP，REST,XMPP,AMQP 自定义协议 自定义协议 可用性 高 一般 高 高 单机吞吐量 一般 差 高 非常高 消息延迟 微秒级 毫秒级 毫秒级 毫秒以内 消息可靠性 高 一般 高 一般 追求可用性：Kafka、 RocketMQ 、RabbitMQ 追求可靠性：RabbitMQ、RocketMQ 追求吞吐能力：RocketMQ、Kafka 追求消息低延迟：RabbitMQ、Kafka 2.RabbitMQ快速入门2.1.安装RabbitMQRabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：https://www.rabbitmq.com/ 安装RabbitMQ，参考课前资料：RabbitMQ部署指南.md MQ的基本结构： RabbitMQ中的一些角色： publisher：生产者 consumer：消费者 exchange个：交换机，负责消息路由 queue：队列，存储消息 virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离 2.2.RabbitMQ常见消息模型RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型： 2.3.导入Demo工程课前资料提供了一个Demo工程，mq-demo: 导入后可以看到结构如下： 包括三部分： mq-demo：父工程，管理项目依赖 publisher：消息的发送者 consumer：消息的消费者 2.4.入门案例HelloWorld案例： 简单队列模式的模型图： 官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色： publisher：消息发布者，将消息发送到队列queue queue：消息队列，负责接受并缓存消息 consumer：订阅队列，处理队列中的消息 2.4.1.publisher实现思路： 建立连接 创建Channel 声明队列 发送消息 关闭连接和channel 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast.mq.helloworld;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import org.junit.Test;import java.io.IOException;import java.util.concurrent.TimeoutException;public class PublisherTest &#123; @Test public void testSendMessage() throws IOException, TimeoutException &#123; // 1.建立连接 ConnectionFactory factory = new ConnectionFactory(); // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码 factory.setHost(\"192.168.150.101\"); factory.setPort(5672); factory.setVirtualHost(\"/\"); factory.setUsername(\"itcast\"); factory.setPassword(\"123321\"); // 1.2.建立连接 Connection connection = factory.newConnection(); // 2.创建通道Channel Channel channel = connection.createChannel(); // 3.创建队列 String queueName = \"simple.queue\"; channel.queueDeclare(queueName, false, false, false, null); // 4.发送消息 String message = \"hello, rabbitmq!\"; channel.basicPublish(\"\", queueName, null, message.getBytes()); System.out.println(\"发送消息成功：【\" + message + \"】\"); // 5.关闭通道和连接 channel.close(); connection.close(); &#125;&#125; 2.4.2.consumer实现代码思路： 建立连接 创建Channel 声明队列 订阅消息 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.itcast.mq.helloworld;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class ConsumerTest &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; // 1.建立连接 ConnectionFactory factory = new ConnectionFactory(); // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码 factory.setHost(\"192.168.150.101\"); factory.setPort(5672); factory.setVirtualHost(\"/\"); factory.setUsername(\"itcast\"); factory.setPassword(\"123321\"); // 1.2.建立连接 Connection connection = factory.newConnection(); // 2.创建通道Channel Channel channel = connection.createChannel(); // 3.创建队列 String queueName = \"simple.queue\"; channel.queueDeclare(queueName, false, false, false, null); // 4.订阅消息 channel.basicConsume(queueName, true, new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; // 5.处理消息 String message = new String(body); System.out.println(\"接收到消息：【\" + message + \"】\"); &#125; &#125;); System.out.println(\"等待接收消息。。。。\"); &#125;&#125; 2.5.总结基本消息队列的消息发送流程： 建立connection 创建channel 利用channel声明队列 利用channel向队列发送消息 基本消息队列的消息接收流程： 建立connection 创建channel 利用channel声明队列 定义consumer的消费行为handleDelivery() 利用channel将消费者与队列绑定 3.SpringAMQPSpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。 SpringAmqp的官方地址：https://spring.io/projects/spring-amqp SpringAMQP提供了三个功能： 自动声明队列、交换机及其绑定关系 基于注解的监听器模式，异步接收消息 封装了RabbitTemplate工具，用于发送消息 3.1.Basic Queue 简单队列模型在父工程mq-demo中引入依赖 12345&lt;!--AMQP依赖，包含RabbitMQ--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 3.1.1.消息发送首先配置MQ地址，在publisher服务的application.yml中添加配置： 1234567spring: rabbitmq: host: 192.168.194.128 # rabbitMQ的ip地址 port: 5672 # 端口 virtual-host: / # 虚拟主机 username: itcast # 用户名 password: 123321 # 密码 然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送： 1234567891011121314151617181920212223242526package cn.itcast.mq.spring;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringAmqpTest &#123; @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSendMessage2SimpleQueue() &#123; // 队列名称 String queueName = \"simple.queue\"; // 消息 String message = \"hello, spring amqp!\"; // 发送消息 rabbitTemplate.convertAndSend(queueName, message); &#125;&#125; 3.1.2.消息接收首先配置MQ地址，在consumer服务的application.yml中添加配置： 1234567spring: rabbitmq: host: 192.168.194.128 # rabbitMQ的ip地址 port: 5672 # 端口 virtual-host: / # 虚拟主机 username: itcast # 用户名 password: 123321 # 密码 然后在consumer服务的cn.itcast.mq.listener包中新建一个类SpringRabbitListener，代码如下： 12345678910111213package cn.itcast.mq.listener;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Componentpublic class SpringRabbitListener &#123; @RabbitListener(queues = \"simple.queue\") public void listenSimpleQueueMessage(String msg) throws InterruptedException &#123; System.out.println(\"spring 消费者接收到消息：【\" + msg + \"】\"); &#125;&#125; 3.1.3.测试启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息 3.2.WorkQueueWork queues，也被称为（Task queues），任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。 当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。 此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。 3.2.1.消息发送这次我们循环发送，模拟大量消息堆积现象。 在publisher服务中的SpringAmqpTest类中添加一个测试方法： 12345678910111213141516/** * workQueue * 向队列中不停发送消息，模拟消息堆积。 */@Testpublic void testWorkQueue() throws InterruptedException &#123; // 队列名称 String queueName = \"simple.queue\"; // 消息 String message = \"hello, message_\"; for (int i = 0; i &lt; 50; i++) &#123; // 发送消息 rabbitTemplate.convertAndSend(queueName, message + i); Thread.sleep(20); &#125;&#125; 3.2.2.消息接收要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法： 1234567891011@RabbitListener(queues = \"simple.queue\")public void listenWorkQueue1(String msg) throws InterruptedException &#123; System.out.println(\"消费者1接收到消息：【\" + msg + \"】\" + LocalTime.now()); Thread.sleep(20);&#125;@RabbitListener(queues = \"simple.queue\")public void listenWorkQueue2(String msg) throws InterruptedException &#123; System.err.println(\"消费者2........接收到消息：【\" + msg + \"】\" + LocalTime.now()); Thread.sleep(200);&#125; 注意到这个消费者sleep了1000秒，模拟任务耗时。 3.2.3.测试启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。 可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。 也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。 3.2.4.能者多劳消费预取限制修改application.yml文件，设置preFetch这个值，可以控制预取消息的上限（默认250条）: 12345678910spring: rabbitmq: host: 192.168.150.101 #主机名 port: 5672#端口 virtual-host: /#虚拟主机 username: itcast #用户名 password: 123321 #密码 listener: simple: prefetch: 1 #每次只能获取一条消息，处理完成才能获取下一个消息 在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置： 12345spring: rabbitmq: listener: simple: prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息 3.2.5.总结Work模型的使用： 多个消费者绑定到一个队列，同一条消息只会被一个消费者处理 通过设置prefetch来控制消费者预取的消息数量 3.3.发布/订阅(Exchange)发布订阅的模型如图： 可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化： Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机） Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型： Fanout：广播，将消息交给所有绑定到交换机的队列 Direct：定向，把消息交给符合指定routing key 的队列 Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列 Consumer：消费者，与以前一样，订阅队列，没有变化 Queue：消息队列也与以前一样，接收消息、缓存消息。 Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！ 3.4.FanoutFanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。 在广播模式下，消息发送流程是这样的： 1） 可以有多个队列 2） 每个队列都要绑定到Exchange（交换机） 3） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定 4） 交换机把消息发送给绑定过的所有队列 5） 订阅队列的消费者都能拿到消息 我们的计划是这样的： 创建一个交换机 itcast.fanout，类型是Fanout 创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout 3.4.1.声明队列和交换机Spring提供了一个接口Exchange，来表示所有不同类型的交换机： 在consumer中创建一个类，声明队列和交换机： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.itcast.mq.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.FanoutExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FanoutConfig &#123; /** * 声明交换机 * @return Fanout类型交换机 */ @Bean public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(\"itcast.fanout\"); &#125; /** * 第1个队列 */ @Bean public Queue fanoutQueue1()&#123; return new Queue(\"fanout.queue1\"); &#125; /** * 绑定队列和交换机 */ @Bean public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange)&#123; return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); &#125; /** * 第2个队列 */ @Bean public Queue fanoutQueue2()&#123; return new Queue(\"fanout.queue2\"); &#125; /** * 绑定队列和交换机 */ @Bean public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange)&#123; return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange); &#125;&#125; 3.4.2.消息接收在consumer服务的SpringRabbitListener中添加两个方法，作为消费者： 123456789@RabbitListener(queues = \"fanout.queue1\")public void listenFanoutQueue1(String msg) &#123; System.out.println(\"消费者1接收到Fanout消息：【\" + msg + \"】\");&#125;@RabbitListener(queues = \"fanout.queue2\")public void listenFanoutQueue2(String msg) &#123; System.out.println(\"消费者2接收到Fanout消息：【\" + msg + \"】\");&#125; 3.4.3.消息发送在publisher服务的SpringAmqpTest类中添加测试方法： 123456789@Testpublic void testFanoutExchange() &#123; // 交换机名称 String exchangeName = \"itcast.fanout\"; // 消息 String message = \"hello, everyone!\"; //发送消息 rabbitTemplate.convertAndSend(exchangeName, \"\", message);&#125; 3.4.4.总结交换机的作用是什么？ 接收publisher发送的消息 将消息按照规则路由到与之绑定的队列 不能缓存消息，路由失败，消息丢失 FanoutExchange的会将消息路由到每个绑定的队列 声明队列、交换机、绑定关系的Bean是什么？ Queue FanoutExchange Binding 3.5.Direct在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。 在Direct模型下： 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。 Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息 案例需求如下： 利用@RabbitListener声明Exchange、Queue、RoutingKey 在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2 在publisher中编写测试方法，向itcast. direct发送消息 3.5.1.基于注解声明队列和交换机基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。 在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机： 1234567891011121314151617@RabbitListener(bindings = @QueueBinding( value = @Queue(name = \"direct.queue1\"), exchange = @Exchange(name = \"itcast.direct\", type = ExchangeTypes.DIRECT), key = &#123;\"red\", \"blue\"&#125;))public void listenDirectQueue1(String msg)&#123; System.out.println(\"消费者接收到direct.queue1的消息：【\" + msg + \"】\");&#125;@RabbitListener(bindings = @QueueBinding( value = @Queue(name = \"direct.queue2\"), exchange = @Exchange(name = \"itcast.direct\", type = ExchangeTypes.DIRECT), key = &#123;\"red\", \"yellow\"&#125;))public void listenDirectQueue2(String msg)&#123; System.out.println(\"消费者接收到direct.queue2的消息：【\" + msg + \"】\");&#125; 3.5.2.消息发送在publisher服务的SpringAmqpTest类中添加测试方法： 123456789@Testpublic void testSendDirectExchange() &#123; // 交换机名称 String exchangeName = \"itcast.direct\"; // 消息 String message = \"红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！\"; // 发送消息 rabbitTemplate.convertAndSend(exchangeName, \"red\", message);&#125; 3.5.3.总结描述下Direct交换机与Fanout交换机的差异？ Fanout交换机将消息路由给每一个与之绑定的队列 Direct交换机根据RoutingKey判断路由给哪个队列 如果多个队列具有相同的RoutingKey，则与Fanout功能类似 基于@RabbitListener注解声明队列和交换机有哪些常见注解？ @Queue @Exchange 3.6.Topic3.6.1.说明Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！ Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert 通配符规则： #：匹配一个或多个词 *：匹配不多不少恰好1个词 举例： item.#：能够匹配item.spu.insert 或者 item.spu item.*：只能匹配item.spu ​ 图示： 解释： Queue1：绑定的是china.# ，因此凡是以 china.开头的routing key 都会被匹配到。包括china.news和china.weather Queue2：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配。包括china.news和japan.news 案例需求： 实现思路如下： 并利用@RabbitListener声明Exchange、Queue、RoutingKey 在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2 在publisher中编写测试方法，向itcast. topic发送消息 3.6.2.消息接收在consumer服务的SpringRabbitListener中添加方法： 1234567891011121314151617@RabbitListener(bindings = @QueueBinding( value = @Queue(name = \"topic.queue1\"), exchange = @Exchange(name = \"itcast.topic\", type = ExchangeTypes.TOPIC), key = \"china.#\"))public void listenTopicQueue1(String msg)&#123; System.out.println(\"消费者接收到topic.queue1的消息：【\" + msg + \"】\");&#125;@RabbitListener(bindings = @QueueBinding( value = @Queue(name = \"topic.queue2\"), exchange = @Exchange(name = \"itcast.topic\", type = ExchangeTypes.TOPIC), key = \"#.news\"))public void listenTopicQueue2(String msg)&#123; System.out.println(\"消费者接收到topic.queue2的消息：【\" + msg + \"】\");&#125; 3.6.3.消息发送在publisher服务的SpringAmqpTest类中添加测试方法： 123456789101112/** * topicExchange */@Testpublic void testSendTopicExchange() &#123; // 交换机名称 String exchangeName = \"itcast.topic\"; // 消息 String message = \"喜报！孙悟空大战哥斯拉，胜!\"; // 发送消息 rabbitTemplate.convertAndSend(exchangeName, \"china.news\", message);&#125; 3.6.4.总结描述下Direct交换机与Topic交换机的差异？ Topic交换机接收的消息RoutingKey必须是多个单词，以 **.** 分割 Topic交换机与队列绑定时的bindingKey可以指定通配符 #：代表0个或多个词 *：代表1个词 3.7.消息转换器Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。 只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题： 数据体积过大 有安全漏洞 可读性差 3.7.1.测试默认转换器测试发送Object类型消息 说明：在SpringAMQP的发送方法中，接收消息的类型是Object，也就是说我们可以发送任意对象类型的消息，SpringAMQP会帮我们序列化为字节后发送。我们在consumer中利用@Bean声明一个队列： 我们在consumer中利用@Bean声明一个队列： 1234567@Configurationpublic class FanoutConfig &#123; @Bean public Queue objectQueue() &#123; return new Queue(\"object.queue\"); &#125;&#125; 在publisher中发送消息以测试： 123456789@Testpublic void testSendObjectQueue() throws InterruptedException &#123; // 准备消息 Map&lt;String,Object&gt; msg = new HashMap&lt;&gt;(); msg.put(\"name\", \"Jack\"); msg.put(\"age\", 21); // 发送消息 rabbitTemplate.convertAndSend(\"object.queue\", msg);&#125; 发送消息后查看控制台： 3.7.2.配置JSON转换器显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。 Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。如果要修改只需要定义一个MessageConverter 类型的Bean即可。推荐用JSON方式序列化，步骤如下： 在publisher和consumer两个服务中都引入依赖,直接放在父目录pom.xml中： 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.10&lt;/version&gt;&lt;/dependency&gt; 或 1234&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt; 我们在publisher和consumer服务声明MessageConverter，可直接放在启动类中： 1234@Beanpublic MessageConverter jsonMessageConverter()&#123; return new Jackson2JsonMessageConverter();&#125; 再次测试发送object到队列中，查看后有 然后定义一个消费者，监听object.queue队列并消费消息： 1234@RabbitListener(queues = \"object.queue\")public void listenObjectQueue(Map&lt;String, Object&gt; msg) &#123; System.out.println(\"收到消息：【\" + msg + \"】\");&#125;","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://codeofli.github.io/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://codeofli.github.io/tags/RabbitMQ/"}]},{"title":"RabbitMQ部署指南","slug":"java-note/SpringCloud/RabbitMQ/RabbitMQ部署指南/RabbitMQ部署指南","date":"2021-10-25T02:40:06.000Z","updated":"2022-03-02T01:21:40.380Z","comments":true,"path":"2021/10/java-note/SpringCloud/RabbitMQ/RabbitMQ部署指南/RabbitMQ部署指南/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/RabbitMQ/RabbitMQ部署指南/RabbitMQ部署指南/","excerpt":"RabbitMQ部署指南1.单机部署我们在Centos7虚拟机中使用Docker来安装。1.1.下载镜像方式一：在线拉取1docker pull rabbitmq:3-management方式二：从本地加载在课前资料已经提供了镜像包： 上传到虚拟机中后，使用命令加载镜像即可：1docker load -i mq.tar","text":"RabbitMQ部署指南1.单机部署我们在Centos7虚拟机中使用Docker来安装。1.1.下载镜像方式一：在线拉取1docker pull rabbitmq:3-management方式二：从本地加载在课前资料已经提供了镜像包： 上传到虚拟机中后，使用命令加载镜像即可：1docker load -i mq.tar 1.2.安装MQ执行下面的命令来运行MQ容器： 123456789docker run \\ -e RABBITMQ_DEFAULT_USER=itcast \\ -e RABBITMQ_DEFAULT_PASS=123321 \\ --name mq \\ --hostname mq1 \\ -p 15672:15672 \\ -p 5672:5672 \\ -d \\ rabbitmq:3-management 浏览器访问（ip自己改）http://192.168.194.128:15672/， 2.集群部署接下来，我们看看如何安装RabbitMQ的集群。 2.1.集群分类在RabbitMQ的官方文档中，讲述了两种集群的配置方式： 普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。 镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。 我们先来看普通模式集群。 2.2.设置网络首先，我们需要让3台MQ互相知道对方的存在。 分别在3台机器中，设置 /etc/hosts文件，添加如下内容： 123192.168.150.101 mq1192.168.150.102 mq2192.168.150.103 mq3 并在每台机器上测试，是否可以ping通对方：","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://codeofli.github.io/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://codeofli.github.io/tags/RabbitMQ/"}]},{"title":"分布式事务seata","slug":"java-note/SpringCloud/Seata/Seate","date":"2021-10-24T02:40:06.000Z","updated":"2022-03-02T01:21:40.533Z","comments":true,"path":"2021/10/java-note/SpringCloud/Seata/Seate/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/Seata/Seate/","excerpt":"分布式事务seata事务的ACID原则演示分布式事务问题 创建数据库，名为seata_demo，然后导入课前资料提供的SQL文件： 1seata-demo.sql 导入课前资料提供的微服务: seata-demo（文件夹） 启动nacos、所有微服务 测试下单功能，发出Post请求: 12curl --location --request POST 'http://localhost:8082/order?userId=user202103032042012&amp;commodityCode=100202003032041&amp;count=2&amp;money=200'","text":"分布式事务seata事务的ACID原则演示分布式事务问题 创建数据库，名为seata_demo，然后导入课前资料提供的SQL文件： 1seata-demo.sql 导入课前资料提供的微服务: seata-demo（文件夹） 启动nacos、所有微服务 测试下单功能，发出Post请求: 12curl --location --request POST 'http://localhost:8082/order?userId=user202103032042012&amp;commodityCode=100202003032041&amp;count=2&amp;money=200' 分布式服务的事务问题在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务，要保证所有分支事务最终状态一致，这样的事务就是分布式事务。 学习目标 1理论基础CAP定理1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标： Consistency（一致性） Availability（可用性） Partition tolerance （分区容错性） Eric Brewer 说，分布式系统无法同时满足这三个指标。这个结论就叫做 CAP 定理。 CAP定理- ConsistencyConsistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致 CAP定理- AvailabilityAvailability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝 CAP定理-Partition tolerancePartition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务 总结简述CAP定理内容？ 分布式系统节点通过网络连接，一定会出现分区问题（P）当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足 思考：elasticsearch集群是CP还是AP？ ES集群出现分区时，故障节点会被剔除集群，数据分片会重新分配到其它节点，保证数据一致。因此是低可用性，高一致性，属于CP BASE理论BASE理论是对CAP的一种解决思路，包含三个思想： Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。 Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。 Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。 而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论： AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。 CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。 分布式事务模型解决分布式事务，各个子系统之间必须能感知到彼此的事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者（子系统事务）。这里的子系统事务，称为分支事务；有关联的各个分支事务在一起称为全局事务 总结 简述BASE理论三个思想： 基本可用 软状态 最终一致 解决分布式事务的思想和模型： 全局事务：整个分布式事务 分支事务：分布式事务中包含的每个子系统的事务 最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据 强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚 2初识SeataSeata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。官网地址：http://seata.io/，其中的文档、播客中提供了大量的使用说明、源码分析。 Seata架构Seata事务管理中有三个重要的角色： TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。 TM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。 RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。 初识SeataSeata提供了四种不同的分布式事务解决方案： XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入 TCC模式：最终一致的分阶段事务模式，有业务侵入AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式SAGA模式：长事务模式，有业务侵入 部署TC服务参考课前资料提供的文档《 seata的部署和集成》： 3动手实践XA模式XA模式原理XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。 seata的XA模式seata的XA模式做了一些调整，但大体相似： TM (Transaction Manager) - 事务管理器RM一阶段的工作： 注册分支事务到TC 执行分支业务sql但不提交 报告执行状态到TC TC(TC (Transaction Coordinator) - 事务协调者)二阶段的工作： TC检测各分支事务执行状态a. 如果都成功，通知所有RM提交事务b. 如果有失败，通知所有RM回滚事务 RM二阶段的工作： 接收TC指令，提交或回滚事务 XA模式的优点是什么？ 事务的强一致性，满足ACID原则。 常用数据库都支持，实现简单，并且没有代码侵入 XA模式的缺点是什么？ 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差 依赖关系型数据库实现事务 实现XA模式Seata的starter已经完成了XA模式的自动装配，实现非常简单，步骤如下： 修改application.yml文件（每个参与事务的微服务），开启XA模式： 12seata: data-source-proxy-mode: XA #开启数据源代理的XA模式 2.给发起全局事务的入口方法添加@GlobalTransactional注解，本例中是OrderServiceImpl中的create方法： 1234567891011121314151617@Override@GlobalTransactionalpublic Long create(Order order) &#123; // 创建订单 orderMapper.insert(order); try &#123; // 扣用户余额 accountClient.deduct(order.getUserId(), order.getMoney()); // 扣库存 storageClient.deduct(order.getCommodityCode(), order.getCount()); &#125; catch (FeignException e) &#123; log.error(\"下单失败，原因:&#123;&#125;\", e.contentUTF8(), e); throw new RuntimeException(e.contentUTF8(), e); &#125; return order.getId();&#125; 3.重启服务并测试 postman上测试 count=10时，数据库数据均未修改 AT模式AT模式原理AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。 阶段一RM的工作： 注册分支事务 记录undo-log（数据快照） 执行业务sql并提交 报告事务状态 阶段二提交时RM的工作： 删除undo-log即可 阶段二回滚时RM的工作： 根据undo-log恢复数据到更新前 例如，一个分支业务的SQL是这样的：update tb_account set money = money - 10 where id = 1 简述AT模式与XA模式最大的区别是什么？ XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。 XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。 XA模式强一致；AT模式最终一致 AT模式的脏写问题脏写 脏写，意思是说有两个事务，事务 A 和事务 B 同时在更新一条数据，事务 A 先把它更新为 A 值，事务 B 紧接着就把它更新为 B 值。如图： 可以看到，此时事务 B 是后更新那行数据的值，所以此时那行数据的值是 B。而且此时事务 A 更新之后会记录一条 undo log 日志。因为事务 A 是先更新的，它在更新之前，这行数据的值为 NULL。所以此时事务 A 的 undo log 日志大概就是：更新之前这行数据的值为 NULL，主键为 XX 那么此时事务 B 更新完数据的值为 B，此时事务 A 突然回滚了，就会用它的 undo log 日志去回滚。此时事务 A 一回滚，直接就会把那行数据的值更新回 NULL 值。如图： 然后就尴尬了，事务 B 一看，为什么我更新的 B 值没了？就因为你事务 A 反悔了把数据值回滚成 NULL 了，结果我更新的 B 值也不见 了。所以对于事务 B 看到的场景而言，就是自己明明更新了，结果值却没了，这就是脏写。 所谓脏写，就是我刚才明明写了一个数据值，结果过了一会却没了。而它的本质就是事务 B 去修改了事务 A 修改过的值，但是此时事务 A 还没提交，所以事务 A 随时会回滚，导致事务 B 修改的值也没了，这就是脏写的定义。 AT模式的优点： 一阶段完成直接提交事务，释放数据库资源，性能比较好 利用全局锁实现读写隔离 没有代码侵入，框架自动完成回滚和提交 AT模式的缺点： 两阶段之间属于软状态，属于最终一致 框架的快照功能会影响性能，但比XA模式要好很多 实现AT模式AT模式中的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单。1.导入课前资料提供的Sql文件：seata-at.sql，其中lock_table导入到TC服务关联的数据库，undo_log表导入到微服务关联的数据库： 1seata-at.sql lock_table导入到TC服务关联的数据库 1234567891011121314151617-- ------------------------------ Table structure for lock_table-- ----------------------------DROP TABLE IF EXISTS `lock_table`;CREATE TABLE `lock_table` ( `row_key` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `xid` varchar(96) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `transaction_id` bigint(20) NULL DEFAULT NULL, `branch_id` bigint(20) NOT NULL, `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `table_name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `pk` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `gmt_create` datetime NULL DEFAULT NULL, `gmt_modified` datetime NULL DEFAULT NULL, PRIMARY KEY (`row_key`) USING BTREE, INDEX `idx_branch_id`(`branch_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact; undo_log表导入到微服务关联的数据库 123456789101112131415161718-- ------------------------------ Table structure for undo_log-- ----------------------------DROP TABLE IF EXISTS `undo_log`;CREATE TABLE `undo_log` ( `branch_id` bigint(20) NOT NULL COMMENT 'branch transaction id', `xid` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'global transaction id', `context` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'undo_log context,such as serialization', `rollback_info` longblob NOT NULL COMMENT 'rollback info', `log_status` int(11) NOT NULL COMMENT '0:normal status,1:defense status', `log_created` datetime(6) NOT NULL COMMENT 'create datetime', `log_modified` datetime(6) NOT NULL COMMENT 'modify datetime', UNIQUE INDEX `ux_undo_log`(`xid`, `branch_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 'AT transaction mode undo table' ROW_FORMAT = Compact;-- ------------------------------ Records of undo_log-- ---------------------------- 2.修改application.yml文件，将事务模式修改为AT模式即可： 12seata: data-source-proxy-mode: AT#开启数据源代理的AT模式 3.重启服务并测试 测试内容同XA TCC模式TCC模式原理TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法： Try：资源的检测和预留； Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。 Cancel：预留资源释放，可以理解为try的反向操作。 举例，一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。 TCc的工作模型图: TCC模式的每个阶段是做什么的？ Try：资源检查和预留 Confirm：业务执行和提交 Cancel：预留资源的释放 TCC的优点是什么？ 一阶段完成直接提交事务，释放数据库资源，性能好 相比AT模型，无需生成快照，无需使用全局锁，性能最强 不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库 TCC的缺点是什么？ 有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦 软状态，事务是最终一致 需要考虑Confirm和Cancel的失败情况，做好幂等处理 案例实现改造account-service服务，利用TCC实现分布式事务 需求如下： 修改account-service，编写try、confirm、cancel逻辑try业务：添加冻结金额，扣减可用金额confirm业务：删除冻结金额cancel业务：删除冻结金额，恢复可用金额保证confirm、cancel接口的幂等性允许空回滚拒绝业务悬挂 TCC的空回滚和业务悬挂当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是空回滚。 对于已经空回滚的业务，如果以后继续执行try，就永远不可能confirm或cancel，这就是业务悬挂。应当阻止执行空回滚后的try操作，避免悬挂 业务分析 声明TCC接口TCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明，语法如下： 123456789101112131415161718@LocalTCCpublic interface TCCService &#123; /** * Try逻辑，@TwoPhaseBusinessAction中的name属性要与当前方法名一致，用于指定Try逻辑对应的方法 */ @TwoPhaseBusinessAction(name = \"prepare\", commitMethod = \"confirm\", rollbackMethod = \"cancel\") void prepare(@BusinessActionContextParameter(paramName = \"param\") String param); /** * 二阶段confirm确认方法、可以另命名，但要保证与commitMethod一致 * * @param context 上下文,可以传递try方法的参数 * @return boolean 执行是否成功 */ boolean confirm(BusinessActionContext context); /** * 二阶段回滚方法，要保证与rollbackMethod一致 */ boolean cancel(BusinessActionContext context);&#125; 1.编写AccountTCCService接口123456789101112131415161718package cn.itcast.account.service;import io.seata.rm.tcc.api.BusinessActionContext;import io.seata.rm.tcc.api.BusinessActionContextParameter;import io.seata.rm.tcc.api.LocalTCC;import io.seata.rm.tcc.api.TwoPhaseBusinessAction;@LocalTCCpublic interface AccountTCCService &#123; @TwoPhaseBusinessAction(name = \"deduct\", commitMethod = \"confirm\", rollbackMethod = \"cancel\") void deduct(@BusinessActionContextParameter(paramName = \"userId\") String userId, @BusinessActionContextParameter(paramName = \"money\")int money); boolean confirm(BusinessActionContext ctx); boolean cancel(BusinessActionContext ctx);&#125; 2.创建account_freeze_tbl表123456789101112131415161718192021222324252627282930313233343536/* Navicat Premium Data Transfer Source Server : local Source Server Type : MySQL Source Server Version : 50622 Source Host : localhost:3306 Source Schema : seata_demo Target Server Type : MySQL Target Server Version : 50622 File Encoding : 65001 Date: 23/06/2021 16:23:20*/SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for account_freeze_tbl-- ----------------------------DROP TABLE IF EXISTS `account_freeze_tbl`;CREATE TABLE `account_freeze_tbl` ( `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `user_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `freeze_money` int(11) UNSIGNED NULL DEFAULT 0, `state` int(1) NULL DEFAULT NULL COMMENT '事务状态，0:try，1:confirm，2:cancel', PRIMARY KEY (`xid`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;-- ------------------------------ Records of account_freeze_tbl-- ----------------------------SET FOREIGN_KEY_CHECKS = 1; 1234567891011121314151617181920import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;@Data@TableName(\"account_freeze_tbl\")public class AccountFreeze &#123; @TableId(type = IdType.INPUT) private String xid; private String userId; private Integer freezeMoney; private Integer state; public static abstract class State &#123; public final static int TRY = 0; public final static int CONFIRM = 1; public final static int CANCEL = 2; &#125;&#125; 因为money是unsigned int ，所以不用检查是否为负数（余额判断） 3.编写接口实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package cn.itcast.account.service.impl;import cn.itcast.account.entity.AccountFreeze;import cn.itcast.account.mapper.AccountFreezeMapper;import cn.itcast.account.mapper.AccountMapper;import cn.itcast.account.service.AccountTCCService;import io.seata.core.context.RootContext;import io.seata.rm.tcc.api.BusinessActionContext;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Service@Slf4jpublic class AccountTCCServiceImpl implements AccountTCCService &#123; @Autowired private AccountMapper accountMapper; @Autowired private AccountFreezeMapper freezeMapper; @Override @Transactional public void deduct(String userId, int money) &#123; // 0.获取事务id String xid = RootContext.getXID(); // 1.扣减可用余额 accountMapper.deduct(userId, money); // 2.记录冻结金额，事务状态 AccountFreeze freeze = new AccountFreeze(); freeze.setUserId(userId); freeze.setFreezeMoney(money); freeze.setState(AccountFreeze.State.TRY); freeze.setXid(xid); freezeMapper.insert(freeze); &#125; // 删除操作，执行多次没区别，天生幂等，没必要判断 @Override public boolean confirm(BusinessActionContext ctx) &#123; // 1.获取事务id String xid = ctx.getXid(); // 2.根据id删除冻结记录 int count = freezeMapper.deleteById(xid); return count == 1; &#125; @Override public boolean cancel(BusinessActionContext ctx) &#123; // 0.查询冻结记录 String xid = ctx.getXid(); String userId = ctx.getActionContext(\"userId\").toString(); AccountFreeze freeze = freezeMapper.selectById(xid); // 1.空回滚的判断，判断freeze是否为null，为null证明try没执行,需要空回滚 if(freeze == null)&#123; // 证明try没有执行，需要空回滚 freeze = new AccountFreeze(); freeze.setUserId(userId); freeze.setFreezeMoney(0); freeze.setState(AccountFreeze.State.CANCEL); freeze.setXid(xid); freezeMapper.insert(freeze); return true; &#125; //2.幂等判断 if(freeze.getState() == AccountFreeze.State.CANCEL)&#123; // 已经处理过一次CANCEL了，无需重复处理 return true; &#125; // 1.恢复可用余额 accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney()); // 2.将冻结金额清零，状态改为CANCEL freeze.setFreezeMoney(0); freeze.setState(AccountFreeze.State.CANCEL); int count = freezeMapper.updateById(freeze); return count == 1; &#125;&#125; 修改web中AccountService为AccountTCCService 1234@Autowiredprivate AccountService accountService;@Autowiredprivate AccountTCCService accountService; 4.重启服务测试 Saga模式Saga模式是SEATA提供的长事务解决方案。也分为两个阶段： •一阶段：直接提交本地事务 •二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚 Saga模式优点： •事务参与者可以基于事件驱动实现异步调用，吞吐高 •一阶段直接提交事务，无锁，性能好 •不用编写TCC中的三个阶段，实现简单 缺点： •软状态持续时间不确定，时效性差 •没有锁，没有事务隔离，会有脏写 四种模式对比 XA AT TCC SAGA 一致性 强一致 弱一致 弱一致 最终一致 隔离性 完全隔离 基于全局锁隔离 基于资源预留隔离 无隔离 代码侵入 无 无 有，要编写三个接口 有，要编写状态机和补偿业务 性能 差 好 非常好 非常好 场景 对一致性、隔离性有高要求的业务 基于关系型数据库的大多数分布式事务场景都可以 •对性能要求较高的事务。 •有非关系型数据库要参与的事务。 •业务流程长、业务流程多 •参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口 seata的部署和集成一、部署Seata的tc-server1.下载首先我们要下载seata-server包，地址在http://seata.io/zh-cn/blog/download.html 当然，课前资料也准备好了： 1seata-server-1.4.2.zip 2.解压在非中文目录解压缩这个zip包，其目录结构如下： 3.修改配置修改conf目录下的registry.conf文件： 内容如下： 12345678910111213141516171819202122232425262728293031registry &#123; # 注册中心类型 file 、nacos 、eureka、redis、zk、consul、etcd3、sofa # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等 type = \"nacos\" nacos &#123; # seata tc 服务注册到 nacos的服务名称，可以自定义 application = \"seata-tc-server\" serverAddr = \"127.0.0.1:8848\" group = \"DEFAULT_GROUP\" namespace = \"\" cluster = \"SH\" username = \"nacos\" password = \"nacos\" &#125;&#125;config &#123; # 配置中心 file、nacos 、apollo、zk、consul、etcd3 # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置 type = \"nacos\" # 配置nacos地址等信息 nacos &#123; serverAddr = \"127.0.0.1:8848\" namespace = \"\" group = \"SEATA_GROUP\" username = \"nacos\" password = \"nacos\" dataId = \"seataServer.properties\" &#125;&#125; 4.在nacos添加配置特别注意，为了让tc服务的集群可以共享配置，我们选择了nacos作为统一配置中心。因此服务端配置文件seataServer.properties文件需要在nacos中配好。 格式如下： 配置内容如下： 12345678910111213141516171819202122232425262728293031323334# 数据存储方式，db代表数据库store.mode=dbstore.db.datasource=druidstore.db.dbType=mysqlstore.db.driverClassName=com.mysql.cj.jdbc.Driverstore.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true&amp;serverTimezone=UTCstore.db.user=rootstore.db.password=rootstore.db.minConn=5store.db.maxConn=30store.db.globalTable=global_tablestore.db.branchTable=branch_tablestore.db.queryLimit=100store.db.lockTable=lock_tablestore.db.maxWait=5000# 事务、日志等配置server.recovery.committingRetryPeriod=1000server.recovery.asynCommittingRetryPeriod=1000server.recovery.rollbackingRetryPeriod=1000server.recovery.timeoutRetryPeriod=1000server.maxCommitRetryTimeout=-1server.maxRollbackRetryTimeout=-1server.rollbackRetryTimeoutUnlockEnable=falseserver.undo.logSaveDays=7server.undo.logDeletePeriod=86400000# 客户端与服务端传输方式transport.serialization=seatatransport.compressor=none# 关闭metrics功能，提高性能metrics.enabled=falsemetrics.registryType=compactmetrics.exporterList=prometheusmetrics.exporterPrometheusPort=9898 ==其中的数据库地址、用户名、密码都需要修改成你自己的数据库信息。== 5.创建数据库表特别注意：tc服务在管理分布式事务时，需要记录事务相关数据到数据库中，你需要提前创建好这些表。 新建一个名为seata的数据库，运行课前资料提供的sql文件： 这些表主要记录全局事务、分支事务、全局锁信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ 分支事务表-- ----------------------------DROP TABLE IF EXISTS `branch_table`;CREATE TABLE `branch_table` ( `branch_id` bigint(20) NOT NULL, `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `transaction_id` bigint(20) NULL DEFAULT NULL, `resource_group_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `branch_type` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `status` tinyint(4) NULL DEFAULT NULL, `client_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `gmt_create` datetime(6) NULL DEFAULT NULL, `gmt_modified` datetime(6) NULL DEFAULT NULL, PRIMARY KEY (`branch_id`) USING BTREE, INDEX `idx_xid`(`xid`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;-- ------------------------------ 全局事务表-- ----------------------------DROP TABLE IF EXISTS `global_table`;CREATE TABLE `global_table` ( `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `transaction_id` bigint(20) NULL DEFAULT NULL, `status` tinyint(4) NOT NULL, `application_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `transaction_service_group` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `transaction_name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `timeout` int(11) NULL DEFAULT NULL, `begin_time` bigint(20) NULL DEFAULT NULL, `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `gmt_create` datetime NULL DEFAULT NULL, `gmt_modified` datetime NULL DEFAULT NULL, PRIMARY KEY (`xid`) USING BTREE, INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) USING BTREE, INDEX `idx_transaction_id`(`transaction_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;SET FOREIGN_KEY_CHECKS = 1; 6.启动TC服务进入bin目录，运行其中的seata-server.bat即可： 启动成功后，seata-server应该已经注册到nacos注册中心了。 打开浏览器，访问nacos地址：http://localhost:8848，然后进入服务列表页面，可以看到seata-tc-server的信息： 二、微服务集成seata1.引入依赖首先，我们需要在微服务(pom.xml)中引入seata依赖： 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--版本较低，1.3.0，因此排除--&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--seata starter 采用1.4.2版本--&gt;&lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;seata.version&#125;&lt;/version&gt;&lt;/dependency&gt; 2.修改配置文件需要修改application.yml文件，添加一些配置： 然后，配置application.yml，让微服务通过注册中心找到seata-tc-server： 123456789101112131415seata: registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址 # 参考tc服务自己的registry.conf中的配置 type: nacos nacos: # tc server-addr: 127.0.0.1:8848 namespace: \"\" group: DEFAULT_GROUP application: seata-tc-server # tc服务在nacos中的服务名称 cluster: SH tx-service-group: seata-demo # 事务组，根据这个获取tc服务的cluster名称 service: vgroup-mapping: # 事务组与TC服务cluster的映射关系 seata-demo: SH 三、TC服务的高可用和异地容灾1.模拟异地容灾的TC集群3计划启动两台seata的tc服务节点： 节点名称 ip地址 端口号 集群名称 seata 127.0.0.1 8091 SH seata2 127.0.0.1 8092 HZ 之前我们已经启动了一台seata服务，端口是8091，集群名为SH。 现在，将seata目录复制一份，起名为seata2 修改seata2/conf/registry.conf内容如下： 1234567891011121314151617181920212223242526272829registry &#123; # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等 type = \"nacos\" nacos &#123; # seata tc 服务注册到 nacos的服务名称，可以自定义 application = \"seata-tc-server\" serverAddr = \"127.0.0.1:8848\" group = \"DEFAULT_GROUP\" namespace = \"\" cluster = \"HZ\" username = \"nacos\" password = \"nacos\" &#125;&#125;config &#123; # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置 type = \"nacos\" # 配置nacos地址等信息 nacos &#123; serverAddr = \"127.0.0.1:8848\" namespace = \"\" group = \"SEATA_GROUP\" username = \"nacos\" password = \"nacos\" dataId = \"seataServer.properties\" &#125;&#125; 进入seata2/bin目录，然后运行命令： 1seata-server.bat -p 8092 打开nacos控制台，查看服务列表： 点进详情查看： 2.将事务组映射配置到nacos接下来，我们需要将tx-service-group与cluster的映射关系都配置到nacos配置中心。 新建一个配置： 配置的内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 事务组映射关系service.vgroupMapping.seata-demo=SHservice.enableDegrade=falseservice.disableGlobalTransaction=false# 与TC服务的通信配置transport.type=TCPtransport.server=NIOtransport.heartbeat=truetransport.enableClientBatchSendRequest=falsetransport.threadFactory.bossThreadPrefix=NettyBosstransport.threadFactory.workerThreadPrefix=NettyServerNIOWorkertransport.threadFactory.serverExecutorThreadPrefix=NettyServerBizHandlertransport.threadFactory.shareBossWorker=falsetransport.threadFactory.clientSelectorThreadPrefix=NettyClientSelectortransport.threadFactory.clientSelectorThreadSize=1transport.threadFactory.clientWorkerThreadPrefix=NettyClientWorkerThreadtransport.threadFactory.bossThreadSize=1transport.threadFactory.workerThreadSize=defaulttransport.shutdown.wait=3# RM配置client.rm.asyncCommitBufferLimit=10000client.rm.lock.retryInterval=10client.rm.lock.retryTimes=30client.rm.lock.retryPolicyBranchRollbackOnConflict=trueclient.rm.reportRetryCount=5client.rm.tableMetaCheckEnable=falseclient.rm.tableMetaCheckerInterval=60000client.rm.sqlParserType=druidclient.rm.reportSuccessEnable=falseclient.rm.sagaBranchRegisterEnable=false# TM配置client.tm.commitRetryCount=5client.tm.rollbackRetryCount=5client.tm.defaultGlobalTransactionTimeout=60000client.tm.degradeCheck=falseclient.tm.degradeCheckAllowTimes=10client.tm.degradeCheckPeriod=2000# undo日志配置client.undo.dataValidation=trueclient.undo.logSerialization=jacksonclient.undo.onlyCareUpdateColumns=trueclient.undo.logTable=undo_logclient.undo.compress.enable=trueclient.undo.compress.type=zipclient.undo.compress.threshold=64kclient.log.exceptionRate=100 3.微服务读取nacos配置接下来，需要修改每一个微服务的application.yml文件，让微服务读取nacos中的client.properties文件： 123456789seata: config: type: nacos nacos: server-addr: 127.0.0.1:8848 username: nacos password: nacos group: SEATA_GROUP data-id: client.properties 重启微服务，现在微服务到底是连接tc的SH集群，还是tc的HZ集群，都统一由nacos的client.properties来决定了。","categories":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/tags/Java/"},{"name":"seata","slug":"seata","permalink":"https://codeofli.github.io/tags/seata/"}]},{"title":"安装elasticsearch","slug":"java-note/SpringCloud/Elasticsearch/安装elasticsearch/安装elasticsearch","date":"2021-10-24T02:40:06.000Z","updated":"2022-03-02T01:21:40.348Z","comments":true,"path":"2021/10/java-note/SpringCloud/Elasticsearch/安装elasticsearch/安装elasticsearch/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/Elasticsearch/安装elasticsearch/安装elasticsearch/","excerpt":"安装elasticsearch1.部署单点es1.1.创建网络因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：1docker network create es-net1.2.加载镜像这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。","text":"安装elasticsearch1.部署单点es1.1.创建网络因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：1docker network create es-net1.2.加载镜像这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。 课前资料提供了镜像的tar包： 大家将其上传到虚拟机中，然后运行命令加载即可： 12# 导入数据docker load -i es.tar 同理还有kibana的tar包也需要这样做。 1.3.运行运行docker命令，部署单点es： 1234567891011docker run -d \\ --name es \\ -e \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" \\ -e \"discovery.type=single-node\" \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\elasticsearch:7.12.1 命令解释： -e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称 -e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问 -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小 -e &quot;discovery.type=single-node&quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 -p 9200:9200：端口映射配置 在浏览器中输入：http://192.168.150.101:9200 即可看到elasticsearch的响应结果： 2.部署kibanakibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。 2.1.部署运行docker命令，部署kibana 123456docker run -d \\--name kibana \\-e ELASTICSEARCH_HOSTS=http://es:9200 \\--network=es-net \\-p 5601:5601 \\kibana:7.12.1 --network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中 -e ELASTICSEARCH_HOSTS=http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch -p 5601:5601：端口映射配置 kibana启动一般比较慢，需要多等待一会，可以通过命令： 1docker logs -f kibana 查看运行日志，当查看到下面的日志，说明成功： 此时，在浏览器输入地址访问：http://192.168.150.101:5601，即可看到结果 2.2.DevToolskibana中提供了一个DevTools界面： 这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。 3.安装IK分词器3.1.在线安装ik插件（较慢）12345678910# 进入容器内部docker exec -it elasticsearch /bin/bash# 在线下载并安装./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip#退出exit#重启容器docker restart elasticsearch 3.2.离线安装ik插件（推荐）1）查看数据卷目录安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看: 1docker volume inspect es-plugins 显示结果： 1234567891011[ &#123; \"CreatedAt\": \"2022-05-06T10:06:34+08:00\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/es-plugins/_data\", \"Name\": \"es-plugins\", \"Options\": null, \"Scope\": \"local\" &#125;] 说明plugins目录被挂载到了：/var/lib/docker/volumes/es-plugins/_data这个目录中。 2）解压缩分词器安装包下面我们需要把课前资料中的ik分词器解压缩，重命名为ik 3）上传到es容器的插件数据卷中也就是/var/lib/docker/volumes/es-plugins/_data： 4）重启容器12# 4、重启容器docker restart es 12# 查看es日志docker logs -f es 5）测试：IK分词器包含两种模式： ik_smart：最少切分 ik_max_word：最细切分 12345GET /_analyze&#123; \"analyzer\": \"ik_max_word\", \"text\": \"黑马程序员学习java太棒了\"&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&#123; \"tokens\" : [ &#123; \"token\" : \"黑马\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"CN_WORD\", \"position\" : 0 &#125;, &#123; \"token\" : \"程序员\", \"start_offset\" : 2, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 1 &#125;, &#123; \"token\" : \"程序\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"CN_WORD\", \"position\" : 2 &#125;, &#123; \"token\" : \"员\", \"start_offset\" : 4, \"end_offset\" : 5, \"type\" : \"CN_CHAR\", \"position\" : 3 &#125;, &#123; \"token\" : \"学习\", \"start_offset\" : 5, \"end_offset\" : 7, \"type\" : \"CN_WORD\", \"position\" : 4 &#125;, &#123; \"token\" : \"java\", \"start_offset\" : 7, \"end_offset\" : 11, \"type\" : \"ENGLISH\", \"position\" : 5 &#125;, &#123; \"token\" : \"太棒了\", \"start_offset\" : 11, \"end_offset\" : 14, \"type\" : \"CN_WORD\", \"position\" : 6 &#125;, &#123; \"token\" : \"太棒\", \"start_offset\" : 11, \"end_offset\" : 13, \"type\" : \"CN_WORD\", \"position\" : 7 &#125;, &#123; \"token\" : \"了\", \"start_offset\" : 13, \"end_offset\" : 14, \"type\" : \"CN_CHAR\", \"position\" : 8 &#125; ]&#125; 3.3 扩展词词典随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。 所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。 1）打开IK分词器config目录： 2）在IKAnalyzer.cfg.xml配置文件内容添加： 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt; &lt;entry key=\"ext_dict\"&gt;ext.dic&lt;/entry&gt;&lt;/properties&gt; 3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改 12传智播客奥力给 4）重启elasticsearch 1234docker restart es# 查看 日志docker logs -f elasticsearch 日志中已经成功加载ext.dic配置文件 5）测试效果： 12345GET /_analyze&#123; \"analyzer\": \"ik_max_word\", \"text\": \"传智播客Java就业超过90%,奥力给！\"&#125; 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 3.4 停用词词典在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。 IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。 1）IKAnalyzer.cfg.xml配置文件内容添加： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典--&gt; &lt;entry key=\"ext_dict\"&gt;ext.dic&lt;/entry&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典 *** 添加停用词词典--&gt; &lt;entry key=\"ext_stopwords\"&gt;stopword.dic&lt;/entry&gt;&lt;/properties&gt; 3）在 stopword.dic 添加停用词 1习大大 4）重启elasticsearch 123456# 重启服务docker restart elasticsearchdocker restart kibana# 查看 日志docker logs -f elasticsearch 日志中已经成功加载stopword.dic配置文件 5）测试效果： 12345GET /_analyze&#123; \"analyzer\": \"ik_max_word\", \"text\": \"传智播客Java就业率超过95%,习大大都点赞,奥力给！\"&#125; 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 4.部署es集群我们会在单机上利用docker容器运行多个es实例来模拟es集群。不过生产环境推荐大家每一台服务节点仅部署一个es的实例。 部署es集群可以直接使用docker-compose来完成，但这要求你的Linux虚拟机至少有4G的内存空间 4.1.创建es集群首先编写一个docker-compose.yml文件，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758version: '2.2'services: es01: image: elasticsearch:7.12.1 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: elasticsearch:7.12.1 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" volumes: - data02:/usr/share/elasticsearch/data ports: - 9201:9200 networks: - elastic es03: image: elasticsearch:7.12.1 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" volumes: - data03:/usr/share/elasticsearch/data networks: - elastic ports: - 9202:9200volumes: data01: driver: local data02: driver: local data03: driver: localnetworks: elastic: driver: bridge es运行需要修改一些linux系统权限，修改/etc/sysctl.conf文件 1vi /etc/sysctl.conf 添加下面的内容： 1vm.max_map_count=262144 然后执行命令，让配置生效： 1sysctl -p 通过docker-compose启动集群： 1docker-compose up -d 可查看是否成功 12docker ps docker logs -f es01 注： 先打开docker 4.2.集群状态监控kibana可以监控es集群，不过新版本需要依赖es的x-pack 功能，配置比较复杂。 这里推荐使用cerebro来监控es集群状态，官方网址：https://github.com/lmenezes/cerebro 课前资料已经提供了安装包： 解压即可使用，非常方便。 解压好的目录如下： 进入对应的bin目录： 双击其中的cerebro.bat文件即可启动服务。 访问http://localhost:9000 即可进入管理界面： 输入你的elasticsearch的任意节点的地址和端口，点击connect即可： 绿色的条，代表集群处于绿色（健康状态）。 实星是主节点，空星是候选节点 4.3.创建索引库1）利用kibana的DevTools创建索引库在DevTools中输入指令： 123456789101112PUT /itcast&#123; \"settings\": &#123; \"number_of_shards\": 3, // 分片数量 \"number_of_replicas\": 1 // 副本数量 &#125;, \"mappings\": &#123; \"properties\": &#123; // mapping映射定义 ... &#125; &#125;&#125; 2）利用cerebro创建索引库利用cerebro还可以创建索引库： 填写索引库信息： 点击右下角的create按钮： 4.4.查看分片效果回到首页，即可查看索引库分片效果：","categories":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://codeofli.github.io/categories/elasticsearch/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://codeofli.github.io/tags/elasticsearch/"}]},{"title":"Elasticsearch","slug":"java-note/SpringCloud/Elasticsearch/Elasticsearch","date":"2021-10-24T02:40:06.000Z","updated":"2022-03-02T01:21:40.180Z","comments":true,"path":"2021/10/java-note/SpringCloud/Elasticsearch/Elasticsearch/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/Elasticsearch/Elasticsearch/","excerpt":"分布式搜索引擎elasticsearch– elasticsearch基础1.初识elasticsearch1.1.了解ES1.1.1.elasticsearch的作用elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容例如： 在GitHub搜索代码 在电商网站搜索商品 在百度搜索答案 在打车软件搜索附近的车","text":"分布式搜索引擎elasticsearch– elasticsearch基础1.初识elasticsearch1.1.了解ES1.1.1.elasticsearch的作用elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容例如： 在GitHub搜索代码 在电商网站搜索商品 在百度搜索答案 在打车软件搜索附近的车 1.1.2.ELK技术栈elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域： 而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。 1.1.3.elasticsearch和luceneelasticsearch底层是基于lucene来实现的。 Lucene是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：https://lucene.apache.org/ 。 elasticsearch的发展历史： 2004年Shay Banon基于Lucene开发了Compass 2010年Shay Banon 重写了Compass，取名为Elasticsearch。 1.1.4.为什么不是其他搜索技术？目前比较知名的搜索引擎技术排名： 虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头： 1.1.5.总结什么是elasticsearch？ 一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能 什么是elastic stack（ELK）？ 是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch 什么是Lucene？ 是Apache的开源搜索引擎类库，提供了搜索引擎的核心API 1.2.倒排索引倒排索引的概念是基于MySQL这样的正向索引而言的。 1.2.1.正向索引那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引： 如果是根据id查询，那么直接走索引，查询速度非常快。 但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下： 1）用户搜索数据，条件是title符合&quot;%手机%&quot; 2）逐行获取数据，比如id为1的数据 3）判断数据中的title是否符合用户搜索条件 4）如果符合则放入结果集，不符合则丢弃。回到步骤1 逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。 1.2.2.倒排索引倒排索引中有两个非常重要的概念： 文档（Document）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息 词条（Term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条 创建倒排索引是对正向索引的一种特殊处理，流程如下： 将每一个文档的数据利用算法分词，得到一个个词条 创建表，每行数据包括词条、词条所在文档id、位置等信息 因为词条唯一性，可以给词条创建索引，例如hash表结构索引 如图： 倒排索引的搜索流程如下（以搜索”华为手机”为例）： 1）用户输入条件&quot;华为手机&quot;进行搜索。 2）对用户输入内容分词，得到词条：华为、手机。 3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。 4）拿着文档id到正向索引中查找具体文档。 如图： 虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。 1.2.3.正向和倒排那么为什么一个叫做正向索引，一个叫做倒排索引呢？ 正向索引是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是根据文档找词条的过程。 而倒排索引则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是根据词条找文档的过程。 是不是恰好反过来了？ 那么两者方式的优缺点是什么呢？ 正向索引： 优点： 可以给多个字段创建索引 根据索引字段搜索、排序速度非常快 缺点： 根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。 倒排索引： 优点： 根据词条搜索、模糊搜索时，速度非常快 缺点： 只能给词条创建索引，而不是字段 无法根据字段做排序 1.3.es的一些概念elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。 1.3.1.文档和字段elasticsearch是面向文档（Document）存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中： 而Json文档中往往包含很多的字段（Field），类似于数据库中的列。 1.3.2.索引和映射索引（Index），就是相同类型的文档的集合。 例如： 所有用户文档，就可以组织在一起，称为用户的索引； 所有商品的文档，可以组织在一起，称为商品的索引； 所有订单的文档，可以组织在一起，称为订单的索引； 因此，我们可以把索引当做是数据库中的表。 数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有映射（mapping），是索引中文档的字段约束信息，类似表的结构约束。 1.3.3.mysql与elasticsearch我们统一的把mysql与elasticsearch的概念做一下对比： MySQL Elasticsearch 说明 Table Index 索引(index)，就是文档的集合，类似数据库的表(table) Row Document 文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式 Column Field 字段（Field），就是JSON文档中的字段，类似数据库中的列（Column） Schema Mapping Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema） SQL DSL DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD 是不是说，我们学习了elasticsearch就不再需要mysql了呢？ 并不是如此，两者各自有自己的擅长支出： Mysql：擅长事务类型操作，可以确保数据的安全和一致性 Elasticsearch：擅长海量数据的搜索、分析、计算 因此在企业中，往往是两者结合使用： 对安全性要求较高的写操作，使用mysql实现 对查询性能要求较高的搜索需求，使用elasticsearch实现 两者再基于某种方式，实现数据的同步，保证一致性 1.4.安装es、kibana1.4.1.安装参考课前资料： 安装elasticsearch.md 1.4.2.分词器es在创建倒排索引时需要对文档分词；在搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理并不友好。我们在kibana的DevTools中测试： 12345POST /_analyze&#123; \"analyzer\": \"standard\", \"text\": \"黑马程序员学习java太棒了！\"&#125; 语法说明：POST：请求方式 /_analyze：请求路径，这里省略了http://192.168.150.101:9200，有kibana帮我们补充 请求参数，json风格： analyzer：分词器类型，这里是默认的standard分词器 text：要分词的内容 处理中文分词，一般会使用IK分词器。https://github.com/medcl/elasticsearch-analysis-ik安装IK分词器，参考课前资料《安装elasticsearch.md》： ik分词器包含两种模式： ik_smart：最少切分，粗粒度 ik_max_word：最细切分，细粒度 1.4.3.总结分词器的作用是什么？ 创建倒排索引时对文档分词 用户搜索时，对输入的内容分词 IK分词器有几种模式？ ik_smart：智能切分，粗粒度 ik_max_word：最细切分，细粒度 IK分词器如何拓展词条？如何停用词条？ 利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典 在词典中添加拓展词条或者停用词条 2.索引库操作索引库就类似数据库表，mapping映射就类似表的结构。 我们要向es中存储数据，必须先创建“库”和“表”。 2.1.mapping映射属性官方文档 https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html mapping是对索引库中文档的约束，常见的mapping属性包括： type：字段数据类型，常见的简单类型有： 字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址） 数值：long、integer、short、byte、double、float、 布尔：boolean 日期：date 对象：object index：是否创建索引，默认为true analyzer：使用哪种分词器 properties：该字段的子字段 例如下面的json文档： 123456789101112&#123; \"age\": 21, \"weight\": 52.1, \"isMarried\": false, \"info\": \"黑马程序员Java讲师\", \"email\": \"zy@itcast.cn\", \"score\": [99.1, 99.5, 98.9], \"name\": &#123; \"firstName\": \"云\", \"lastName\": \"赵\" &#125;&#125; 对应的每个字段映射（mapping）： age：类型为 integer；参与搜索，因此需要index为true；无需分词器 weight：类型为float；参与搜索，因此需要index为true；无需分词器 isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器 info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器 score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器 name：类型为object，需要定义多个子属性 name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器 name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器 2.2.索引库的CRUD这里我们统一使用Kibana编写DSL的方式来演示。 2.2.1.创建索引库和映射基本语法： 请求方式：PUT 请求路径：/索引库名，可以自定义 请求参数：mapping映射 格式： 1234567891011121314151617181920212223PUT /索引库名称&#123; \"mappings\": &#123; \"properties\": &#123; \"字段名\":&#123; \"type\": \"text\", \"analyzer\": \"ik_smart\" &#125;, \"字段名2\":&#123; \"type\": \"keyword\", \"index\": \"false\" &#125;, \"字段名3\":&#123; \"properties\": &#123; \"子字段\": &#123; \"type\": \"keyword\" &#125; &#125; &#125;, // ...略 &#125; &#125;&#125; 示例：1234567891011121314151617181920212223242526PUT /heima&#123; \"mappings\": &#123; \"properties\": &#123; \"info\":&#123; \"type\": \"text\", \"analyzer\": \"ik_smart\" &#125;, \"email\":&#123; \"type\": \"keyword\", \"index\": \"false\" &#125;, \"name\":&#123; \"type\": \"object\", \"properties\": &#123; \"firstName\": &#123; \"type\": \"keyword\" &#125;, \"lastName\": &#123; \"type\": \"keyword\" &#125; &#125; &#125; &#125; &#125;&#125; 在Dev Tools运行可得到 12345&#123; \"acknowledged\" : true, \"shards_acknowledged\" : true, \"index\" : \"heima\"&#125; 2.2.2.查询索引库基本语法： 请求方式：GET 请求路径：/索引库名 请求参数：无 格式： 1GET /索引库名 示例： 2.2.3.修改索引库倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库一旦创建，无法修改mapping。 虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。 语法说明： 12345678PUT /索引库名/_mapping&#123; \"properties\": &#123; \"新字段名\":&#123; \"type\": \"integer\" &#125; &#125;&#125; 示例： 123456789# 修改索引库，添加新字段PUT /heima/_mapping&#123; \"properties\":&#123; \"age\":&#123; \"type\": \"integer\" &#125; &#125;&#125; 2.2.4.删除索引库语法： 请求方式：DELETE 请求路径：/索引库名 请求参数：无 格式： 1DELETE /索引库名 在kibana中测试： 2.2.5.总结索引库操作有哪些？ 创建索引库：PUT /索引库名 查询索引库：GET /索引库名 删除索引库：DELETE /索引库名 添加字段：PUT /索引库名/_mapping 3.文档操作3.1.新增文档语法： 12345678910POST /索引库名/_doc/文档id&#123; \"字段1\": \"值1\", \"字段2\": \"值2\", \"字段3\": &#123; \"子属性1\": \"值3\", \"子属性2\": \"值4\" &#125;, // ...&#125; 示例： 12345678910# 插入文档POST /heima/_doc/1&#123; \"info\": \"黑马程序员Java讲师\", \"email\": \"zy@itcast.cn\", \"name\": &#123; \"firstName\": \"云\", \"lastName\": \"赵\" &#125;&#125; 响应： 3.2.查询文档根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。 语法： 1GET /&#123;索引库名称&#125;/_doc/&#123;id&#125; 通过kibana查看数据： 12# 查询文档GET /heima/_doc/1 查看结果： 3.3.删除文档删除使用DELETE请求，同样，需要根据id进行删除： 语法： 1DELETE /&#123;索引库名&#125;/_doc/id值 示例： 12# 根据id删除数据DELETE /heima/_doc/1 结果： 3.4.修改文档修改有两种方式： 全量修改：直接覆盖原来的文档 增量修改：修改文档中的部分字段 3.4.1.全量修改全量修改是覆盖原来的文档，其本质是： 根据指定的id删除文档 新增一个相同id的文档 注意：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。 语法： 123456PUT /&#123;索引库名&#125;/_doc/文档id&#123; \"字段1\": \"值1\", \"字段2\": \"值2\", // ... 略&#125; 示例： 12345678910# 全量修改文档PUT /heima/_doc/1&#123; \"info\": \"黑马程序员高级Java讲师\", \"email\": \"zy@itcast.cn\", \"name\": &#123; \"firstName\": \"云\", \"lastName\": \"赵\" &#125;&#125; 3.4.2.增量修改增量修改是只修改指定id匹配的文档中的部分字段。 语法： 123456POST /&#123;索引库名&#125;/_update/文档id&#123; \"doc\": &#123; \"字段名\": \"新的值\", &#125;&#125; 示例： 1234567# 局部修改文档POST /heima/_update/1&#123; \"doc\": &#123; \"email\": \"ZhaoYun@itcast.cn\" &#125;&#125; 3.5.总结文档操作有哪些？ 创建文档：POST /{索引库名}/_doc/文档id { json文档 } 查询文档：GET /{索引库名}/_doc/文档id 删除文档：DELETE /{索引库名}/_doc/文档id 修改文档： 全量修改：PUT /{索引库名}/_doc/文档id { json文档 } 增量修改：POST /{索引库名}/_update/文档id { “doc”: {字段}} 4.RestClient操作索引库什么是RestClient ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：https://www.elastic.co/guide/en/elasticsearch/client/index.html 其中的Java Rest Client又包括两种： Java Low Level Rest Client Java High Level Rest Client 我们学习的是Java HighLevel Rest Client客户端API 4.0.导入Demo工程4.0.1.导入数据首先导入课前资料提供的数据库数据： tb_hotel.sql 数据结构如下： 123456789101112131415CREATE TABLE `tb_hotel` ( `id` bigint(20) NOT NULL COMMENT '酒店id', `name` varchar(255) NOT NULL COMMENT '酒店名称；例：7天酒店', `address` varchar(255) NOT NULL COMMENT '酒店地址；例：航头路', `price` int(10) NOT NULL COMMENT '酒店价格；例：329', `score` int(2) NOT NULL COMMENT '酒店评分；例：45，就是4.5分', `brand` varchar(32) NOT NULL COMMENT '酒店品牌；例：如家', `city` varchar(32) NOT NULL COMMENT '所在城市；例：上海', `star_name` varchar(16) DEFAULT NULL COMMENT '酒店星级，从低到高分别是：1星到5星，1钻到5钻', `business` varchar(255) DEFAULT NULL COMMENT '商圈；例：虹桥', `latitude` varchar(32) NOT NULL COMMENT '纬度；例：31.2497', `longitude` varchar(32) NOT NULL COMMENT '经度；例：120.3925', `pic` varchar(255) DEFAULT NULL COMMENT '酒店图片；例:/img/1.jpg', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 4.0.2.导入项目然后导入课前资料提供的项目: hotel-demo文件夹 项目结构如图： 4.0.3.mapping映射分析创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括： 字段名 字段数据类型 是否参与搜索 是否需要分词 如果分词，分词器是什么？ 其中： 字段名、字段数据类型，可以参考数据表结构的名称和类型 是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索 是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词 分词器，我们可以统一使用ik_max_word 来看下酒店数据的索引库结构: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 酒店的mappingPUT /hotel&#123; \"mappings\": &#123; \"properties\": &#123; \"id\": &#123; \"type\": \"keyword\" &#125;, \"name\":&#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"copy_to\": \"all\" &#125;, \"address\":&#123; \"type\": \"keyword\", \"index\": false &#125;, \"price\":&#123; \"type\": \"integer\" &#125;, \"score\":&#123; \"type\": \"integer\" &#125;, \"brand\":&#123; \"type\": \"keyword\", \"copy_to\": \"all\" &#125;, \"city\":&#123; \"type\": \"keyword\", \"copy_to\": \"all\" &#125;, \"starName\":&#123; \"type\": \"keyword\" &#125;, \"business\":&#123; \"type\": \"keyword\" &#125;, \"location\":&#123; \"type\": \"geo_point\" &#125;, \"pic\":&#123; \"type\": \"keyword\", \"index\": false &#125;, \"all\":&#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\" &#125; &#125; &#125;&#125; 几个特殊字段说明： location：地理坐标，里面包含精度、纬度 all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索 地理坐标说明： copy_to说明： 4.0.4.初始化JavaRestClient在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。 分为三步： 1）引入es的RestHighLevelClient依赖： 12345&lt;!--elasticsearch--&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本： 1234&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;elasticsearch.version&gt;7.12.1&lt;/elasticsearch.version&gt;&lt;/properties&gt; 3）初始化RestHighLevelClient： 初始化的代码如下： 123RestHighLevelClient client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\"http://192.168.150.101:9200\"))); 这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中： 1234567891011121314151617181920212223242526272829package cn.itcast.hotel;import org.apache.http.HttpHost;import org.elasticsearch.client.RestHighLevelClient;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.io.IOException;public class HotelIndexTest &#123; private RestHighLevelClient client; @Test void testInit()&#123; System.out.println(client); &#125; @BeforeEach void setUp() &#123; this.client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\"http://192.168.150.101:9200\") )); &#125; @AfterEach void tearDown() throws IOException &#123; this.client.close(); &#125;&#125; 4.1.创建索引库4.1.1.代码解读创建索引库的API如下： 代码分为三步： 1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。 2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。 3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。 4.1.2.完整示例在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.itcast.hotel.constants;public class HotelConstants &#123; public static final String MAPPING_TEMPLATE = \"&#123;\\n\" + \" \\\"mappings\\\": &#123;\\n\" + \" \\\"properties\\\": &#123;\\n\" + \" \\\"id\\\": &#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\"\\n\" + \" &#125;,\\n\" + \" \\\"name\\\":&#123;\\n\" + \" \\\"type\\\": \\\"text\\\",\\n\" + \" \\\"analyzer\\\": \\\"ik_max_word\\\",\\n\" + \" \\\"copy_to\\\": \\\"all\\\"\\n\" + \" &#125;,\\n\" + \" \\\"address\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\",\\n\" + \" \\\"index\\\": false\\n\" + \" &#125;,\\n\" + \" \\\"price\\\":&#123;\\n\" + \" \\\"type\\\": \\\"integer\\\"\\n\" + \" &#125;,\\n\" + \" \\\"score\\\":&#123;\\n\" + \" \\\"type\\\": \\\"integer\\\"\\n\" + \" &#125;,\\n\" + \" \\\"brand\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\",\\n\" + \" \\\"copy_to\\\": \\\"all\\\"\\n\" + \" &#125;,\\n\" + \" \\\"city\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\",\\n\" + \" \\\"copy_to\\\": \\\"all\\\"\\n\" + \" &#125;,\\n\" + \" \\\"starName\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\"\\n\" + \" &#125;,\\n\" + \" \\\"business\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\"\\n\" + \" &#125;,\\n\" + \" \\\"location\\\":&#123;\\n\" + \" \\\"type\\\": \\\"geo_point\\\"\\n\" + \" &#125;,\\n\" + \" \\\"pic\\\":&#123;\\n\" + \" \\\"type\\\": \\\"keyword\\\",\\n\" + \" \\\"index\\\": false\\n\" + \" &#125;,\\n\" + \" \\\"all\\\":&#123;\\n\" + \" \\\"type\\\": \\\"text\\\",\\n\" + \" \\\"analyzer\\\": \\\"ik_max_word\\\"\\n\" + \" &#125;\\n\" + \" &#125;\\n\" + \" &#125;\\n\" + \"&#125;\";&#125; 在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引： 123456789@Testvoid createHotelIndex() throws IOException &#123; // 1.创建Request对象 CreateIndexRequest request = new CreateIndexRequest(\"hotel\"); // 2.准备请求的参数：DSL语句 request.source(MAPPING_TEMPLATE, XContentType.JSON); // 3.发送请求 client.indices().create(request, RequestOptions.DEFAULT);&#125; 可在http://192.168.153.128:5601/app/dev_tools#/console测试 1GET /hotel 4.2.删除索引库删除索引库的DSL语句非常简单： 1DELETE /hotel 与创建索引库相比： 请求方式从PUT变为DELTE 请求路径不变 无请求参数 所以代码的差异，注意体现在Request对象上。依然是三步走： 1）创建Request对象。这次是DeleteIndexRequest对象 2）准备参数。这里是无参 3）发送请求。改用delete方法 在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引： 1234567@Testvoid testDeleteHotelIndex() throws IOException &#123; // 1.创建Request对象 DeleteIndexRequest request = new DeleteIndexRequest(\"hotel\"); // 2.发送请求 client.indices().delete(request, RequestOptions.DEFAULT);&#125; 4.3.判断索引库是否存在判断索引库是否存在，本质就是查询，对应的DSL是： 1GET /hotel 因此与删除的Java代码流程是类似的。依然是三步走： 1）创建Request对象。这次是GetIndexRequest对象 2）准备参数。这里是无参 3）发送请求。改用exists方法 123456789@Testvoid testExistsHotelIndex() throws IOException &#123; // 1.创建Request对象 GetIndexRequest request = new GetIndexRequest(\"hotel\"); // 2.发送请求 boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); // 3.输出 System.err.println(exists ? \"索引库已经存在！\" : \"索引库不存在！\");&#125; 4.4.总结JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。 索引库操作的基本步骤： 初始化RestHighLevelClient 创建XxxIndexRequest。XXX是Create、Get、Delete 准备DSL（ Create时需要，其它是无参） 发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete 5.RestClient操作文档为了与索引库操作分离，我们再次参加一个测试类，做两件事情： 初始化RestHighLevelClient 我们的酒店数据在数据库，需要利用IHotelService去查询，所以注入这个接口 1234567891011121314151617181920212223242526272829303132package cn.itcast.hotel;import cn.itcast.hotel.pojo.Hotel;import cn.itcast.hotel.service.IHotelService;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.util.List;@SpringBootTestpublic class HotelDocumentTest &#123; @Autowired private IHotelService hotelService; private RestHighLevelClient client; @BeforeEach void setUp() &#123; this.client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\"http://192.168.150.101:9200\") )); &#125; @AfterEach void tearDown() throws IOException &#123; this.client.close(); &#125;&#125; 5.1.新增文档我们要将数据库的酒店数据查询出来，写入elasticsearch中。 5.1.1.索引库实体类数据库查询后的结果是一个Hotel类型的对象。结构如下： 1234567891011121314151617@Data@TableName(\"tb_hotel\")public class Hotel &#123; @TableId(type = IdType.INPUT) private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String longitude; private String latitude; private String pic;&#125; 与我们的索引库结构存在差异： longitude和latitude需要合并为location 因此，我们需要定义一个新的类型，与索引库结构吻合： 12345678910111213141516171819202122232425262728293031323334package cn.itcast.hotel.pojo;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \", \" + hotel.getLongitude(); this.pic = hotel.getPic(); &#125;&#125; 5.1.2.语法说明新增文档的DSL语句如下： 12345POST /&#123;索引库名&#125;/_doc/1&#123; \"name\": \"Jack\", \"age\": 21&#125; 对应的java代码如图： 可以看到与创建索引库类似，同样是三步走： 1）创建Request对象 2）准备请求参数，也就是DSL中的JSON文档 3）发送请求 变化的地方在于，这里直接使用client.xxx()的API，不再需要client.indices()了。 5.1.3.完整代码我们导入酒店数据，基本流程一致，但是需要考虑几点变化： 酒店数据来自于数据库，我们需要先查询出来，得到hotel对象 hotel对象需要转为HotelDoc对象 HotelDoc需要序列化为json格式 因此，代码整体步骤如下： 1）根据id查询酒店数据Hotel 2）将Hotel封装为HotelDoc 3）将HotelDoc序列化为JSON 4）创建IndexRequest，指定索引库名和id 5）准备请求参数，也就是JSON文档 6）发送请求 在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 12345678910111213141516@Testvoid testAddDocument() throws IOException &#123; // 1.根据id查询酒店数据 Hotel hotel = hotelService.getById(61083L); // 2.转换为文档类型 HotelDoc hotelDoc = new HotelDoc(hotel); // 3.将HotelDoc转json String json = JSON.toJSONString(hotelDoc); // 1.准备Request对象 IndexRequest request = new IndexRequest(\"hotel\").id(hotelDoc.getId().toString()); // 2.准备Json文档 request.source(json, XContentType.JSON); // 3.发送请求 client.index(request, RequestOptions.DEFAULT);&#125; 5.2.查询文档5.2.1.语法说明查询的DSL语句如下： 1GET /hotel/_doc/&#123;id&#125; 非常简单，因此代码大概分两步： 准备Request对象 发送请求 不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下： 可以看到，结果是一个JSON，其中文档放在一个_source属性中，因此解析就是拿到_source，反序列化为Java对象即可。 与之前类似，也是三步走： 1）准备Request对象。这次是查询，所以是GetRequest 2）发送请求，得到结果。因为是查询，这里调用client.get()方法 3）解析结果，就是对JSON做反序列化 5.2.2.完整代码在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 123456789101112@Testvoid testGetDocumentById() throws IOException &#123; // 1.准备Request GetRequest request = new GetRequest(\"hotel\", \"61082\"); // 2.发送请求，得到响应 GetResponse response = client.get(request, RequestOptions.DEFAULT); // 3.解析响应结果 String json = response.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); System.out.println(hotelDoc);&#125; 5.3.删除文档删除的DSL为是这样的： 1DELETE /hotel/_doc/&#123;id&#125; 与查询相比，仅仅是请求方式从DELETE变成GET，可以想象Java代码应该依然是三步走： 1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id 2）准备参数，无参 3）发送请求。因为是删除，所以是client.delete()方法 在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 1234567@Testvoid testDeleteDocument() throws IOException &#123; // 1.准备Request DeleteRequest request = new DeleteRequest(\"hotel\", \"61083\"); // 2.发送请求 client.delete(request, RequestOptions.DEFAULT);&#125; 5.4.修改文档5.4.1.语法说明修改我们讲过两种方式： 全量修改：本质是先根据id删除，再新增 增量修改：修改文档中的指定字段值 在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID： 如果新增时，ID已经存在，则修改 如果新增时，ID不存在，则新增 这里不再赘述，我们主要关注增量修改。 代码示例如图： 与之前类似，也是三步走： 1）准备Request对象。这次是修改，所以是UpdateRequest 2）准备参数。也就是JSON文档，里面包含要修改的字段 3）更新文档。这里调用client.update()方法 5.4.2.完整代码在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 123456789101112@Testvoid testUpdateDocument() throws IOException &#123; // 1.准备Request UpdateRequest request = new UpdateRequest(\"hotel\", \"61083\"); // 2.准备请求参数 request.doc( \"price\", \"952\", \"starName\", \"四钻\" ); // 3.发送请求 client.update(request, RequestOptions.DEFAULT);&#125; 5.5.批量导入文档案例需求：利用BulkRequest批量将数据库数据导入到索引库中。 步骤如下： 利用mybatis-plus查询酒店数据 将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc） 利用JavaRestClient中的BulkRequest批处理，实现批量新增文档 5.5.1.语法说明批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。 其中提供了一个add方法，用来添加其他请求： 可以看到，能添加的请求包括： IndexRequest，也就是新增 UpdateRequest，也就是修改 DeleteRequest，也就是删除 因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例： 其实还是三步走： 1）创建Request对象。这里是BulkRequest 2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest 3）发起请求。这里是批处理，调用的方法为client.bulk()方法 我们在导入酒店数据时，将上述代码改造成for循环处理即可。 5.5.2.完整代码在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 12345678910111213141516171819@Testvoid testBulkRequest() throws IOException &#123; // 批量查询酒店数据 List&lt;Hotel&gt; hotels = hotelService.list(); // 1.创建Request BulkRequest request = new BulkRequest(); // 2.准备参数，添加多个新增的Request for (Hotel hotel : hotels) &#123; // 2.1.转换为文档类型HotelDoc HotelDoc hotelDoc = new HotelDoc(hotel); // 2.2.创建新增文档的Request对象 request.add(new IndexRequest(\"hotel\") .id(hotelDoc.getId().toString()) .source(JSON.toJSONString(hotelDoc), XContentType.JSON)); &#125; // 3.发送请求 client.bulk(request, RequestOptions.DEFAULT);&#125; http://192.168.153.128:5601/app/dev_tools#/console中GET /hotel/_search可查看 5.6.小结文档操作的基本步骤： 初始化RestHighLevelClient 创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk 准备参数（Index、Update、Bulk时需要） 发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk 解析结果（Get时需要） 分布式搜索引擎02在昨天的学习中，我们已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。 所以今天，我们研究下elasticsearch的数据搜索功能。我们会分别使用DSL和RestClient实现搜索。 1.DSL查询文档elasticsearch的查询依然是基于JSON风格的DSL来实现的。 1.1.DSL查询分类Elasticsearch提供了基于JSON的DSL（Domain Specific Language）来定义查询。常见的查询类型包括： 查询所有：查询出所有数据，一般测试用。例如：match_all 全文检索（full text）查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如： match_query multi_match_query 精确查询：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如： ids range term 地理（geo）查询：根据经纬度查询。例如： geo_distance geo_bounding_box 复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如： bool function_score 查询的语法基本一致： 12345678GET /indexName/_search&#123; \"query\": &#123; \"查询类型\": &#123; \"查询条件\": \"条件值\" &#125; &#125;&#125; 我们以查询所有为例，其中： 查询类型为match_all 没有查询条件 12345678// 查询所有GET /indexName/_search&#123; \"query\": &#123; \"match_all\": &#123; &#125; &#125;&#125; 其它查询无非就是查询类型、查询条件的变化。 1.2.全文检索查询1.2.1.使用场景全文检索查询的基本流程如下： 对用户搜索的内容做分词，得到词条 根据词条去倒排索引库中匹配，得到文档id 根据文档id找到文档，返回给用户 比较常用的场景包括： 商城的输入框搜索 百度输入框搜索 例如京东： 因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。 1.2.2.基本语法常见的全文检索查询包括： match查询：单字段查询 multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件 match查询语法如下： 12345678GET /indexName/_search&#123; \"query\": &#123; \"match\": &#123; \"FIELD\": \"TEXT\" &#125; &#125;&#125; mulit_match语法如下： 123456789GET /indexName/_search&#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"TEXT\", \"fields\": [\"FIELD1\", \" FIELD12\"] &#125; &#125;&#125; 1.2.3.示例match查询示例： 123456789# match查询GET /hotel/_search&#123; \"query\": &#123; \"match\": &#123; \"all\": \"如家外滩\" &#125; &#125;&#125; multi_match查询示例： 12345678910# mutil_match查询GET /hotel/_search&#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"外滩如家\", \"fields\": [\"brand\",\"name\",\"business\"] &#125; &#125;&#125; 可以看到，两种查询结果是一样的，为什么？ 因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。 但是，搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。 1.2.4.总结match和multi_match的区别是什么？ match：根据一个字段查询 multi_match：根据多个字段查询，参与查询字段越多，查询性能越差 1.3.精准查询精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以不会对搜索条件分词。常见的有： term：根据词条精确值查询 range：根据值的范围查询 1.3.1.term查询因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是不分词的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。 语法说明： 1234567891011// term查询GET /indexName/_search&#123; \"query\": &#123; \"term\": &#123; \"FIELD\": &#123; \"value\": \"VALUE\" &#125; &#125; &#125;&#125; 示例： 当我搜索的是精确词条时，能正确查询出结果： 1234567891011# term查询GET /hotel/_search&#123; \"query\": &#123; \"term\": &#123; \"city\": &#123; \"value\": \"上海\" &#125; &#125; &#125;&#125; 但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到： 1.3.2.range查询范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。 gte: greater than or equal 基本语法： 123456789101112// range查询GET /indexName/_search&#123; \"query\": &#123; \"range\": &#123; \"FIELD\": &#123; \"gte\": 10, // 这里的gte代表大于等于，gt则代表大于 \"lte\": 20 // lte代表小于等于，lt则代表小于 &#125; &#125; &#125;&#125; 示例： 123456789101112# range查询GET /hotel/_search&#123; \"query\": &#123; \"range\": &#123; \"price\": &#123; \"gte\": 100, \"lte\": 300 &#125; &#125; &#125;&#125; 1.3.3.总结精确查询常见的有哪些？ term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段 range查询：根据数值范围查询，可以是数值、日期的范围 1.4.地理坐标查询所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html 常见的使用场景包括： 携程：搜索我附近的酒店 滴滴：搜索我附近的出租车 微信：搜索我附近的人 附近的酒店： 附近的车： 1.4.1.矩形范围查询矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档： 查询时，需要指定矩形的左上、右下两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。 语法如下： 123456789101112131415161718// geo_bounding_box查询GET /indexName/_search&#123; \"query\": &#123; \"geo_bounding_box\": &#123; \"FIELD\": &#123; \"top_left\": &#123; // 左上点 \"lat\": 31.1, \"lon\": 121.5 &#125;, \"bottom_right\": &#123; // 右下点 \"lat\": 30.9, \"lon\": 121.7 &#125; &#125; &#125; &#125;&#125; 这种并不符合“附近的人”这样的需求，所以我们就不做了。 用的少 1.4.2.附近查询附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。 换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件： 语法说明： 12345678910// geo_distance 查询GET /indexName/_search&#123; \"query\": &#123; \"geo_distance\": &#123; \"distance\": \"15km\", // 半径 \"FIELD\": \"31.21,121.5\" // 圆心 &#125; &#125;&#125; 示例： 我们先搜索陆家嘴附近15km的酒店： 12345678910# distance查询GET /hotel/_search&#123; \"query\": &#123; \"geo_distance\": &#123; \"distance\": \"15km\", \"location\": \"31.21, 121.5\" &#125; &#125;&#125; 发现共有47家酒店。 然后把半径缩短到3公里： 可以发现，搜索到的酒店数量减少到了5家。 1.5.复合查询复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种： fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名 bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索 1.5.1.相关性算分当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。 例如，我们搜索 “虹桥如家”，结果如下： 1234567891011121314151617181920[ &#123; \"_score\" : 17.850193, \"_source\" : &#123; \"name\" : \"虹桥如家酒店真不错\", &#125; &#125;, &#123; \"_score\" : 12.259849, \"_source\" : &#123; \"name\" : \"外滩如家酒店真不错\", &#125; &#125;, &#123; \"_score\" : 11.91091, \"_source\" : &#123; \"name\" : \"迪士尼如家酒店真不错\", &#125; &#125;] 在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下： 在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下： TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑： 小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种： TF-IDF算法 BM25算法，elasticsearch5.1版本后采用的算法 1.5.2.算分函数查询根据相关度打分是比较合理的需求，但合理的不一定是产品经理需要的。 以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图： 要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。 1）语法说明 function score 查询中包含四部分内容： 原始查询条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，原始算分（query score) 过滤条件：filter部分，符合该条件的文档才会重新算分 算分函数：符合filter条件的文档要根据这个函数做运算，得到的函数算分（function score），有四种函数 weight：函数结果是常量 field_value_factor：以文档中的某个字段值作为函数结果 random_score：以随机数作为函数结果 script_score：自定义算分函数算法 运算模式：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括： multiply：相乘 replace：用function score替换query score 其它，例如：sum、avg、max、min function score的运行流程如下： 1）根据原始条件查询搜索文档，并且计算相关性算分，称为原始算分（query score） 2）根据过滤条件，过滤文档 3）符合过滤条件的文档，基于算分函数运算，得到函数算分（function score） 4）将原始算分（query score）和函数算分（function score）基于运算模式做运算，得到最终结果，作为相关性算分。 因此，其中的关键点是： 过滤条件：决定哪些文档的算分被修改 算分函数：决定函数算分的算法 运算模式：决定最终算分结果 2）示例需求：给“如家”这个品牌的酒店排名靠前一些 翻译一下这个需求，转换为之前说的四个要点： 原始条件：不确定，可以任意变化 过滤条件：brand = “如家” 算分函数：可以简单粗暴，直接给固定的算分结果，weight 运算模式：比如求和 因此最终的DSL语句如下： 12345678910111213141516171819GET /hotel/_search&#123; \"query\": &#123; \"function_score\": &#123; \"query\": &#123; .... &#125;, // 原始查询，可以是任意条件 \"functions\": [ // 算分函数 &#123; \"filter\": &#123; // 满足的条件，品牌必须是如家 \"term\": &#123; \"brand\": \"如家\" &#125; &#125;, \"weight\": 2 // 算分权重为2 &#125; ], \"boost_mode\": \"sum\" // 加权模式，求和 &#125; &#125;&#125; 测试，在未添加算分函数时，如家得分如下： 123456789101112GET /hotel/_search&#123; \"query\": &#123; \"function_score\": &#123; \"query\": &#123; \"match\": &#123; \"all\": \"外滩\" &#125; &#125; &#125; &#125;&#125; 添加了算分函数后，如家得分就提升了： 123456789101112131415161718192021222324# function_score查询GET /hotel/_search&#123; \"query\": &#123; \"function_score\": &#123; \"query\": &#123; \"match\": &#123; \"all\": \"外滩\" &#125; &#125;, \"functions\": [ &#123; \"filter\":&#123; \"term\":&#123; \"brand\":\"如家\" &#125; &#125;, \"weight\": 10 &#125; ], \"boost_mode\": \"sum\" &#125; &#125;&#125; 3）小结function score query定义的三要素是什么？ 过滤条件：哪些文档要加分 算分函数：如何计算function score 加权方式：function score 与 query score如何运算 1.5.3.布尔查询布尔查询是一个或多个查询子句的组合，每一个子句就是一个子查询。子查询的组合方式有： must：必须匹配每个子查询，类似“与” should：选择性匹配子查询，类似“或” must_not：必须不匹配，不参与算分，类似“非” filter：必须匹配，不参与算分 不算分效率高 比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤： 每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。 需要注意的是，搜索时，参与打分的字段越多，查询的性能也越差。因此这种多条件查询时，建议这样做： 搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分 其它过滤条件，采用filter查询。不参与算分 1）语法示例：1234567891011121314151617181920GET /hotel/_search&#123; \"query\": &#123; \"bool\": &#123; \"must\": [ &#123;\"term\": &#123;\"city\": \"上海\" &#125;&#125; ], \"should\": [ &#123;\"term\": &#123;\"brand\": \"皇冠假日\" &#125;&#125;, &#123;\"term\": &#123;\"brand\": \"华美达\" &#125;&#125; ], \"must_not\": [ &#123; \"range\": &#123; \"price\": &#123; \"lte\": 500 &#125; &#125;&#125; ], \"filter\": [ &#123; \"range\": &#123;\"score\": &#123; \"gte\": 45 &#125; &#125;&#125; ] &#125; &#125;&#125; 2）示例需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。 分析： 名称搜索，属于全文检索查询，应该参与算分。放到must中 价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中 周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中 12345678910111213141516171819202122232425262728293031323334GET /hotel/_search&#123; \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"match\": &#123; \"name\": \"如家\" &#125; &#125; ], \"must_not\": [ &#123; \"range\": &#123; \"price\": &#123; \"gt\": 400 &#125; &#125; &#125; ], \"filter\": [ &#123; \"geo_distance\": &#123; \"distance\": \"10km\", \"location\": &#123; \"lat\": 31.21, \"lon\": 121.5 &#125; &#125; &#125; ] &#125; &#125;&#125; 3）小结bool查询有几种逻辑关系？ must：必须匹配的条件，可以理解为“与” should：选择性匹配的条件，可以理解为“或” must_not：必须不匹配的条件，不参与打分 filter：必须匹配的条件，不参与打分 2.搜索结果处理搜索的结果可以按照用户指定的方式去处理或展示。 2.1.排序elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索结果排序。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。 2.1.1.普通字段排序keyword、数值、日期类型排序的语法基本一致。 语法： 1234567891011GET /indexName/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"sort\": [ &#123; \"FIELD\": \"desc\" // 排序字段、排序方式ASC、DESC &#125; ]&#125; 排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推 示例： 需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序 1234567891011121314# sort排序GET /hotel/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"sort\": [ &#123; \"score\": \"desc\" &#125;,&#123; \"price\": \"asc\" &#125; ]&#125; 2.1.2.地理坐标排序地理坐标排序略有不同。 语法说明： 123456789101112131415GET /indexName/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"sort\": [ &#123; \"_geo_distance\" : &#123; \"FIELD\" : \"纬度，经度\", // 文档中geo_point类型的字段名、目标坐标点 \"order\" : \"asc\", // 排序方式 \"unit\" : \"km\" // 排序的距离单位 &#125; &#125; ]&#125; 这个查询的含义是： 指定一个坐标，作为目标点 计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少 根据距离排序 示例： 需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序 提示：获取你的位置的经纬度的方式：https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/ 1234567891011121314151617# 找到121,31周围的酒店，距离升序排序GET /hotel/_search&#123; \"query\": &#123;\"match_all\": &#123;&#125;&#125;, \"sort\": [ &#123; \"_geo_distance\": &#123; \"location\": &#123; \"lat\": 31, \"lon\": 121 &#125;, \"order\": \"asc\", \"unit\": \"km\" &#125; &#125; ]&#125; 假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。 2.2.分页elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果： from：从第几个文档开始 size：总共查询几个文档 类似于mysql中的limit ?, ? 2.2.1.基本的分页分页的基本语法如下： 123456789101112# 分页查询GET /hotel/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"from\": 0, // 分页开始的位置，默认为0 \"size\": 10, // 期望获取的文档总数 \"sort\": [ &#123;\"price\": \"asc\"&#125; ]&#125; 2.2.2.深度分页问题现在，我要查询990~1000的数据，查询逻辑要这么写： 1234567891011GET /hotel/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"from\": 990, // 分页开始的位置，默认为0 \"size\": 10, // 期望获取的文档总数 \"sort\": [ &#123;\"price\": \"asc\"&#125; ]&#125; 这里是查询990开始的数据，也就是 第990~第1000条 数据。 不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条： 查询TOP1000，如果es是单点模式，这并无太大影响。 但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。 因为节点A的TOP200，在另一个节点可能排到10000名以外了。 因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。 那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？ 当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。 针对深度分页，ES提供了两种解决方案，官方文档： search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。 scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。 2.2.3.小结分页查询的常见实现方案以及优缺点： from + size： 优点：支持随机翻页 缺点：深度分页问题，默认查询上限（from + size）是10000 场景：百度、京东、谷歌、淘宝这样的随机翻页搜索 after search： 优点：没有查询上限（单次查询的size不超过10000） 缺点：只能向后逐页查询，不支持随机翻页 场景：没有随机翻页需求的搜索，例如手机向下滚动翻页 scroll： 优点：没有查询上限（单次查询的size不超过10000） 缺点：会有额外内存消耗，并且搜索结果是非实时的 场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。 2.3.高亮2.3.1.高亮原理什么是高亮显示呢？ 我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示： 高亮显示的实现分为两步： 1）给文档中的所有关键字都添加一个标签，例如&lt;em&gt;标签 2）页面给&lt;em&gt;标签编写CSS样式 2.3.2.实现高亮高亮的语法： 12345678910111213141516GET /hotel/_search&#123; \"query\": &#123; \"match\": &#123; \"FIELD\": \"TEXT\" // 查询条件，高亮一定要使用全文检索查询 &#125; &#125;, \"highlight\": &#123; \"fields\": &#123; // 指定要高亮的字段 \"FIELD\": &#123; \"pre_tags\": \"&lt;em&gt;\", // 用来标记高亮字段的前置标签 \"post_tags\": \"&lt;/em&gt;\" // 用来标记高亮字段的后置标签 &#125; &#125; &#125;&#125; 注意： 高亮是对关键字高亮，因此搜索条件必须带有关键字，而不能是范围这样的查询。 默认情况下，高亮的字段，必须与搜索指定的字段一致，否则无法高亮 如果要对非搜索字段高亮，则需要添加一个属性：required_field_match=false 12345678910111213141516GET /hotel/_search&#123; \"query\": &#123; \"match\": &#123; \"FIELD\": \"TEXT\" // 查询条件，高亮一定要使用全文检索查询 &#125; &#125;, \"highlight\": &#123; \"fields\": &#123; // 指定要高亮的字段 \"FIELD\": &#123; \"pre_tags\": \"&lt;em&gt;\", // 用来标记高亮字段的前置标签 \"post_tags\": \"&lt;/em&gt;\" // 用来标记高亮字段的后置标签 &#125; &#125; &#125;&#125; 示例： 123456789101112131415161718# 高亮查询，默认情况下，ES搜索字段必须与高亮字段一致GET /hotel/_search&#123; \"query\": &#123; \"match\": &#123; \"all\": \"如家\" &#125; &#125;, \"highlight\": &#123; \"fields\": &#123; \"name\": &#123; \"require_field_match\": \"false\", \"pre_tags\": \"&lt;em&gt;\", \"post_tags\": \"&lt;/em&gt;\" &#125; &#125; &#125;&#125; 2.4.总结查询的DSL是一个大的JSON对象，包含下列属性： query：查询条件 from和size：分页条件 sort：排序条件 highlight：高亮条件 示例： 3.RestClient查询文档文档的查询同样适用昨天学习的 RestHighLevelClient对象，基本步骤包括： 1）准备Request对象 2）准备请求参数 3）发起请求 4）解析响应 3.1.快速入门我们以match_all查询为例 3.1.1.发起查询请求 代码解读： 第一步，创建SearchRequest对象，指定索引库名 第二步，利用request.source()构建DSL，DSL中可以包含查询、分页、排序、高亮等 query()：代表查询条件，利用QueryBuilders.matchAllQuery()构建一个match_all查询的DSL 第三步，利用client.search()发送请求，得到响应 这里关键的API有两个，一个是request.source()，其中包含了查询、排序、分页、高亮等所有功能： 另一个是QueryBuilders，其中包含match、term、function_score、bool等各种查询： 3.1.2.解析响应响应结果的解析： elasticsearch返回的结果是一个JSON字符串，结构包含： hits：命中的结果 total：总条数，其中的value是具体的总条数值 max_score：所有结果中得分最高的文档的相关性算分 hits：搜索结果的文档数组，其中的每个文档都是一个json对象 _source：文档中的原始数据，也是json对象 因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下： SearchHits：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果 SearchHits#getTotalHits().value：获取总条数信息 SearchHits#getHits()：获取SearchHit数组，也就是文档数组 SearchHit#getSourceAsString()：获取文档结果中的_source，也就是原始的json文档数据 3.1.3.完整代码完整代码如下： 12345678910111213141516171819202122232425262728293031@Testvoid testMatchAll() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL request.source() .query(QueryBuilders.matchAllQuery()); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125;private void handleResponse(SearchResponse response) &#123; // 4.解析响应 SearchHits searchHits = response.getHits(); // 4.1.获取总条数 long total = searchHits.getTotalHits().value; System.out.println(\"共搜索到\" + total + \"条数据\"); // 4.2.文档数组 SearchHit[] hits = searchHits.getHits(); // 4.3.遍历 for (SearchHit hit : hits) &#123; // 获取文档source String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); System.out.println(\"hotelDoc = \" + hotelDoc); &#125;&#125; 3.1.4.小结查询的基本步骤是： 创建SearchRequest对象 准备Request.source()，也就是DSL。 ① QueryBuilders来构建查询条件 ② 传入Request.source() 的 query() 方法 发送请求，得到结果 解析结果（参考JSON结果，从外到内，逐层解析） 3.2.match查询全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。 因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法： 而结果解析代码则完全一致，可以抽取并共享。 完整代码如下： 12345678910111213@Testvoid testMatch() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL request.source() .query(QueryBuilders.matchQuery(\"all\", \"如家\")); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.3.精确查询精确查询主要是两者： term：词条精确匹配 range：范围查询 与之前的查询相比，差异同样在查询条件，其它都一样。 查询条件构造的API如下： 3.4.布尔查询布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下： 可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。 完整代码如下： 12345678910111213141516171819@Testvoid testBool() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.准备BooleanQuery BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 2.2.添加term boolQuery.must(QueryBuilders.termQuery(\"city\", \"杭州\")); // 2.3.添加range boolQuery.filter(QueryBuilders.rangeQuery(\"price\").lte(250)); request.source().query(boolQuery); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.5.排序、分页搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。 对应的API如下： 完整代码示例： 1234567891011121314151617181920@Testvoid testPageAndSort() throws IOException &#123; // 页码，每页大小 int page = 1, size = 5; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.query request.source().query(QueryBuilders.matchAllQuery()); // 2.2.排序 sort request.source().sort(\"price\", SortOrder.ASC); // 2.3.分页 from、size request.source().from((page - 1) * size).size(5); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.6.高亮高亮的代码与之前代码差异较大，有两点： 查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。 结果解析：结果除了要解析_source文档数据，还要解析高亮结果 3.6.1.高亮请求构建高亮请求的构建API如下： 上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。 完整代码如下： 123456789101112131415@Testvoid testHighlight() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.query request.source().query(QueryBuilders.matchQuery(\"all\", \"如家\")); // 2.2.高亮 request.source().highlighter(new HighlightBuilder().field(\"name\").requireFieldMatch(false)); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.6.2.高亮结果解析高亮的结果与查询的文档结果默认是分离的，并不在一起。 因此解析高亮的代码需要额外处理： 代码解读： 第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象 第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值 第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField 第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了 第五步：用高亮的结果替换HotelDoc中的非高亮结果 完整代码如下： 1234567891011121314151617181920212223242526272829private void handleResponse(SearchResponse response) &#123; // 4.解析响应 SearchHits searchHits = response.getHits(); // 4.1.获取总条数 long total = searchHits.getTotalHits().value; System.out.println(\"共搜索到\" + total + \"条数据\"); // 4.2.文档数组 SearchHit[] hits = searchHits.getHits(); // 4.3.遍历 for (SearchHit hit : hits) &#123; // 获取文档source String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); // 获取高亮结果 Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields(); if (!CollectionUtils.isEmpty(highlightFields)) &#123; // 根据字段名获取高亮结果 HighlightField highlightField = highlightFields.get(\"name\"); if (highlightField != null) &#123; // 获取高亮值 String name = highlightField.getFragments()[0].string(); // 覆盖非高亮结果 hotelDoc.setName(name); &#125; &#125; System.out.println(\"hotelDoc = \" + hotelDoc); &#125;&#125; 4.黑马旅游案例下面，我们通过黑马旅游的案例来实战演练下之前学习的知识。 我们实现四部分功能： 酒店搜索和分页 酒店结果过滤 我周边的酒店 酒店竞价排名 启动我们提供的hotel-demo项目，其默认端口是8089，访问http://localhost:8090，就能看到项目页面了： 4.1.酒店搜索和分页案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页 4.1.1.需求分析在项目的首页，有一个大大的搜索框，还有分页按钮： 点击搜索按钮，可以看到浏览器控制台发出了请求： 请求参数如下： 由此可以知道，我们这个请求的信息如下： 请求方式：POST 请求路径：/hotel/list 请求参数：JSON对象，包含4个字段： key：搜索关键字 page：页码 size：每页大小 sortBy：排序，目前暂不实现 返回值：分页查询，需要返回分页结果PageResult，包含两个属性： total：总条数 List&lt;HotelDoc&gt;：当前页的数据 因此，我们实现业务的流程如下： 步骤一：定义实体类，接收请求参数的JSON对象 步骤二：编写controller，接收页面的请求 步骤三：编写业务实现，利用RestHighLevelClient实现搜索、分页 4.1.2.定义实体类实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。 1）请求参数 前端请求的json结构如下： 123456&#123; \"key\": \"搜索关键字\", \"page\": 1, \"size\": 3, \"sortBy\": \"default\"&#125; 因此，我们在cn.itcast.hotel.pojo包下定义一个实体类： 1234567891011package cn.itcast.hotel.pojo;import lombok.Data;@Datapublic class RequestParams &#123; private String key; private Integer page; private Integer size; private String sortBy;&#125; 2）返回值 分页查询，需要返回分页结果PageResult，包含两个属性： total：总条数 List&lt;HotelDoc&gt;：当前页的数据 因此，我们在cn.itcast.hotel.pojo中定义返回结果： 12345678910111213141516171819package cn.itcast.hotel.pojo;import lombok.Data;import java.util.List;@Datapublic class PageResult &#123; private Long total; private List&lt;HotelDoc&gt; hotels; public PageResult() &#123; &#125; public PageResult(Long total, List&lt;HotelDoc&gt; hotels) &#123; this.total = total; this.hotels = hotels; &#125;&#125; 4.1.3.定义controller定义一个HotelController，声明查询接口，满足下列要求： 请求方式：Post 请求路径：/hotel/list 请求参数：对象，类型为RequestParam 返回值：PageResult，包含两个属性 Long total：总条数 List&lt;HotelDoc&gt; hotels：酒店数据 因此，我们在cn.itcast.hotel.web中定义HotelController： 123456789101112@RestController@RequestMapping(\"/hotel\")public class HotelController &#123; @Autowired private IHotelService hotelService; // 搜索酒店数据 @PostMapping(\"/list\") public PageResult search(@RequestBody RequestParams params)&#123; return hotelService.search(params); &#125;&#125; 4.1.4.实现搜索业务我们在controller调用了IHotelService，并没有实现该方法，因此下面我们就在IHotelService中定义方法，并且去实现业务逻辑。 1）在cn.itcast.hotel.service中的IHotelService接口中定义一个方法： 123456/** * 根据关键字搜索酒店信息 * @param params 请求参数对象，包含用户输入的关键字 * @return 酒店文档列表 */PageResult search(RequestParams params); 2）实现搜索业务，肯定离不开RestHighLevelClient，我们需要把它注册到Spring中作为一个Bean。在cn.itcast.hotel中的HotelDemoApplication中声明这个Bean： 123456@Beanpublic RestHighLevelClient client()&#123; return new RestHighLevelClient(RestClient.builder( HttpHost.create(\"http://192.168.150.101:9200\") ));&#125; 3）在cn.itcast.hotel.service.impl中的HotelService中实现search方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Servicepublic class HotelService extends ServiceImpl&lt;HotelMapper, Hotel&gt; implements IHotelService &#123; @Autowired private RestHighLevelClient client; @Override public PageResult search(RequestParams params) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.query String key = params.getKey(); if (key == null || \"\".equals(key)) &#123; request.source().query(QueryBuilders.matchAllQuery()); &#125; else &#123; request.source().query(QueryBuilders.matchQuery(\"all\", key)); &#125; // 2.2.分页 int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 return handleResponse(response); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; // 结果解析 private PageResult handleResponse(SearchResponse response) &#123; // 4.解析响应 SearchHits searchHits = response.getHits(); // 4.1.获取总条数 long total = searchHits.getTotalHits().value; // 4.2.文档数组 SearchHit[] hits = searchHits.getHits(); // 4.3.遍历 List&lt;HotelDoc&gt; hotels = new ArrayList&lt;&gt;(); for (SearchHit hit : hits) &#123; // 获取文档source String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); // 放入集合 hotels.add(hotelDoc); &#125; // 4.4.封装返回 return new PageResult(total, hotels); &#125;&#125; 4.2.酒店结果过滤需求：添加品牌、城市、星级、价格等过滤功能 4.2.1.需求分析在页面搜索框下面，会有一些过滤项： 传递的参数如图： 包含的过滤条件有： brand：品牌值 city：城市 minPrice~maxPrice：价格范围 starName：星级 我们需要做两件事情： 修改请求参数的对象RequestParams，接收上述参数 修改业务逻辑，在搜索条件之外，添加一些过滤条件 4.2.2.修改实体类修改在cn.itcast.hotel.pojo包下的实体类RequestParams： 12345678910111213@Datapublic class RequestParams &#123; private String key; private Integer page; private Integer size; private String sortBy; // 下面是新增的过滤条件参数 private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice;&#125; 4.2.3.修改搜索业务在HotelService的search方法中，只有一个地方需要修改：requet.source().query( … )其中的查询条件。 在之前的业务中，只有match查询，根据关键字搜索，现在要添加条件过滤，包括： 品牌过滤：是keyword类型，用term查询 星级过滤：是keyword类型，用term查询 价格过滤：是数值类型，用range查询 城市过滤：是keyword类型，用term查询 多个查询条件组合，肯定是boolean查询来组合： 关键字搜索放到must中，参与算分 其它过滤条件放到filter中，不参与算分 因为条件构建的逻辑比较复杂，这里先封装为一个函数： buildBasicQuery的代码如下： 123456789101112131415161718192021222324252627282930313233private void buildBasicQuery(RequestParams params, SearchRequest request) &#123; // 1.构建BooleanQuery BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 2.关键字搜索 String key = params.getKey(); if (key == null || \"\".equals(key)) &#123; boolQuery.must(QueryBuilders.matchAllQuery()); &#125; else &#123; boolQuery.must(QueryBuilders.matchQuery(\"all\", key)); &#125; // 3.城市条件 if (params.getCity() != null &amp;&amp; !params.getCity().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"city\", params.getCity())); &#125; // 4.品牌条件 if (params.getBrand() != null &amp;&amp; !params.getBrand().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"brand\", params.getBrand())); &#125; // 5.星级条件 if (params.getStarName() != null &amp;&amp; !params.getStarName().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"starName\", params.getStarName())); &#125; // 6.价格 if (params.getMinPrice() != null &amp;&amp; params.getMaxPrice() != null) &#123; boolQuery.filter(QueryBuilders .rangeQuery(\"price\") .gte(params.getMinPrice()) .lte(params.getMaxPrice()) ); &#125; // 7.放入source request.source().query(boolQuery);&#125; 4.3.我周边的酒店需求：我附近的酒店 4.3.1.需求分析在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置： 并且，在前端会发起查询请求，将你的坐标发送到服务端： 我们要做的事情就是基于这个location坐标，然后按照距离对周围酒店排序。实现思路如下： 修改RequestParams参数，接收location字段 修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能 4.3.2.修改实体类修改在cn.itcast.hotel.pojo包下的实体类RequestParams： 123456789101112131415161718package cn.itcast.hotel.pojo;import lombok.Data;@Datapublic class RequestParams &#123; private String key; private Integer page; private Integer size; private String sortBy; private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice; // 我当前的地理坐标 private String location;&#125; 4.3.3.距离排序API我们以前学习过排序功能，包括两种： 普通字段排序 地理坐标排序 我们只讲了普通字段排序对应的java写法。地理坐标排序只学过DSL语法，如下： 123456789101112131415161718GET /indexName/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"sort\": [ &#123; \"price\": \"asc\" &#125;, &#123; \"_geo_distance\" : &#123; \"FIELD\" : \"纬度，经度\", \"order\" : \"asc\", \"unit\" : \"km\" &#125; &#125; ]&#125; 对应的java代码示例： 4.3.4.添加距离排序在cn.itcast.hotel.service.impl的HotelService的search方法中，添加一个排序功能： 完整代码： 1234567891011121314151617181920212223242526272829303132@Overridepublic PageResult search(RequestParams params) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.query buildBasicQuery(params, request); // 2.2.分页 int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // 2.3.排序 String location = params.getLocation(); if (location != null &amp;&amp; !location.equals(\"\")) &#123; request.source().sort(SortBuilders .geoDistanceSort(\"location\", new GeoPoint(location)) .order(SortOrder.ASC) .unit(DistanceUnit.KILOMETERS) ); &#125; // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 return handleResponse(response); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125; 4.3.5.排序距离显示重启服务后，测试我的酒店功能： 发现确实可以实现对我附近酒店的排序，不过并没有看到酒店到底距离我多远，这该怎么办？ 排序完成后，页面还要获取我附近每个酒店的具体距离值，这个值在响应结果中是独立的： 因此，我们在结果解析阶段，除了解析source部分以外，还要得到sort部分，也就是排序的距离，然后放到响应结果中。 我们要做两件事： 修改HotelDoc，添加排序距离字段，用于页面显示 修改HotelService类中的handleResponse方法，添加对sort值的获取 1）修改HotelDoc类，添加距离字段 12345678910111213141516171819202122232425262728293031323334353637package cn.itcast.hotel.pojo;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; // 排序时的 距离值 private Object distance; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \", \" + hotel.getLongitude(); this.pic = hotel.getPic(); &#125;&#125; 2）修改HotelService中的handleResponse方法 12345678910111213141516171819202122232425262728// 结果解析 private PageResult handleResponse(SearchResponse response) &#123; // 4.解析响应 SearchHits searchHits = response.getHits(); // 4.1.获取总条数 long total = searchHits.getTotalHits().value; // 4.2.文档数组 SearchHit[] hits = searchHits.getHits(); // 4.3.遍历 List&lt;HotelDoc&gt; hotels = new ArrayList&lt;&gt;(); for (SearchHit hit : hits) &#123; // 获取文档source String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); // 获取排序值 Object[] sortValues = hit.getSortValues(); if(sortValues.length &gt; 0)&#123; Object sortValue = sortValues[0]; hotelDoc.setDistance(sortValue); &#125; // 放入集合 hotels.add(hotelDoc); &#125; // 4.4.封装返回 return new PageResult(total, hotels); &#125; 重启后测试，发现页面能成功显示距离了： 4.4.酒店竞价排名需求：让指定的酒店在搜索结果中排名置顶 4.4.1.需求分析要让指定酒店在搜索结果中排名置顶，效果如图： 页面会给指定的酒店添加广告标记。 那怎样才能让指定的酒店排名置顶呢？ 我们之前学习过的function_score查询可以影响算分，算分高了，自然排名也就高了。而function_score包含3个要素： 过滤条件：哪些文档要加分 算分函数：如何计算function score 加权方式：function score 与 query score如何运算 这里的需求是：让指定酒店排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以根据这个标记来判断，是否要提高算分。 比如，我们给酒店添加一个字段：isAD，Boolean类型： true：是广告 false：不是广告 这样function_score包含3个要素就很好确定了： 过滤条件：判断isAD 是否为true 算分函数：我们可以用最简单暴力的weight，固定加权值 加权方式：可以用默认的相乘，大大提高算分 因此，业务的实现步骤包括： 给HotelDoc类添加isAD字段，Boolean类型 挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true 修改search方法，添加function score功能，给isAD值为true的酒店增加权重 4.4.2.修改HotelDoc实体给cn.itcast.hotel.pojo包下的HotelDoc类添加isAD字段： 123456789101112131415161718@Data@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; // 排序时的 距离值 private Object distance; // 广告标记 private Boolean isAD; 4.4.3.添加广告标记接下来，我们挑几个酒店，添加isAD字段，设置为true： 123456789101112131415161718192021222324POST /hotel/_update/1902197537&#123; \"doc\": &#123; \"isAD\": true &#125;&#125;POST /hotel/_update/2056126831&#123; \"doc\": &#123; \"isAD\": true &#125;&#125;POST /hotel/_update/1989806195&#123; \"doc\": &#123; \"isAD\": true &#125;&#125;POST /hotel/_update/2056105938&#123; \"doc\": &#123; \"isAD\": true &#125;&#125; 4.4.4.添加算分函数查询接下来我们就要修改查询条件了。之前是用的boolean 查询，现在要改成function_socre查询。 function_score查询结构如下： 对应的JavaAPI如下： 我们可以将之前写的boolean查询作为原始查询条件放到query中，接下来就是添加过滤条件、算分函数、加权模式了。所以原来的代码依然可以沿用。 修改cn.itcast.hotel.service.impl包下的HotelService类中的buildBasicQuery方法，添加算分函数查询： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void buildBasicQuery(RequestParams params, SearchRequest request) &#123; // 1.构建BooleanQuery BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 关键字搜索 String key = params.getKey(); if (key == null || \"\".equals(key)) &#123; boolQuery.must(QueryBuilders.matchAllQuery()); &#125; else &#123; boolQuery.must(QueryBuilders.matchQuery(\"all\", key)); &#125; // 城市条件 if (params.getCity() != null &amp;&amp; !params.getCity().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"city\", params.getCity())); &#125; // 品牌条件 if (params.getBrand() != null &amp;&amp; !params.getBrand().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"brand\", params.getBrand())); &#125; // 星级条件 if (params.getStarName() != null &amp;&amp; !params.getStarName().equals(\"\")) &#123; boolQuery.filter(QueryBuilders.termQuery(\"starName\", params.getStarName())); &#125; // 价格 if (params.getMinPrice() != null &amp;&amp; params.getMaxPrice() != null) &#123; boolQuery.filter(QueryBuilders .rangeQuery(\"price\") .gte(params.getMinPrice()) .lte(params.getMaxPrice()) ); &#125; // 2.算分控制 FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery( // 原始查询，相关性算分的查询 boolQuery, // function score的数组 new FunctionScoreQueryBuilder.FilterFunctionBuilder[]&#123; // 其中的一个function score 元素 new FunctionScoreQueryBuilder.FilterFunctionBuilder( // 过滤条件 QueryBuilders.termQuery(\"isAD\", true), // 算分函数 ScoreFunctionBuilders.weightFactorFunction(10) ) &#125;); request.source().query(functionScoreQuery);&#125; 分布式搜索引擎030.学习目标1.数据聚合聚合（aggregations）可以让我们极其方便的实现对数据的统计、分析、运算。例如： 什么品牌的手机最受欢迎？ 这些手机的平均价格、最高价格、最低价格？ 这些手机每月的销售情况如何？ 实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。 1.1.聚合的种类聚合常见的有三类： 桶（Bucket）聚合：用来对文档做分组 TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组 Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组 度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等 Avg：求平均值 Max：求最大值 Min：求最小值 Stats：同时求max、min、avg、sum等 管道（pipeline）聚合：其它聚合的结果为基础做聚合 注意：参加聚合的字段必须是keyword、日期、数值、布尔类型 1.2.DSL实现聚合现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。 1.2.1.Bucket聚合语法语法如下： 123456789101112GET /hotel/_search&#123; \"size\": 0, // 设置size为0，结果中不包含文档，只包含聚合结果 \"aggs\": &#123; // 定义聚合 \"brandAgg\": &#123; //给聚合起个名字 \"terms\": &#123; // 聚合的类型，按照品牌值聚合，所以选择term \"field\": \"brand\", // 参与聚合的字段 \"size\": 20 // 希望获取的聚合结果数量 &#125; &#125; &#125;&#125; 结果如图： 12345678910111213# 聚合功能GET /hotel/_search&#123; \"size\": 0, \"aggs\": &#123; \"brandAgg\": &#123; \"terms\": &#123; \"field\": \"brand\", \"size\": 20 &#125; &#125; &#125;&#125; 1.2.2.聚合结果排序默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。 我们可以指定order属性，自定义聚合的排序方式： 12345678910111213141516# 聚合功能,自定义排序规则GET /hotel/_search&#123; \"size\": 0, \"aggs\": &#123; \"brandAgg\": &#123; \"terms\": &#123; \"field\": \"brand\", \"order\": &#123; \"_count\": \"asc\" // 按照_count升序排列 &#125;, \"size\": 20 &#125; &#125; &#125;&#125; 1.2.3.限定聚合范围默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。 我们可以限定要聚合的文档范围，只要添加query条件即可： 1234567891011121314151617181920# 聚合功能,限定聚合范围GET /hotel/_search&#123; \"query\": &#123; \"range\": &#123; \"price\": &#123; \"lte\": 200 // 只对200元以下的文档聚合 &#125; &#125; &#125;, \"size\": 0, \"aggs\": &#123; \"brandAgg\": &#123; \"terms\": &#123; \"field\": \"brand\", \"size\": 20 &#125; &#125; &#125;&#125; 这次，聚合得到的品牌明显变少了： 1.2.4.Metric聚合语法上节课，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。 这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。 语法如下： 12345678910111213141516171819GET /hotel/_search&#123; \"size\": 0, \"aggs\": &#123; \"brandAgg\": &#123; \"terms\": &#123; \"field\": \"brand\", \"size\": 20 &#125;, \"aggs\": &#123; // 是brands聚合的子聚合，也就是分组后对每组分别计算 \"score_stats\": &#123; // 聚合名称 \"stats\": &#123; // 聚合类型，这里stats可以计算min、max、avg等 \"field\": \"score\" // 聚合字段，这里是score &#125; &#125; &#125; &#125; &#125;&#125; 这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。 另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序： 1234567891011121314151617181920212223# 嵌套聚合metricGET /hotel/_search&#123; \"size\": 0, \"aggs\": &#123; \"brandAgg\": &#123; \"terms\": &#123; \"field\": \"brand\", \"size\": 20, \"order\": &#123; \"scoreAgg.avg\": \"desc\" &#125; &#125;, \"aggs\": &#123; \"scoreAgg\": &#123; \"stats\": &#123; \"field\": \"score\" &#125; &#125; &#125; &#125; &#125;&#125; 1.2.5.小结aggs代表聚合，与query同级，此时query的作用是？ 限定聚合的的文档范围 聚合必须的三要素： 聚合名称 聚合类型 聚合字段 聚合可配置属性有： size：指定聚合结果数量 order：指定聚合结果排序方式 field：指定聚合字段 1.3.RestAPI实现聚合1.3.1.API语法聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。 聚合条件的语法： 聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析： 1234567891011121314151617181920212223242526@Test void testAggregation() throws IOException &#123; // 1.准备请求 SearchRequest request = new SearchRequest(\"hotel\"); // 2.请求参数 // 2.1.size request.source().size(0); // 2.2.聚合 request.source().aggregation( AggregationBuilders.terms(\"brandAgg\").field(\"brand\").size(20)); // 3.发出请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析结果 Aggregations aggregations = response.getAggregations(); // 4.1.根据聚合名称，获取聚合结果 Terms brandAgg = aggregations.get(\"brandAgg\"); // 4.2.获取buckets List&lt;? extends Terms.Bucket&gt; buckets = brandAgg.getBuckets(); // 4.3.遍历 for (Terms.Bucket bucket : buckets) &#123; String brandName = bucket.getKeyAsString(); System.out.println(\"brandName = \" + brandName); long docCount = bucket.getDocCount(); System.out.println(\"docCount = \" + docCount); &#125; &#125; 1.3.2.业务需求需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的： 分析： 目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。 例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。 也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。 如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？ 使用聚合功能，利用Bucket聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。 因为是对搜索结果聚合，因此聚合是限定范围的聚合，也就是说聚合的限定条件跟搜索文档的条件一致。 查看浏览器可以发现，前端其实已经发出了这样的一个请求： 请求参数与搜索文档的参数完全一致。 返回值类型就是页面要展示的最终结果： 结果是一个Map结构： key是字符串，城市、星级、品牌、价格 value是集合，例如多个城市的名称 1.3.3.业务实现在cn.itcast.hotel.web包的HotelController中添加一个方法，遵循下面的要求： 请求方式：POST 请求路径：/hotel/filters 请求参数：RequestParams，与搜索文档的参数一致 返回值类型：Map&lt;String, List&lt;String&gt;&gt; 代码： 1234@PostMapping(\"filters\")public Map&lt;String, List&lt;String&gt;&gt; getFilters(@RequestBody RequestParams params)&#123; return hotelService.getFilters(params);&#125; 这里调用了IHotelService中的getFilters方法，尚未实现。 在cn.itcast.hotel.service.IHotelService中定义新方法： 1Map&lt;String, List&lt;String&gt;&gt; filters(RequestParams params); 在cn.itcast.hotel.service.impl.HotelService中实现该方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Overridepublic Map&lt;String, List&lt;String&gt;&gt; filters(RequestParams params) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL // 2.1.query buildBasicQuery(params, request); // 2.2.设置size request.source().size(0); // 2.3.聚合 buildAggregation(request); // 3.发出请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析结果 Map&lt;String, List&lt;String&gt;&gt; result = new HashMap&lt;&gt;(); Aggregations aggregations = response.getAggregations(); // 4.1.根据品牌名称，获取品牌结果 List&lt;String&gt; brandList = getAggByName(aggregations, \"brandAgg\"); result.put(\"品牌\", brandList); // 4.2.根据品牌名称，获取品牌结果 List&lt;String&gt; cityList = getAggByName(aggregations, \"cityAgg\"); result.put(\"城市\", cityList); // 4.3.根据品牌名称，获取品牌结果 List&lt;String&gt; starList = getAggByName(aggregations, \"starAgg\"); result.put(\"星级\", starList); return result; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125;private void buildAggregation(SearchRequest request) &#123; request.source().aggregation(AggregationBuilders .terms(\"brandAgg\") .field(\"brand\") .size(100) ); request.source().aggregation(AggregationBuilders .terms(\"cityAgg\") .field(\"city\") .size(100) ); request.source().aggregation(AggregationBuilders .terms(\"starAgg\") .field(\"starName\") .size(100) );&#125;private List&lt;String&gt; getAggByName(Aggregations aggregations, String aggName) &#123; // 4.1.根据聚合名称获取聚合结果 Terms brandTerms = aggregations.get(aggName); // 4.2.获取buckets List&lt;? extends Terms.Bucket&gt; buckets = brandTerms.getBuckets(); // 4.3.遍历 List&lt;String&gt; brandList = new ArrayList&lt;&gt;(); for (Terms.Bucket bucket : buckets) &#123; // 4.4.获取key String key = bucket.getKeyAsString(); brandList.add(key); &#125; return brandList;&#125; 2.自动补全当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图： 这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。 因为需要根据拼音字母来推断，因此要用到拼音分词功能。 2.1.拼音分词器要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：https://github.com/medcl/elasticsearch-analysis-pinyin 课前资料中也提供了拼音分词器的安装包： 安装方式与IK分词器一样，分三步： ​ ①解压 ​ ②上传到虚拟机中，elasticsearch的plugin目录 ​ /var/lib/docker/volumes/es-plugins/_data ​ ③重启elasticsearch ​ ④测试 详细安装步骤可以参考IK分词器的安装过程。 测试用法如下： 12345POST /_analyze&#123; \"text\": \"如家酒店还不错\", \"analyzer\": \"pinyin\"&#125; 结果： 2.2.自定义分词器默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。 elasticsearch中分词器（analyzer）的组成包含三部分： character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符 tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等 文档分词时会依次由这三部分来处理文档： 声明自定义分词器的语法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667PUT /test&#123; \"settings\": &#123; \"analysis\": &#123; \"analyzer\": &#123; // 自定义分词器 \"my_analyzer\": &#123; // 分词器名称 \"tokenizer\": \"ik_max_word\", \"filter\": \"py\" &#125; &#125;, \"filter\": &#123; // 自定义tokenizer filter \"py\": &#123; // 过滤器名称 \"type\": \"pinyin\", // 过滤器类型，这里是pinyin \"keep_full_pinyin\": false, \"keep_joined_full_pinyin\": true, \"keep_original\": true, \"limit_first_letter_length\": 16, \"remove_duplicated_term\": true, \"none_chinese_pinyin_tokenize\": false &#125; &#125; &#125; &#125;, \"mappings\": &#123; \"properties\": &#123; \"name\": &#123; \"type\": \"text\", \"analyzer\": \"my_analyzer\", //创建时使用 \"search_analyzer\": \"ik_smart\" //search使用 &#125; &#125; &#125;&#125;PUT /test&#123; \"settings\": &#123; \"analysis\": &#123; \"analyzer\": &#123; \"my_analyzer\": &#123; \"tokenizer\": \"ik_max_word\", \"filter\": \"py\" &#125; &#125;, \"filter\": &#123; \"py\": &#123; \"type\": \"pinyin\", \"keep_full_pinyin\": false, \"keep_joined_full_pinyin\": true, \"keep_original\": true, \"limit_first_letter_length\": 16, \"remove_duplicated_term\": true, \"none_chinese_pinyin_tokenize\": false &#125; &#125; &#125; &#125;, \"mappings\": &#123; \"properties\": &#123; \"name\": &#123; \"type\": \"text\", \"analyzer\": \"my_analyzer\", \"search_analyzer\": \"ik_smart\" &#125; &#125; &#125;&#125; 测试： 总结： 如何使用拼音分词器？ ①下载pinyin分词器 ②解压并放到elasticsearch的plugin目录 ③重启即可 如何自定义分词器？ ①创建索引库时，在settings中配置，可以包含三部分 ②character filter ③tokenizer ④filter 拼音分词器注意事项？ 为了避免搜索到同音字，搜索时不要使用拼音分词器 2.3.自动补全查询elasticsearch提供了Completion Suggester查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束： 参与补全查询的字段必须是completion类型。 字段的内容一般是用来补全的多个词条形成的数组。 比如，一个这样的索引库： 1234567891011# 创建索引库PUT test2&#123; \"mappings\": &#123; \"properties\": &#123; \"title\":&#123; \"type\": \"completion\" &#125; &#125; &#125;&#125; 然后插入下面的数据： 12345678910111213# 示例数据POST test2/_doc&#123; \"title\": [\"Sony\", \"WH-1000XM3\"]&#125;POST test2/_doc&#123; \"title\": [\"SK-II\", \"PITERA\"]&#125;POST test2/_doc&#123; \"title\": [\"Nintendo\", \"switch\"]&#125; 查询的DSL语句如下： 123456789101112131415161718192021222324252627282930// 自动补全查询GET /test/_search&#123; \"suggest\": &#123; \"title_suggest\": &#123; \"text\": \"s\", // 关键字 \"completion\": &#123; \"field\": \"title\", // 补全查询的字段 \"skip_duplicates\": true, // 跳过重复的 \"size\": 10 // 获取前10条结果 &#125; &#125; &#125;&#125;# 自动补全查询GET /test2/_search&#123; \"suggest\": &#123; \"title_suggest\": &#123; \"text\": \"s\", \"completion\": &#123; \"field\": \"title\", \"skip_duplicates\": true, \"size\": 10 &#125; &#125; &#125;&#125; 2.4.实现酒店搜索框自动补全现在，我们的hotel索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。 另外，我们需要添加一个字段，用来做自动补全，将brand、suggestion、city等都放进去，作为自动补全的提示。 因此，总结一下，我们需要做的事情包括： 修改hotel索引库结构，设置自定义拼音分词器 修改索引库的name、all字段，使用自定义分词器 索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器 给HotelDoc类添加suggestion字段，内容包含brand、business 重新导入数据到hotel库 2.4.1.修改酒店映射结构12# 查看酒店数据结构GET /hotel/_mapping 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 酒店数据索引库PUT /hotel&#123; \"settings\": &#123; \"analysis\": &#123; \"analyzer\": &#123; \"text_anlyzer\": &#123; \"tokenizer\": \"ik_max_word\", \"filter\": \"py\" &#125;, \"completion_analyzer\": &#123; \"tokenizer\": \"keyword\", \"filter\": \"py\" &#125; &#125;, \"filter\": &#123; \"py\": &#123; \"type\": \"pinyin\", \"keep_full_pinyin\": false, \"keep_joined_full_pinyin\": true, \"keep_original\": true, \"limit_first_letter_length\": 16, \"remove_duplicated_term\": true, \"none_chinese_pinyin_tokenize\": false &#125; &#125; &#125; &#125;, \"mappings\": &#123; \"properties\": &#123; \"id\":&#123; \"type\": \"keyword\" &#125;, \"name\":&#123; \"type\": \"text\", \"analyzer\": \"text_anlyzer\", \"search_analyzer\": \"ik_smart\", \"copy_to\": \"all\" &#125;, \"address\":&#123; \"type\": \"keyword\", \"index\": false &#125;, \"price\":&#123; \"type\": \"integer\" &#125;, \"score\":&#123; \"type\": \"integer\" &#125;, \"brand\":&#123; \"type\": \"keyword\", \"copy_to\": \"all\" &#125;, \"city\":&#123; \"type\": \"keyword\" &#125;, \"starName\":&#123; \"type\": \"keyword\" &#125;, \"business\":&#123; \"type\": \"keyword\", \"copy_to\": \"all\" &#125;, \"location\":&#123; \"type\": \"geo_point\" &#125;, \"pic\":&#123; \"type\": \"keyword\", \"index\": false &#125;, \"all\":&#123; \"type\": \"text\", \"analyzer\": \"text_anlyzer\", \"search_analyzer\": \"ik_smart\" &#125;, \"suggestion\":&#123; \"type\": \"completion\", \"analyzer\": \"completion_analyzer\" &#125; &#125; &#125;&#125; 2.4.2.修改HotelDoc实体HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。 因此我们在HotelDoc中添加一个suggestion字段，类型为List&lt;String&gt;，然后将brand、city、business等信息放到里面。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.itcast.hotel.pojo;import lombok.Data;import lombok.NoArgsConstructor;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;@Data@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; private Object distance; private Boolean isAD; private List&lt;String&gt; suggestion; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \", \" + hotel.getLongitude(); this.pic = hotel.getPic(); // 组装suggestion if(this.business.contains(\"/\"))&#123; // business有多个值，需要切割 String[] arr = this.business.split(\"/\"); // 添加元素 this.suggestion = new ArrayList&lt;&gt;(); this.suggestion.add(this.brand); Collections.addAll(this.suggestion, arr); &#125;else &#123; this.suggestion = Arrays.asList(this.brand, this.business); &#125; &#125;&#125; 2.4.3.重新导入cn.itcast.hotel.HotelDocumentTest#testBulkRequest方法 重新执行之前编写的导入数据功能，可以看到新的酒店数据中包含了suggestion： 123456GET /hotel/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125; 测试自动补全 12345678910111213GET /hotel/_search&#123; \"suggest\": &#123; \"suggestions\": &#123; \"text\": \"h\", \"completion\": &#123; \"field\": \"suggestion\", \"skip_duplicates\": true, \"size\": 10 &#125; &#125; &#125;&#125; 2.4.4.自动补全查询的JavaAPI之前我们学习了自动补全查询的DSL，而没有学习对应的JavaAPI，这里给出一个示例： 而自动补全的结果也比较特殊，解析的代码如下： 1234567891011121314151617181920212223242526272829@Testvoid testSuggest() throws IOException &#123; // 1.准备request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL request.source().suggest( new SuggestBuilder().addSuggestion( \"suggestions\", SuggestBuilders.completionSuggestion(\"suggestion\") .prefix(\"h\") .skipDuplicates(true) .size(10) ) ); // 3.发送请求，得到响应 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.结果解析 Suggest suggest = response.getSuggest(); // 4.1根据补全查询名称，获取补全结果 CompletionSuggestion suggestions = suggest.getSuggestion(\"suggestions\"); // 4.2.获取options List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions(); // 4.3.遍历 for (CompletionSuggestion.Entry.Option option : options) &#123; String text = option.getText().toString(); System.out.println(text); &#125;&#125; 2.4.5.实现搜索框自动补全查看前端页面，可以发现当我们在输入框键入时，前端会发起ajax请求： 返回值是补全词条的集合，类型为List&lt;String&gt; 1）在cn.itcast.hotel.web包下的HotelController中添加新接口，接收新的请求： 1234@GetMapping(\"suggestion\")public List&lt;String&gt; getSuggestions(@RequestParam(\"key\") String prefix) &#123; return hotelService.getSuggestions(prefix);&#125; 2）在cn.itcast.hotel.service包下的IhotelService中添加方法： 1List&lt;String&gt; getSuggestions(String prefix); 3）在cn.itcast.hotel.service.impl.HotelService中实现该方法： 1234567891011121314151617181920212223242526272829303132@Overridepublic List&lt;String&gt; getSuggestions(String prefix) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(\"hotel\"); // 2.准备DSL request.source().suggest(new SuggestBuilder().addSuggestion( \"suggestions\", SuggestBuilders.completionSuggestion(\"suggestion\") .prefix(prefix) .skipDuplicates(true) .size(10) )); // 3.发起请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析结果 Suggest suggest = response.getSuggest(); // 4.1.根据补全查询名称，获取补全结果 CompletionSuggestion suggestions = suggest.getSuggestion(\"suggestions\"); // 4.2.获取options List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions(); // 4.3.遍历 List&lt;String&gt; list = new ArrayList&lt;&gt;(options.size()); for (CompletionSuggestion.Entry.Option option : options) &#123; String text = option.getText().toString(); list.add(text); &#125; return list; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125; 3.数据同步elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的数据同步。 3.1.思路分析常见的数据同步方案有三种： 同步调用 异步通知 监听binlog 3.1.1.同步调用方案一：同步调用 基本步骤如下： hotel-demo对外提供接口，用来修改elasticsearch中的数据 酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口， 3.1.2.异步通知方案二：异步通知 流程如下： hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息 hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改 3.1.3.监听binlog方案三：监听binlog 流程如下： 给mysql开启binlog功能 mysql完成增、删、改操作都会记录在binlog中 hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容 3.1.4.选择方式一：同步调用 优点：实现简单，粗暴 缺点：业务耦合度高 方式二：异步通知 优点：低耦合，实现难度一般 缺点：依赖mq的可靠性 方式三：监听binlog 优点：完全解除服务间耦合 缺点：开启binlog增加数据库负担、实现复杂度高 3.2.基于mq实现数据同步3.2.1.思路利用课前资料提供的hotel-admin项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。 步骤： 导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD 声明exchange、queue、RoutingKey 在hotel-admin中的增、删、改业务中完成消息发送 在hotel-demo中完成消息监听，并更新elasticsearch中数据 启动并测试数据同步功能 3.2.2.导入demo导入课前资料提供的hotel-admin项目： 运行后，访问 http://localhost:8099 其中包含了酒店的CRUD功能： 3.2.3.声明交换机、队列MQ结构如图： 1）引入依赖在hotel-admin、hotel-demo中引入rabbitmq的依赖： 12345&lt;!--amqp--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 配置mq 1234567spring: rabbitmq: host: 192.168.153.128 port: 5672 username: itcast password: 123321 virtual-host: / mq应用端口是5672 管理页面端口是15672 2）声明队列交换机名称在hotel-admin和hotel-demo中的cn.itcast.hotel.constatnts包下新建一个类MqConstants： 123456789101112131415161718192021222324package cn.itcast.hotel.constatnts; public class MqConstants &#123; /** * 交换机 */ public final static String HOTEL_EXCHANGE = \"hotel.topic\"; /** * 监听新增和修改的队列 */ public final static String HOTEL_INSERT_QUEUE = \"hotel.insert.queue\"; /** * 监听删除的队列 */ public final static String HOTEL_DELETE_QUEUE = \"hotel.delete.queue\"; /** * 新增或修改的RoutingKey */ public final static String HOTEL_INSERT_KEY = \"hotel.insert\"; /** * 删除的RoutingKey */ public final static String HOTEL_DELETE_KEY = \"hotel.delete\";&#125; 3）声明队列交换机在hotel-demo中，定义配置类，声明队列、交换机： 12345678910111213141516171819202122232425262728293031323334353637package cn.itcast.hotel.config;import cn.itcast.hotel.constants.MqConstants;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.Queue;import org.springframework.amqp.core.TopicExchange;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MqConfig &#123; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(MqConstants.HOTEL_EXCHANGE, true, false); &#125; @Bean public Queue insertQueue()&#123; return new Queue(MqConstants.HOTEL_INSERT_QUEUE, true); &#125; @Bean public Queue deleteQueue()&#123; return new Queue(MqConstants.HOTEL_DELETE_QUEUE, true); &#125; @Bean public Binding insertQueueBinding()&#123; return BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY); &#125; @Bean public Binding deleteQueueBinding()&#123; return BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY); &#125;&#125; 3.2.4.发送MQ消息在hotel-admin中的增、删、改业务中分别发送MQ消息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@RestController@RequestMapping(\"hotel\")public class HotelController &#123; @Autowired private IHotelService hotelService; @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\"/&#123;id&#125;\") public Hotel queryById(@PathVariable(\"id\") Long id)&#123; return hotelService.getById(id); &#125; @GetMapping(\"/list\") public PageResult hotelList( @RequestParam(value = \"page\", defaultValue = \"1\") Integer page, @RequestParam(value = \"size\", defaultValue = \"1\") Integer size )&#123; Page&lt;Hotel&gt; result = hotelService.page(new Page&lt;&gt;(page, size)); return new PageResult(result.getTotal(), result.getRecords()); &#125; @PostMapping public void saveHotel(@RequestBody Hotel hotel)&#123; // 新增酒店 hotelService.save(hotel); // 发送MQ消息 rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_INSERT_KEY, hotel.getId()); &#125; @PutMapping() public void updateById(@RequestBody Hotel hotel)&#123; if (hotel.getId() == null) &#123; throw new InvalidParameterException(\"id不能为空\"); &#125; hotelService.updateById(hotel); // 发送MQ消息 rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_INSERT_KEY, hotel.getId()); &#125; @DeleteMapping(\"/&#123;id&#125;\") public void deleteById(@PathVariable(\"id\") Long id) &#123; hotelService.removeById(id); // 发送MQ消息 rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_DELETE_KEY, id); &#125;&#125; 3.2.5.接收MQ消息hotel-demo接收到MQ消息要做的事情包括： 新增消息：根据传递的hotel的id查询hotel信息，然后新增一条数据到索引库 删除消息：根据传递的hotel的id删除索引库中的一条数据 1）首先在hotel-demo的cn.itcast.hotel.service包下的IHotelService中新增新增、删除业务 123void deleteById(Long id);void insertById(Long id); 2）给hotel-demo中的cn.itcast.hotel.service.impl包下的HotelService中实现业务： 123456789101112131415161718192021222324252627282930@Overridepublic void deleteById(Long id) &#123; try &#123; // 1.准备Request DeleteRequest request = new DeleteRequest(\"hotel\", id.toString()); // 2.发送请求 client.delete(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125;@Overridepublic void insertById(Long id) &#123; try &#123; // 0.根据id查询酒店数据 Hotel hotel = getById(id); // 转换为文档类型 HotelDoc hotelDoc = new HotelDoc(hotel); // 1.准备Request对象 IndexRequest request = new IndexRequest(\"hotel\").id(hotel.getId().toString()); // 2.准备Json文档 request.source(JSON.toJSONString(hotelDoc), XContentType.JSON); // 3.发送请求 client.index(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125; 3）编写监听器 在hotel-demo中的cn.itcast.hotel.mq包新增一个类： 1234567891011121314151617181920212223242526272829303132package cn.itcast.hotel.mq;import cn.itcast.hotel.constants.MqConstants;import cn.itcast.hotel.service.IHotelService;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class HotelListener &#123; @Autowired private IHotelService hotelService; /** * 监听酒店新增或修改的业务 * @param id 酒店id */ @RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE) public void listenHotelInsertOrUpdate(Long id)&#123; hotelService.insertById(id); &#125; /** * 监听酒店删除的业务 * @param id 酒店id */ @RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE) public void listenHotelDelete(Long id)&#123; hotelService.deleteById(id); &#125;&#125; 最后测试即可 4.es集群单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。 海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点 单点故障问题：将分片数据在不同节点备份（replica ） ES集群相关概念: 集群（cluster）：一组拥有共同的 cluster name 的 节点。 节点（node) ：集群中的一个 Elasticearch 实例 分片（shard）：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中 解决问题：数据量太大，单点存储量有限的问题。 此处，我们把数据分成3片：shard0、shard1、shard2 主分片（Primary shard）：相对于副本分片的定义。 副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。 ​ 数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！ 为了在高可用和成本间寻求平衡，我们可以这样做： 首先对数据分片，存储到不同节点 然后对每个分片进行备份，放到对方节点，完成互相备份 这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例： 现在，每个分片都有1个备份，存储在3个节点： node0：保存了分片0和1 node1：保存了分片0和2 node2：保存了分片1和2 4.1.搭建ES集群参考课前资料的文档： 其中的第四章节： 4.2.集群脑裂问题4.2.1.集群职责划分elasticsearch中集群节点有不同的职责划分： 默认情况下，集群中的任何一个节点都同时具备上述四种角色。 但是真实的集群一定要将集群职责分离： master节点：对CPU要求高，但是内存要求第 data节点：对CPU和内存要求都高 coordinating节点：对网络带宽、CPU要求高 职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。 一个典型的es集群职责划分如图： 4.2.2.脑裂问题脑裂是因为集群中的节点失联导致的。 例如一个集群中，主节点与其它节点失联： 此时，node2和node3认为node1宕机，就会重新选主： 当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。 当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况： 解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题 例如：3个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。 4.2.3.小结master eligible节点的作用是什么？ 参与集群选主 主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求 data节点的作用是什么？ 数据的CRUD coordinator节点的作用是什么？ 路由请求到其它节点 合并查询到的结果，返回给用户 4.3.集群分布式存储当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？ 4.3.1.分片存储测试使用insomnia 插入三条数据： 测试可以看到，三条数据分别在不同分片： 加上explain字段 结果： 4.3.2.分片存储原理elasticsearch会通过hash算法来计算文档应该存储到哪个分片： 说明： _routing默认是文档的id 算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！ 新增文档的流程如下： 解读： 1）新增一个id=1的文档 2）对id做hash运算，假如得到的是2，则应该存储到shard-2 3）shard-2的主分片在node3节点，将数据路由到node3 4）保存文档 5）同步给shard-2的副本replica-2，在node2节点 6）返回结果给coordinating-node节点 4.4.集群分布式查询elasticsearch的查询分成两个阶段： scatter phase：分散阶段，coordinating node会把请求分发到每一个分片 gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户 4.5.集群故障转移集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。 1）例如一个集群结构如图： 现在，node1是主节点，其它两个节点是从节点。 2）突然，node1发生了故障： 宕机后的第一件事，需要重新选主，例如选中了node2： node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3： 模拟故障 1[root@localhost ~]# docker-compose stop es01 重新启动 1[root@localhost ~]# docker-compose restart es01 会恢复","categories":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://codeofli.github.io/categories/Elasticsearch/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://codeofli.github.io/tags/Elasticsearch/"}]},{"title":"CentOS7安装Docker","slug":"docker/Centos7安装Docker/Centos7安装Docker","date":"2021-10-23T02:40:06.000Z","updated":"2022-03-02T01:21:40.696Z","comments":true,"path":"2021/10/docker/Centos7安装Docker/Centos7安装Docker/","link":"","permalink":"https://codeofli.github.io/2021/10/docker/Centos7安装Docker/Centos7安装Docker/","excerpt":"0.安装DockerDocker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。Docker CE 分为 stable test 和 nightly 三个更新频道。官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。","text":"0.安装DockerDocker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。Docker CE 分为 stable test 和 nightly 三个更新频道。官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。 1.CentOS安装DockerDocker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。 1.1.卸载（可选）如果之前安装过旧版本的Docker，可以使用下面命令卸载： 1234567891011yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce 1.2.安装docker首先需要大家虚拟机联网，安装yum工具 123yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 --skip-broken 然后更新本地镜像源： 12345678# 设置docker镜像源yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sed -i 's/download.docker.com/mirrors.aliyun.com\\/docker-ce/g' /etc/yum.repos.d/docker-ce.repoyum makecache fast 然后输入命令： 1yum install -y docker-ce docker-ce为社区免费版本。稍等片刻，docker即可安装成功。 1.3.启动dockerDocker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 启动docker前，一定要关闭防火墙后！！ 1234# 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld 通过命令启动docker： 12345systemctl start docker # 启动docker服务systemctl stop docker # 停止docker服务systemctl restart docker # 重启docker服务 然后输入命令，可以查看docker版本： 1docker -v 如: 12[root@VM-0-5-centos ~]# docker -vDocker version 20.10.8, build 3967b7d 1.4.配置镜像加速docker官方镜像仓库网速较差，我们需要设置国内镜像服务： 参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 2.CentOS7安装DockerCompose2.1.下载Linux下需要通过命令下载： 12# 安装curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件： 上传到/usr/local/bin/目录也可以。 2.2.修改文件权限修改文件权限： 12# 修改权限chmod +x /usr/local/bin/docker-compose 2.3.Base自动补全命令：12# 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 如果这里出现错误，需要修改自己的hosts文件： 1echo \"199.232.68.133 raw.githubusercontent.com\" &gt;&gt; /etc/hosts 3.Docker镜像仓库搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。 官网地址：https://hub.docker.com/_/registry 3.1.简化版镜像仓库Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。 搭建方式比较简单，命令如下： 123456docker run -d \\ --restart=always \\ --name registry \\ -p 5000:5000 \\ -v registry-data:/var/lib/registry \\ registry 命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。 访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像 3.2.带有图形化界面版本使用DockerCompose部署带有图象界面的DockerRegistry，命令如下： 123456789101112131415version: '3.0'services: registry: image: registry volumes: - ./registry-data:/var/lib/registry ui: image: joxit/docker-registry-ui:static ports: - 8080:80 environment: - REGISTRY_TITLE=传智教育私有仓库 - REGISTRY_URL=http://registry:5000 depends_on: - registry 1docker-compose up -d 3.3.配置Docker信任地址我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置： 12345678# 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：\"insecure-registries\":[\"http://192.168.194.128:8080\"]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker 注意是自己的ip","categories":[{"name":"Docker","slug":"Docker","permalink":"https://codeofli.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://codeofli.github.io/tags/Docker/"}]},{"title":"Nacos集群搭建","slug":"java-note/SpringCloud/Nacos/Nacos集群搭建","date":"2021-10-23T02:40:06.000Z","updated":"2022-03-02T01:21:40.364Z","comments":true,"path":"2021/10/java-note/SpringCloud/Nacos/Nacos集群搭建/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/Nacos/Nacos集群搭建/","excerpt":"Nacos集群搭建1.集群结构图官方给出的Nacos集群图：SLB，Server Load Balancer，服务器负载均衡其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。我们计划的集群结构：三个nacos节点的地址： 节点 ip port nacos1 192.168.150.1 8845 nacos2 192.168.150.1 8846 nacos3 192.168.150.1 8847","text":"Nacos集群搭建1.集群结构图官方给出的Nacos集群图：SLB，Server Load Balancer，服务器负载均衡其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。我们计划的集群结构：三个nacos节点的地址： 节点 ip port nacos1 192.168.150.1 8845 nacos2 192.168.150.1 8846 nacos3 192.168.150.1 8847 2.搭建集群搭建集群的基本步骤： 搭建数据库，初始化数据库表结构 下载nacos安装包 配置nacos 启动nacos集群 nginx反向代理 2.1.初始化数据库Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。 官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库可以参考传智教育的后续高手课程。 这里我们以单点的数据库为例来讲解。 首先新建一个数据库，命名为nacos，而后导入下面的SQL： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198CREATE TABLE `config_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(255) DEFAULT NULL, `content` longtext NOT NULL COMMENT 'content', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip', `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', `c_desc` varchar(256) DEFAULT NULL, `c_use` varchar(64) DEFAULT NULL, `effect` varchar(64) DEFAULT NULL, `type` varchar(64) DEFAULT NULL, `c_schema` text, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_aggr *//******************************************/CREATE TABLE `config_info_aggr` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(255) NOT NULL COMMENT 'group_id', `datum_id` varchar(255) NOT NULL COMMENT 'datum_id', `content` longtext NOT NULL COMMENT '内容', `gmt_modified` datetime NOT NULL COMMENT '修改时间', `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='增加租户字段';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_beta *//******************************************/CREATE TABLE `config_info_beta` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL COMMENT 'content', `beta_ips` varchar(1024) DEFAULT NULL COMMENT 'betaIps', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip', `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_beta';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_tag *//******************************************/CREATE TABLE `config_info_tag` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id', `tag_id` varchar(128) NOT NULL COMMENT 'tag_id', `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL COMMENT 'content', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_tag';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_tags_relation *//******************************************/CREATE TABLE `config_tags_relation` ( `id` bigint(20) NOT NULL COMMENT 'id', `tag_name` varchar(128) NOT NULL COMMENT 'tag_name', `tag_type` varchar(64) DEFAULT NULL COMMENT 'tag_type', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id', `nid` bigint(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`nid`), UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_tag_relation';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = group_capacity *//******************************************/CREATE TABLE `group_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID', `group_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Group ID，空字符表示整个集群', `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值', `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量', `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值', `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数，，0表示使用默认值', `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值', `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_group_id` (`group_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='集群、各Group容量信息表';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = his_config_info *//******************************************/CREATE TABLE `his_config_info` ( `id` bigint(64) unsigned NOT NULL, `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `data_id` varchar(255) NOT NULL, `group_id` varchar(128) NOT NULL, `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL, `md5` varchar(32) DEFAULT NULL, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `src_user` text, `src_ip` varchar(50) DEFAULT NULL, `op_type` char(10) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`nid`), KEY `idx_gmt_create` (`gmt_create`), KEY `idx_gmt_modified` (`gmt_modified`), KEY `idx_did` (`data_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='多租户改造';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = tenant_capacity *//******************************************/CREATE TABLE `tenant_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID', `tenant_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Tenant ID', `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值', `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量', `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值', `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数', `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值', `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='租户容量信息表';CREATE TABLE `tenant_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `kp` varchar(128) NOT NULL COMMENT 'kp', `tenant_id` varchar(128) default '' COMMENT 'tenant_id', `tenant_name` varchar(128) default '' COMMENT 'tenant_name', `tenant_desc` varchar(256) DEFAULT NULL COMMENT 'tenant_desc', `create_source` varchar(32) DEFAULT NULL COMMENT 'create_source', `gmt_create` bigint(20) NOT NULL COMMENT '创建时间', `gmt_modified` bigint(20) NOT NULL COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='tenant_info';CREATE TABLE `users` ( `username` varchar(50) NOT NULL PRIMARY KEY, `password` varchar(500) NOT NULL, `enabled` boolean NOT NULL);CREATE TABLE `roles` ( `username` varchar(50) NOT NULL, `role` varchar(50) NOT NULL, UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE);CREATE TABLE `permissions` ( `role` varchar(50) NOT NULL, `resource` varchar(255) NOT NULL, `action` varchar(8) NOT NULL, UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE);INSERT INTO users (username, password, enabled) VALUES ('nacos', '$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu', TRUE);INSERT INTO roles (username, role) VALUES ('nacos', 'ROLE_ADMIN'); 2.2.下载nacosnacos在GitHub上有下载地址：https://github.com/alibaba/nacos/tags，可以选择任意版本下载。 本例中才用1.4.1版本： 2.3.配置Nacos将这个包解压到任意非中文目录下，如图： 目录说明： bin：启动脚本 conf：配置文件 进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf： 然后添加内容： 123127.0.0.1:8845127.0.0.1.8846127.0.0.1.8847 然后修改application.properties文件，添加数据库配置 1234567spring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTCdb.user.0=rootdb.password.0=123 2.4.启动将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3 然后分别修改三个文件夹中的application.properties， nacos1: 1server.port=8845 nacos2: 1server.port=8846 nacos3: 1server.port=8847 然后分别启动三个nacos节点： 1startup.cmd 2.5.nginx反向代理找到课前资料提供的nginx安装包： 解压到任意非中文目录下： 修改conf/nginx.conf文件，配置如下： 1234567891011121314upstream nacos-cluster &#123; server 127.0.0.1:8845; server 127.0.0.1:8846; server 127.0.0.1:8847;&#125;server &#123; listen 80; server_name localhost; location /nacos &#123; proxy_pass http://nacos-cluster; &#125;&#125; 而后在浏览器访问：http://localhost/nacos即可。 代码中application.yml文件配置如下： 1234spring: cloud: nacos: server-addr: localhost:80 # Nacos地址 2.6.优化 实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置. Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"Nacos","slug":"Nacos","permalink":"https://codeofli.github.io/tags/Nacos/"}]},{"title":"Nacos安装指南","slug":"java-note/SpringCloud/Nacos/Nacos安装指南","date":"2021-10-23T02:40:06.000Z","updated":"2022-03-02T01:21:40.364Z","comments":true,"path":"2021/10/java-note/SpringCloud/Nacos/Nacos安装指南/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/Nacos/Nacos安装指南/","excerpt":"Nacos安装指南1.Windows安装开发阶段采用单机安装即可。1.1.下载安装包在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：GitHub主页：https://github.com/alibaba/nacosGitHub的Release下载页：https://github.com/alibaba/nacos/releases","text":"Nacos安装指南1.Windows安装开发阶段采用单机安装即可。1.1.下载安装包在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：GitHub主页：https://github.com/alibaba/nacosGitHub的Release下载页：https://github.com/alibaba/nacos/releases 如图： 本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包： windows版本使用nacos-server-1.4.1.zip包即可。 1.2.解压将这个包解压到任意非中文目录下，如图： 目录说明： bin：启动脚本 conf：配置文件 1.3.端口配置Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。 如果无法关闭占用8848端口的进程，也可以进入nacos的conf目录，修改配置文件中的端口： 修改其中的内容： 1.4.启动启动非常简单，进入bin目录，结构如下： 然后执行命令即可： windows命令： 1startup.cmd -m standalone 执行后的效果如图： 1.5.访问在浏览器输入地址：http://127.0.0.1:8848/nacos即可： 默认的账号和密码都是nacos，进入后： 2.Linux安装Linux或者Mac安装方式与Windows类似。 2.1.安装JDKNacos依赖于JDK运行，索引Linux上也需要安装JDK才行。 上传jdk安装包： 上传到某个目录，例如：/usr/local/ 然后解压缩： 1tar -xvf jdk-8u144-linux-x64.tar.gz 然后重命名为java 配置环境变量： 12export JAVA_HOME=/usr/local/javaexport PATH=$PATH:$JAVA_HOME/bin 设置环境变量： 1source /etc/profile 2.2.上传安装包如图： 也可以直接使用课前资料中的tar.gz： 上传到Linux服务器的某个目录，例如/usr/local/src目录下： 2.3.解压命令解压缩安装包： 1tar -xvf nacos-server-1.4.1.tar.gz 然后删除安装包： 1rm -rf nacos-server-1.4.1.tar.gz 目录中最终样式： 目录内部： 2.4.端口配置与windows中类似 2.5.启动在nacos/bin目录中，输入命令启动Nacos： 1sh startup.sh -m standalone 3.Nacos的依赖父工程： 1234567&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 客户端： 12345&lt;!-- nacos客户端依赖包 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/tags/Java/"},{"name":"Nacos","slug":"Nacos","permalink":"https://codeofli.github.io/tags/Nacos/"}]},{"title":"微服务保护Sentinel","slug":"java-note/SpringCloud/微服务保护Sentinel/Sentinel","date":"2021-10-23T02:40:06.000Z","updated":"2022-03-02T01:21:40.981Z","comments":true,"path":"2021/10/java-note/SpringCloud/微服务保护Sentinel/Sentinel/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/微服务保护Sentinel/Sentinel/","excerpt":"微服务保护1.初识Sentinel1.1.雪崩问题及解决方案1.1.1.雪崩问题微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。 如图，如果服务提供者I发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I的业务似乎不受影响。 但是，依赖服务I的业务请求被阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：","text":"微服务保护1.初识Sentinel1.1.雪崩问题及解决方案1.1.1.雪崩问题微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。 如图，如果服务提供者I发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I的业务似乎不受影响。 但是，依赖服务I的业务请求被阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞： 服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，那么当前服务也就不可用了。 那么，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，雪崩就发生了： 微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。 2解决雪崩问题1.1.2.超时处理解决雪崩问题的常见方式有四种： •超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待 1.1.3.仓壁模式方案2：仓壁模式 限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离。 仓壁模式来源于船舱的设计： 船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。 于此类似，我们可以限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离。 1.1.4.断路器断路器模式：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。 比较好的一种方案 断路器会统计访问某个服务的请求数量，异常比例： 当发现访问服务D的请求异常比例过高时，认为服务D有导致雪崩的风险，会拦截访问服务D的一切请求，形成熔断： 1.1.5.限流流量控制：限制业务访问的QPS，避免服务因流量的突增而故障。 这是一种预防雪崩的方式。 QPS每秒查询率(Query Per Second) 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 1.1.6.总结什么是雪崩问题？ 微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。 如何避免因瞬间高并发流量而导致服务故障？ 流量控制 如何避免因服务故障引起的雪崩问题？ 超时处理线程隔离降级熔断 可以认为： 限流是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种预防措施。 超时处理、线程隔离、降级熔断是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种补救措施。 1.2.服务保护技术对比在SpringCloud当中支持多种服务保护技术： Netfix Hystrix Sentinel Resilience4J 早期比较流行的是Hystrix框架，但目前国内实用最广泛的还是阿里巴巴的Sentinel框架，这里我们做下对比： Sentinel Hystrix 隔离策略 信号量隔离 线程池隔离/信号量隔离 熔断降级策略 基于慢调用比例或异常比例 基于失败比率 实时指标实现 滑动窗口 滑动窗口（基于 RxJava） 规则配置 支持多种数据源 支持多种数据源 扩展性 多个扩展点 插件的形式 基于注解的支持 支持 支持 限流 基于 QPS，支持基于调用关系的限流 有限的支持 流量整形 支持慢启动、匀速排队模式 不支持 系统自适应保护 支持 不支持 控制台 开箱即用，可配置规则、查看秒级监控、机器发现等 不完善 常见框架的适配 Servlet、Spring Cloud、Dubbo、gRPC 等 Servlet、Spring Cloud Netflix 1.3.Sentinel介绍和安装1.3.1.初识SentinelSentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：https://sentinelguard.io/zh-cn/index.html Sentinel 具有以下特征: •丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。 •完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。 •广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。 •完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。 1.3.2.安装Sentinel1）下载 sentinel官方提供了UI控制台，方便我们对系统做限流设置。大家可以在GitHub下载。 课前资料也提供了下载好的jar包： sentinel-dashboard-1.8.1.jar 2）运行 将jar包放到任意非中文目录，执行命令： 1java -jar sentinel-dashboard-1.8.1.jar 如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置： 配置项 默认值 说明 server.port 8080 服务端口 sentinel.dashboard.auth.username sentinel 默认用户名 sentinel.dashboard.auth.password sentinel 默认密码 例如，修改端口： 1java -Dserver.port=8090 -jar sentinel-dashboard-1.8.1.jar 官方文档 3）访问 访问http://localhost:8080页面，就可以看到sentinel的控制台了： 需要输入账号和密码，默认都是：sentinel 登录后，发现一片空白，什么都没有： 这是因为我们还没有与微服务整合。 1.4.微服务整合Sentinel我们在order-service中整合sentinel，并连接sentinel的控制台，步骤如下： 1）引入sentinel依赖 12345&lt;!--sentinel--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置控制台 修改application.yaml文件，添加下面内容： 1234567server: port: 8088spring: cloud: sentinel: transport: dashboard: localhost:8080 # sentinel控制台地址 3）访问order-service的任意端点 打开浏览器，访问http://localhost:8088/order/101，这样才能触发sentinel的监控。 然后再访问sentinel的控制台，查看效果： 2.流量控制雪崩问题虽然有四种方案，但是限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。我们先学习这种模式。 2.1.簇点链路当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做簇点链路。簇点链路中被监控的每一个接口就是一个资源。 默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。 例如，我们刚才访问的order-service中的OrderController中的端点：/order/{orderId} 流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则： 流控：流量控制 降级：降级熔断 热点：热点参数限流，是限流的一种 授权：请求的权限控制 2.1.快速入门2.1.1.示例点击资源/order/{orderId}后面的流控按钮，就可以弹出表单。 表单中可以填写限流规则，如下： 其含义是限制 /order/{orderId}这个资源的单机QPS为1，即每秒只允许1次请求，超出的请求会被拦截并报错。 default默认是所以来源 2.1.2.练习：需求：给 /order/{orderId}这个资源设置流控规则，QPS不能超过 5，然后测试。 1）首先在sentinel控制台添加限流规则 2）利用jmeter测试 如果没有用过jmeter，可以参考课前资料提供的文档《Jmeter快速入门.md》 课前资料提供了编写好的Jmeter测试样例： sentinel测试.jmx 打开jmeter，导入课前资料提供的测试样例： 选择： 20个用户，2秒内运行完，QPS是10，超过了5. 选中流控入门，QPS&lt;5右键运行： 注意，不要点击菜单中的执行按钮来运行。 结果： 可以看到，成功的请求每次只有5个 2.2.流控模式在添加限流规则时，点击高级选项，可以选择三种流控模式： 直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式 关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流 链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流 快速入门测试的就是直接模式。 2.2.1.关联模式关联模式：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流 配置规则： 语法说明：当/write资源访问量触发阈值时，就会对/read资源限流，避免影响/write资源。 使用场景：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。 需求说明： 在OrderController新建两个端点：/order/query和/order/update，无需实现业务 配置流控规则，当/order/ update资源被访问的QPS超过5时，对/order/query请求限流 1）定义/order/query端点，模拟订单查询 1234@GetMapping(\"/query\")public String queryOrder() &#123; return \"查询订单成功\";&#125; 2）定义/order/update端点，模拟订单更新 1234@GetMapping(\"/update\")public String updateOrder() &#123; return \"更新订单成功\";&#125; 重启服务，查看sentinel控制台的簇点链路： 3）配置流控规则 对哪个端点限流，就对谁配置流控规则，就点击哪个端点后面的按钮。我们是对订单查询/order/query限流，因此点击它后面的按钮： 在表单中填写流控规则： 4）在Jmeter测试 选择《流控模式-关联》： 可以看到1000个用户，100秒，因此QPS为10，超过了我们设定的阈值：5 查看http请求： 请求的目标是/order/update，这样这个断点就会触发阈值。 但限流的目标是/order/query，我们在浏览器访问，可以发现： 确实被限流了。 5）总结 2.2.2.链路模式链路模式：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。 配置示例： 例如有两条请求链路： /test1 –&gt; /common /test2 –&gt; /common 如果只希望统计从/test2进入到/common的请求，则可以这样配置： 实战案例 需求：有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。 步骤： 在OrderService中添加一个queryGoods方法，不用实现业务 在OrderController中，改造/order/query端点，调用OrderService中的queryGoods方法 在OrderController中添加一个/order/save的端点，调用OrderService的queryGoods方法 给queryGoods设置限流规则，从/order/query进入queryGoods的方法限制QPS必须小于2 实现： 1）添加查询商品方法在order-service服务中，给OrderService类添加一个queryGoods方法： 123public void queryGoods()&#123; System.err.println(\"查询商品\");&#125; 2）查询订单时，查询商品在order-service的OrderController中，修改/order/query端点的业务逻辑： 12345678@GetMapping(\"/query\")public String queryOrder() &#123; // 查询商品 orderService.queryGoods(); // 查询订单 System.out.println(\"查询订单\"); return \"查询订单成功\";&#125; 3）新增订单，查询商品在order-service的OrderController中，修改/order/save端点，模拟新增订单： 12345678@GetMapping(\"/save\")public String saveOrder() &#123; // 查询商品 orderService.queryGoods(); // 查询订单 System.err.println(\"新增订单\"); return \"新增订单成功\";&#125; 4）给查询商品添加资源标记默认情况下，OrderService中的方法是不被Sentinel监控的，需要我们自己通过注解来标记要监控的方法。 给OrderService的queryGoods方法添加@SentinelResource注解： 1234@SentinelResource(\"goods\")public void queryGoods()&#123; System.err.println(\"查询商品\");&#125; 链路模式中，是对不同来源的两个链路做监控。但是sentinel默认会给进入SpringMVC的所有请求设置同一个root资源，会导致链路模式失效。 我们需要关闭这种对SpringMVC的资源聚合，修改order-service服务的application.yml文件： 1234spring: cloud: sentinel: web-context-unify: false # 关闭context整合 重启服务，访问/order/query和/order/save，可以查看到sentinel的簇点链路规则中，出现了新的资源： 5）添加流控规则点击goods资源后面的流控按钮，在弹出的表单中填写下面信息： 只统计从/order/query进入/goods的资源，QPS阈值为2，超出则被限流。 6）Jmeter测试选择《流控模式-链路》： 可以看到这里200个用户，50秒内发完，QPS为4，超过了我们设定的阈值2 一个http请求是访问/order/save： 运行的结果： 完全不受影响。 另一个是访问/order/query： 运行结果： 每次只有2个通过。 2.2.3.总结流控模式有哪些？ •直接：对当前资源限流 •关联：高优先级资源触发阈值，对低优先级资源限流。 •链路：阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流 2.3.流控效果在流控的高级选项中，还有一个流控效果选项： 流控效果是指请求达到流控阈值时应该采取的措施，包括三种： 快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。 warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。 排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长 2.3.1.warm up阈值一般是一个微服务能承担的最大QPS，但是一个服务刚刚启动时，一切资源尚未初始化（冷启动），如果直接将QPS跑到最大值，可能导致服务瞬间宕机。 warm up也叫预热模式，是应对服务冷启动的一种方案。请求阈值初始值是 maxThreshold / coldFactor，持续指定时长后，逐渐提高到maxThreshold值。而coldFactor的默认值是3. 例如，我设置QPS的maxThreshold为10，预热时间为5秒，那么初始阈值就是 10 / 3 ，也就是3，然后在5秒后逐渐增长到10. 案例 需求：给/order/{orderId}这个资源设置限流，最大QPS为10，利用warm up效果，预热时长为5秒 1）配置流控规则： 2）Jmeter测试选择《流控效果，warm up》： QPS为10. 刚刚启动时，大部分请求失败，成功的只有3个，说明QPS被限定在3： 随着时间推移，成功比例越来越高： 到Sentinel控制台查看实时监控： 一段时间后： 2.3.2.排队等待当请求超过QPS阈值时，快速失败和warm up 会拒绝新的请求并抛出异常。 而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。 工作原理 例如：QPS = 5，意味着每200ms处理一个队列中的请求；timeout = 2000，意味着预期等待时长超过2000ms的请求会被拒绝并抛出异常。 那什么叫做预期等待时长呢？ 比如现在一下子来了12 个请求，因为每200ms执行一个请求，那么： 第6个请求的预期等待时长 = 200 * （6 - 1） = 1000ms 第12个请求的预期等待时长 = 200 * （12-1） = 2200ms 现在，第1秒同时接收到10个请求，但第2秒只有1个请求，此时QPS的曲线这样的： 如果使用队列模式做流控，所有进入的请求都要排队，以固定的200ms的间隔执行，QPS会变的很平滑： 平滑的QPS曲线，对于服务器来说是更友好的。 案例 需求：给/order/{orderId}这个资源设置限流，最大QPS为10，利用排队的流控效果，超时时长设置为5s 1）添加流控规则 2）Jmeter测试选择《流控效果，队列》： QPS为15，已经超过了我们设定的10。 如果是之前的 快速失败、warmup模式，超出的请求应该会直接报错。 但是我们看看队列模式的运行结果： 全部都通过了。 再去sentinel查看实时监控的QPS曲线： QPS非常平滑，一致保持在10，但是超出的请求没有被拒绝，而是放入队列。因此响应时间（等待时间）会越来越长。 当队列满了以后，才会有部分请求失败： 2.3.3.总结流控效果有哪些？ 快速失败：QPS超过阈值时，拒绝新的请求 warm up： QPS超过阈值时，拒绝新的请求；QPS阈值是逐渐提升的，可以避免冷启动时高并发导致服务宕机。 排队等待：请求会进入队列，按照阈值允许的时间间隔依次执行请求；如果请求预期等待时长大于超时时间，直接拒绝 2.4.热点参数限流之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是分别统计参数值相同的请求，判断是否超过QPS阈值。 2.4.1.全局参数限流例如，一个根据id查询商品的接口： 访问/goods/{id}的请求中，id参数值会有变化，热点参数限流会根据参数值分别统计QPS，统计结果： 当id=1的请求触发阈值被限流时，id值不为1的请求不受影响。 配置示例： 代表的含义是：对hot这个资源的0号参数（第一个参数）做统计，每1秒相同参数值的请求数不能超过5 2.4.2.热点参数限流刚才的配置中，对查询商品这个接口的所有商品一视同仁，QPS都限定为5. 而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样，高一些。那就需要配置热点参数限流的高级选项了： 结合上一个配置，这里的含义是对0号的long类型参数限流，每1秒相同参数的QPS不能超过5，有两个例外： •如果参数值是100，则每1秒允许的QPS为10 •如果参数值是101，则每1秒允许的QPS为15 2.4.4.案例案例需求：给/order/{orderId}这个资源添加热点参数限流，规则如下： •默认的热点参数规则是每1秒请求量不超过2 •给102这个参数设置例外：每1秒请求量不超过4 •给103这个参数设置例外：每1秒请求量不超过10 注意事项：热点参数限流对默认的SpringMVC资源无效，需要利用@SentinelResource注解标记资源 1）标记资源给order-service中的OrderController中的/order/{orderId}资源添加注解： 2）热点参数限流规则访问该接口，可以看到我们标记的hot资源出现了： 这里不要点击hot后面的按钮，页面有BUG 点击左侧菜单中热点规则菜单： 点击新增，填写表单： 3）Jmeter测试选择《热点参数限流 QPS1》： 这里发起请求的QPS为5. 包含3个http请求： 普通参数，QPS阈值为2 运行结果： 例外项，QPS阈值为4 运行结果： 例外项，QPS阈值为10 运行结果： 3.隔离和降级限流是一种预防措施，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。 而要将这些故障控制在一定范围，避免雪崩，就要靠线程隔离（舱壁模式）和熔断降级手段了。 线程隔离之前讲到过：调用者在调用服务提供者时，给每个调用的请求分配独立线程池，出现故障时，最多消耗这个线程池内资源，避免把调用者的所有资源耗尽。 熔断降级：是在调用方这边加入断路器，统计对服务提供者的调用，如果调用的失败比例过高，则熔断该业务，不允许访问该服务的提供者了。 可以看到，不管是线程隔离还是熔断降级，都是对客户端（调用方）的保护。需要在调用方 发起远程调用时做线程隔离、或者服务熔断。 而我们的微服务远程调用都是基于Feign来完成的，因此我们需要将Feign与Sentinel整合，在Feign里面实现线程隔离和服务熔断。 3.1.FeignClient整合SentinelSpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel。 3.1.1.修改配置，开启sentinel功能修改OrderService的application.yml文件，开启Feign的Sentinel功能： 123feign: sentinel: enabled: true # 开启feign对sentinel的支持 3.1.2.编写失败降级逻辑业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。 给FeignClient编写失败后的降级逻辑 ①方式一：FallbackClass，无法对远程调用的异常做处理 ②方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种 这里我们演示方式二的失败降级处理。 步骤一：在feing-api项目中定义类，实现FallbackFactory： 代码： 1234567891011121314151617181920package cn.itcast.feign.clients.fallback;import cn.itcast.feign.clients.UserClient;import cn.itcast.feign.pojo.User;import feign.hystrix.FallbackFactory;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class UserClientFallbackFactory implements FallbackFactory&lt;UserClient&gt; &#123; @Override public UserClient create(Throwable throwable) &#123; return new UserClient() &#123; @Override public User findById(Long id) &#123; log.error(\"查询用户异常\", throwable); return new User(); &#125; &#125;; &#125;&#125; 步骤二：在feing-api项目中的DefaultFeignConfiguration类中将UserClientFallbackFactory注册为一个Bean： 1234@Beanpublic UserClientFallbackFactory userClientFallbackFactory()&#123; return new UserClientFallbackFactory();&#125; 步骤三：在feing-api项目中的UserClient接口中使用UserClientFallbackFactory： 123456789101112import cn.itcast.feign.clients.fallback.UserClientFallbackFactory;import cn.itcast.feign.pojo.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(value = \"userservice\", fallbackFactory = UserClientFallbackFactory.class)public interface UserClient &#123; @GetMapping(\"/user/&#123;id&#125;\") User findById(@PathVariable(\"id\") Long id);&#125; 重启后，访问一次订单查询业务，然后查看sentinel控制台，可以看到新的簇点链路： 3.1.3.总结Sentinel支持的雪崩解决方案： 线程隔离（仓壁模式） 降级熔断 Feign整合Sentinel的步骤： 在application.yml中配置：feign.sentienl.enable=true 给FeignClient编写FallbackFactory并注册为Bean 将FallbackFactory配置到FeignClient 3.2.线程隔离（舱壁模式）3.2.1.线程隔离的实现方式线程隔离有两种方式实现： 线程池隔离 信号量隔离（Sentinel默认采用） 如图： 线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果 信号量隔离：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。 两者的优缺点： 3.2.2.sentinel的线程隔离用法说明： 在添加限流规则时，可以选择两种阈值类型： QPS：就是每秒的请求数，在快速入门中已经演示过 线程数：是该资源能使用用的tomcat线程数的最大值。也就是通过限制线程数量，实现线程隔离（舱壁模式）。 案例需求：给 order-service服务中的UserClient的查询用户接口设置流控规则，线程数不能超过 2。然后利用jemeter测试。 1）配置隔离规则选择feign接口后面的流控按钮： 填写表单： 2）Jmeter测试选择《阈值类型-线程数&lt;2》： 一次发生10个请求，有较大概率并发线程数超过2，而超出的请求会走之前定义的失败降级逻辑。 查看运行结果： 发现虽然结果都是通过了，不过部分请求得到的响应是降级返回的null信息。 3.2.3.总结线程隔离的两种手段是？ 信号量隔离 线程池隔离 信号量隔离的特点是？ 基于计数器模式，简单，开销小 线程池隔离的特点是？ 基于线程池模式，有额外开销，但隔离控制更强 3.3.熔断降级熔断降级是解决雪崩问题的重要手段。其思路是由断路器统计服务调用的异常比例、慢请求比例，如果超出阈值则会熔断该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。 断路器控制熔断和放行是通过状态机来完成的： 状态机包括三个状态： closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态 open：打开状态，服务调用被熔断，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态5秒后会进入half-open状态 half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 请求成功：则切换到closed状态 请求失败：则切换到open状态 断路器熔断策略有三种：慢调用、异常比例、异常数 3.3.1.慢调用慢调用：业务的响应时长（RT，Response Time）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。 例如： 解读：RT超过500ms的调用是慢调用，统计最近10000ms内的请求，如果请求量超过10次，并且慢调用比例不低于0.5，则触发熔断，熔断时长为5秒。然后进入half-open状态，放行一次请求做测试。 案例 需求：给 UserClient的查询用户接口设置降级规则，慢调用的RT阈值为50ms，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5 1）设置慢调用修改user-service中的/user/{id}这个接口的业务。通过休眠模拟一个延迟时间： 1234567891011121314151617/** * 路径： /user/110 * * @param id 用户id * @return 用户 */@GetMapping(\"/&#123;id&#125;\")public User queryById(@PathVariable(\"id\") Long id, @RequestHeader(value = \"Truth\", required = false) String truth) throws InterruptedException &#123; if (id == 1) &#123; // 休眠，触发熔断 Thread.sleep(60); &#125; else if (id == 2) &#123; throw new RuntimeException(\"故意出错，触发熔断\"); &#125; return userService.queryById(id);&#125; 此时，orderId=101的订单，关联的是id为1的用户，调用时长为60ms： orderId=102的订单，关联的是id为2的用户，调用时长为非常短； 2）设置熔断规则下面，给feign接口设置降级规则： 规则： 超过50ms的请求都会被认为是慢请求 3）测试在浏览器访问：http://localhost:8088/order/101，快速**刷新5次**，可以发现： 触发了熔断，请求时长缩短至5ms，快速失败了，并且走降级逻辑，返回的null 在浏览器访问：http://localhost:8088/order/102，竟然也被熔断了： 3.3.2.异常比例、异常数异常比例或异常数：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。 例如，一个异常比例设置： 解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于0.4，则触发熔断。 一个异常数设置： 解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于2次，则触发熔断。 案例 需求：给 UserClient的查询用户接口设置降级规则，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5s 1）设置异常请求首先，修改user-service中的/user/{id}这个接口的业务。手动抛出异常，以触发异常比例的熔断： 也就是说，id 为 2时，就会触发异常 2）设置熔断规则下面，给feign接口设置降级规则： 规则： 在5次请求中，只要异常比例超过0.4，也就是有2次以上的异常，就会触发熔断。 3）测试在浏览器快速访问：http://localhost:8088/order/102，快速刷新5次，触发熔断： 此时，我们去访问本来应该正常的103： 4.授权规则授权规则可以对请求方来源做判断和控制。 4.1.授权规则4.1.1.基本规则授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。 白名单：来源（origin）在白名单内的调用者允许访问 黑名单：来源（origin）在黑名单内的调用者不允许访问 点击左侧菜单的授权，可以看到授权规则： 资源名：就是受保护的资源，例如/order/{orderId} 流控应用：是来源者的名单， 如果是勾选白名单，则名单中的来源被许可访问。 如果是勾选黑名单，则名单中的来源被禁止访问。 比如： 我们允许请求从gateway到order-service，不允许浏览器访问order-service，那么白名单中就要填写网关的来源名称（origin）。 4.1.2.如何获取originSentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的。 123456public interface RequestOriginParser &#123; /** * 从请求request对象中获取origin，获取方式自定义 */ String parseOrigin(HttpServletRequest request);&#125; 这个方法的作用就是从request对象中，获取请求者的origin值并返回。 默认情况下，sentinel不管请求者从哪里来，返回值永远是default，也就是说一切请求的来源都被认为是一样的值default。 因此，我们需要自定义这个接口的实现，让不同的请求，返回不同的origin。 例如order-service服务中，我们定义一个RequestOriginParser的实现类： 123456789101112131415161718192021package cn.itcast.order.sentinel;import com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.RequestOriginParser;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import javax.servlet.http.HttpServletRequest;@Componentpublic class HeaderOriginParser implements RequestOriginParser &#123; @Override public String parseOrigin(HttpServletRequest request) &#123; // 1.获取请求头 String origin = request.getHeader(\"origin\"); // 2.非空判断 if (StringUtils.isEmpty(origin)) &#123; origin = \"blank\"; &#125; return origin; &#125;&#125; 我们会尝试从request-header中获取origin值。 4.1.3.给网关添加请求头既然获取请求origin的方式是从reques-header中获取origin值，我们必须让所有从gateway路由到微服务的请求都带上origin头。 这个需要利用之前学习的一个GatewayFilter来实现，AddRequestHeaderGatewayFilter。 修改gateway服务中的application.yml，添加一个defaultFilter： 1234567spring: cloud: gateway: default-filters: - AddRequestHeader=origin,gateway # 添加名为origin的请求头，值为gateway routes: # ...略 这样，从gateway路由的所有请求都会带上origin头，值为gateway。而从其它地方到达微服务的请求则没有这个头。 4.1.4.配置授权规则接下来，我们添加一个授权规则，放行origin值为gateway的请求。 配置如下： 现在，我们直接跳过网关，访问order-service服务： 通过网关访问： 4.2.自定义异常结果默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。 4.2.1.异常类型而如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口： 123456public interface BlockExceptionHandler &#123; /** * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException */ void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception;&#125; 这个方法有三个参数： HttpServletRequest request：request对象 HttpServletResponse response：response对象 BlockException e：被sentinel拦截时抛出的异常 这里的BlockException包含多个不同的子类： 异常 说明 FlowException 限流异常 ParamFlowException 热点参数限流的异常 DegradeException 降级异常 AuthorityException 授权规则异常 SystemBlockException 系统规则异常 4.2.2.自定义异常处理下面，我们就在order-service定义一个自定义异常处理类： 123456789101112131415161718192021222324252627282930313233343536package cn.itcast.order.sentinel;import com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.BlockExceptionHandler;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.alibaba.csp.sentinel.slots.block.authority.AuthorityException;import com.alibaba.csp.sentinel.slots.block.degrade.DegradeException;import com.alibaba.csp.sentinel.slots.block.flow.FlowException;import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Componentpublic class SentinelExceptionHandler implements BlockExceptionHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception &#123; String msg = \"未知异常\"; int status = 429; if (e instanceof FlowException) &#123; msg = \"请求被限流了\"; &#125; else if (e instanceof ParamFlowException) &#123; msg = \"请求被热点参数限流\"; &#125; else if (e instanceof DegradeException) &#123; msg = \"请求被降级了\"; &#125; else if (e instanceof AuthorityException) &#123; msg = \"没有权限访问\"; status = 401; &#125; response.setContentType(\"application/json;charset=utf-8\"); response.setStatus(status); response.getWriter().println(\"&#123;\\\"msg\\\": \" + msg + \", \\\"status\\\": \" + status + \"&#125;\"); &#125;&#125; 重启测试，在不同场景下，会返回不同的异常消息. 限流： 授权拦截时： 5.规则持久化现在，sentinel的所有规则都是内存存储，重启后所有规则都会丢失。在生产环境下，我们必须确保这些规则的持久化，避免丢失。 5.1.规则管理模式规则是否能持久化，取决于规则管理模式，sentinel支持三种规则管理模式： 原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。 pull模式 push模式，推荐使用 5.1.1.pull模式pull模式：控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。 5.1.2.push模式push模式：控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新。 5.2.实现push模式详细步骤可以参考课前资料的《sentinel规则持久化》：","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"Sentinel","slug":"Sentinel","permalink":"https://codeofli.github.io/tags/Sentinel/"}]},{"title":"Sentinel规则持久化","slug":"java-note/SpringCloud/微服务保护Sentinel/sentinel规则持久化/sentinel规则持久化","date":"2021-10-23T02:40:06.000Z","updated":"2022-03-02T01:21:41.259Z","comments":true,"path":"2021/10/java-note/SpringCloud/微服务保护Sentinel/sentinel规则持久化/sentinel规则持久化/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/微服务保护Sentinel/sentinel规则持久化/sentinel规则持久化/","excerpt":"Sentinel 规则持久化一、修改order-service服务修改OrderService，让其监听Nacos中的sentinel规则配置。具体步骤如下：1.引入依赖在order-service中引入sentinel监听nacos的依赖：1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt;","text":"Sentinel 规则持久化一、修改order-service服务修改OrderService，让其监听Nacos中的sentinel规则配置。具体步骤如下：1.引入依赖在order-service中引入sentinel监听nacos的依赖：1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt; 2.配置nacos地址在order-service中的application.yml文件配置nacos地址及监听的配置信息： 12345678910111213141516spring: cloud: sentinel: datasource: flow: nacos: server-addr: localhost:8848 # nacos地址 dataId: orderservice-flow-rules groupId: SENTINEL_GROUP rule-type: flow # 还可以是：degrade、authority、param-flow# degrade:# nacos:# server-addr: localhost:8848 # nacos地址# dataId: orderservice-degrade-rules# groupId: SENTINEL_GROUP# rule-type: degrade # 还可以是：degrade、authority、param-flow 二、修改sentinel-dashboard源码SentinelDashboard默认不支持nacos的持久化，需要修改源码。 1. 解压解压课前资料中的sentinel源码包： 然后并用IDEA打开这个项目，结构如下： 2. 修改nacos依赖在sentinel-dashboard源码的pom文件中，nacos的依赖默认的scope是test，只能在测试时使用，这里要去除： 将sentinel-datasource-nacos依赖的scope去掉： 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt; 3. 添加nacos支持在sentinel-dashboard的test包下，已经编写了对nacos的支持，我们需要将其拷贝到main下。 4. 修改nacos地址然后，还需要修改测试代码中的NacosConfig类： 修改其中的nacos地址，让其读取application.properties中的配置： 在sentinel-dashboard的application.properties中添加nacos地址配置： 1nacos.addr=localhost:8848 5. 配置nacos数据源另外，还需要修改com.alibaba.csp.sentinel.dashboard.controller.v2包下的FlowControllerV2类： 让我们添加的Nacos数据源生效： 6. 修改前端页面接下来，还要修改前端页面，添加一个支持nacos的菜单。 修改src/main/webapp/resources/app/scripts/directives/sidebar/目录下的sidebar.html文件： 将其中的这部分注释打开： 修改其中的文本： 7. 重新编译、打包项目运行IDEA中的maven插件，编译和打包修改好的Sentinel-Dashboard： 在资料中有配置好了的，sentinel-dashboard.jar，直接使用亦可 8.启动启动方式跟官方一样： 1java -jar sentinel-dashboard.jar 如果要修改nacos地址，需要添加参数： 1java -jar -Dnacos.addr=localhost:8848 sentinel-dashboard.jar 进入http://localhost:8080/发现有-NACOS就成功了 nacos页面中也有配置管理","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"Sentinel","slug":"Sentinel","permalink":"https://codeofli.github.io/tags/Sentinel/"}]},{"title":"Jmeter快速入门","slug":"java-note/SpringCloud/微服务保护Sentinel/Jmeter快速入门/Jmeter快速入门","date":"2021-10-23T02:40:06.000Z","updated":"2022-03-02T01:21:40.950Z","comments":true,"path":"2021/10/java-note/SpringCloud/微服务保护Sentinel/Jmeter快速入门/Jmeter快速入门/","link":"","permalink":"https://codeofli.github.io/2021/10/java-note/SpringCloud/微服务保护Sentinel/Jmeter快速入门/Jmeter快速入门/","excerpt":"Jmeter快速入门1.安装JmeterJmeter依赖于JDK，所以必须确保当前计算机上已经安装了JDK，并且配置了环境变量。1.1.下载可以Apache Jmeter官网下载，地址：http://jmeter.apache.org/download_jmeter.cgi当然，我们课前资料也提供了下载好的安装包：","text":"Jmeter快速入门1.安装JmeterJmeter依赖于JDK，所以必须确保当前计算机上已经安装了JDK，并且配置了环境变量。1.1.下载可以Apache Jmeter官网下载，地址：http://jmeter.apache.org/download_jmeter.cgi当然，我们课前资料也提供了下载好的安装包： apache-jmeter-5.4.1.zip 1.2.解压因为下载的是zip包，解压缩即可使用，目录结构如下： 其中的bin目录就是执行的脚本，其中包含启动脚本： 1.3.运行双击即可运行，但是有两点注意： 启动速度比较慢，要耐心等待 启动后黑窗口不能关闭，否则Jmeter也跟着关闭了 2.快速入门2.1.设置中文语言默认Jmeter的语言是英文，需要设置： 效果： 注意：上面的配置只能保证本次运行是中文，如果要永久中文，需要修改Jmeter的配置文件 打开jmeter文件夹，在bin目录中找到 jmeter.properties，添加下面配置： 1language=zh_CN 注意：前面不要出现#，#代表注释，另外这里是下划线，不是中划线 2.2.基本用法在测试计划上点鼠标右键，选择添加 &gt; 线程（用户） &gt; 线程组： 在新增的线程组中，填写线程信息： 给线程组点鼠标右键，添加http取样器： 编写取样器内容： 添加监听报告： 添加监听结果树： 汇总报告结果： 结果树：","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"Jmeter","slug":"Jmeter","permalink":"https://codeofli.github.io/tags/Jmeter/"}]},{"title":"Markdown","slug":"markdown/markdown","date":"2021-10-23T02:19:04.236Z","updated":"2022-05-17T04:31:25.430Z","comments":true,"path":"2021/10/markdown/markdown/","link":"","permalink":"https://codeofli.github.io/2021/10/markdown/markdown/","excerpt":"[[TOC]] MarkdownMarkdown 基本语法标签： Markdown Markdown 官方教程Markdown 菜鸟教程Markdown 基本语法文本编辑1. 斜体和粗体使用 * 和**表示斜体和粗体。123*斜体文本***粗体文本*****粗斜体文本***效果如下：斜体文本粗体文本粗斜体文本","text":"[[TOC]] MarkdownMarkdown 基本语法标签： Markdown Markdown 官方教程Markdown 菜鸟教程Markdown 基本语法文本编辑1. 斜体和粗体使用 * 和**表示斜体和粗体。123*斜体文本***粗体文本*****粗斜体文本***效果如下：斜体文本粗体文本粗斜体文本 2. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 3.分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 12345***---___ 效果如下： 4. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 5. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------#### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：## H1, ### H2, #### H3，##### H4。 使用 Emoji 表情有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入emoji shortcodes。 #复制和粘贴表情符号在大多数情况下，您可以简单地从Emojipedia 等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。 Tip: 如果您使用的是静态网站生成器，请确保将HTML页面编码为UTF-8。. #使用表情符号简码一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。 123去露营了！ :tent: 很快回来。真好笑！ :joy: 呈现的输出如下所示： 去露营了！⛺很快回来。 真好笑！😂 Note: 注意：您可以使用此表情符号简码列表，但请记住，表情符号简码因应用程序而异。有关更多信息，请参阅Markdown应用程序的文档。 链接语法链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。 超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接title&quot;) 示例： 这是去往 本人博客 的链接。 注：链接 和html一样能使用相对路径 Git.md 123[Git.md](../Git/Git.md)[百度](www.baidu.com)[本人博客](https://codeofli.github.io/) md页面内跳转1[超链接显示名](#标题名 \"超链接title\") 说明： 标题 是可选的，可以用单引号 或 双引号； 文件内标题名：#+标题号 转换成HTML后，会生成如下标签： 1&lt;a href=\"#标题名\" title=\"超链接title\"&gt;内容&lt;/a&gt; 如： md页面内跳转 列表4. 无序列表使用- 表示无序列表。 1- 无序列表项 示例： 无序列表项 5. 有序列表 使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 插入图像要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。 插入图片Markdown语法代码：![图片alt](图片链接 &quot;图片title&quot;)。 示例： 代码1. 行内代码块使用 `` `表示行内代码块。 1让我们聊聊 `html`。 示例： 让我们聊聊 html。 2. 代码块使用 四个缩进空格 和表示代码块。12345678示例： 这是一个代码块，此行左侧有四个不可见的空格。```markdown​ 这是一个代码块，此行左侧有四个不可见的空格。​1234567```#### 3. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。非代码示例： $ sudo apt-get install vim-gnome 12345678910111213141516Python 示例：```python@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: ## interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); Markdown 高阶语法内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 TOC,table of contents,内容列表,目录 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 画图支持7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 1234567891011121314gantt title 项目开发流程 section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5d section 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5d section 发布验收 发布: 2d 验收: 3d 12345678910111213141516171819202122gantt dateFormat YYYY-MM-DD title 使用mermaid语言定制甘特图 section 任务1 已完成的任务 :done, des1, 2014-01-06,2014-01-08 正在进行的任务 :active, des2, 2014-01-09, 3d 待完成任务1 : des3, after des2, 5d 待完成任务2 : des4, after des3, 5d section 关键任务 已完成的关键任务 :crit, done, 2014-01-06,24h 已完成的关键任务2 :crit, done, after des1, 2d 正在进行的关键任务 :crit, active, 3d 待完成的关键任务 :crit, 5d 待完成任务 :2d 待完成任务2 :1d section 文档编写 描述甘特图语法 :active, a1, after des1, 3d 完成甘特图实例1 :after a1 , 20h 完成甘特图实例2 :doc1, after a1 , 48h 更多语法参考：甘特图语法参考10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考 参考博客 11. Mermaid 序列图12345sequenceDiagramAlice-&gt;John: Hello John, how are you?loop every minuteJohn--&gt;Alice: Great!end 示例 12345678910111213141516sequenceDiagramparticipant 登录 as 前端登录participant Nginx as Nginx服务器participant 后端服务 as 后端服务器 登录 -&gt;&gt; +Nginx: 登录，有权限不?Nginx--&gt;&gt; 后端服务: 验证通过吗？activate NginxNote over Nginx,后端服务: 可以访问吗&lt;br/&gt;能放行不？.deactivate Nginxloop 多试几次吧Nginx--&gt;&gt;后端服务: 再验证一遍后端服务--&gt;&gt;Nginx: 通过吧end登录--&gt;&gt;Nginx: okNginx-&gt;&gt;后端服务: 通行 更多语法参考：Mermaid 序列图语法参考 参考博客 表格支持 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 13. 定义型列表名词 1定义 1（左侧有一个可见的冒号和四个不可见的空格）代码块 2这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）代码块（左侧有八个不可见的空格）14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： 1234567891011- [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)- [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： Cmd Markdown 开发 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 支持以 PDF 格式导出文稿 新增Todo列表功能 语法参考 改进 LaTex 功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 语法参考 七月旅行准备 准备邮轮上需要携带的物品 浏览日本免税店的物品 购买蓝宝石公主号七月一日的船票 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。 跳转到文本内的指定位置知道用的是typora就好办了，有官方的说明： https://support.typora.io/Lin… 如果要跳转到## title 1[link](#title) jump to title 注：要按住ctrl点击那个link markdown如何跳转到文本内的指定位置 例 也可参考Typora中实现内部跳转 LaTeX数学公式在Markdown文档中是能使用LaTeX数学公式的 LaTex官方文档感觉写的不好 $ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 常用的数学符号希腊字母1、小写希腊字母下面的都要上面这个案例一样才有用。两边只写了一个$的可以插在文本中，而两边写两个连续的$则会单独占一行，并且会居中而且还要大一些。 ####### 2、大写希腊字母 大写希腊字母只需要将小写希腊字母的第一个英文字母大写即可。但是需要注意的是，有些小写希腊字母的大写可以直接通过键盘输入，也就是说和英文大写是相同的。 希腊字母 英语 希腊字母 英语 α \\alpha $\\nu$ \\nu β \\beta $\\Xi$$\\xi$ \\Xi|\\xi $\\Gamma$γ \\Gamma|\\gamma $o$ \\o $\\Delta$δ \\Delta|\\delta $\\Pi\\pi$ \\Pi\\pi $\\Epsilon\\epsilon$ \\epsilon $\\rho$ \\rho $\\Zeta\\zeta$ \\zeta $\\Sigma$$\\sigma$ \\Sigma\\sigma η \\eta $\\tau$ \\tau $\\Theta\\theta$ \\Theta\\theta $\\Upsilon\\upsilon$ \\Upsilon\\upsilon ι \\iota $\\Phi$$\\phi$ \\Phi\\phi κ \\kappa $\\chi$ \\chi $\\Lambda$λ \\Lambda|\\lambda $\\Psi\\psi$ \\Psi\\psi μ \\mu $\\Omega$$\\omega$ \\Omega\\omega 运算符 对于加减除，对应键盘上便可打出来，但是对于乘法，键盘上没有这个符号，所以我们应该输入 \\times 来显示一个 $\\times $号。 普通字符在数学公式中含义一样，除了 ## $ % &amp; ~ _ ^ \\ { } 若要在数学环境中表示这些符号## $ % &amp; _ { }，需要分别表示为## $ % &amp; _ { }，即在个字符前加上\\ 。 集合符号集合符号一些特殊的集合符号，使用 \\mathbb 命令： 集合符号 编码 $实数集合\\mathbb{R}$ \\mathbb{R} 或 \\mathbb R $\\mathbb{z}$ \\mathbb{z} $\\mathbb{N}$ \\mathbb{N} 集合关系符号 符号 英语 属于$\\in$ \\in 不属于$\\notin$ \\notin LaTeX 中的特殊符号参考博文 格式简单格式####### 1、上下标 上标：表示$ f(x) = x^ 2 $ 1`$ f(x) = x^ 2 $` 或者 `$ f(x) = &#123;x&#125;^ &#123;2&#125; $` 均可 下标：表示$ f(x) = x_2 $ 1$ f(x) = x_2 $ 或者 $ f(x) = &#123;x&#125;_&#123;2&#125; $ 均可 上下标可以级联：$ f(x) = x_1^2 + {x}_{2}^{2} $ 1$ f(x) = x_1^2 + &#123;x&#125;_&#123;2&#125;^&#123;2&#125; $ ####### 2、加粗和倾斜 加粗：$ f(x) = \\textbf{x}^2 $ 均可表示 1$ f(x) = \\textbf&#123;x&#125;^2 $ 文本：$ f(x) = x^2 \\mbox{abcd} $ 均可表示 1$ f(x) = x^2 \\mbox&#123;abcd&#125; $ 倾斜：$ f(x) = x^2 \\mbox{\\emph{abcd} defg} $ 1$ f(x) = x^2 \\mbox&#123;\\emph&#123;abcd&#125; defg&#125; $ ####### 3、分数 1$ f(x,y) = \\frac&#123;x^2&#125;&#123;y^3&#125; $ $ f(x,y) = \\frac{x^2}{y^3} $ ####### 4、开根号 1$ f(x,y) = \\sqrt[n]&#123;&#123;x^2&#125;&#123;y^3&#125;&#125; $ 1$ f(x,y) = \\sqrt[n]&#123;&#123;x^2&#125;&#123;y^3&#125;&#125; $ ####### 5、省略号 1$ f(x_1, x_2, \\ldots, x_n) = x_1 + x_2 + \\cdots + x_n $ $ f(x_1, x_2, \\ldots, x_n) = x_1 + x_2 + \\cdots + x_n $ ####### 6、括号和分隔符 公式高度比较低的话直接从键盘输入括号即可，但是对于公式高度比较高的情形，需要特殊的运算。 1$ &#123;f&#125;&apos;(x) = (\\frac&#123;df&#125;&#123;dx&#125;) $ $ {f}’(x) = (\\frac{df}{dx}) $ 1$ &#123;f&#125;&apos;(x) = \\left( \\frac&#123;df&#125;&#123;dx&#125; \\right) $ $$ {f}’(x) = \\left( \\frac{df}{dx} \\right) $$可以看出，通过将 \\left( 和 \\right) 结合使用，可以将括号大小随着其内容变化。[ ] 和 { } 同理。 1$ &#123;f&#125;&apos;(0) = \\left. \\frac&#123;df&#125;&#123;dx&#125; \\right|_&#123;x=0&#125; $ $ {f}’(0) = \\left. \\frac{df}{dx} \\right|_{x=0} $ 字母上面加符号加^号 $\\hat{a},\\widehat{A}$ 1$\\hat&#123;a&#125;,\\widehat&#123;A&#125;$ 加横线 输入 \\overline 加波浪线 输入 \\widetilde 加一个点 \\dot{要加点的字母} 加两个点\\ddot{要加点的字母} 加箭头 输入\\vec 三、矩阵和行列式1234$ A=\\left[ \\begin&#123;matrix&#125; a &amp; b \\\\ c &amp; d \\\\\\end&#123;matrix&#125; \\right] $ $ A=\\left[ \\begin{matrix} a &amp; b \\ c &amp; d \\\\end{matrix} \\right] $ 1234$ \\chi (\\lambda)=\\left| \\begin&#123;matrix&#125; \\lambda - a &amp; -b \\\\ -c &amp; \\lambda - d \\\\\\end&#123;matrix&#125; \\right| $ $ \\chi (\\lambda)=\\left| \\begin{matrix} \\lambda - a &amp; -b \\ -c &amp; \\lambda - d \\\\end{matrix} \\right| $ 四、求和与连乘12$ \\sum_&#123;k=1&#125;^n k^2 = \\frac&#123;1&#125;&#123;2&#125; n (n+1) $12 $ \\sum_{k=1}^n k^2 = \\frac{1}{2} n (n+1) $ 1$ \\prod_&#123;k=1&#125;^n k = n! $ $ \\prod_{k=1}^n k = n! $ 五、导数、极限、积分####### 1、导数 导数的表示用一对花括号将被导函数括起来，然后加上一个英文的引号即可。 1$ &#123;f&#125;&apos;(x) = x^2 + x $ $ {f}’(x) = x^2 + x $ ####### 2、极限 1$ \\lim_&#123;x \\to 0&#125; \\frac&#123;3x^2 +7x^3&#125;&#123;x^2 +5x^4&#125; = 3 $ $$ \\lim_{x \\to 0} \\frac{3x^2 +7x^3}{x^2 +5x^4} = 3 $$ ####### 3、积分 积分中，需要注意的是，在多重积分内 dx 和 dy 之间 使用一个斜杠加一个逗号 , 来增大稍许间距。同样，在两个积分号之间使用一个斜杠加一个感叹号 ! 来减小稍许间距。使之更美观。 1$ \\int_a^b f(x)\\,dx $ $ \\int_a^b f(x),dx $ 1$ \\int_0^&#123;+\\infty&#125; x^n e^&#123;-x&#125; \\,dx = n! $ $ \\int_0^{+\\infty} x^n e^{-x} ,dx = n! $ 123$ \\int_&#123;x^2 + y^2 \\leq R^2&#125; f(x,y)\\,dx\\,dy = \\int_&#123;\\theta=0&#125;^&#123;2\\pi&#125; \\int_&#123;r=0&#125;^R f(r\\cos\\theta,r\\sin\\theta) r\\,dr\\,d\\theta $ $ \\int_{x^2 + y^2 \\leq R^2} f(x,y),dx,dy =\\int_{\\theta=0}^{2\\pi} \\int_{r=0}^Rf(r\\cos\\theta,r\\sin\\theta) r,dr,d\\theta $ 12$ \\int \\!\\!\\! \\int_D f(x,y)\\,dx\\,dy\\int \\int_D f(x,y)\\,dx\\,dy $ $ \\int !!! \\int_D f(x,y),dx,dy\\int \\int_D f(x,y),dx,dy $ 在加入了 ! 之后，距离的改变还是很明显的。 123$ i\\hbar\\frac&#123;\\partial \\psi&#125;&#123;\\partial &#123;t&#125;&#125; = \\frac&#123;-\\hbar^2&#125;&#123;2m&#125; \\left( \\frac&#123;\\partial^2&#125;&#123;\\partial x^2&#125; + \\frac&#123;\\partial^2&#125;&#123;\\partial y^2&#125; + \\frac&#123;\\partial^2&#125;&#123;\\partial z^2&#125; \\right) \\psi + V \\psi $ $ i\\hbar\\frac{\\partial \\psi}{\\partial {t}} = \\frac{-\\hbar^2}{2m}\\left( \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} +\\frac{\\partial^2}{\\partial z^2} \\right) \\psi + V \\psi $ 12$ \\frac&#123;d&#125;&#123;dt&#125; \\int \\!\\!\\! \\int \\!\\!\\! \\int_&#123;\\textbf&#123;R&#125;^3&#125; \\left| \\psi(\\mathbf&#123;r&#125;,t) \\right|^2\\,dx\\,dy\\,dz = 0 $ $$ \\frac{d}{dt} \\int !!! \\int !!! \\int_{\\textbf{R}^3} \\left| \\psi(\\mathbf{r},t) \\right|^2,dx,dy,dz = 0 $$ 附： ####### 关于如何在Word中插入LaTeX公式： 链接：撒哈拉之心23的博文该种方法若公式显示不完整，需调整段落行距为最小值：百度链接 参考博文 用其他软件编写使用word写LaTex公式，能直接选择相应结构。如果自己实在不会写，可以用word写成公式，然后转成LaTex编码格式。 Markdown使用使用notepad++增加markdown换行typora产生的markdown文件通常没有换行,及两个空格， 可以使用notepad++或者word、进行替换，将\\r\\n替换为两个空格+\\r\\n https://www.jianshu.com/p/c4d28c3f69ac) Typora使用Typora时，注意开启Markdown扩展功能 注：LaTeX数学公式显示太小了，用其他编辑器查看更好（VSCode） VSCode安装插件**VSCode编辑md文件流程图flow在预览： Markdown Preview Enhanced Markdown PDF markdown转pdfVSCode安装Markdown PDF插件，右键Export即可 pdf转markdownpdf转markdown地址:https://pdf2md.morethan.io/ 上述网址，只能转换相应文本为markdown，不能处理图片。而且对应一些代码块也不能正确处理。","categories":[],"tags":[]},{"title":"SpringCloud01","slug":"java-note/SpringCloud/SpringCloud","date":"2021-09-12T02:40:06.000Z","updated":"2022-03-16T02:29:58.881Z","comments":true,"path":"2021/09/java-note/SpringCloud/SpringCloud/","link":"","permalink":"https://codeofli.github.io/2021/09/java-note/SpringCloud/SpringCloud/","excerpt":"SpringCloud011.认识微服务随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？1.0.学习目标了解微服务架构的优缺点微服务技术栈1.1.单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。单体架构的优缺点如下：","text":"SpringCloud011.认识微服务随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？1.0.学习目标了解微服务架构的优缺点微服务技术栈1.1.单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。单体架构的优缺点如下： 优点： 架构简单 部署成本低 缺点： 耦合度高（维护困难、升级困难） 1.2.分布式架构分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。 分布式架构的优缺点： 优点： 降低服务耦合 有利于服务升级和拓展 缺点： 服务调用关系错综复杂 分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考： 服务拆分的粒度如何界定？ 服务之间如何调用？ 服务的调用关系如何管理？ 人们需要制定一套行之有效的标准来约束分布式架构。 1.3.微服务微服务的架构特征： 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责 自治：团队独立、技术独立、数据独立，独立部署和交付 面向服务：服务提供统一标准的接口，与语言和技术无关 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题 微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。 因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 。 但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。 其中在Java领域最引人注目的就是SpringCloud提供的方案了。 1.4.SpringCloudSpringCloud是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。 SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。 其中常见的组件包括： 另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下： 笔记使用的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。 1.5.总结 单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统 分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝 微服务：一种良好的分布式架构方案 ①优点：拆分粒度更小、服务更独立、耦合度更低 ②缺点：架构非常复杂，运维、监控、部署难度提高 SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件 2.服务拆分和远程调用任何分布式架构都离不开服务的拆分，微服务也是一样。 2.1.服务拆分原则这里我总结了微服务拆分时的几个原则： 不同微服务，不要重复开发相同业务 微服务数据独立，不要访问其它微服务的数据库 微服务可以将自己的业务暴露为接口，供其它微服务调用 2.2.服务拆分示例以课前资料中的微服务cloud-demo为例，其结构如下： cloud-demo：父工程，管理依赖 order-service：订单微服务，负责订单相关业务 user-service：用户微服务，负责用户相关业务 要求： 订单微服务和用户微服务都必须有各自的数据库，相互独立 订单服务和用户服务都对外暴露Restful的接口 订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库 2.2.1.导入demo工程用IDEA导入课前资料提供的Demo： 项目结构如下： 导入后，会在IDEA右下角出现弹窗： 点击弹窗，然后按下图选择： 会出现这样的菜单： 配置下项目使用的JDK： 2.3.实现远程调用案例在order-service服务中，有一个根据id查询订单的接口： 根据id查询订单，返回值是Order对象，如图： 其中的user为null 在user-service中有一个根据id查询用户的接口： 查询的结果如图： 2.3.1.案例需求：修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。 因此，我们需要在order-service中 向user-service发起一个http的请求，调用http://localhost:8081/user/{userId}这个接口。 大概的步骤是这样的： 注册一个RestTemplate的实例到Spring容器 修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User 将查询的User填充到Order对象，一起返回 2.3.2.注册RestTemplate首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例： 123456789101112131415161718192021package cn.itcast.order;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@MapperScan(\"cn.itcast.order.mapper\")@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 2.3.3.实现远程调用修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法： 2.4.提供者与消费者在服务调用关系中，会有两个不同的角色： 服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务） 服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口） 但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。 如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？ 对于A调用B的业务而言：A是服务消费者，B是服务提供者 对于B调用C的业务而言：B是服务消费者，C是服务提供者 因此，服务B既可以是服务提供者，也可以是服务消费者。 3.Eureka注册中心假如我们的服务提供者user-service部署了多个实例，如图： 即问题是：一个服务消费者(order-service)向有多个服务提供者(user-service)的服务名称发起远程调用时….. 大家思考几个问题： order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？ 有多个user-service实例地址，order-service调用时该如何选择？ order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？ 3.1.Eureka的结构和作用==Eureka作用==：记录服务名称和多个服务实例的映射关系，从而使得通过服务名称向一个服务发起远程调用时， 能找到相应的实际服务地址。 这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下： 回答之前的各个问题。 问题1：order-service如何得知user-service实例地址？ 获取地址信息的流程如下： user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册 eureka-server保存服务名称到服务实例地址列表的映射关系 order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取 问题2：order-service如何从多个user-service实例中选择具体的实例？ order-service从实例列表中利用负载均衡算法选中一个实例地址 向该实例地址发起远程调用 问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？ user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳 当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除 order-service拉取服务时，就能将故障实例排除了 注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端 总结在Eureka架构中，微服务角色有两类: EurekaServer:服务端，注册中心 记录服务信息：服务名称和多个服务实例的映射关系等内容 心跳监控：保证记录的服务实例能正常使用。 EurekaClient:客户端 Provider:服务提供者，例如案例中的user-service 注册自己的信息到EurekaServer 每隔30秒向EurekaServer发送心跳 consumer:服务消费者，例如案例中的order-service 根据服务名称从EurekaServer拉取服务列表 基于服务列表做负载均衡，选中一个微服务（服务实例）后发起远程调用 因此，接下来我们动手实践的步骤包括： 3.2.搭建eureka-server首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务 3.2.1.创建eureka-server服务在cloud-demo父工程下，创建一个子模块： 填写模块信息： 然后填写服务信息：eureka-server 3.2.2.引入eureka依赖引入SpringCloud为eureka提供的starter依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 3.2.3.编写启动类给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能： 12345678910111213package cn.itcast.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 3.2.4.编写配置文件编写一个application.yml文件，内容如下： 123456789server: port: 10086spring: application: name: eureka-servereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 3.2.5.启动服务启动微服务，然后在浏览器访问：http://127.0.0.1:10086 看到下面结果应该是成功了： 3.3.服务注册下面，我们将user-service注册到eureka-server中去。 1）引入依赖在user-service的pom文件中，引入下面的eureka-client依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置文件在user-service中，修改application.yml文件，添加服务名称、eureka地址： 1234567spring: application: name: userservice # user服务的服务名称eureka: client: service-url: # eureka的地址信息 defaultZone: http://127.0.0.1:10086/eureka 3）启动多个user-service实例为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。 首先，复制原来的user-service启动配置： 然后，在弹出的窗口中，填写信息： 现在，SpringBoot窗口会出现两个user-service启动配置： 不过，第一个是8081端口，第二个是8082端口。 启动两个user-service实例： 查看eureka-server管理页面： 总结 1.服务注册 引入eureka-client依赖 在application.yml中配置eureka地址 2．无论是消费者还是提供者，引入eureka-client依赖、知道eureka地址（eureka服务端）后，都可以完成服务注册 3.4.服务发现下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。 1）引入依赖之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。 在order-service的pom文件中，引入下面的eureka-client依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置文件服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息： 在order-service中，修改application.yml文件，添加服务名称、eureka地址： 123456789server: port: 10086 # 服务端口spring: application: name: eurekaserver # eureka的服务名称eureka: client: service-url: # eureka的地址信息 defaultZone: http://127.0.0.1:10086/eureka 3）服务拉取和负载均衡最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。 不过这些动作不用我们去做，只需要添加一些注解即可。 在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解： 修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口： spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。 总结 1．搭建EurekaServer 引入eureka-server依赖 添加@EnableEurekaServer注解·在application.yml中配置eureka地址 2．服务注册 引入eureka-client依赖 在application.yml中配置eureka地址 3．服务发现 引入eureka-client依赖 在application.yml中配置eureka地址 给RestTemplate添加@LoadBalanced注解 用服务提供者的服务名称远程调用 4.Ribbon负载均衡上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？ 4.1.负载均衡原理SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。 那么我们发出的请求明明是http://userservice/user/1，怎么变成了http://localhost:8081的呢？ 4.2.源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。 我们进行源码跟踪： 1）LoadBalancerInterceptor 可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事： request.getURI()：获取请求uri，本例中就是 http://user-service/user/8 originalUri.getHost()：获取uri路径的主机名，其实就是服务id，user-service this.loadBalancer.execute()：处理服务id，和用户请求。 这里的this.loadBalancer是LoadBalancerClient类型，我们继续跟入。 2）LoadBalancerClient继续跟入execute方法： 代码是这样的： getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。 getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务 放行后，再次访问并跟踪，发现获取的是8081： 果然实现了负载均衡。 3）负载均衡策略IRule在刚才的代码中，可以看到获取服务使通过一个getServer方法来做负载均衡: 我们继续跟入： 继续跟踪源码chooseServer方法，发现这么一段代码： BaseLoadBalancer 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 RoundRobin轮询（调度） 到这里，整个负载均衡的流程我们就清楚了。 4）总结SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下： 基本流程如下： 拦截我们的RestTemplate请求http://userservice/user/1 RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表 eureka返回列表，localhost:8081、localhost:8082 IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081 RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到http://localhost:8081/user/1，发起真实请求 4.3.负载均衡策略4.3.1.负载均衡策略负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类： 不同规则的含义如下： 内置负载均衡规则类 规则描述 RoundRobinRule 简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。 AvailabilityFilteringRule 对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit属性进行配置。 WeightedResponseTimeRule 为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。 ZoneAvoidanceRule 以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。 BestAvailableRule 忽略那些短路的服务器，并选择并发数较低的服务器。 RandomRule 随机选择一个可用的服务器。 RetryRule 重试机制的选择逻辑 默认的实现就是ZoneAvoidanceRule，是一种轮询方案 4.3.2.自定义负载均衡策略通过定义IRule实现可以修改负载均衡规则，有两种方式： 代码方式：在order-service中的OrderApplication类中，定义一个新的IRule： 1234@Beanpublic IRule randomRule()&#123; return new RandomRule();&#125; 这个针对全体服务 配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则： 123userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 这个针对某一个服务userservice 注意，一般用默认的负载均衡规则，不做修改。 4.4.饥饿加载Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。 而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载： 12345ribbon: eager-load: enabled: true # 开启饥饿加载 clients: # 指定饥饿加载的服务名称 - userservice 总结 5.Nacos注册中心国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。 5.1.认识和安装NacosNacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。 安装方式可以参考课前资料《Nacos安装指南.md》 5.2.服务注册到nacosNacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。 主要差异在于： 依赖不同 服务地址不同 1）引入依赖在cloud-demo父工程的pom文件中的&lt;dependencyManagement&gt;中引入SpringCloudAlibaba的依赖： 12345678&lt;!--nacos的管理依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 然后在user-service和order-service中的pom文件中引入nacos-discovery依赖： 12345&lt;!--nacos的配置管理依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 注意：不要忘了注释掉eureka的依赖。 2）配置nacos地址在user-service和order-service的application.yml中添加nacos地址： 1234spring: cloud: nacos: server-addr: localhost:8848 #nacos服务地址 注意：不要忘了注释掉eureka的地址 3）重启重启微服务后，登录nacos管理页面，可以看到微服务信息： 总结 5.3.服务分级存储模型一个服务可以有多个实例，例如我们的user-service，可以有: 127.0.0.1:8081 127.0.0.1:8082 127.0.0.1:8083 假如这些实例分布于全国各地的不同机房，例如： 127.0.0.1:8081，在上海机房 127.0.0.1:8082，在上海机房 127.0.0.1:8083，在杭州机房 Nacos就将同一机房内的实例 划分为一个集群。 也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图： 微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如： 杭州机房内的order-service应该优先访问同机房的user-service。 5.3.1.给user-service配置集群修改user-service的application.yml文件，添加集群配置： 123456spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ # 集群名称 重启两个user-service实例后，我们可以在nacos控制台看到下面结果： 我们再次复制一个user-service启动配置，添加属性： 1-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH 配置如图所示： 启动UserApplication3后再次查看nacos控制台： 总结 5.3.2.同集群优先的负载均衡失败https://www.bilibili.com/video/BV1LQ4y127n4?p=20默认的ZoneAvoidanceRule并不能实现根据同集群优先来实现负载均衡。 因此Nacos中提供了一个NacosRule的实现，可以优先从同集群中挑选实例。 1）给order-service配置集群信息 修改order-service的application.yml文件，添加集群配置： 123456spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ # 集群名称 2）修改负载均衡规则 修改order-service的application.yml文件，修改负载均衡规则： 123userservice: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 代码方式：在order-service中的OrderApplication类中，定义一个新的IRule： 1234@Beanpublic IRule randomRule()&#123; return new NacosRule();&#125; 这个针对全体服务 成功 5.4.权重配置实际部署中会出现这样的场景： 服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。 但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。 因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。 在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重： 在弹出的编辑窗口，修改权重： 注意：如果权重修改为0，则该实例永远不会被访问 5.5.环境隔离Nacos提供了namespace来实现环境隔离功能。 nacos中可以有多个namespace namespace下可以有group、service等 不同namespace之间相互隔离，例如不同namespace的服务互相不可见 5.5.1.创建namespace默认情况下，所有service、data、group都在同一个namespace，名为public： 我们可以点击页面新增按钮，添加一个namespace： 然后，填写表单： 就能在页面看到一个新的namespace： 5.5.2.给微服务配置namespace给微服务配置namespace只能通过修改配置来实现。 例如，修改order-service的application.yml文件： 1234567spring: cloud: nacos: server-addr: localhost:8848 #nacos服务地址 discovery: cluster-name: HZ # 集群名称 namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID 重启order-service后，访问控制台，可以看到下面的结果： 此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错： 5.6.Nacos与Eureka的区别Nacos的服务实例分为两种l类型： 临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。 非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。 配置一个服务实例为永久实例： 12345spring: cloud: nacos: discovery: ephemeral: false # 设置为非临时实例，是否是临时实例 Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异： 总结 Nacos与eureka的共同点 都支持服务注册和服务拉取 都支持服务提供者心跳方式做健康检测 Nacos与Eureka的区别 Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式 临时实例心跳不正常会被剔除，非临时实例则不会被剔除 Nacos支持服务列表变更的消息推送模式，服务列表更新更及时，eureka时效性就相对而言比较差 Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式 SpringCloud实用篇021.Nacos配置管理Nacos除了可以做注册中心，同样可以做配置管理来使用。 1.1.统一配置管理当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。 Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。 1.1.1.在nacos中添加配置文件如何在nacos中管理配置呢？ 然后在弹出的表单中，填写配置信息： 注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。 1.1.2.从微服务拉取配置微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。 但如果尚未读取application.yml，又如何得知nacos地址呢？ 因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下： 1）引入nacos-config依赖 首先，在user-service服务中，引入nacos-config的客户端依赖： 12345&lt;!--nacos配置管理依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 2）添加bootstrap.yaml 然后，在user-service中添加一个bootstrap.yaml文件，内容如下： 12345678910spring: application: name: userservice # 服务名称 profiles: active: dev #开发环境，这里是dev cloud: nacos: server-addr: localhost:8848 # Nacos地址 config: file-extension: yaml # 文件后缀名 这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据 ${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}作为文件id，来读取配置。 本例中，就是去读取userservice-dev.yaml： 服务名称-开发环境.文件后缀名 3）读取nacos配置 在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置： 完整代码： 1234567891011121314151617181920212223242526272829package cn.itcast.user.web;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(\"/user\")public class UserController &#123; @Autowired private UserService userService; @Value(\"$&#123;pattern.dateformat&#125;\") private String dateformat; @GetMapping(\"now\") public String now()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)); &#125; // ...略&#125; 在页面访问，可以看到效果： 1.2.配置热更新我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是配置热更新。 要实现配置热更新，可以使用两种方式： 1.2.1.方式一在@Value注入的变量所在类上添加注解@RefreshScope： 1.2.2.方式二使用@ConfigurationProperties注解代替@Value注解。 注:在使用@ConfigurationProperties时不需要@RefreshScope，推荐使用这种方式 在user-service服务中，添加一个类，读取patterrn.dateformat属性： 123456789101112package cn.itcast.user.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@Data@ConfigurationProperties(prefix = \"pattern\")public class PatternProperties &#123; private String dateformat;&#125; 在UserController中使用这个类代替@Value： 完整代码： 123456789101112131415161718192021222324252627282930313233package cn.itcast.user.web;import cn.itcast.user.config.PatternProperties;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(\"/user\")public class UserController &#123; @Autowired private UserService userService; @Autowired private PatternProperties patternProperties; @GetMapping(\"now\") public String now()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat())); &#125; // 略&#125; 1.3.配置共享其实微服务启动时，会去nacos读取多个配置文件，例如： [spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml [spring.application.name].yaml，例如：userservice.yaml 而[spring.application.name].yaml不包含环境，因此可以被多个环境共享。 下面我们通过案例来测试配置共享 1）添加一个环境共享配置我们在nacos中添加一个userservice.yaml文件： 2）在user-service中读取共享配置在user-service服务中，修改PatternProperties类，读取新添加的属性： 在user-service服务中，修改UserController，添加一个方法： 3）运行两个UserApplication，使用不同的profile修改UserApplication2这个启动项，改变其profile值： 这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。 启动UserApplication和UserApplication2 访问http://localhost:8081/user/prop，结果： 访问http://localhost:8082/user/prop，结果： 可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。 4）配置共享的优先级当nacos、服务本地同时出现相同属性时，优先级有高低之分： bug：注：如果没能读取到nacos的共享配置，重启nacos可解决 1.4.搭建Nacos集群Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档： nacos集群搭建.md https://www.bilibili.com/video/BV1LQ4y127n4?p=29 2.Feign远程调用先来看我们以前利用RestTemplate发起远程调用的代码： 存在下面的问题： •代码可读性差，编程体验不统一 •参数复杂URL难以维护 Feign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign 其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。 2.1.Feign替代RestTemplateFegin的使用步骤如下： 1）引入依赖我们在order-service服务的pom文件中引入feign的依赖： 12345&lt;!--feign客户端依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 2）添加注解在order-service的启动类添加注解开启Feign的功能： 1@EnableFeignClients 3）编写Feign的客户端在order-service中新建一个接口，内容如下： 123456789101112package cn.itcast.order.client;import cn.itcast.order.pojo.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(\"userservice\")public interface UserClient &#123; @GetMapping(\"/user/&#123;id&#125;\") User findById(@PathVariable(\"id\") Long id);&#125; 这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如： 服务名称：userservice 请求方式：GET 请求路径：/user/{id} 请求参数：Long id 返回值类型：User 这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。 4）测试修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate： 是不是看起来优雅多了。 5）总结使用Feign的步骤： ① 引入依赖 ② 添加@EnableFeignClients注解 ③ 编写FeignClient接口 ④ 使用FeignClient中定义的方法代替RestTemplate 2.2.自定义配置Feign可以支持很多的自定义配置，如下表所示： 类型 作用 说明 feign.Logger.Level 修改日志级别 包含四种不同的级别：NONE、BASIC、HEADERS、FULL feign.codec.Decoder 响应结果的解析器 http远程调用的结果做解析，例如解析json字符串为java对象 feign.codec.Encoder 请求参数编码 将请求参数编码，便于通过http请求发送 feign. Contract 支持的注解格式 默认是SpringMVC的注解 feign. Retryer 失败重试机制 请求失败的重试机制，默认是没有，不过会使用Ribbon的重试 一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。 平时建议用NONE或者BASIC，记录日志会消耗一定的性能 下面以日志为例来演示如何自定义配置。 2.2.1.配置文件方式基于配置文件修改feign的日志级别可以针对单个服务： 12345feign: client: config: userservice: # 针对某个微服务的配置 loggerLevel: FULL # 日志级别 也可以针对所有服务： 12345feign: client: config: default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置 loggerLevel: FULL # 日志级别 而日志的级别分为四种： NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 2.2.2.Java代码方式也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象： 123456public class DefaultFeignConfiguration &#123; @Bean public Logger.Level feignLogLevel()&#123; return Logger.Level.BASIC; // 日志级别为BASIC &#125;&#125; 如果要全局生效，将其放到启动类的@EnableFeignClients这个注解中： 1@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class) 如果是局部生效，则把它放到对应的@FeignClient这个注解中： 1@FeignClient(value = \"userservice\", configuration = DefaultFeignConfiguration .class) 2.3.Feign使用优化Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括： •URLConnection：默认实现，不支持连接池 •Apache HttpClient ：支持连接池 •OKHttp：支持连接池 因此提高Feign的性能主要手段就是使用连接池代替默认的URLConnection。 这里我们用Apache的HttpClient来演示。 1）引入依赖 在order-service的pom文件中引入Apache的HttpClient依赖： 12345&lt;!--httpClient的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置连接池 在order-service的application.yml中添加配置： 123456789feign: client: config: default: # default全局的配置 loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息 httpclient: enabled: true # 开启feign对HttpClient的支持 max-connections: 200 # 最大的连接数 max-connections-per-route: 50 # 每个路径的最大连接数 接下来，在FeignClientFactoryBean中的loadBalance方法中打断点： Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient： 如果上面操作完成后，未更新为Apache HttpClient，查看已经下载好对应依赖，有可能是Maven未加载对应的依赖，用maven reload一下project，重新加载对应依赖或可解决 总结，Feign的优化： 1.日志级别尽量用basic 2.使用HttpClient或OKHttp代替URLConnection ① 引入feign-httpClient依赖 ② 配置文件开启httpClient功能，设置连接池参数 2.4.最佳实践所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。 自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似： feign客户端： UserController： 有没有一种办法简化这种重复的代码编写呢？ 2.4.1.继承方式抽象客服端和服务端的共同方法到一个接口中 一样的代码可以通过继承来共享： 1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。 2）Feign客户端和Controller都集成该接口 官方不推荐使用 优点： 简单 实现了代码共享 缺点： 服务提供方、服务消费方紧耦合 参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解 2.4.2.抽取方式将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。 例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。 2.4.3.实现基于抽取的最佳实践1）抽取首先创建一个module，命名为feign-api： 项目结构： 在feign-api中然后引入feign的starter依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中 2）在order-service中使用feign-api首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。 在order-service的pom文件中中引入feign-api的依赖： 123456&lt;!--引入feign的统一api--&gt;&lt;dependency&gt; &lt;groupId&gt;cn.itcast.demo&lt;/groupId&gt; &lt;artifactId&gt;feign-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包 3）重启测试重启后，发现服务报错了： 这是因为UserClient现在在cn.itcast.feign.clients包下， 而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。 4）解决扫描包问题方式一： 指定Feign应该扫描的包： 1@EnableFeignClients(basePackages = \"cn.itcast.feign.clients\") 方式二： 指定需要加载的Client接口： 1@EnableFeignClients(clients = &#123;UserClient.class&#125;) 推荐用第二种 3.Gateway服务网关Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。 3.1.为什么需要网关Gateway网关是我们服务的守门神，所有微服务的统一入口。 网关的核心功能特性： 请求路由 权限控制 限流 架构图： 权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。 路由和负载均衡：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。 限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。 在SpringCloud中网关的实现包括两种： gateway zuul Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。 3.2.gateway快速入门下面，我们就演示下网关的基本路由功能。基本步骤如下： 创建SpringBoot工程gateway，引入网关依赖 编写启动类 编写基础配置和路由规则 启动网关服务进行测试 1）创建gateway服务，引入依赖创建服务： 引入依赖： 12345678910&lt;!--网关gateway依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 2）编写启动类123456789101112package cn.itcast.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 3）编写基础配置和路由规则创建application.yml文件，内容如下： 123456789101112131415server: port: 10010 # 网关端口spring: application: name: gateway # 服务名称 cloud: nacos: server-addr: localhost:8848 # nacos地址 gateway: routes: # 网关路由配置 - id: user-service # 路由id，自定义，只要唯一即可 # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址 uri: lb://userservice # 路由的目标地址 lb（LoadBalance）就是负载均衡，后面跟服务名称 predicates: # 路由断言，也就是判断请求是否符合路由规则的条件 - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求 我们将符合Path 规则的一切请求，都代理到 uri参数指定的地址。 本例中，我们将 /user/**开头的请求，代理到lb://userservice，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。 注意：gateway中配置rui的useservice和自己声明的服务名称一致，否则可能发生网管不能访问，但单独访问一个服务（ip）是可行的 4）重启测试重启网关，访问http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果： 5）网关路由的流程图整个访问的流程如下： 总结： 网关搭建步骤： 创建项目，引入nacos服务发现和gateway依赖 配置application.yml，包括服务基本信息、nacos地址、路由 路由配置包括： 路由id：路由的唯一标示 路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡 路由断言（predicates）：判断路由的规则， 路由过滤器（filters）：对请求或响应做处理 接下来，就重点来学习路由断言和路由过滤器的详细知识 3.3.断言工厂我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件 例如Path=/user/**是按照路径匹配，这个规则是由 org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来 处理的，像这样的断言工厂在SpringCloudGateway还有十几个: 官方文档有案例 https://docs.spring.io/spring-cloud-gateway/docs/3.0.4-SNAPSHOT/reference/html/#gateway-request-predicates-factories 名称 说明 示例 After 是某个时间点后的请求 - After=2037-01-20T17:42:47.789-07:00[America/Denver] Before 是某个时间点之前的请求 - Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai] Between 是某两个时间点之前的请求 - Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver] Cookie 请求必须包含某些cookie - Cookie=chocolate, ch.p Header 请求必须包含某些header - Header=X-Request-Id, \\d+ Host 请求必须是访问某个host（域名） - Host=.somehost.org,.anotherhost.org Method 请求方式必须是指定方式 - Method=GET,POST Path 请求路径必须符合指定规则 - Path=/red/{segment},/blue/** Query 请求参数必须包含指定参数 - Query=name, Jack或者- Query=name RemoteAddr 请求者的ip必须是指定范围 - RemoteAddr=192.168.1.1/24 Weight 权重处理 我们只需要掌握Path这种路由工程就可以了。 3.4.过滤器工厂GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理： 3.4.1.路由过滤器的种类Spring提供了31种不同的路由过滤器工厂。例如： https://docs.spring.io/spring-cloud-gateway/docs/3.0.4-SNAPSHOT/reference/html/#gatewayfilter-factories 名称 说明 AddRequestHeader 给当前请求添加一个请求头 RemoveRequestHeader 移除请求中的一个请求头 AddResponseHeader 给响应结果中添加一个响应头 RemoveResponseHeader 从响应结果中移除有一个响应头 RequestRateLimiter 限制请求的流量 3.4.2.请求头过滤器下面我们以AddRequestHeader 为例来讲解。 需求：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome! 只需要修改gateway服务的application.yml文件，添加路由过滤即可： 12345678910spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** filters: # 过滤器 - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头 当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。 3.4.3.默认过滤器如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下： 12345678910spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** default-filters: # 默认过滤项 - AddRequestHeader=Truth, Itcast is freaking awesome! 3.4.4.总结过滤器的作用是什么？ ① 对路由的请求或响应做加工处理，比如添加请求头 ② 配置在路由下的过滤器只对当前路由的请求生效 defaultFilters的作用是什么？ ① 对所有路由都生效的过滤器 3.5.全局过滤器上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。 3.5.1.全局过滤器作用全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。 定义方式是实现GlobalFilter接口。 12345678910public interface GlobalFilter &#123; /** * 处理当前请求，有必要的话通过&#123;@link GatewayFilterChain&#125;将请求交给下一个过滤器处理 * * @param exchange 请求上下文，里面可以获取Request、Response等信息 * @param chain 用来把请求委托给下一个过滤器 * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束 */ Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);&#125; 在filter中编写自定义逻辑，可以实现下列功能： 登录状态判断 权限校验 请求限流等 3.5.2.自定义全局过滤器需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件： 参数中是否有authorization， authorization参数值是否为admin 如果同时满足则放行，否则拦截 实现： 在gateway中定义一个过滤器： 12345678910111213141516171819202122232425262728293031package cn.itcast.gateway.filters;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;@Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 1.获取请求参数 MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams(); // 2.获取authorization参数 String auth = params.getFirst(\"authorization\"); // 3.校验 if (\"admin\".equals(auth)) &#123; // 放行 return chain.filter(exchange); &#125; // 4.拦截 // 4.1.禁止访问，设置状态码 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); // 4.2.结束处理 return exchange.getResponse().setComplete(); &#125;&#125; 3.5.3.过滤器执行顺序请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter 请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器： 排序的规则是什么呢？ 每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。 GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定 路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。 当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。 详细内容，可以查看源码： org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。 org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链 3.6.跨域问题3.6.1.什么是跨域问题跨域：域名不一致就是跨域，主要包括： 域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com 域名相同，端口不同：localhost:8080和localhost:8081 跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题 解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看https://www.ruanyifeng.com/blog/2016/04/cors.html CORS是一个W3C标准，全称是“跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 3.6.2.模拟跨域问题找到课前资料的页面文件： 放入tomcat或者nginx这样的web服务器中，启动并访问。 可以安装npm，再安装live-server，再执行 1live-server --port 8090 live-server一款npm工具，全局npm i -g live-server后，项目目录使用live-server命令行命令便可直接在浏览器中预览（默认找index.html，其他请自行带上文件名空格后跟在后面），并且自动全局监听实时更新。 可以在浏览器控制台看到下面的错误： 从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。 3.6.3.解决跨域问题在gateway服务的application.yml文件中，添加下面的配置： 12345678910111213141516171819spring: cloud: gateway: # 。。。 globalcors: # 全局的跨域处理 add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题 corsConfigurations: '[/**]': #/**表示拦截一切请求 allowedOrigins: # 允许哪些网站的跨域请求 - \"http://localhost:8090\" allowedMethods: # 允许的跨域ajax的请求方式 - \"GET\" - \"POST\" - \"DELETE\" - \"PUT\" - \"OPTIONS\" allowedHeaders: \"*\" # 允许在请求中携带的头信息 allowCredentials: true # 是否允许携带cookie maxAge: 360000 # 这次跨域检测的有效期","categories":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeofli.github.io/tags/Java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://codeofli.github.io/tags/SpringCloud/"}]},{"title":"Axios","slug":"js-note/axios/axios","date":"2020-10-13T14:19:09.000Z","updated":"2022-03-02T01:21:41.304Z","comments":true,"path":"2020/10/js-note/axios/axios/","link":"","permalink":"https://codeofli.github.io/2020/10/js-note/axios/axios/","excerpt":"[TOC]axios的全局配置常见配置选项，具体可看官网封装axiosaxios使用封装接口1234567891011request(&#123; url: '/p/getProblemSet/'+index&#125;).then( res =&gt;&#123; console.log(res); &#125;).catch( err =&gt;&#123; console.log(err) &#125;)","text":"[TOC]axios的全局配置常见配置选项，具体可看官网封装axiosaxios使用封装接口1234567891011request(&#123; url: '/p/getProblemSet/'+index&#125;).then( res =&gt;&#123; console.log(res); &#125;).catch( err =&gt;&#123; console.log(err) &#125;) Parameters与Data的区别:实际上就是GET和POST区别; 我们知道GET请求的参数都是在URL上的，服务器并不会读取http body里面的数据,这样我们传递的就是Params里的请求的参数了；如果想让服务器读取http body里面的数据那就需要用POST请求了，POST请求的参数就存放在body； 以后如果是GET请求最好是在parameters里面设置，而POST请求就在Body Data里面设置. axios接收图片1234567891011121314151617181920212223242526getVerifyImage() &#123; request(&#123; url: \"/verify/image\", method: \"get\", responseType: \"arraybuffer\" &#125;) .then(response =&gt; &#123; //将从后台获取的图片流进行转换 return ( \"data:image/png;base64,\" + btoa( new Uint8Array(response.data).reduce( (data, byte) =&gt; data + String.fromCharCode(byte), \"\" ) ) ); &#125;) .then(res =&gt; &#123; console.log(res); this.verifiedImg = res; &#125;) .catch(err =&gt; &#123; console.log(err); &#125;);&#125; axios跨域需要在默认实例添加 1withCredentials: true 123456const instance = axios.create(&#123; baseURL: process.env.VUE_APP_BASE_API, timeout: 5000, // 请求的超时时间 // `withCredentials` 表示跨域请求时是否需要使用凭证，允许携带cookie withCredentials: true, // default false&#125;) https://segmentfault.com/a/1190000011811117 axios上传文件","categories":[],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://codeofli.github.io/tags/Axios/"}]},{"title":"nginx","slug":"nginx/nginx","date":"2019-11-25T14:22:09.000Z","updated":"2022-03-17T11:13:18.735Z","comments":true,"path":"2019/11/nginx/nginx/","link":"","permalink":"https://codeofli.github.io/2019/11/nginx/nginx/","excerpt":"[TOC]nginxhttp://nginx.org/en/docs/http/ngx_http_proxy_module.html#example1、 nginx 简介（1） 什么是 nginx 和可以做什么事情（2） 正向代理（3） 反向代理（4） 动静分离2、 Nginx 的安装（1） 在 linux 系统中安装 nginx 3、 Nginx 的常用命令和配置文件","text":"[TOC]nginxhttp://nginx.org/en/docs/http/ngx_http_proxy_module.html#example1、 nginx 简介（1） 什么是 nginx 和可以做什么事情（2） 正向代理（3） 反向代理（4） 动静分离2、 Nginx 的安装（1） 在 linux 系统中安装 nginx 3、 Nginx 的常用命令和配置文件 4、 Nginx 配置实例 1 反向代理 5、 Nginx 配置实例 2 负载均衡 6、 Nginx 配置实例 3 动静分离 7、 Nginx 的高可用集群 （1） nginx 配置主从模式 （2） nginx 配置双主模式 Nginx 的简介什么是 nginxNginx 是高性能的 HTTP 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。 2、正向代理Nginx不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。正向代理：如果把局域网外的Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet ，则需要通过代理服务器来访问，这种代理服务就称为正向代理。 需要在==客户端配置代理服务器==进行指定网站访问 3、反向代理暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。 代理服务器 反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。 4、负载均衡增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 5、动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 Nginx 的安装Nginx 安装配置|菜鸟教程 进入 nginx 官网，下载 https://nginx.org/en/download.html 1.安装 pcre一般放在 /usr/src中 1wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz 第二步 解压压缩文件使用命令 1tar -xvf pcre-8.37.tar.gz 3、进入安装包目录 1cd pcre-8.37 4、编译安装 12./configuremake &amp;&amp; make install 4.1make install报错 12345678910111213[cevent@hadoop213 pcre-8.37]$ make installmake install-ammake[1]: Entering directory `/opt/module/pcre-8.37'make[2]: Entering directory `/opt/module/pcre-8.37' /bin/mkdir -p '/usr/local/lib' /bin/sh ./libtool --mode=install /usr/bin/install -c libpcre.la libpcreposix.la libpcrecpp.la '/usr/local/lib'libtool: install: /usr/bin/install -c .libs/libpcre.so.1.2.5 /usr/local/lib/libpcre.so.1.2.5/usr/bin/install: cannot create regular file `/usr/local/lib/libpcre.so.1.2.5': Permission denied 没有附权make[2]: *** [install-libLTLIBRARIES] 错误 1make[2]: Leaving directory `/opt/module/pcre-8.37'make[1]: *** [install-am] 错误 2make[1]: Leaving directory `/opt/module/pcre-8.37'make: *** [install] 错误 2 【解决】 12345678910111213141516[cevent@hadoop213 pcre-8.37]$ sudo chown -R cevent:cevent /usr/local/ 修改权限，需要在usr/local下创建相关目录[cevent@hadoop213 pcre-8.37]$ make install 安装make install-ammake[1]: Entering directory `/opt/module/pcre-8.37'make[2]: Entering directory `/opt/module/pcre-8.37' /bin/mkdir -p '/usr/local/lib' /bin/sh ./libtool --mode=install /usr/bin/install -c libpcre.la libpcreposix.la libpcrecpp.la '/usr/local/lib'libtool: install: /usr/bin/install -c .libs/libpcre.so.1.2.5 /usr/local/lib/libpcre.so.1.2.5……ln -sf pcre_utf32_to_host_byte_order.3 /usr/local/share/man/man3/pcre32_utf32_to_host_byte_order.3ln -sf pcre_version.3 /usr/local/share/man/man3/pcre32_version.3make[3]: Leaving directory `/opt/module/pcre-8.37'make[2]: Leaving directory `/opt/module/pcre-8.37'make[1]: Leaving directory `/opt/module/pcre-8.37'[cevent@hadoop213 pcre-8.37]$ pcre-config --version 查看版本号8.37 5、查看pcre版本 1pcre-config --version 2 ）安装 openssl 、 zlib 、 gcc 依赖 centos 1yum -y install make zlib zlib devel gcc c++ libtool openssl openssl devel ubuntu https://blog.csdn.net/z920954494/article/details/52132125 3 ）安装 nginx 使用命令解压 1tar -xvf nginx-1.20.2.tar.gz 12./configuremake &amp;&amp; make install 进入目录 /usr/local/nginx/sbin/nginx 启动服务 12cd /usr/local/nginx/sbin/./nginx nginx默认监听80端口，直接在浏览器中访问ip地址即可 1234server &#123; listen 80; ...&#125; 在 window s 系统中访问 linu x 中 nginx ，默认不能访问的，因为防火墙问题 1 ）关闭防火墙 2 ）开放访问的端口号 80 端口 查看开放的端口号 firewall cmd list all 设置开放的端口号 firewall cmd add service=http permanentfirewall cmd add port=80/tcp permanent 重启防火墙 firewall cmd reload Nginx 的常用的命令1export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 首先要进入nginx 目录中 1cd /usr/local/nginx/sbin 注意 自己安装的 为 ./nginx 1/usr/local/nginx/sbin/nginx 命令 描述 nginx -h 查看Nginx的帮助 nginx -v 查看Nginx的版本 nginx -t 测试Nginx的配置 nginx -T 测试Nginx的配置，并打印配置信息 nginx 启动nginx nginx -s reload 重新加载配置文件，平滑启动nginx nginx -s stop 停止nginx的命令 Nginx 的配置文件nginx 配置文件位置用apt-get或者yum安装都是/etc,与源码安装的/usr/local/nginx/conf/nginx.conf不一样 配置文件中的内容包含三部分内容 1.全局块：从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。 比如worker_processes 1;处理并发数的配置 2.events 块events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。 比如worker_connections 1024; 支持的最大连接数为 1024 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。 3.http 块还包含两部分：http 全局块server 块 这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http全局块、server 块。 http 全局块http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 server 块这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 location 块。 1、全局 server 块 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。 2、location 块 一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 具体事例123456server &#123; listen 8080; root /data/up1; location / &#123; &#125;&#125; root 指令放在 server 上下文中。当响应请求的 location 区块中，没有自己的 root 指令，上述的 root 指令才会被使用。 反向代理nginx 配置实例 反向代理1代理端口 ip:80 -&gt; localhost:8080 1、实现效果 （1）打开浏览器，在浏览器地址栏输入地址 www.123.com，跳转到liunx 系统tomcat 主页 面中 2.准备工作 1）在liunx 系统安装tomcat，使用默认端口8080 tomcat 安装文件放到liunx 系统中，解压 进入tomcat 的bin 目录中，./startup.sh 启动tomcat 服务器 （2）对外开放访问的端口 3）在windows 系统中通过浏览器访问tomcat 服务器 3、访问过程的分析 4、具体配置 第一步 在windows 系统的host 文件进行域名和ip 对应关系的配置 C:\\Windows\\System32\\drivers\\etc目录下的hosts文件文末添加一行 1106.54.94.80 www.123.com 第二步 在nginx 进行请求转发的配置（反向代理配置） 在server组中的location中添加一行 1proxy_pass http://127.0.0.1:8080; 12345678server &#123; location / &#123; root html; proxy_pass http://127.0.0.1:8080; index index.html index.htm; &#125; ...&#125; Nginx 配置实例-反向代理实例 2实现效果： 使用 nginx 反向代理， 根据访问的路径跳转到不同端口的服务中 nginx 监听端口为 80 访问 http://127.0.0.1/edu/ 直接跳转到 127.0.0.1:8080 访问 http://127.0.0.1/vod/ 直接跳转到 127.0.0.1:8081 2 、准备工作 1 ）准备两个 tomcat 服务器，一个 8080 端口，一个 8081 端口 2 ）创建文件夹和测试页面 放在webapps目录下即可 3 、具体配置 1 ）找到 nginx 配置文件，进行反向代理配置 2 ）开放对外访问的端口号 9001 8080 8081 1234567891011 server &#123; listen 80; server_name localhost; location ~ /edu/ &#123; proxy_pass http://127.0.0.1:8080; &#125; location ~ /vod/ &#123; proxy_pass http://127.0.0.1:8081; &#125;&#125; location 指令说明该指令用于匹配 URL。 语法如下： 1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。 2、~：用于表示 uri 包含正则表达式，并且区分大小写。 3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。 4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。 Nginx 配置实例-负载均衡1 、实现效果 1 ）浏览器地址栏输入地址 http://192.168. 17.129/edu/a.html ，负载均衡效果，平均 8080和 8081 端口中 2 、准备工作 1 ）准备两台 tomcat 服务器，一台 8080 ，一台 8081 2 ）在两台 tomcat 里面 webapps 目录中，创建名称是 edu 文件夹，在 edu 文件夹中创建页面 a.html ，用于测试 3 、在 nginx 的配置文件中进行负载均衡的配置 12345678910111213141516171819upstream myserver&#123; server localhost:8080; server localhost:8081; &#125; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://myserver; root html; index index.html index.htm; &#125; &#125; 负载均衡随着互联网信息的爆炸性增长，负载均衡（load balance ）已经不再是一个很陌生的话题顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品，很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎，nginx 就是其中的一个，在 linux 下有 Nginx 、 LVS 、 Haproxy 等等服务可以提供负载均衡服务，而且 Nginx 提供了几种分配方式 策略 1、轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 2、weightweight代表权 重默认为 1, 权重越高被分配的客户端越多 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如： 1234upstream server_pool&#123; server 192.168.5.21 weight=10; server 192.168.5.22 weight=10; &#125; 3、ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如： 12345upstream server_pool&#123; ip_hash; server 192.168.5.21:80; server 192.168.5.22:80; &#125; 4、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 1234upstream server_pool&#123; server 192.168.5.21:80; server 192.168.5.22:80; fair; &#125; Nginx 配置实例-动静分离1 、什么是动静分离 Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx 处理静态页面，Tomcat处理动态页面。动静分离从目前实现角度来讲大致分为两种， 一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案； 另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。 通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。 2 、准备工作 1 ）在 liunx 系统中准备静态资源，用于进行访问 在根目录创建data文件件 3 、具体配置 1 ）在 nginx 配置文件中进行配置 123456789location /www/ &#123; root /data/; index index.html index.htm;&#125;location /image/ &#123; root /data/; autoindex on;&#125; Nginx 配置高可用的集群 https://www.bilibili.com/video/av68136734?p=14 myngx_http_proxy_module Nginx出现403 forbiddenhttps://blog.csdn.net/qq_35843543/article/details/81561240/ 1.2将nginx.config的user改为和启动用户一致， 1#user nobody; croshttps://blog.csdn.net/envon123/article/details/83270277 在相应后端服务url中（location）添加 1234567891011add_header 'Access-Control-Allow-Origin' $http_origin;add_header 'Access-Control-Allow-Credentials' 'true';add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';add_header 'Access-Control-Allow-Headers' 'DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range';if ($request_method = 'OPTIONS') &#123; add_header 'Access-Control-Max-Age' 1728000; add_header 'Content-Type' 'text/plain; charset=utf-8'; add_header 'Content-Length' 0; return 204;&#125; vue修改配置文件主要做两件事： 把Nginx服务器的默认路径改成我们项目所在的路径。 如果你的vue工程用的路由是history模式，需要将客户端发来的url重定向到默认的index.html，才能正常访问。否则只能看到主页。刷新或点击其他页面都会404。 在配置文件中的server里如下修改。 12345location / &#123; root /home/CRExpress/www; try_files $uri $uri/ /index.html last; index index.html;&#125; root后面的地址是项目上传的路径。try_files是添加到index的映射。 123456location / &#123; root /home/ubuntu/static; proxy_pass http://127.0.0.1:8080; try_files $uri $uri/ /index.html last; index index.html index.htm;&#125; 部署前后端分离项目https://segmentfault.com/a/1190000014972747 在前后端分离端项目里，前端的代码会被打包成为纯静态文件。使用 Nginx的目的就是让静态文件运行起服务，由于后端的接口也是分离的，直接请求可能会产生跨域问题，此时就需要Nginx转发代理后端接口。 Nginx配置如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto; #启动进程error_log /var/log/nginx/error.log; #全局错误日志pid /run/nginx.pid; #PID文件# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024; #单个后台worker process进程的最大并发链接数 &#125;http &#123; gzip on; #开启gzip压缩 gzip_min_length 1k; #设置对数据启用压缩的最少字节数 gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 6; #设置数据的压缩等级,等级为1-9，压缩比从小到大 gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; #设置需要压缩的数据格式 gzip_vary on; #虚拟主机配置 server &#123; listen 80; server_name mark.binlive.cn; root /home/spa-project/dist; #定义服务器的默认网站根目录位置 index index.html; #定义index页面 error_page 404 /index.html; #将404错误页面重定向到index.html可以解决history模式访问不到页面问题 location ^~ /api/&#123; proxy_pass http://127.0.0.1:7000; proxy_send_timeout 1800; proxy_read_timeout 1800; proxy_connect_timeout 1800; client_max_body_size 2048m; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $http_host; # required for docker client's sake proxy_set_header X-Real-IP $remote_addr; # pass on real client's IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; location ^~ /auth/&#123; proxy_pass http://127.0.0.1:7000; proxy_send_timeout 1800; proxy_read_timeout 1800; proxy_connect_timeout 1800; client_max_body_size 2048m; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $http_host; # required for docker client's sake proxy_set_header X-Real-IP $remote_addr; # pass on real client's IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; &#125; &#125; 将前端代码打包后的dist文件放入指定服务目录 将服务目录指定到spa-project/dist目录下即可代理静态服务 配置里开启了gzip压缩，可以很大程度上减小文件体积大小 将404错误页面重定向到index.html，可以解决前端history路由模式由于刷新页面访问不到服务出现404的问题 location为代理接口，可以转发代理后端的请求接口域名或者ip，即可解决接口跨域问题 Nginx 配置高可用的集群 2、配置高可用的准备工作 （1）需要两台服务器 192.168.17.129 和 192.168.17.131 在两台服务器安装 nginx 在两台服务器安装 keepalived 3、在两台服务器安装 keepalived 使用 yum 命令进行安装 yum install keepalived –y 安装之后，在 etc 里面生成目录 keepalived，有文件 keepalived.conf 4、完成高可用配置（主从配置） （1）修改/etc/keepalived/keepalivec.conf 配置文件 global_defs { notification_email { &#x61;&#99;&#97;&#115;&#115;&#x65;&#110;&#x40;&#x66;&#105;&#x72;&#x65;&#x77;&#x61;&#x6c;&#x6c;&#46;&#x6c;&#111;&#x63; &#102;&#x61;&#105;&#108;&#x6f;&#118;&#101;&#114;&#x40;&#x66;&#x69;&#x72;&#101;&#119;&#97;&#108;&#108;&#x2e;&#x6c;&#x6f;&#99; &#x73;&#x79;&#115;&#x61;&#x64;&#x6d;&#105;&#x6e;&#x40;&#102;&#105;&#x72;&#101;&#119;&#97;&#108;&#x6c;&#46;&#108;&#111;&#x63; } notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.17.129 smtp_connect_timeout 30 router_id LVS_DEVEL } vrrp_script chk_http_port { script “/usr/local/src/nginx_check.sh” interval 2 #（检测脚本执行的间隔） weight 2 } vrrp_instance VI_1 { state BACKUP # 备份服务器上将 MASTER 改为 BACKUP interface ens33 //网卡 virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同 priority 90 # 主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 Nginx 的原理 2、worker 如何进行工作的 3、一个 master 和多个 woker 有好处 可以使用 nginx –s reload 热部署，利用 nginx 进行热部署操作 每个 woker 是独立的进程，如果有其中的一个woker 出现问题，其他 woker 独立的， 继续进行争抢，实现请求过程，不会造成服务中断 4、设置多少个 woker 合适 安装ssl证书腾讯云安装教程 记得开放相应的端口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970server &#123; listen 443 ssl; server_name www.yestojudge.cn; #启用 SSL 功能 # ssl on; deprecated #证书文件名称 ssl_certificate 1_www.yestojudge.cn_bundle.crt; #私钥文件名称 ssl_certificate_key 2_www.yestojudge.cn.key; ssl_session_timeout 5m; #请按照以下协议配置 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; root /home/ubuntu/static; location ^~ /api/&#123; proxy_pass http://127.0.0.1:8080; &#125; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /home/ubuntu/static/; proxy_pass http://127.0.0.1:8080; try_files $uri $uri/ /index.html last; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; server &#123; listen 80; #填写绑定证书的域名 server_name www.yestojudge.cn; #把http的域名请求转成https rewrite ^(.*)$ https://www.yestojudge.cn:443$1 permanent; &#125; 开启gziphttps://blog.csdn.net/huangbaokang/article/details/79931429 加入gzip配置在nginx.conf文件的http模块中加入gzip的配置 1234567891011121314151617181920212223242526272829303132333435363738[root@localhost html]# cat ../conf/nginx.confuser root;worker_processes 4;worker_rlimit_nofile 65535;events &#123; worker_connections 65535;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; #开启gzip gzip_min_length 1k; #低于1kb的资源不压缩 gzip_comp_level 3; #压缩级别【1-9】，越大压缩率越高，同时消耗cpu资源也越多，建议设置在4左右。 gzip_types text/plain application/javascript application/x-javascript text/javascript text/xml text/css; #需要压缩哪些响应类型的资源，多个空格隔开。不建议压缩图片，下面会讲为什么。 gzip_disable \"MSIE [1-6]\\.\"; #配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持） gzip_vary on; #是否添加“Vary: Accept-Encoding”响应头 server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 可以看到相应头带上了Content-Encoding:gzip标识，说明gzip压缩起效果了。 gzip虽然好用，但是一下类型的资源不建议启用。 1、图片类型 原因：图片如jpg、png本身就会有压缩，所以就算开启gzip后，压缩前和压缩后大小没有多大区别，所以开启了反而会白白的浪费资源。（Tips：可以试试将一张jpg图片压缩为zip，观察大小并没有多大的变化。虽然zip和gzip算法不一样，但是可以看出压缩图片的价值并不大） 2、大文件 原因：会消耗大量的cpu资源，且不一定有明显的效果。 显著减少,vue只是支持gzip,开启需要服务器进行 windowshttps://blog.csdn.net/u010648555/article/details/79418779 为了方便本地的开发和验证，于是Windows上安装Nginx 注意不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程。[参考博文1]在nginx.exe目录，打开命令行工具，用命令 启动 1.进入解压的目标,我的 E:\\nginx-1.13.92.执行启动命令 ，有一个一闪而过的效果！ 1start nginx.exe 六 简单的一些启动、关闭服务命令介绍 在nginx.exe目录，打开命令行工具，用命令 启动/关闭/重启nginx command name start nginx 启动 启动nginx start nginx修改配置后重新加载生效 nginx -s reload重新打开日志文件 nginx -s reopennginx -t -c nginx.conf 测试nginx配置文件是否正确 关闭nginx ：快速停止nginx nginx -s stop完整有序的停止nginx nginx -s quit","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"python","slug":"python/python/python","date":"2019-11-22T13:14:50.000Z","updated":"2021-10-23T02:19:04.269Z","comments":true,"path":"2019/11/python/python/python/","link":"","permalink":"https://codeofli.github.io/2019/11/python/python/python/","excerpt":"[TOC]关于pyhton Python语言是通用语言 Python语言是脚本语言 Python语言是开源语言 Python语言是跨平台语言 Python语言是多模型语言Python语言创立者:Guido van Rossum2002年，Python 2.x2008年，Python 3.x 注：变量命名主要采用下划线规则","text":"[TOC]关于pyhton Python语言是通用语言 Python语言是脚本语言 Python语言是开源语言 Python语言是跨平台语言 Python语言是多模型语言Python语言创立者:Guido van Rossum2002年，Python 2.x2008年，Python 3.x 注：变量命名主要采用下划线规则 python基础语法程序的格式框架代码高亮：编程的色彩辅助体系，不是语法要求 缩进一行代码开始前的空白区域，表达程序的格式框架 缩进表达程序的格式框架 严格明确：缩进是语法的一部分，缩进不正确程序运行错误 所属关系：表达代码间包含和层次关系的唯一手段 长度一致：程序内一致即可，一般用 4 个空格或 1 个 TAB 注释用于提高代码可读性的辅助性文字，不被执行 不被程序执行的辅助性说明信息 单行注释：以 开头，其后内容为注释 1#这里是单行注释 多行注释 ：以 开头和结尾 12''' 这是多行注释第一行这是多行注释第二行 ''' 命名与保留字变量程序中用于保存和表示数据的占位符号 变量采用标识符(名字) 来表示，关联标识符的过程叫命名 可以使用等号(=)向变量赋值或修改值，=被称为赋值符号 命名关联标识符的过程命名规则: 大小写字母、数字、下划线和中文等字符及组合 注意事项: 大小写敏感、首字符不能是数字、不与保留字相同 保留字被编程语言内部定义并保留使用的标识符 Python语言有35个保留字(也叫关键字) Python语言有35个保留字(也叫关键字) if 是保留字，If 是变量 分支语法条件判断用于条件组合的三个保留字 操作符及使用 描述 x and y 两个条件x和y的逻辑与 x or y 两个条件x和y的逻辑或 not x 条件x的逻辑非 操作符 数学符号 描述 &lt; &lt; 小于 &lt;= ≤ 小于等于 &gt;= ≥ 大于等于 &gt; &gt; 大于 == = 等于 ！ = ≠ 不等于 1if &lt;condition&gt;: &lt;statement&gt; special： 1if not bool: statementd 二分支紧凑形式 1&lt;statement&gt; if &lt;condition&gt; else &lt;statement&gt; 多分支 注意 是elif，不是else if 1234567if &lt;条件1&gt; :&lt;语句块1&gt;elif &lt;条件2&gt; :&lt;语句块2&gt;……else :&lt;语句块N&gt; 循环结构遍历某个结构形成的循环运行方式 从遍历结构中逐一提取元素，放在循环变量中 12for &lt;循环变量&gt; in &lt;遍历结构&gt; : &lt;语句块&gt; 由保留字for和in组成，完整遍历所有元素后结束 每次循环，所获得元素放入循环变量，并执行一次语句块 计数循环(N次) 遍历由range()函数产生的数字序列，产生循环 range(N) 产生的序列，左闭右开，即[0,N) 12for i in range(N) : &lt;语句块&gt; 字符串遍历循环 s是字符串，遍历字符串每个字符，产生循环 12for c in s : &lt;语句块&gt; 123&gt;&gt;&gt; for c in \"Python123\":print(c, end=\",\")P,y,t,h,o,n,1,2,3, ls是一个列表， 遍历其每个元素，产生循环 12345for item in ls : &lt;语句块&gt;&gt;&gt;&gt; for item in [123, \"PY\", 456] :print(item, end=\",\")123,PY,456, 文件遍历循环 fi是一个文件标识符，遍历其每行，产生循环 12for line in fi : &lt;语句块&gt; while由条件控制的循环运行方式 反复执行语句块，直到条件不满足时结束 12while &lt;条件&gt; : &lt;语句块&gt; 循环控制保留字break 和 continue break跳出并结束当前整个循环，执行循环后的语句 continue结束当次循环，继续执行后续次数循环 break和continue可以与for和while循环搭配使用 循环的扩展(else)循环与else 当循环没有被break语句退出时，执行else语句块 else语句块作为”正常”完成循环的奖励 这里else的用法与异常处理中else用法相似 123456789while &lt;条件&gt; : &lt;语句块1&gt;else : &lt;语句块2&gt;for &lt;变量&gt; in &lt;遍历结构&gt; : &lt;语句块1&gt;else : &lt;语句块2&gt; 12345678910111213141516&gt;&gt;&gt; for c in \"PYTHON\" :if c == \"T\" :continueprint(c, end=\"\")else:print(\"正常退出\")PYHON正常退出&gt;&gt;&gt; for c in \"PYTHON\" : if c == \"T\" : break print(c, end=\"\")else:print(\"正常退出\")PY import库import:使用库名调用12import &lt;libaryName&gt;import &lt;libaryName&gt; as &lt;alias&gt; form:能直接调用函数当我们使用from * 的时候，会取得模块顶层左右赋值的变量名的拷贝。 123from 库 import 函数名from 库 import *&lt;functionName&gt;(argc) 输入输出print()以字符串形式向控制台输出的函数 1print(&#123;&#125;.format()) &#123;&#125;表示槽，后续format()填入 1234title = \"a+b\"print('%s %d insert!!!!!!' % (title, 5))title = \"a+b\"print('%s insert!!!!!!' % title) input()1input([prompt]) 在一行输入多个数字 1a, b, c, d = map(int, input().split()) 函数的定义与使用函数的定义函数是一段代码的表示 函数是一段具有特定功能的、可重用的语句组 函数是一种功能的抽象，一般函数表达特定功能 两个作用：降低编程难度和代码复用 123def&lt;函数名&gt;(&lt;参数(0个或多个)&gt;): &lt;函数体&gt; return&lt;返回值&gt; 函数的调用调用是运行函数代码的方式 调用时要给出实际参数 实际参数替换定义中的参数 函数调用后得到返回值 可选参数传递函数定义时可以为某些参数指定默认值，构成可选参数 123def&lt;函数名&gt;(&lt;非可选参数&gt;,&lt;可选参数&gt;): &lt;函数体&gt; return&lt;返回值&gt; 例如： 12345def fact(n,m=1) : s = 1 foriinrange(1, n+1): s *= i return s//m 可变参数传递123def &lt;函数名&gt; (&lt;参数&gt;, *b): &lt;函数体&gt; return &lt;返回值&gt; 例如 1234567def fact(n, *b) : s = 1 for i in range(1, n+1): s *= i for item in b: s *= item return s 函数的返回值函数可以返回0个或多个结果 return保留字用来传递返回值 函数可以有返回值，也可以没有，可以有return，也可以没有 return可以传递0个返回值，也可以传递任意多个返回值 局部变量和全局变量规则1: 局部变量和全局变量是不同变量 局部变量是函数内部的占位符，与全局变量可能重名但不同 函数运算结束后，局部变量被释放 可以使用global保留字在函数内部使用全局变量 1234567n, s = 10, 100def fact(n) : global s #fact()函数中使用global保留字声明此处s是全局变量s for i in range(1, n+1): s *= i return sprint(fact(n), s) 123运行结果&gt;&gt;&gt;362880000 362880000 规则2: 局部变量为组合数据类型且未创建，等同于全局变量 123456ls = [\"F\", \"f\"] #通过使用[]真实创建了一个全局变量列表lsdef func(a) : ls.append(a) #此处ls是列表类型，未真实创建则等同于全局变量 returnfunc(\"C\") #局部变量ls被修改print(ls) 123运行结果&gt;&gt;&gt;['F', 'f'] 使用规则 基本数据类型，无论是否重名，局部变量与全局变量不同 可以通过global保留字在函数内部声明全局变量 组合数据类型，如果局部变量未真实创建，则是全局变量 lambda函数lambda函数返回函数名作为结果 lambda函数是一种匿名函数，即没有名字的函数 使用lambda保留字定义，函数名是返回结果 lambda函数用于定义简单的、能够在一行内表示的函数 1&lt;函数名&gt; = lambda&lt;参数&gt; : &lt;表达式&gt; 等价于 123def &lt;函数名&gt; (&lt;参数&gt;): &lt;函数体&gt; return &lt;返回值&gt; 定义文件编码Defining Python Source Code Encodings Defining the Encoding Python will default to ASCII as standard encoding if no other encoding hints are given. To define a source code encoding, a magic comment must be placed into the source files either as first or second line in the file, such as: 1# coding=&lt;encoding name&gt; or (using formats recognized by popular editors): 12#!/usr/bin/python# -*- coding: &lt;encoding name&gt; -*- or: 12#!/usr/bin/python# vim: set fileencoding=&lt;encoding name&gt; : 12#!/usr/bin/python# -*- coding: utf-8 -*- 基本数据类型及其操作判断变量类型12345import typesif type(text) is types.StringType: ....type(x) == types(1) # 判断是否int 类型type(x) == type('a') #是否string类型 数字类型整数类型注：python 中不支持 a++ 和 ++a 与数学中整数的概念一致 可正可负，没有取值范围限制 pow(x,y)函数：计算 xy，想算多大算多大1234pow(2,100)1267650600228229401496703205376pow(2,pow(2,15))1415461031044954789001553…… 4种进制表示形式 十进制： 1010, 99, -217 二进制，以0b或0B开头： 0b010, -0B101 八进制，以0o或0O开头： 0o123, -0O456 十六进制，以0x或0X开头： 0x9a, -0X89 浮点数类型与数学中实数的概念一致 带有小数点及小数的数字 浮点数取值范围和小数精度都存在限制，但常规计算可忽略 取值范围数量级约-10307至10308，精度数量级10-16 浮点数间运算存在不确定尾数，不是bug 12340.1 + 0.30.40.1 + 0.20.30000000000000004 #不确定尾数 round(x, d)：对x四舍五入， d是小数截取位数 浮点数间运算与比较用round()函数辅助 不确定尾数一般发生在10-16左右， round()十分有效 浮点数可以采用科学计数法表示 使用字母e或E作为幂的符号，以10为基数，格式如下：e 表示 a*10b 例如： 4.3e-3 值为0.0043 9.6E5 值为960000.0 复数类型与数学中复数的概念一致如果x2 = -1，那么x的值是什么？ 定义 j = -𝟏𝟏 ，以此为基础，构建数学体系 a+bj 被称为复数，其中， a是实部， b是虚部 复数实例z = 1.23e-4+5.6e+89j 实部是什么？ z.real 获得实部 虚部是什么？ z.imag 获得虚部 数值运算操作符操作符是完成运算的一种符号体系 操作符及使用 描述 x + y 加， x与y之和 x – y 减， x与y之差 x * y 乘， x与y之积 x / y 除， x与y之商 10/3结果是3.3333333333333335 x // y 整数除， x与y之整数商 10//3结果是3 + x x本身 - y x的负值 x % y 余数，模运算 10%3结果是1 x ** y 幂运算， x的y次幂， x^y;当y是小数时，开方运算10**0.5结果是 增强操作符及使用 描述 x op= y 即 x = x op y，其中， op为二元操作符 x op= y x += y x -= y x = y x /= y x //= y x %= y x *= y x op= y &gt;&gt;&gt; x = 3.1415 &gt;&gt;&gt; x *= 3 与 x = x *3 等价 31.006276662836743 数字类型的关系类型间可进行混合运算，生成结果为”最宽”类型 三种类型存在一种逐渐”扩展”或”变宽”的关系： 整数 -&gt; 浮点数 -&gt; 复数 例如： 123 + 4.0 = 127.0 (整数+浮点数 = 浮点数) 数值运算函数一些以函数形式提供的数值运算功能 函数及使用 描述 abs(x) 绝对值， x的绝对值 abs(-10.01) 结果为 10.01 divmod(x,y) 商余， (x//y, x%y)，同时输出商和余数 divmod(10, 3) 结果为 (3, 1) pow(x, y[, z]) 幂余， (x**y)%z， [..]表示参数z可省略 pow(3, pow(3, 99), 10000) 结果为 4587 round(x[, d]) 四舍五入， d是保留小数位数，默认值为 round(-10.123, 2) 结果为 -10.12 max(x1,x2, … ,xn) 最大值，返回x1,x2, … ,xn中的最大值， n不限 max(1, 9, 5, 4, 3) 结果为 9 min(x1,x2, … ,xn) 最小值，返回x1,x2, … ,xn中的最小值， n不限 min(1, 9, 5, 4, 3) 结果为 1 int(x) 将x变成整数，舍弃小数部分 int(123.45) 结果为123； int(“123”) 结果为123 float(x) 将x变成浮点数，增加小数部分 float(12) 结果为12.0； float(“1.23”) 结果为1.23 complex(x) 将x变成复数，增加虚数部分 complex(4) 结果为 4 + 0j 字符串由0个或多个字符组成的有序字符序列-字符串是字符的有序序列，可以对其中的字符进行索引 1\"请\"是\"请输入带有符号的温度值: \"的第0个字符 字符串有2类共4种表示方法-由一对单引号或双引号表示，仅表示单行字符串 1\"请输入带有符号的温度值: \"或者'C' -由一对三单引号或三双引号表示，可表示多行字符串 12'''Python语言''' 三引号是多行注释 字符串的序号正向递增序号和反向递减序号 字符串的使用使用[ ]获取字符串中一个或多个字符 索引：返回字符串中单个字符 &lt;字符串&gt;[M] 1\"请输入带有符号的温度值: \"[0]或者TempStr[-1] 切片：返回字符串中一段字符子串 &lt;字符串&gt;[M: N] 1\"请输入带有符号的温度值: \"[1:3]或者TempStr[0:-1] 使用[M:N: K]根据步长(K)对字符串切片 &lt;字符串&gt;[M: N]，M缺失表示至开头，N缺失表示至结尾 1\"〇一二三四五六七八九十\"[:3]结果是\"〇一二\" &lt;字符串&gt;[M: N: K]，根据步长K对字符串切片 12\"〇一二三四五六七八九十\"[1:8:2] 结果是\"一三五七\"\"〇一二三四五六七八九十\"[::-1] 结果是\"十九八七六五四三二一〇\" 字符串的特殊字符 转义符\\ 转义符表达特定字符的本意 1\"这里有个双引号(\\\")\"结果为这里有个双引号(\") 转义符形成一些组合，表达一些不可打印的含义 1\"\\b\"回退\"\\n\"换行(光标移动到下行首)\"\\r\"回车(光标移动到本行首) 字符串操作符 操作符及使用 描述 x+ y 连接两个字符串x和y n *x 或x *n 复制n次字符串x x in s 如果x是s的子串，返回True，否则返回False 字符串处理函数 函数及使用 描述 len(x) 长度，返回字符串x的长度len(“一二三456”) 结果为6 str(x) 任意类型x所对应的字符串形式str(1.23)结果为”1.23”str([1,2])结果为”[1,2]” hex(x)或oct(x) 整数x的十六进制或八进制小写形式字符串hex(425)结果为”0x1a9”oct(425)结果为”0o651” chr(u) x为Unicode编码，返回其对应的字符 ord(x) x为字符，返回其对应的Unicode编码 Unicode编码 统一字符编码，即覆盖几乎所有字符的编码方式 从0到1114111(0x10FFFF)空间，每个编码对应一个字符 Python字符串中每个字符都是Unicode编码字符 字符串处理方法 方法及使用 描述 str.lower()或str.upper() 返回字符串的副本，全部字符小写/大写“AbCdEfGh”.lower()结果为”abcdefgh” str.split(sep=None) 返回一个列表，由str根据sep被分隔的部分组成“A,B,C”.split(“,”)结果为[‘A’,’B’,’C’] str.count(sub) 返回子串sub在str中出现的次数“an apple a day”.count(“a”)结果为4 str.replace(old, new) 返回字符串str副本，所有old子串被替换为new“python”.replace(“n”,”n123.io”)结果为“python123.io” str.center(width[,fillchar]) 字符串str根据宽度width居中，fillchar可选&quot;python&quot;.center(20,&quot;=&quot;)结果为&lt;br/&gt;&#39;=======python=======&#39; str.strip(chars) 从str中去掉在其左侧和右侧chars中列出的字符 str.join(iter) 在iter变量除最后元素外每个元素后增加一个str“,”.join(“12345”)结果为“1,2,3,4,5”#主要用于字符串分隔等 字符串类型的格式化格式化是对字符串进行格式表达的方式 字符串格式化使用.format()方法，用法如下： 1&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;) format()方法的格式控制槽内部对格式化的配置方式 1&#123; &lt;参数序号&gt; ：&lt;格式控制标记&gt;&#125; ： &lt;填充&gt; &lt;对齐&gt; &lt;宽度&gt; &lt;,&gt; &lt;.精度&gt; &lt;类型&gt; 引导符号 用于填充的单个字符 &lt; 左对齐&gt; 右对齐^ 居中对齐 槽设定的输出宽度 数字的千位分隔符 浮点数小数精度或字符串最大输出长度 整数类型b, c, d, o, x, X浮点数类型e, E, f, % 123456789101112&gt;&gt;&gt;\"&#123;0:=^20&#125;\".format(\"PYTHON\")'=======PYTHON======='&gt;&gt;&gt;\"&#123;0:*&gt;20&#125;\".format(\"BIT\")'*****************BIT'&gt;&gt;&gt;\"&#123;:10&#125;\".format(\"BIT\")'BIT '&gt;&gt;&gt;\"&#123;0:,.2f&#125;\".format(12345.6789)'12,345.68'&gt;&gt;&gt;\"&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;\".format(425)'110101001,Ʃ,425,651,1a9,1A9'&gt;&gt;&gt;\"&#123;0:e&#125;,&#123;0:E&#125;,&#123;0:f&#125;,&#123;0:%&#125;\".format(3.14)'3.140000e+00,3.140000E+00,3.140000,314.000000%' 序列类型iteratorIterator Types 序列是一个基类类型 序列类型定义序列是具有先后关系的一组元素 序列是一维元素向量，元素类型可以不同 类似数学元素序列：s0, s1, … , sn-1 元素间由序号引导，通过下标访问序列的特定元素 ![1573915049023](python/Iterator Types.png) 序列处理函数及方法6个操作符 操作符及应用 描述 x in s 如果x是序列s的元素，返回True，否则返回False x not in s 如果x是序列s的元素，返回False，否则返回True s + t 连接两个序列s和t s*n 或n*s 将序列s复制n次 s[i] 索引，返回s中的第i个元素，i是序列的序号 s[i: j]或s[i: j: k] 切片，返回序列s中第i到j以k为步长的元素子序列 5个函数和方法 函数和方法 描述 len(s) 返回序列s的长度，即元素个数 min(s) 返回序列s的最小元素，s中元素需要可比较 max(s) 返回序列s的最大元素，s中元素需要可比较 s.index(x) 或s.index(x, i,j) 返回序列s从i开始到j位置中第一次出现元素x的位置 s.count(x) 返回序列s中出现x的总次数 元组类型定义元组是序列类型的一种扩展 元组是一种序列类型，一旦创建就不能被修改 使用小括号() 或tuple() 创建，元素间用逗号, 分隔 可以使用或不使用小括号 12def func(): return1,2 123456&gt;&gt;&gt;creature = \"cat\", \"dog\",\"tiger\",\"human\"&gt;&gt;&gt;creature('cat', 'dog', 'tiger', 'human')&gt;&gt;&gt;color = (0x001100, \"blue\", creature)&gt;&gt;&gt;color(4352, 'blue', ('cat', 'dog', 'tiger', 'human')) 元组类型操作 元组继承了序列类型的全部通用操作 -元组因为创建后不能修改，因此没有特殊操作 列表类型列表是序列类型的一种扩展，十分常用 列表是一种序列类型，创建后可以随意被修改 使用方括号[] 或list() 创建，元素间用逗号, 分隔 列表中各元素类型可以不同，无长度限制 列表类型操作函数和方法 函数或方法 描述 ls[i] = x 替换列表ls第i元素为x ls[i: j: k]= lt 用列表lt替换ls切片后所对应元素子列表 del ls[i] 删除列表ls中第i元素 del ls[i: j: k] 删除列表ls中第i到第j以k为步长的元素 ls += lt 更新列表ls，将列表lt元素增加到列表ls中 ls *= n 更新列表ls，其元素重复n次 ls.append(x) 在列表ls最后增加一个元素x ls.clear() 删除列表ls中所有元素 ls.copy() 生成一个新列表，赋值ls中所有元素 ls.insert(i,x) 在列表ls的第i位置增加元素x ls.pop(i) 将列表ls中第i位置元素取出并删除该元素 ls.remove(x) 将列表ls中出现的第一个元素x删除 ls.reverse() 将列表ls中的元素反转 集合类型集合是多个元素的无序组合 集合类型与数学中的集合概念一致 集合元素之间无序，每个元素唯一，不存在相同元素 集合元素不可更改，不能是可变数据类型 为什么？ 集合用大括号 {} 表示，元素间用逗号分隔 建立集合类型用 {} 或 set() 建立空集合类型，必须使用set() 123456&gt;&gt;&gt; A = &#123;\"python\", 123, (\"python\",123)&#125; #使用&#123;&#125;建立集合&#123;123, 'python', ('python', 123)&#125;&gt;&gt;&gt; B = set(\"pypy123\") #使用set()建立集合&#123;'1', 'p', '2', '3', 'y'&#125;&gt;&gt;&gt; C = &#123;\"python\", 123, \"python\",123&#125;&#123;'python', 123&#125; 集合操作符 操作符及应用 描述 S | T 并，返回一个新集合，包括在集合S和T中的所有元素 S - T 差，返回一个新集合，包括在集合S但不在T中的元素 S &amp; T 交，返回一个新集合，包括同时在集合S和T中的元素 S ^ T 补，返回一个新集合，包括集合S和T中的非相同元素 S &lt;= T 或 S &lt; T 返回True/False，判断S和T的子集关系 S &gt;= T 或 S &gt; T 返回True/False，判断S和T的包含关系 S |= T 并，更新集合S，包括在集合S和T中的所有元素 S -= T 差，更新集合S，包括在集合S但不在T中的元素 S &amp;= T 交，更新集合S，包括同时在集合S和T中的元素 S ^= T 补，更新集合S，包括集合S和T中的非相同元素 123456789101112&gt;&gt;&gt; A = &#123;\"p\", \"y\" , 123&#125;&gt;&gt;&gt; B = set(\"pypy123\")&gt;&gt;&gt; A-B&#123;123&#125;&gt;&gt;&gt; B-A&#123;'3', '1', '2'&#125;&gt;&gt;&gt; A&amp;B&#123;'p', 'y'&#125;&gt;&gt;&gt; A|B&#123;'1', 'p', '2', 'y', '3', 123&#125;&gt;&gt;&gt; A^B&#123;'2', 123, '3', '1'&#125; 集合处理方法 S.add(x) 如果x不在集合S中，将x增加到S S.discard(x) 移除S中元素x，如果x不在集合S中，不报错 S.remove(x) 移除S中元素x，如果x不在集合S中，产生KeyError异常 S.clear() 移除S中所有元素 S.pop() 随机返回S的一个元素，更新S，若S为空产生KeyError异常 S.copy() 返回集合S的一个副本 len(S) 返回集合S的元素个数 x in S 判断S中元素x， x在集合S中，返回True，否则返回False x not in S 判断S中元素x， x不在集合S中，返回True，否则返回False set(x) 将其他类型变量x转变为集合类型 1234567891011121314&gt;&gt;&gt; A = &#123;\"p\", \"y\" , 123&#125;&gt;&gt;&gt; for item in A:print(item, end=\"\")p123y&gt;&gt;&gt; A&#123;'p', 123, 'y'&#125;&gt;&gt;&gt; try:while True:print(A.pop(), end=\"\"))except:passp123y&gt;&gt;&gt; Aset() 集合类型应用场景包含关系比较 1234\"p\" in &#123;\"p\", \"y\" , 123&#125;True&#123;\"p\", \"y\"&#125; &gt;= &#123;\"p\", \"y\" , 123&#125;False 数据去重：集合类型所有元素无重复 12345&gt;&gt;&gt; ls = [\"p\", \"p\", \"y\", \"y\", 123]&gt;&gt;&gt; s = set(ls) # 利用了集合无重复元素的特点&#123;'p', 'y', 123&#125;&gt;&gt;&gt; lt = list(s) # 还可以将集合转换为列表['p', 'y', 123] 字典类型及操作字典类型定义字典类型是“映射”的体现 映射是一种键(索引)和值(数据)的对应 键值对：键是数据索引的扩展 字典是键值对的集合，键值对之间无序 采用大括号{}和dict()创建，键值对用冒号: 表示{&lt;键1&gt;:&lt;值1&gt;, &lt;键2&gt;:&lt;值2&gt;, … , &lt;键n&gt;:&lt;值n&gt;} 在字典变量中，通过键获得值&lt;字典变量&gt; = {&lt;键1&gt;:&lt;值1&gt;, … , &lt;键n&gt;:&lt;值n&gt;}&lt;值&gt; = &lt;字典变量&gt;[&lt;键&gt;][ ] 用来向字典变量中索引或增加元素 1&lt;字典变量&gt;[&lt;键&gt;] = &lt;值&gt; 123456789&gt;&gt;&gt; d = &#123;\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"&#125;&gt;&gt;&gt; d&#123;'中国': '北京', '美国': '华盛顿', '法国': '巴黎'&#125;&gt;&gt;&gt; d[\"中国\"]'北京'&gt;&gt;&gt; de = &#123;&#125; ; type(de)&lt;class 'dict'&gt;type(x)返回变量x的类型 字典类型操作函数和方法 函数或方法 描述 del d[k] 删除字典d中键k对应的数据值 k in d 判断键k是否在字典d中，如果在返回True，否则False d.keys() 返回字典d中所有的键信息 d.values() 返回字典d中所有的值信息 d.items() 返回字典d中所有的键值对信息 d.get(k, ) 键k存在，则返回相应值，不在则返回值 d.pop(k, ) 键k存在，则取出相应值，不在则返回值 d.popitem() 随机从字典d中取出一个键值对，以元组形式返回 d.clear() 删除所有的键值对 len(d) 返回字典d中元素的个数 123456789101112131415&gt;&gt;&gt; d = &#123;\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"&#125;&gt;&gt;&gt; \"中国\" in dTrue&gt;&gt;&gt; d.keys()dict_keys(['中国', '美国', '法国'])&gt;&gt;&gt; d.values()dict_values(['北京', '华盛顿', '巴黎'])&gt;&gt;&gt; d = &#123;\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"&#125;&gt;&gt;&gt; d.get(\"中国\",\"伊斯兰堡\")'北京'&gt;&gt;&gt; d.get(\"巴基斯坦\",\"伊斯兰堡\")'伊斯兰堡'&gt;&gt;&gt; d.popitem()('美国', '华盛顿') 元素遍历 12for k in d :&lt;语句块&gt; 文件处理文件的理解文件是数据的抽象和集合 文件是存储在辅助存储器上的数据序列 文件是数据存储的一种形式 文件展现形态：文本文件和二进制文件 文本文件 vs. 二进制文件 文件文件和二进制文件只是文件的展示方式 本质上，所有文件都是二进制形式存储 形式上， 所有文件采用两种方式展示 文本文件 由单一特定编码组成的文件，如UTF-8编码 由于存在编码，也被看成是存储着的长字符串 适用于例如： .txt文件、 .py文件等 二进制文件 直接由比特0和1组成， 没有统一字符编码 一般存在二进制0和1的组织结构，即文件格式 适用于例如： .png文件、 .avi文件等 文本文件vs二进制文件f.txt文件保存：“中国是一个伟大的国家！”； 文本形式打开文件12345678#tf = open(\"f.txt\", mode=\"rt\",encoding='UTF-8') 能指定编码tf = open(\"f.txt\", \"rt\",encoding='UTF-8')print(tf.readline())tf.close()============= RESTART: E:/Codes/Python/new/file.py ====================中国是一个伟大的国家！&gt;&gt;&gt; 二进制形式打开文件12345678tf = open(\"f.txt\", mode=\"rb\")#tf = open(\"f.txt\", \"rb\")print(tf.readline())tf.close()====== RESTART: E:/Codes/Python/new/file.py ====================b'\\xe4\\xb8\\xad\\xe5\\x9b\\xbd\\xe6\\x98\\xaf\\xe4\\xb8\\x80\\xe4\\xb8\\xaa\\xe4\\xbc\\x9f\\xe5\\xa4\\xa7\\xe7\\x9a\\x84\\xe5\\x9b\\xbd\\xe5\\xae\\xb6\\xef\\xbc\\x81'&gt;&gt;&gt; 文件的使用 文件的打开 1&lt;变量名(文件句柄)&gt; = open(&lt;文件名|文件路径和名称&gt;, &lt;打开模式 |文本 or 二进制|读 or 写 &gt;) 文件路径和名称源文件同目录可省路径 123\"D:/PYE/f.txt\"\"D:\\\\PYE\\\\f.txt\" \"f.txt\"\"./PYE/f.txt\" 打开模式文本形式、只读模式、默认值 文件的打开模式 描述 ‘r’ 只读模式，默认值，如果文件不存在，返回FileNotFoundError ‘w’ 覆盖写模式，文件不存在则创建，存在则完全覆盖 ‘x’ 创建写模式，文件不存在则创建，存在则返回FileExistsError ‘a’ 追加写模式，文件不存在则创建，存在则在文件最后追加内容 ‘b’ 二进制文件模式 ‘t’ 文本文件模式，默认值 ‘+’ 与r/w/x/a一同使用，在原功能基础上增加同时读写功能 1234567891011121314f = open(\"f.txt\")f = open(\"f.txt\", \"rt\")f = open(\"f.txt\", \"w\")f = open(\"f.txt\", \"a+\")f = open(\"f.txt\", \"x\")f = open(\"f.txt\", \"b\")f = open(\"f.txt\", \"wb\")- 文本形式、只读模式、默认值- 文本形式、只读模式、同默认值- 文本形式、覆盖写模式- 文本形式、追加写模式+ 读文件- 文本形式、创建写模式- 二进制形式、只读模式- 二进制形式、覆盖写模式 12345678#文本形式打开文件tf = open(\"f.txt\", \"rt\")print(tf.readline())tf.close()#二进制形式打开文件bf = open(\"f.txt\", \"rb\")print(bf.readline())bf.close() 文件内容的读取 操作方法 描述 .read(size=-1) 读入全部内容，如果给出参数，读入前size长度 &gt;&gt;&gt;s = f.read(2) 中国 .readline(size=-1) 读入一行内容，如果给出参数，读入该行前size长度 &gt;&gt;&gt;s = f.readline() 中国是一个伟大的国家！ .readlines(hint=-1) 读入文件所有行，以每行为元素形成列表 如果给出参数，读入前hint行 &gt;&gt;&gt;s = f.readlines() [‘中国是一个伟大的国家！ ‘] 文件的逐行操作 逐行遍历文件：方法一 一次读入，分行处理 12345fname = input(\"请输入要打开的文件名称:\")fo = open(fname,\"r\")for line in fo.readlines(): print(line)fo.close() 逐行遍历文件：方法二 分行读入，逐行处理 12345fname = input(\"请输入要打开的文件名称:\")fo = open(fname,\"r\")for line in fo:print(line)fo.close() 数据的文件写入 操作方法 描述 .write(s) 向文件写入一个字符串或字节流 &gt;&gt;&gt;f.write(“中国是一个伟大的国家!”) .writelines(lines) 将一个元素全为字符串的列表写入文件 &gt;&gt;&gt;ls = [“中国”, “法国”, “美国”] &gt;&gt;&gt;f.writelines(ls) 中国法国美国 .seek(offset) 改变当前文件操作指针的位置， offset含义如下： 0 – 文件开头； 1 – 当前位置； 2 – 文件结尾 &gt;&gt;&gt;f.seek(0) #回到文件开头 数据的文件写入 写入一个字符串列表(没有任何输出) 123456fo = open(\"output.txt\",\"w+\")ls = [\"中国\", \"法国\", \"美国\"]fo.writelines(ls)for line in fo: print(line)fo.close() 写入一个字符串列表 1234567fo = open(\"output.txt\",\"w+\")ls = [\"中国\", \"法国\", \"美国\"]fo.writelines(ls)fo.seek(0)for line in fo: print(line)fo.close() with open文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的： 1f.close() 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现： 123456try: f = open('/path/to/file', 'r') print(f.read())finally: if f: f.close() 但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法： 12with open('/path/to/file', 'r') as f: print(f.read()) 这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。 遍历文件夹下的所有文件12345678910111213for root, dirs, files in os.walk(file): # root 表示当前正在访问的文件夹路径 # dirs 表示该文件夹下的子目录名list # files 表示该文件夹下的文件list # 遍历文件 for f in files: print(os.path.join(root, f)) # 遍历所有的文件夹 for d in dirs: print(os.path.join(root, d)) 删除文件os.remove() 方法用于删除指定路径的文件。如果指定的路径是一个目录，将抛出OSError。 在Unix, Windows中有效 语法remove()方法语法格式如下： 1`os.remove(path)` 参数 path – 要移除的文件路径 返回值该方法没有返回值 复制目录及文件1shutil.copytree(source_dir, target_dir) python常用标准库标准库Python计算生态 = 标准库 + 第三方库 标准库：随解释器直接安装到操作系统中的功能模块 第三方库：需要经过安装才能使用的功能模块 库 Library 、包 Package 、模块 Module ，统称 模块 turtle库基本介绍turtle(海龟) 库是 turtle 绘图体系的 Python 实现 turtle 绘图体系： 1969 年诞生，主要用于程序设计入门 Python 语言的 标准库 之一 入门级的图形绘制函数库 turtle绘图窗体布局 1turtle.setup( width , height, startx , starty) setup() 设置窗体大小及位置 4 个参数中后两个可选 setup() 不是必须的 turtle空间坐标体系 1turtle.goto( x, y) turtle角度坐标体系 1turtle.seth(angle) seth()改变海龟行进方向 angle为绝对度数 seth()只改变方向但不行进 RGB色彩体系RGB色彩模式由由三种颜色构成的万物色 RGB指红蓝绿三个通道的颜色组合 覆盖视力所能感知的所有颜色 RGB每色取值范围0-255整数或0-1小数 turtle的RGB色彩模式默认采用小数值 可切换为整数值 1turtle.colormode(mode) 1.0：RGB小数值模式 255：RGB整数值模式 time库time库是Python中处理时间的标准库 计算机时间的表达 提供获取系统时间并格式化输出功能 提供系统级精确计时功能，用于程序性能分析 12import timetime.&lt;b&gt;() time库包括三类函数 时间获取：time() ctime() gmtime() 时间格式化：strftime() strptime() 程序计时：sleep(), perf_counter() 时间获取 函数 描述 time() 获取当前时间戳，即计算机内部时间值，浮点数&gt;&gt;&gt;time.time()1516939876.6022282 ctime() 获取当前时间并以易读方式表示，返回字符串&gt;&gt;time.ctime()’Fri Jan 26 12:11:16 2018’ gmtime() 获取当前时间，表示为计算机可处理的时间格式&gt;&gt;&gt;time.gmtime()time.struct_time(tm_year=2018, tm_mon=1, tm_mday=26, tm_hour=4, tm_min=11, tm_sec=16, tm_wday=4, tm_yday=26, tm_isdst=0) 时间格式化 格式化：类似字符串格式化，需要有展示模板 展示模板由特定的格式化控制符组成 strftime()方法 1strftime(tpl, ts) tpl是格式化模板字符串，用来定义输出效果ts是计算机内部时间类型变量 12&gt;&gt;&gt;t = time.gmtime()&gt;&gt;&gt;time.strftime(\"%Y-%m-%d %H:%M:%S\",t) '2018-01-26 12:55:20' 格式化控制符 格式化字符串 日期/时间说明 值范围和实例 %Y 年份 0000~9999，例如：1900 %m 月份 01~12，例如：10 %B 月份名称 January~December，例如：April %b 月份名称缩写 Jan~Dec，例如：Apr %d 日期 01~31，例如：25 %A 星期 Monday~Sunday，例如：Wednesday %a 星期缩写 Mon~Sun，例如：Wed %H 小时（24h制） 00~23，例如：12 %I 小时（12h制） 01~12，例如：7 %p 上/下午 AM, PM，例如：PM %M 分钟 00~59，例如：26 %S 秒 00~59，例如：26 12&gt;&gt;&gt;t = time.gmtime()&gt;&gt;&gt;time.strftime(\"%Y-%m-%d %H:%M:%S\",t) 12&gt;&gt;&gt;timeStr = '2018-01-26 12:55:20'&gt;&gt;&gt;time.strptime(timeStr, “%Y-%m-%d %H:%M:%S”) 程序计时程序计时应用广泛 程序计时指测量起止动作所经历时间的过程 测量时间：perf_counter() 产生时间：sleep() 1perf_counter() 返回一个CPU级别的精确时间计数值，单位为秒由于这个计数值起点不确定，连续调用差值才有意义 1234&gt;&gt;&gt;start = time.perf_counter() 318.66599499718114&gt;&gt;&gt;end = time.perf_counter() 341.3905185375658&gt;&gt;&gt;end - start&gt;&gt;&gt;22.724523540384666 sleep(s) s拟休眠的时间，单位是秒，可以是浮点数 123&gt;&gt;&gt;def wait():time.sleep(3.3)&gt;&gt;&gt;wait() #程序将等待3.3秒后再退出 random库random库是使用随机数的Python标准库 伪随机数: 采用梅森旋转算法生成的(伪)随机序列中元素 random库主要用于生成随机数 使用random库: import random 常用函数random库包括两类函数，常用共8个 基本随机数函数：seed(),random() 扩展随机数函数：randint(), getrandbits(), uniform(), randrange(), choice(), shuffle() 基本随机数函数 函数 描述 seed(a=None) 初始化给定的随机数种子，默认为当前系统时间&gt;&gt;&gt;random.seed(10) #产生种子10对应的序列 random() 生成一个[0.0, 1.0)之间的随机小数&gt;&gt;&gt;random.random()0.5714025946899135 函数 描述 randint(a, b) 生成一个[a, b]之间的整数&gt;&gt;&gt;random.randint(10, 100)64 randrange(m, n[, k]) 生成一个[m, n)之间以k为步长的随机整数&gt;&gt;&gt;random.randrange(10, 100, 10)80 getrandbits(k) 生成一个k比特长的随机整数&gt;&gt;&gt;random.getrandbits(16)37885 uniform(a,b) 生成一个[a, b]之间的随机小数&gt;&gt;&gt;random.uniform(10, 100)13.096321648808136 choice(seq) 从序列seq中随机选择一个元素&gt;&gt;&gt;random.choice([1,2,3,4,5,6,7,8,9])8 shuffle(seq) 将序列seq中元素随机排列，返回打乱后的序列&gt;&gt;&gt;s=[1,2,3,4,5,6,7,8,9];random.shuffle(s);print(s)[3, 5, 8, 9, 6, 1, 2, 7, 4] os库os库基本介绍os库提供通用的、基本的操作系统交互功能 os库是Python标准库，包含几百个函数 常用路径操作、进程管理、环境参数等几类 路径操作：os.path子库，处理文件路径及信息 进程管理：启动系统中其他程序 环境参数：获得系统软硬件信息等环境 os库之路径操作路径操作os.path子库以path为入口，用于操作和处理文件路径 123import os.path或import os.path as op 函数 描述 os.path.abspath(path) 返回path在当前系统中的绝对路径&gt;&gt;&gt;os.path.abspath(“file.txt”)‘C:\\Users\\Tian Song\\Python36-32\\file.txt’ os.path.normpath(path) 归一化path的表示形式，统一用\\分隔路径&gt;&gt;&gt;os.path.normpath(“D://PYE//file.txt”)‘D:\\PYE\\file.txt’ os.path.relpath(path) 返回当前程序与文件之间的相对路径 (relative path)&gt;&gt;&gt;os.path.relpath(“C://PYE//file.txt”)‘..\\..\\..\\..\\..\\..\\..\\PYE\\file.txt’ os.path.dirname(path) 返回path中的目录名称&gt;&gt;&gt;os.path.dirname(“D://PYE//file.txt”)‘D://PYE’ os.path.basename(path) 返回path中最后的文件名称&gt;&gt;&gt;os.path.basename(“D://PYE//file.txt”)‘file.txt’ os.path.join(path, *paths) 组合path与paths，返回一个路径字符串&gt;&gt;&gt;os.path.join(“D:/“, “PYE/file.txt”)‘D:/PYE/file.txt’ os.path.exists(path) 判断path对应文件或目录是否存在，返回True或False&gt;&gt;&gt;os.path.exists(“D://PYE//file.txt”)False os.path.isfile(path) 判断path所对应是否为已存在的文件，返回True或False&gt;&gt;&gt;os.path.isfile(“D://PYE//file.txt”)True os.path.isdir(path) 判断path所对应是否为已存在的目录，返回True或False&gt;&gt;&gt;os.path.isdir(“D://PYE//file.txt”)False os.path.getatime(path) 返回path对应文件或目录上一次的访问时间&gt;&gt;&gt;os.path.getatime(“D:/PYE/file.txt”)1518356633.7551725 os.path.getmtime(path) 返回path对应文件或目录上一次的访问时间&gt;&gt;&gt;os.path.getatime(“D:/PYE/file.txt”)1518356633.7551725 os.path.getmtime(path) 返回path对应文件或目录最近一次的修改时间&gt;&gt;&gt;os.path.getmtime(“D:/PYE/file.txt”)1518356633.7551725 os.path.getctime(path) 返回path对应文件或目录的创建时间time.ctime(os.path.getctime(“D:/PYE/file.txt”))‘Sun Feb 11 21:43:53 2018’ os.path.getsize(path) 返回path对应文件的大小，以字节为单位&gt;&gt;&gt;os.path.getsize(“D:/PYE/file.txt”)180768 获取当前文件路径123print(os.getcwd())print(os.path.abspath('.'))print(os.path.abspath(os.curdir)) os库之进程管理1os.system(command) 执行程序或命令command 在Windows系统中，返回值为cmd的调用返回信息 1234import osos.system(\"C:\\\\Windows\\\\System32\\\\calc.exe\")&gt;&gt;&gt;0 os库之环境环境获取或改变系统环境信息 函数 描述 os.chdir(path) 修改当前程序操作的路径&gt;&gt;&gt;os.chdir(“D:”) os.getcwd() 返回程序的当前路径&gt;&gt;&gt;os.getcwd()‘D:\\‘ os.getlogin() 获得当前系统登录用户名称&gt;&gt;&gt;os.getlogin() ‘Tian Song’ os.cpu_count() 获得当前系统的CPU数量&gt;&gt;&gt;os.cpu_count() 8 os.urandom(n) 获得n个字节长度的随机字符串，通常用于加解密运算&gt;&gt;&gt;os.urandom(10)b’7\\xbe\\xf2!\\xc1=\\x01gL\\xb3’ 正则表达式regular expression, regex, RE 什么是正则表达式正则表达式是对字符串串操作的一种逻辑公式，就是用事先定义好的一些特定 字符、及这些特定字符的组合，组成一个“规则字符串串”，这个“规则字符串”用 来表达对字符串的一种过滤逻辑。非Python独有，re模块实现 常见匹配模式 模式 描述 \\w 匹配字母数字及下划线 \\W 匹配非字母数字下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9] \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 * 匹配0个或多个的表达式。 + 匹配1个或多个的表达式。 ? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 {n} 精确匹配n个前面表达式。 {n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a&#124;b 匹配a或b ( ) 匹配括号内的表达式，也表示一个组 re.matchre.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 1re.match(pattern, string, flags=0) 最常规的匹配12345678import recontent = 'Hello 123 4567 World_This is a Regex Demo'print(len(content))result = re.match('^Hello\\s\\d\\d\\d\\s\\d&#123;4&#125;\\s\\w&#123;10&#125;.*Demo$', content)print(result)print(result.group())print(result.span()) out: 123441&lt;re.Match object; span=(0, 41), match='Hello 123 4567 World_This is a Regex Demo'&gt;Hello 123 4567 World_This is a Regex Demo(0, 41) 泛匹配.*来匹配任意字段 1234567import recontent = 'Hello 123 4567 World_This is a Regex Demo'result = re.match('^Hello.*Demo$', content)print(result)print(result.group())print(result.span()) out: 123&lt;re.Match object; span=(0, 41), match='Hello 123 4567 World_This is a Regex Demo'&gt;Hello 123 4567 World_This is a Regex Demo(0, 41) 匹配目标通过添加()进行分组，提取，指定数据 1234567import recontent = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^Hello\\s(\\d+)\\sWorld.*Demo$', content)print(result)print(result.group(1))print(result.span()) out: 123&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567(0, 40) 贪婪匹配Re库默认采用贪婪匹配 123456import recontent = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*(\\d+).*Demo$', content)print(result)print(result.group(1)) out: .*匹配掉了尽可能多的字符 12&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;7 非贪婪匹配只要长度输出可能不同的，都可以通过在操作符后增加?变成最小匹配 123456import recontent = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*?(\\d+).*Demo$', content)print(result)print(result.group(1)) out: 12&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567 匹配模式通过设置匹配模式，将.能匹配换行符 1234567import recontent = '''Hello 1234567 World_Thisis a Regex Demo'''result = re.match('^He.*?(\\d+).*?Demo$', content, re.S)print(result.group(1)) out: 11234567 转义12345import recontent = 'price is $5.00'result = re.match('price is $5.00', content)print(result) 1None 12345import recontent = 'price is $5.00'result = re.match('price is \\$5\\.00', content)print(result) out: 1&lt;re.Match object; span=(0, 14), match='price is $5.00'&gt; 总结：尽量使用泛匹配、使用括号得到匹配目标、尽量使用非贪婪模式、有换行符就用re.S re.searchre.search 扫描整个字符串并返回第一个成功的匹配。 12345import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'result = re.match('Hello.*?(\\d+).*?Demo', content)print(result) 1None 123456import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'result = re.search('Hello.*?(\\d+).*?Demo', content)print(result)print(result.group(1)) 12&lt;re.Match object; span=(13, 53), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567 总结：为匹配方便，能用search就不用match 匹配演练12345678910111213141516171819202122232425import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;&lt;i class=\"fa fa-user\"&gt;&lt;/i&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''result = re.search('&lt;li.*?active.*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;', html, re.S)if result: print(result.group(1), result.group(2)) import re html = ‘’’ 经典老歌 经典老歌列表 一路上有你 沧海一声笑 往事随风 光辉岁月 记事本 但愿人长久 ''' result = re.search('(.*?)', html, re.S) if result: print(result.group(1), result.group(2)) 12345678910111213141516171819202122232425import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''result = re.search('&lt;li.*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;', html)if result: print(result.group(1), result.group(2)) re.findall搜索字符串，以列表形式返回全部能匹配的子串。 12345678910111213141516171819202122232425262728import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''results = re.findall('&lt;li.*?href=\"(.*?)\".*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;', html, re.S)print(results)print(type(results))for result in results: print(result) print(result[0], result[1], result[2]) 1234567891011121314151617181920212223242526import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''results = re.findall('&lt;li.*?&gt;\\s*?(&lt;a.*?&gt;)?(\\w+)(&lt;/a&gt;)?\\s*?&lt;/li&gt;', html, re.S)print(results)for result in results: print(result[1]) re.sub替换字符串中每一个匹配的子串后返回替换后的字符串。 12345import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'content = re.sub('\\d+', 'Replacement', content)print(content) 1Extra stings Hello Replacement World_This is a Regex Demo Extra stings 12345import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'content = re.sub('(\\d+)', r'\\1 8910', content)print(content) \\1指明分组中的第一个 1Extra stings Hello 1234567 8910 World_This is a Regex Demo Extra stings 12345678910111213141516171819202122232425262728import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = re.sub('&lt;a.*?&gt;|&lt;/a&gt;', '', html)print(html)results = re.findall('&lt;li.*?&gt;(.*?)&lt;/li&gt;', html, re.S)print(results)for result in results: print(result.strip()) re.compile将正则字符串编译成正则表达式对象 将一个正则表达式串编译成正则对象，以便于复用该匹配模式 12345678import recontent = '''Hello 1234567 World_Thisis a Regex Demo'''pattern = re.compile('Hello.*Demo', re.S)result = re.match(pattern, content)#result = re.match('Hello.*Demo', content, re.S)print(result) 1&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This\\nis a Regex Demo'&gt; 豆瓣读书实战练习12345678910import requestsimport recontent = requests.get('https://book.douban.com/').textpattern = re.compile('&lt;li.*?cover.*?href=\"(.*?)\".*?title=\"(.*?)\".*?more-meta.*?author\"&gt;(.*?)&lt;/span&gt;.*?year\"&gt;(.*?)&lt;/span&gt;.*?&lt;/li&gt;', re.S)results = re.findall(pattern, content)for result in results: url, name, author, date = result author = re.sub('\\s', '', author) date = re.sub('\\s', '', date) print(url, name, author, date) 异常处理异常处理的基本使用 123456789try : &lt;语句块1&gt;except : &lt;语句块2&gt;try : &lt;语句块1&gt;except &lt;异常类型&gt; : &lt;语句块2&gt; 1234567891011try : num = eval(input(\"请输入一个整数: \")) print(num**2)except : print(\"输入不是整数\")try : num = eval(input(\"请输入一个整数: \")) print(num**2)except NameError: print(\"输入不是整数\") 示例标注异常类型后，仅响应此类异常异常类型名字等同于变量名 异常处理的高级使用 finally对应语句块4一定执行 else对应语句块3在不发生异常时执行 12345678try : &lt;语句块1&gt;except : &lt;语句块2&gt;else : &lt;语句块3&gt;finally : &lt;语句块4&gt; 12345try: ...except xxx as xx: traceback.print_exc() ... 12345try: response = urllib.request.urlopen('http://httpbin.org/get',timeout=1) except urllib.error.URLError as e: if isinstance(e.strerror,socket.timeout): print('TIME OUT') 主动抛出异常。格式：主动抛出异常终止程序 1raise 异常名称(‘异常描述’) 1raise RuntimeError('testError') 打印异常信息我们可以使用 traceback这个内置模块来获取异常更加详细的信息： 12345import traceback try: ... except Exception,e: traceback.print_exc() traceback.print_exc() 直接打印异常traceback.format_exc()返回字符串还可以将信息写入到文件 traceback.print_exc(file=open(‘error.txt’,’a+’)) python第三方库Python社区 PyPI PyPI: Python Package Index PSF维护的展示全球Python计算生态的主站 学会检索并利用PyPI，找到合适的第三方库开发程序 实例：开发与区块链相关的程序 第1步：在pypi.org搜索 blockchain 第2步：挑选适合开发目标的第三方库作为基础 第3步：完成自己需要的功能 三种方法 方法1(主要方法): 使用pip命令 方法2: 集成安装方法 方法3: 文件安装方法 pip -h 1234567891011121314151617181920E:\\Users\\11623\\Anaconda3\\Lib\\site-packages&gt;pip -hUsage: pip &lt;command&gt; [options]Commands: install Install packages. download Download packages. uninstall Uninstall packages. freeze Output installed packages in requirements format. list List installed packages. show Show information about installed packages. check Verify installed packages have compatible dependencies. config Manage local and global configuration. search Search PyPI for packages. wheel Build wheels from your requirements. hash Compute hashes of package archives. completion A helper command used for command completion. debug Show information useful for debugging. help Show help for commands. pip常用指令安装指定的第三方库 1pip install &lt;第三方库名&gt; 使用-U标签更新已安装的指定第三方库 1pip install –U &lt;第三方库名&gt; 卸载指定的第三方库 1D:\\&gt;pip uninstall &lt;第三方库名&gt; 下载但不安装指定的第三方库 1D:\\&gt;pip download &lt;第三方库名&gt; 列出某个指定第三方库的详细信息 1D:\\&gt;pip show &lt;第三方库名&gt; 根据关键词在名称和介绍中搜索第三方库 1D:\\&gt;pip search &lt;关键词&gt; 1pip search blockchain 1D:\\&gt;pip list 列出当前系统已经安装的第三方库 第三方库的集成安装方法 Anaconda集成安装：结合特定Python开发工具的批量安装 https://www.continuum.io 支持近800个第三方库 包含多个主流工具 适合数据计算领域开发 Anaconda跟换国内镜像源https://blog.csdn.net/dream_allday/article/details/80344511 文件安装方法为什么有些第三方库用pip可以下载，但无法安装？ 某些第三方库pip下载后，需要编译再安装 如果操作系统没有编译环境，则能下载但不能安装 可以直接下载编译后的版本用于安装吗？ http://www.lfd.uci.edu/~gohlke/pythonlibs/ 将pip源更换到国内镜像https://blog.csdn.net/sinat_21591675/article/details/82770360 Python命名规则https://www.jianshu.com/p/a793c0d960fe 模块名,包名,文件名模块应该使用尽可能短的、全小写命名，可以在模块命名时使用下划线以增强可读性。同样包的命名也应该是这样的，虽然其并不鼓励下划线 主要是考虑模块名是与文件夹相对应的，因此需要考虑文件系统的一些命名规则的，比如Unix系统对大小写敏感，而过长的文件名会影响其在 Windows\\Mac\\Dos 等系统中的正常使用。 通常是小写字母，单词之间用_分割 注意：文件名混合大小写仅被允许用于这种风格已经占据优势的时候，以便保持向后兼容 类名和java一样，类名都使用首字母大写开头(Pascal命名风格，驼峰)的规范。 使用 _单下划线开头的类名为内部使用 1from module_name import * 默认不被导入的情况 _InnerClass 变量全局变量名（类变量，在java中相当于static变量）大写字母，单词之间用 _分割 12NUMBERCOLOR_WRITE 普通变量小写字母，单词之间用 _分割 注意： 不论是类成员变量还是全局变量，均不使用 m 或 g 前缀(匈牙利标记法)。 私有类成员使用单一下划线前缀标识，多定义公开成员，少定义私有成员。 变量名不应带有类型信息，因为Python是动态类型语言。如 iValue、names_list、dict_obj 等都是不好的命名。 实例变量：以 _ 开头，其他和普通变量一样 私有实例变量（外部访问会报错）以 __开头（2个下划线），其他和普通变量一样 1__private_var 专有变量__开头，__结尾，一般为python的自有变量， 1不要以这种方式命名普通变量，这个是保留字，要满足防御性编程需求 12__doc____class__ 函数普通函数和普通变量一样 123get_name()count_number()ad_stat() 私有函数（外部访问会报错）以 __ 开头（2个下划线），其他和普通函数一样 1__get_name() 函数和方法的参数总使用“self”作为实例方法的第一个参数。 总使用“cls”作为类方法的第一个参数。 如果一个函数的参数名称和保留的关键字冲突，通常使用一个后缀下划线好于使用缩写或奇怪的拼写 常量常量名所有字母大写，由下划线连接各个单词如 MAX_OVERFLOW，TOTAL 异常因为异常也是一个类，所以遵守类的命名规则 此外，如果异常实际上指代一个错误的话，应该使用“Error”做后缀。 缩写命名应当尽量使用全拼写的单词，缩写的情况有如下两种： 常用的缩写，如XML、ID等，在命名时也应只大写首字母，如XmlParser 命名中含有长单词，对某个单词进行缩写。这时应使用约定成俗的缩写方式 例如： 名称 缩写 function fn text txt object obj count cnt number num 前导后缀下划线总结 一个前导下划线：表示非公有。 一个后缀下划线：避免关键字冲突。 两个前导下划线：当命名一个类属性引起名称冲突时使用。 两个前导和后缀下划线：“魔术”（有特殊用途）对象或者属性，例如init或者file。绝对不要创造这样的名字，而只是使用它们。 注意：关于下划线的使用存在一些争议 Python 用下划线作为变量前缀和后缀指定特殊变量 123456## 不能用'from module import *'导入（相当于 private）_xxx## 系统定义名字__xxx__## 类中的私有变量名(相当于protect)__xxx 下划线核心风格1避免用下划线作为变量名的开始 因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避免用下划线作为变量名的开始。 一般来讲，变量名_xxx被看作是“私有的”，在模块或类外不可以使用。当变量是私有的时候，用_xxx 来表示变量是很好的习惯。“单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；“双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据 以单下划线开头_foo的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用“from xxx import *”而导入； 以双下划线开头的__foo代表类的私有成员； 以双下划线开头和结尾的__foo__代表python里特殊方法专用的标识，如__init__（）代表类的构造函数。 特定命名方式主要是指 __xxx__ 形式的系统保留字命名法。 项目中也可以使用这种命名，它的意义在于这种形式的变量是只读的，这种形式的类成员函数尽量不要重载 如 123456class Base(object): def __init__(self, id, parent = None): self.__id__ = id self.__parent__ = parent def __message__(self, msgid): ## … 其中 __id__、__parent__ 和 __message__ 都采用了系统保留字命名法 __双下划线开头双下划线结尾__：指那些包含在用户无法控制的命名空间中的“魔术”对象或属性 如类成员的__name__、__doc__、__init__、__import__、__file__、等 推荐永远不要将这样的命名方式应用于自己的变量或函数。 单下划线结尾_：只是为了避免与python关键字的命名冲突 _单下划线开头：弱“内部使用”标识，如：from M import *，将不导入所有以下划线开头的对象，包括包、模块、成员 python 类python动态添加属性(对象属性，类属性)1234567891011121314151617181920212223242526class cltdy: #定义类，并起一个名字 n = 1000 #类属性，类内的变量 def __init__(self,name,age,profession='IT民工'): #构造函数，类接收外部传入参数全靠构造函数 self.name = name self.age = age self.profession = profession def printing_name(self): #类的方法 print('我的名字是：%s'%self.name) def printing_age(self): print(\"我的年龄：%s\"%self.age) def printing_pfsn(self): print(\"我的职业：%s\"%self.profession)test = cltdy('sober',25,'DevOps') #类的实例化，将参数传入类中，传入参数可以多但不可以少于类构造函数的参数(self参数除外，self是将实例化的变量名传入类)print(\"这是类实例化后的内存地址：%s\"%test)test.printing_name() #调用实例化后类中的方法test.name = 'moon' #可以修改构造函数中参数的值test.printing_name()test.printing_pfsn()print(test.n)test.n = 2000 #修改类属性，只针对test实例化生效print(test.n,'\\n====================')t2 = cltdy('jack',22,'student') #实例化类对象，命名t2print(t2.n)t2.printing_age() 使用pycharm导入python项目选择New environment 或者 Existing environment都可以，路径选择本地配置的python.exe路径即可； New Environment:New Environment部分是选择新建项目所依赖的python库，第一个选项会在项目中简历一个venv（virtualenv）目录，这里存放一个虚拟的python环境。这里所有的类库依赖都可以直接脱离系统安装的python独立运行。 Existing Interpreter:Existing Interpreter关联已经存在的python解释器，如果不想在项目中出现venv这个虚拟解释器就可以选择本地安装的python环境。通常选择Existing Interpreter即可 python定义类似常量const.py 12345678910class PROBLEM: MEMORY_LIMIT = \"memory_limit\" TIME_LIMIT = \"time_limit\" DESCRIPTION = 'description' SAMPLE_INPUT = \"sample_input\" SAMPLE_OUTPUT = \"sample_output\" FORMAT_INPUT = \"format_input\" FORMAT_OUTPUT = \"format_output\" HINT = \"hint\" STATE = \"state\" 使用： 12from const import *print(PROBLEM.DESCRIPTION) __init__.py文件init.py 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有init.py 文件. ######### 批量引入 init.py 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有init.py 文件。 通常init.py 文件为空，但是我们还可以为它增加其他的功能。我们在导入一个包时，实际上是导入了它的init.py文件。这样我们可以在init.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入。 packageinit.pyimport reimport urllibimport sysimport os a.pyimport packageprint(package.re, package.urllib, package.sys, package.os)init.py中还有一个重要的变量，all, 它用来将模块全部导入 init.pyall = [‘os’, ‘sys’, ‘re’, ‘urllib’] a.pyfrom package import *可以被import语句导入的对象是以下类型：模块文件（.py文件）C或C++扩展（已编译为共享库或DLL文件）包（包含多个模块）内建模块（使用C编写并已链接到Python解释器中）当导入模块时，解释器按照sys.path列表中的目录顺序来查找导入文件。 import sys print(sys.path) Linux:[‘’, ‘/usr/local/lib/python3.4’,‘/usr/local/lib/python3.4/plat-sunos5’,‘/usr/local/lib/python3.4/lib-tk’,‘/usr/local/lib/python3.4/lib-dynload’,‘/usr/local/lib/python3.4/site-packages’]其中list第一个元素空字符串代表当前目录。 关于.pyc 文件 与 .pyo 文件py文件的汇编,只有在import语句执行时进行，当.py文件第一次被导入时，它会被汇编为字节代码，并将字节码写入同名的.pyc文件中。后来每次导入操作都会直接执行.pyc 文件（当.py文件的修改时间发生改变，这样会生成新的.pyc文件），在解释器使用-O选项时，将使用同名的.pyo文件，这个文件去掉了断言（assert）、断行号以及其他调试信息，体积更小，运行更快。（使用-OO选项，生成的.pyo文件会忽略文档信息） 导入模块 模块通常为单独的.py文件，可以用import直接引用，可以作为模块的文件类型有.py、.pyo、.pyc、.pyd、.so、.dll 对象调用类中的变量和方法 init方法是一个特殊的方法,只要类名+() 产生一个对象,自动执行类中的init方法,并把类的地址传给方法里的第一个参数,约定把第一个参数定为’self’, 再给对象封装相应的属性. (1) dict 查询对象中的所有的内容 (2) 万能的点： . 123456789101112131415class Person: mind = '有思想' belif = '有信仰' animal = '高级动物' def __init__(self, name,age,hobby): self.name = name self.age = age self.hobby = hobby print(name,age,hobby) def work(self): print('会工作') return self def money(self): print('会消费') print(self) 私有方法如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 yield关键字yield 《=》生成器 包含yield语句的函数是一个生成器 生成器每次产生一个值（ yield语句），函数被冻结，被唤醒后再产生一个值生成器是一个不断产生值的函数 生成器相比一次列出所有内容的优势：1)更节省存储空间2)响应更迅速3)使用更灵活 实例： 123456def gen(n): for i in range(n): yield i ** 2 for i in gen(5): print(i, \" \", end=\"\") 生成器每调用一次在yield位置产生一个值，直到函数执行结束 一次返回所有值 12345def square(n): return [i **2 for i in range(n)] for i in square(5): print(i, \" \", end=\"\") 函数传递问题python不允许程序员选择采用传值还是传引用。python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。 如果函数收到的是一个不可变对象（数字、字符或元组）的引用，就不能直接修改原始对象–相当于通过‘值传递’来传递对象。 如果函数收到的是一个可变对象（字典、列表）的引用，就能修改对象的原始值–相当于‘传引用’来传递对象。 Python里面如何拷贝一个对象1.浅拷贝 ： 使用copy.copy,它可以进行对象的浅拷贝(shallow copy),它复制了对象,但对于对象中的元素,依然使用引用（换句话说修改拷贝对象元素，则被拷贝对象元素也被修改）2.深拷贝 ： 使用copy.deepcopy，它可以进行深拷贝，不仅拷贝了对象，同时也拷贝了对象中的元素，获得了全新的对象，与被拷贝对象完全独立，但这需要牺牲一定的时间和空间。3.特殊拷贝： 如要复制列表L,使用list(L),要复制一个字典d,使用dict(d),要复制一个集合s,使用set(s)。 总结一下的话：如果你要复制某个对象object, 它属于python内建的类型type,那么你可以使用type(object)来 获得一个拷贝。 4 举例： import copy list = [1, 2, 3, 4, [‘a’, ‘b’]] #原始对象 b = list #赋值，传对象的引用，依然指向list c = copy.copy(list) #对象拷贝，浅拷贝（元素依然是共享的引用） d = copy.deepcopy(list) #对象拷贝，深拷贝 list.append(5) #修改对象list list[4].append(‘c’) #修改对象list中的[‘a’, ‘b’]数组对象 print ‘list = ‘, list print ‘b = ‘, b print ‘c = ‘, c print ‘d = ‘, d 输出结果：list = [1, 2, 3, 4, [‘a’, ‘b’, ‘c’], 5]b = [1, 2, 3, 4, [‘a’, ‘b’, ‘c’], 5]c = [1, 2, 3, 4, [‘a’, ‘b’, ‘c’]]d = [1, 2, 3, 4, [‘a’, ‘b’]]","categories":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/tags/python/"}]},{"title":"springBoot","slug":"java-note/springBoot/springBoot","date":"2019-11-17T07:27:48.000Z","updated":"2022-03-30T02:18:41.405Z","comments":true,"path":"2019/11/java-note/springBoot/springBoot/","link":"","permalink":"https://codeofli.github.io/2019/11/java-note/springBoot/springBoot/","excerpt":"一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案； 2、微服务2014，martin fowler微服务：架构风格（服务微化）一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；","text":"一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案； 2、微服务2014，martin fowler微服务：架构风格（服务微化）一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 ##环境准备谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入注意：即使指定了对象加载的配置文件，但是如果主配置文件中存在该对象并能成功解析，那么直接使用先找到的对象，application.properties&gt;application.yml 配置文件 12345678910111213person:# lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 last-name: zhangsan javaBean： 123456789101112131415161718192021/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； *@ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;······ 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码12345678910111213#diea properties默认使用utf-8#配置person的值person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=false#对象person.maps.k1=v1 person.maps.k2=14#listperson.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件是yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 注意：即使指定了对象加载的配置文件，但是如果主配置文件中存在该对象并能成功解析，那么直接使用先找到的对象，application.properties&gt;application.yml 使用@PropertySource也需要@ConfigurationProperties(prefix = “person”)注解 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 123456789@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)//导入Spring的配置文件让其生效@SpringBootApplicationpublic class SpringBoot02ConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot02ConfigApplication.class, args); &#125;&#125; 不来编写Spring的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(\"配置类@Bean给容器中添加组件了...\"); return new HelloService(); &#125;&#125; ##4、配置文件占位符 1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值12345678910person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,c#hello默认值person.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 12#2.0以上版本java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087 --server.servlet.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports(){AutoConfigurationImportSelector类中}方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 1HttpProperties.class 新版本已更名 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = \"spring.http.encoding\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223242526272829//springboot新版本============================CONDITIONS EVALUATION REPORT=====================================================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 常用配置属性123#视图解析器前后缀spring.mvc.view.prefix=/WEB-INF/spring.mvc.view.suffix=.jsp server.servlet.context-path一、server.servlet.context-path配置的作用定义： server.servlet.context-path= # Context path of the application. 应用的上下文路径，也可以称为项目路径，是构成url地址的一部分。 server.servlet.context-path不配置时，默认为 / ，如：localhost:8080/xxxxxx 当server.servlet.context-path有配置时，比如 /demo，此时的访问方式为localhost:8080/demo/xxxxxx 二、springboot 2.0变革后的配置区别1、springboot 2.0之前，配置为 server.context-path 2、springboot 2.0之后，配置为 server.servlet.context-path 三、一个思考原来的运营项目(已上线)，配置文件添加 server.servlet.context-path 配置后，需要在thymleaf 中进行action请求的追加吗？ 答案：不需要。 栗子： 前端页面采取form请求 1&lt;form th:action=\"@&#123;/user/userLogin&#125;\" method=\"post\" id=\"userLogin\"&gt;&lt;/form&gt; action拦截接受方式 123456@Controller@RequestMapping(\"/user\")public class LoginController &#123;@PostMapping(\"/userLogin\")public String userLogin(HttpServletRequest request, Model model) &#123; 原项目的基础上，追加一个配置 server: port: 8080 servlet: context-path: /demo只需要再开始进入首页时，追加 localhost:8080/demo ，后续的thymleaf中的href和action等无需添加/demo 。 使用@ConditionalOnProperty来控制是否生成一个bean1. 简介 Spring Boot通过@ConditionalOnProperty来控制Configuration是否生效 2. 说明12345678910111213141516171819@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Documented@Conditional(OnPropertyCondition.class)public @interface ConditionalOnProperty &#123; String[] value() default &#123;&#125;; //数组，获取对应property名称的值，与name不可同时使用 String prefix() default &quot;&quot;;//property名称的前缀，可有可无 String[] name() default &#123;&#125;;//数组，property完整名称或部分名称（可与prefix组合使用，组成完整的property名称），与value不可同时使用 String havingValue() default &quot;&quot;;//可与name组合使用，比较获取到的属性值与havingValue给定的值是否相同，相同才加载配置 boolean matchIfMissing() default false;//缺少该property时是否可以加载。如果为true，没有该property也会正常加载；反之报错 boolean relaxedNames() default true;//是否可以松散匹配，至今不知道怎么使用的 &#125; &#125; 3. 使用方法 通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值。如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效。 4. code12345678910111213@Configuration//在application.properties配置\"mf.assert\"，对应的值为true@ConditionalOnProperty(prefix=\"mf\",name = \"assert\", havingValue = \"true\")public class AssertConfig &#123; @Autowired private HelloServiceProperties helloServiceProperties; @Bean public HelloService helloService()&#123; HelloService helloService = new HelloService(); helloService.setMsg(helloServiceProperties.getMsg()); return helloService; &#125;&#125; 5. 收获springboot注解丰富，我们可以利用好这些注解来实现我们自定义的starter配置，减少硬编码的校验，降低组件间的耦合性!!! 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(\"rawtypes\")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用(配置）；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%nSpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(\"/webjars/**\") .addResourceLocations( \"classpath:/META-INF/resources/webjars/\") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== java/resources都是内路径的根路径（classpath） 12345\"classpath:/META-INF/resources/\", \"classpath:/resources/\",\"classpath:/static/\", \"classpath:/public/\" \"/\"：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc http://localhost:8080/asserts/js/Chart.min.js ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 12#定义自己的静态资源文件夹spring.resources.static-locations=classpath:/hello/,classpath:/atguigu/ 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=\"$&#123;session.user&#125;： &lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*&#123;lastName&#125;\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*&#123;nationality&#125;\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType='FAST')&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=\"~&#123;commons :: main&#125;\"&gt;...&lt;/div&gt; Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path=\"/hello\" view-name=\"success\"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/hello\"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter（@deprecate）类型；不能标注@EnableWebMvc==; 实现接口WebMvcConfigurer为2支持 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = \"spring.messages\")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * \"org.mypackage\"), it will be resolved from the classpath root. */ private String basename = \"messages\"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"asserts/css/bootstrap.min.css\" th:href=\"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"asserts/css/signin.css\" th:href=\"@&#123;/asserts/css/signin.css&#125;\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\"&gt; &lt;img class=\"mb-4\" th:src=\"@&#123;/asserts/img/bootstrap-solid.svg&#125;\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#&#123;login.tip&#125;\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#&#123;login.username&#125;\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.password&#125;\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#&#123;login.password&#125;\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#&#123;login.btn&#125;\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split(\"_\"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style=\"color: red\" th:text=\"$&#123;msg&#125;\" th:if=\"$&#123;not #strings.isEmpty(msg)&#125;\"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(\"loginUser\"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute(\"msg\",\"没有权限请先登陆\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); &#125; &#125;; return adapter; &#125; ==2.0以上版本会拦截静态资源== 12345678//静态文件@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; //静态文件 registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/static/\"); //webjar文件 registry.addResourceHandler(\"/webjars/**\").addResourceLocations(\"/webjars/\");&#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE thymeleaf默认为classpath:/templates/xxx.html 123 // thymeleaf默认就会拼串// classpath:/templates/xxxx.htmlreturn \"emp/list\"; 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=\"~&#123;footer :: copy&#125;\"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class=\"col-md-2 d-none d-md-block bg-light sidebar\" id=\"sidebar\"&gt; &lt;div class=\"sidebar-sticky\"&gt; &lt;ul class=\"nav flex-column\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link active\" th:class=\"$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;\" href=\"#\" th:href=\"@&#123;/main.html&#125;\"&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\"&gt; &lt;path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"&gt;&lt;/path&gt; &lt;polyline points=\"9 22 9 12 15 12 15 22\"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace=\"commons/bar::#sidebar(activeUri='emps')\"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添加&lt;/button&gt;&lt;/form&gt; // redirect: 表示重定向到一个地址 /代表当前项目路径// forward: 表示转发到一个地址 thymeleaf的视图解析器代码 123456789101112131415161718192021222324252627282930313233public class ThymeleafViewResolver extends AbstractCachingViewResolver implements Ordered &#123;@Override protected View createView(final String viewName, final Locale locale) throws Exception &#123; // First possible call to check \"viewNames\": before processing redirects and forwards if (!this.alwaysProcessRedirectAndForward &amp;&amp; !canHandle(viewName, locale)) &#123; vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" cannot be handled by ThymeleafViewResolver. Passing on to the next resolver in the chain.\", viewName); return null; &#125; // Process redirects (HTTP redirects) if (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123; vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" is a redirect, and will not be handled directly by ThymeleafViewResolver.\", viewName); final String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length(), viewName.length()); final RedirectView view = new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible()); return (View) getApplicationContext().getAutowireCapableBeanFactory().initializeBean(view, viewName); &#125; // Process forwards (to JSP resources) if (viewName.startsWith(FORWARD_URL_PREFIX)) &#123; // The \"forward:\" prefix will actually create a Servlet/JSP view, and that's precisely its aim per the Spring // documentation. See http://docs.spring.io/spring-framework/docs/4.2.4.RELEASE/spring-framework-reference/html/mvc.html#mvc-redirecting-forward-prefix vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" is a forward, and will not be handled directly by ThymeleafViewResolver.\", viewName); final String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length(), viewName.length()); return new InternalResourceView(forwardUrl); &#125; // Second possible call to check \"viewNames\": after processing redirects and forwards if (this.alwaysProcessRedirectAndForward &amp;&amp; !canHandle(viewName, locale)) &#123; vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" cannot be handled by ThymeleafViewResolver. Passing on to the next resolver in the chain.\", viewName); return null; &#125; vrlogger.trace(\"[THYMELEAF] View &#123;&#125; will be handled by ThymeleafViewResolver and a \" + \"&#123;&#125; instance will be created for it\", viewName, getViewClass().getSimpleName()); return loadView(viewName, locale); &#125; springboot在WebMvcAutoConfiguration.java中默认配置的格式是 1234/** * Date format to use. For instance, `dd/MM/yyyy`. */private String dateFormat; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action=\"@&#123;/emp&#125;\" method=\"post\"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name=\"_method\";值就是我们指定的请求方式--&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"$&#123;emp!=null&#125;\"/&gt; &lt;input type=\"hidden\" name=\"id\" th:if=\"$&#123;emp!=null&#125;\" th:value=\"$&#123;emp.id&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.email&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;option th:selected=\"$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;\" th:value=\"$&#123;dept.id&#125;\" th:each=\"dept:$&#123;depts&#125;\" th:text=\"$&#123;dept.departmentName&#125;\"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"$&#123;emp!=null&#125;?'修改':'添加'\"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each=\"emp:$&#123;emps&#125;\"&gt; &lt;td th:text=\"$&#123;emp.id&#125;\"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text=\"$&#123;emp.email&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.gender&#125;==0?'女':'男'\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.department.departmentName&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-sm btn-primary\" th:href=\"@&#123;/emp/&#125;+$&#123;emp.id&#125;\"&gt;编辑&lt;/a&gt; &lt;button th:attr=\"del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;\" class=\"btn btn-sm btn-danger deleteBtn\"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(\".deleteBtn\").click(function()&#123; //删除当前员工的 $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(\"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;\")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = \"text/html\")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value(\"$&#123;error.path:/error&#125;\")private String path = \"/error\"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 123456789101112* Default implementation of &#123;@link ErrorAttributes&#125;. Provides the following attributes * when possible: * &lt;ul&gt; * &lt;li&gt;timestamp - The time that the errors were extracted&lt;/li&gt; * &lt;li&gt;status - The status code&lt;/li&gt; * &lt;li&gt;error - The error reason&lt;/li&gt; * &lt;li&gt;exception - The class name of the root exception (if configured)&lt;/li&gt; * &lt;li&gt;message - The exception message&lt;/li&gt; * &lt;li&gt;errors - Any &#123;@link ObjectError&#125;s from a &#123;@link BindingResult&#125; exception * &lt;li&gt;trace - The exception stack trace&lt;/li&gt; * &lt;li&gt;path - The URL path when the exception was raised&lt;/li&gt; * &lt;/ul&gt; ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 1234567891011121314@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; &#125;&#125;//1、浏览器客户端返回的都是json//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 123BasicErrorController中获取状态码的方法protected HttpStatus getStatus(HttpServletRequest request) &#123; Integer statusCode = (Integer) request.getAttribute(\"javax.servlet.error.status_code\"); 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); //转发到/error return \"forward:/error\"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、（html）页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\"company\",\"atguigu\"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 12345678910111213141516171819202122@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125;//2.0以上版本=============== @Bean //一定要将这个定制器加入到容器中public WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; aa()&#123; return new WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableServletWebServerFactory server) &#123; server.setPort(9000); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\"/myServlet\"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 2.0版本 ![](E:\\pictures\\Language\\spring boot\\images\\configurable继承.png) 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；2.0springboot的autoConfigure类： 12345678910111213141516171819202122232425262728293031@Configuration@ConditionalOnWebApplication@EnableConfigurationProperties(ServerProperties.class)public class EmbeddedWebServerFactoryCustomizerAutoConfiguration &#123; /** * Nested configuration if Tomcat is being used. */ @Configuration @ConditionalOnClass(&#123; Tomcat.class, UpgradeProtocol.class &#125;) public static class TomcatWebServerFactoryCustomizerConfiguration &#123; @Bean public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) &#123; return new TomcatWebServerFactoryCustomizer(environment, serverProperties); &#125; &#125; @Configuration@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@ConditionalOnClass(ServletRequest.class)@ConditionalOnWebApplication(type = Type.SERVLET)@EnableConfigurationProperties(ServerProperties.class)@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, ServletWebServerFactoryConfiguration.EmbeddedTomcat.class, ServletWebServerFactoryConfiguration.EmbeddedJetty.class, ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)public class ServletWebServerFactoryAutoConfiguration &#123; EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor WebServerFactoryCustomizerBeanPostProcessor（2.0版本） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器//2.0版本 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof WebServerFactory) &#123; postProcessBeforeInitialization((WebServerFactory) bean); &#125; return bean; &#125; private Collection&lt;WebServerFactoryCustomizer&lt;?&gt;&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;&gt;(getWebServerFactoryCustomizerBeans()); this.customizers.sort(AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers; &#125; 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 123456789101112131415161718192021222324public class SpringApplication &#123;protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; switch (this.webApplicationType) &#123; case SERVLET: contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); &#125; &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( \"Unable create a default ApplicationContext, \" + \"please specify an ApplicationContextClass\", ex); &#125; &#125; return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass); &#125; 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 1private void createWebServer()//2.0版本 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); 1ServletWebServerFactory factory = getWebServerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory(TomcatServletWebServerFactory)创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 1this.webServer = factory.getWebServer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 12345public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123;this.onRefresh(); // 创建servlet容器this.registerListeners();this.finishBeanFactoryInitialization(beanFactory); //创建我们自己定义的bean组件 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer ![](E:\\pictures\\Language\\spring boot\\images\\ServletContainerInitializer目录.png) 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info(\"Root context already created (using as parent).\"); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), \"No SpringApplication sources have been defined. Either override the \" + \"configure method or add an @Configuration annotation\"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 123456789//自己的SpringBootServletInitializer的子类重写了configure方法public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动Servlet容器，再启动SpringBoot应用== 五、Docker详见docker.md 6数据访问(数据库)1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 12345678910spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc url: jdbc:mysql://localhost:3306/yoj?serverTimezone=UTC driver-class-name: com.mysql.jdbc.Driver com.mysql.cj.jdbc.Drive Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； 1//class com.zaxxer.hikari.HikariDataSource 2.0版本默认使用 ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = \"spring.datasource.type\")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； 1DataSourceInitializerInvoker 2.0版本还包括了这个类 ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 12345678910111213141516171819202122schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.31.39:3307/jdbc driver-class-name: com.mysql.cj.jdbc.Driver #DDL schema: - classpath:department.sql #DML data: - classpath:insert-dept.sql #2.0需要开启 initialization-mode: always 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); initParams.put(\"allow\",\"\");//默认就是允许所有访问 initParams.put(\"deny\",\"192.168.15.21\"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; &#125;&#125; 3、整合MyBatis123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;!--2.0注释--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select(\"select * from department where id=#&#123;id&#125;\") public Department getDeptById(Integer id); @Delete(\"delete from department where id=#&#123;id&#125;\") public int deleteDeptById(Integer id);//声明自增主键，这样就能拿到自增的主键值 @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#&#123;departmentName&#125;)\") public int insertDept(Department department); @Update(\"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;\") public int updateDept(Department department);&#125; 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789//使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = \"com.atguigu.springboot.mapper\")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 1234567891011121314//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = \"tbl_user\") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；@JsonIgnoreProperties(&#123;\"handler\",\"hibernateLazyInitializer\"&#125;)//解决json报错public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = \"last_name\",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行run方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 //打印控制台图标 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println(\"ApplicationContextInitializer...initialize...\"+applicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println(\"SpringApplicationRunListener...starting...\"); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get(\"os.name\"); System.out.println(\"SpringApplicationRunListener...environmentPrepared..\"+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println(\"SpringApplicationRunListener...contextPrepared...\"); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println(\"SpringApplicationRunListener...contextLoaded...\"); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println(\"SpringApplicationRunListener...finished...\"); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(\"ApplicationRunner...run....\"); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(\"CommandLineRunner...run...\"+ Arrays.asList(args)); &#125;&#125; 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie //结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = \"atguigu.hello\")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 123456789101112131415161718package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+\"-\" +name + helloProperties.getSuffix(); &#125;&#125; 12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples Springboot 部署jar包(官方推荐)jar包方式启动，也就是使用spring boot内置的tomcat运行。服务器上面只要你配置了jdk1.8及以上，就ok。不需要外置tomcat1.打成jar包 2.将jar包放到任意目录，执行下面的命令 1234567$ nohup java -jar test.jar &gt;temp.txt &amp;nohup java -jar yoj.jar &gt;yoj.txt &amp;ubuntu@VM-0-5-ubuntu:~$ java -Dfile.encoding=utf-8 -jar yoj-0.0.1-SNAPSHOT.jar &gt; yoj.txt &amp;java -Dfile.encoding=utf-8 -jar -Dserver.port=8080 xxx.jar //这种方法会把日志文件输入到你指定的文件中，没有则会自动创建。进程会在后台运行。 nohupnohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 nohup 是 no hang up 的缩写，就是不挂断的意思。 nohup命令： 如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。 在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。 案例\\1. nohup command &gt; myout.file 2&gt;&amp;1 &amp; 在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ； 2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。 \\2. 0 22 * * * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py &gt; /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2&gt;&amp;1 这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中 服务器注意事项1.mysql字符集需要设置为utf-82.spring boot 的control==@RequestMapping字符串必须由“/”开始== 不然本地能访问，但是服务器不能访问 1@RequestMapping(\"/set/&#123;pageNumber&#125;\") return 不能加斜杆 return “problem/set”; spring boot 加密导入jar包123456&lt;!-- https://mvnrepository.com/artifact/com.github.ulisesbocchio/jasypt-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; jasypt.encryptor. password: 加密密码的字符串 123456789jasypt: encryptor: password: lmz#配置数据源spring: datasource: url: jdbc:mysql://localhost:3306/yoj?serverTimezone=UTC username: root password: 123456 编写测试类 12345678910111213141516171819202122232425262728package com.yoj;import org.jasypt.encryption.StringEncryptor;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class EncryptTest &#123; @Autowired StringEncryptor encryptor; @Test public void test()&#123; String userName = encryptor.encrypt(\"root\"); System.out.println(userName); String password = encryptor.encrypt(\"123456\"); System.out.println(password); String originUserName = encryptor.decrypt(\"2IL6K8NI+eUHYpu8AsfB7Q==\"); System.out.println(originUserName); String originPassword = encryptor.decrypt(\"+u6jN11/Ykzl5kHU0rg2Ew==\"); System.out.println(originPassword); &#125;&#125; 将得到的加密串，写到数据库配置 123456789jasypt: encryptor: password: lmz#配置数据源spring: datasource: url: jdbc:mysql://localhost:3306/yoj?serverTimezone=UTC username: ENC(&#123;2IL6K8NI+eUHYpu8AsfB7Q==&#125;) password: NEC(&#123;vojGG7u7QZ3mN1DsX1gA1g==&#125;) 常见问题test测试插入，数据并没有保存到数据库使用junit测试插入，测试显示成功，但是数据并没有保存到数据库。是因为在junit下，插入数据会自动回滚，所以测试显示成功但实际上不能插入。若要插入到数据库，只需在测试方法上添加@Rollback(false)注解即可。 自己使用文件上传、下载官方文档 自己例子：上传图片 Application.java添加@EnableConfigurationProperties(StorageProperties.class) 123456@EnableConfigurationProperties(StorageProperties.class)public class YojApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(YojApplication.class, args); &#125;&#125; 1234567891011121314151617@ConfigurationProperties(\"storage\")public class StorageProperties &#123; /** * Folder location for storing files */ private String location = \"upload-dir\"; public String getLocation() &#123; return location; &#125; public void setLocation(String location) &#123; this.location = location; &#125;&#125; 注：项目名/upload-dir/avatar目录需存在 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@Service@Slf4jpublic class StorageService &#123;// @Value(\"$&#123;spring.servlet.multipart.location&#125;\") private final Path storeRootLocation; @Autowired private UserUtil currentUserUtil; @Autowired public StorageService(StorageProperties properties) &#123; this.storeRootLocation = Paths.get(properties.getLocation()); &#125; /** * @param uploadFile * @return is or not upload successfully */ public boolean storeAvatar(MultipartFile uploadFile, HttpServletRequest req) &#123; // empty file data if (uploadFile == null || uploadFile.isEmpty()) &#123; log.info(\"not have uploadFile data\"); return false; &#125; // 组成新的文件名 String oldName = uploadFile.getOriginalFilename(); //不是图片后缀名 if (!oldName.endsWith(\".jpg\") &amp;&amp; !oldName.endsWith(\".png\") &amp;&amp; !oldName.endsWith(\".gif\")) &#123; log.info(\"not have a image suffix\"); return false; &#125; //related path : static/uploadFile // newFile is composed of saveDirectory + useId.originSuffix String newFileName = currentUserUtil.getUserDetail().getUsername() + oldName.substring(oldName.lastIndexOf(\".\"), oldName.length()); Path storePath = Paths.get(storeRootLocation.normalize().toAbsolutePath().toString(), \"avatar\", newFileName); try (InputStream inputStream = uploadFile.getInputStream()) &#123; Files.copy(inputStream, storePath, StandardCopyOption.REPLACE_EXISTING); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // judge is or not a image file File savedImage = new File(storePath.toString()); if (!isImage(savedImage)) &#123; log.info(\"is not a image file\"); savedImage.delete(); return false; &#125; return true; &#125; /** * 通过读取文件并获取其width及height的方式，来判断判断当前文件是否图片，这是一种非常简单的方式。 * 这种方式较安全！ * * @param imageFile * @return */ public static boolean isImage(File imageFile) &#123; if (!imageFile.exists()) &#123; return false; &#125; Image img = null; try &#123; img = ImageIO.read(imageFile); if (img == null || img.getWidth(null) &lt;= 0 || img.getHeight(null) &lt;= 0) &#123; return false; &#125; return true; &#125; catch (Exception e) &#123; return false; &#125; finally &#123; img = null; &#125; &#125;&#125; 123456789101112131415#文件传输配置spring.servlet.multipart.enabled=truespring.servlet.multipart.file-size-threshold=0#表示上传文件的临时保存位置，要保证其路径存在。可以省略配置#spring.servlet.multipart.location=D:\\\\OJspring.servlet.multipart.max-file-size=1MBspring.servlet.multipart.max-request-size=10MBspring.servlet.multipart.resolve-lazily=false#代码解释：#第l 行表示是否开启文件上传支持，默认为true。#第2 行表示文件写入磁盘的闽值，默认为0 。#第4 行表示上传的羊个文件的最大大小，默认为11\\侣。#第5 行表示多文件上传时文件的总大小，默认为10孔侣。#第6 行表示文件是否延迟解析，默认为false 。 通过url访问项目外的其他目录下的图片1.首先在application.properties文件中增加配置： 123456#资源绝对路径为file: D://Codes/Java/yoj/upload-dir，图片存放的真实路径#意思是springboot开放此资源路径供外部读取spring.resources.static-locations=file:D://Codes/Java/yoj/upload-dir#资源映射路径为/image/**，使用url访问的请求路径spring.mvc.static-path-pattern=/image/** vue 1&lt;img class=&quot;user-img ml-auto&quot; :src=&quot;appApi+&apos;/image/avatar/1.jpg&apos;&quot;/&gt; 2.如果项目使用了权限认证，则需要将/image/** 添加在免认证的配置中，才能直接访问。 如此便可以访问图片了：https://localhost:8050/image/avatar/1.jpg","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"springBoot","slug":"springBoot","permalink":"https://codeofli.github.io/tags/springBoot/"}]},{"title":"pythonMongoDb","slug":"python/PythonMongoDb","date":"2019-11-14T14:19:09.000Z","updated":"2021-10-23T02:19:04.267Z","comments":true,"path":"2019/11/python/PythonMongoDb/","link":"","permalink":"https://codeofli.github.io/2019/11/python/PythonMongoDb/","excerpt":"[TOC]python操作mongodb菜鸟教程官方中文文档连接mongodb12345678#!/usr/bin/env python# -*- coding:utf-8 -*-from pymongo import MongoClientconn = MongoClient('192.168.0.113', 27017)db = conn.mydb #连接mydb数据库，没有则自动创建my_set = db.test_set #使用test_set集合，没有则自动创建","text":"[TOC]python操作mongodb菜鸟教程官方中文文档连接mongodb12345678#!/usr/bin/env python# -*- coding:utf-8 -*-from pymongo import MongoClientconn = MongoClient('192.168.0.113', 27017)db = conn.mydb #连接mydb数据库，没有则自动创建my_set = db.test_set #使用test_set集合，没有则自动创建 插入数据查询数据https://www.runoob.com/python3/python-mongodb-query-document.html 查询一条数据我们可以使用 find_one() 方法来查询集合中的一条数据。 1234567891011#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] x = mycol.find_one() print(x) 查询集合中所有数据find() 方法可以查询集合中的所有数据，类似 SQL 中的 SELECT * 操作。 以下实例查找 sites 集合中的所有数据： 12345678910#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] for x in mycol.find(): print(x) $exists查找字段是否存在判断字段是否存在 1db.users.find(&#123;age: &#123;\"$exists\": True&#125;&#125;); $or1&#123; $or: [ &#123; &lt;expression1&gt; &#125;, &#123; &lt;expression2&gt; &#125;, ... , &#123; &lt;expressionN&gt; &#125; ] &#125; 1db.inventory.find( &#123; $or: [ &#123; quantity: &#123; $lt: 20 &#125; &#125;, &#123; price: 10 &#125; ] &#125; ) $ne不等于查询x 的值不等于3 的数据 12query = &#123;Problem.DATA_STATUS: &#123;\"$ne\": StateValue.FILE_SUCCESS&#125;&#125;mongo_util.problem_collection.find(query) 举例如下: C1 表的数据如下: 1234&gt; db.c1.find()&#123; \"_id\" : ObjectId(\"4fb4af85afa87dc1bed94330\"), \"age\" : 7, \"length_1\" : 30 &#125;&#123; \"_id\" : ObjectId(\"4fb4af89afa87dc1bed94331\"), \"age\" : 8, \"length_1\" : 30 &#125;&#123; \"_id\" : ObjectId(\"4fb4af8cafa87dc1bed94332\"), \"age\" : 6, \"length_1\" : 30 &#125; 查询age 的值不等于7 的数据 123&gt; db.c1.find( &#123; age : &#123; $ne : 7 &#125; &#125; );&#123; \"_id\" : ObjectId(\"4fb4af89afa87dc1bed94331\"), \"age\" : 8, \"length_1\" : 30 &#125;&#123; \"_id\" : ObjectId(\"4fb4af8cafa87dc1bed94332\"), \"age\" : 6, \"length_1\" : 30 &#125; 可以看出只显示出了age 不等于7 的数据，其它不符合规则的数据并没有显示出来 在users文档中查询”age”不等于20的记录： 1db.users.find(&#123;age:&#123;$ne:20&#125;&#125;); 高级查询查询的条件语句中，我们还可以使用修饰符。 以下实例用于读取 name 字段中第一个字母 ASCII 值大于 “H” 的数据，大于的修饰符条件为 {“$gt”: “H”} : 1234567891011121314#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] myquery = &#123; \"name\": \"RUNOOB\" &#125; mydoc = mycol.find(myquery) for x in mydoc: print(x) 使用正则表达式查询我们还可以使用正则表达式作为修饰符。 正则表达式修饰符只用于搜索字符串的字段。 以下实例用于读取 name 字段中第一个字母为 “R” 的数据，正则表达式修饰符条件为 {“$regex”: “^R”} : 1234567891011121314#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] myquery = &#123; \"name\": &#123; \"$regex\": \"^R\" &#125; &#125; mydoc = mycol.find(myquery) for x in mydoc: print(x) 返回指定条数记录如果我们要对查询结果设置指定条数的记录可以使用 limit() 方法，该方法只接受一个数字参数。 计数count1problem_table.count_documents(query) 123query = &#123;\"id\": &#123;\"$regex\": \"^\" + tag_dict[name]&#125;&#125;print(query)query_cnt = problem_table.count_documents(query) 查询值为Null或不存在的字段The { name : null } query matches documents that either contain the name field whose value is null or that do not contain the name field. 给出如下查询: 1db.users.find( &#123; name: null &#125; ) 更新数据https://www.runoob.com/python3/python-mongodb-update-document.html 1234567891011121314import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] myquery = &#123; \"alexa\": \"10000\" &#125;newvalues = &#123; \"$set\": &#123; \"alexa\": \"12345\" &#125; &#125; mycol.find_one_update(myquery, newvalues) # 输出修改后的 \"sites\" 集合for x in mycol.find(): print(x) 删除字段1db.yourcollection.update_one(&#123;&#125;, &#123;\"$unset\": &#123;\"name\": \"\"&#125;&#125;) 1db.yourcollection.update_many(&#123;&#125;, &#123;\"$unset\": &#123;\"name\": \"\"&#125;&#125;) 添加字段直接使用update即可 1test_collection.update_one(&#123;\"id\":\"test1\"&#125;, &#123;\"$set\": &#123;\"new_field\": \"xxx\"&#125;&#125;) 删除数据排序sort() 方法可以指定升序或降序排序。 sort() 方法第一个参数为要排序的字段，第二个字段指定排序规则，1 为升序，-1 为降序，默认为升序。 对字段 alexa 按升序排序： 1234567891011#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] mydoc = mycol.find().sort(\"alexa\")for x in mydoc: print(x)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/tags/python/"}]},{"title":"docker","slug":"docker/docker","date":"2019-11-12T07:39:56.000Z","updated":"2022-03-02T01:21:40.164Z","comments":true,"path":"2019/11/docker/docker/","link":"","permalink":"https://codeofli.github.io/2019/11/docker/docker/","excerpt":"[TOC]1.简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术；Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；运行中的这个镜像称为容器，容器启动是非常快速的。2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；","text":"[TOC]1.简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术；Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；运行中的这个镜像称为容器，容器启动是非常快速的。2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(docker)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤：(安装不成功可以到菜鸟教程安装) 1、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker 1sudo apt install docker.io 3、输入y确认安装4、启动docker 123[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.6 5、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 操作 命令 说明 运行 docker run –name container-name -d image-nameeg:docker run –name myredis –d redis– –name：自定义容器名-d：后台运行image-name:指定镜像模板 列表 docker ps（查看运行中的容器）； 加上-a；可以查看所有容器 启动 docker start container-name/container-id 启动容器 停止 docker stop container-name/container-id 停止当前你运行的容器 删除 docker rm container-id 删除指定容器 端口映射 -p 6379:6379eg:docker run -d -p 6379:6379 –name myredisdocker.io/redis -p:主机端口(映射到)容器内部的端口 容器日志 docker logs container-name/container-id 更多命令 https://docs.docker.com/engine/reference/commandline/docker/ 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 使用进入容器Bash1docker exec -it containerID bash 将本地sql文件导入容器1sudo docker cp /home/ubuntu/yoj.sql(文件路径) mysql(容器名):/home/tmp/yoj.txt(容器文件保存路径+文件名) docker cp 第一个参数指定本地文件或者文件夹，第二个参数指定容器及容器内的目标文件夹 1sudo docker cp /home/ubuntu/yoj.sql mysql:/home Docker-Mysql安装MySQL示例123docker pull mysql#mysql 版本最好在5.7左右，不然navicat连不上[root@MiWiFi-R3A-srv ~]# docker pull mysql:5.7.27 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql \"docker-entrypoint.sh\" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 123456[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlnicolas@iZuf6i77uwsb2oiszspgvkZ:/home/admin$ sudo docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.27b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 1234567[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlnicolas@iZuf6i77uwsb2oiszspgvkZ:/home/admin$ sudo docker run -p 3306:3306 --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.27ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 1234567891011docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数#创建mysql容器+character-setdocker run -p 3306:3306 --name mysql03 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.27 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_cidocker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=db123456 --name mysql -e TZ=Asia/Shanghai mysql:5.7 1234567891011-e TZ=Asia/Shanghai 时区修改为中国时区-p 3306：3306：将容器的3306端口映射到主机的3306端口-v $ PWD / conf / my.cnf：/etc/mysql/my.cnf：将主机当前目录下的conf / my.cnf挂载到容器的/etc/mysql/my.cnf-v $ PWD / logs：/ logs：将主机当前目录下的日志目录挂载到容器的/ logs-v $ PWD / data：/ mysql_data：将主机当前目录下的数据目录挂载到容器的/ mysql_data-e MYSQL_ROOT_PASSWORD = 123456：初始化 root用户的密码 修改时区和字符集 1docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -e TZ=Asia/Shanghai -d mysql:5.7.27 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 安装mysql之后进行操作3.进入容器bash并进入mysql命令行： 1ubuntu@VM-0-5-ubuntu:/etc/apt$ sudo docker exec -it mysql02 bash Docker容器启动的时候，如果要挂载宿主机的一个目录，可以用-v参数指定。 譬如我要启动一个centos容器，宿主机的/test目录挂载到容器的/soft目录，可通过以下方式指定： 12docker run -it -v /test:/soft centos /bin/bashdocker run -it -v /hmoe/ubuntu:/tmp mysql02 /bin/bash mysql使用12sudo docker run -p 3306:3306 --name mysql8 -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0.23 --character-set-server=utf8 --collation-server=utf8_unicode_ci –name: 容器名 MySql 导入 *.sql文件1.将本地sql文件导入容器1sudo docker cp /home/ubuntu/yoj.sql(文件路径) mysql(容器名):/home/tmp/yoj.txt(容器文件保存路径+文件名) docker cp 第一个参数指定本地文件或者文件夹，第二个参数指定容器及容器内的目标文件夹 1sudo docker cp /home/ubuntu/yoj.sql mysql8:/home 登入容器内MYSQL执行sqlcommand format 1docker exec -it (mysql-container-name)[xxx] (in mysql command)[mysql -uroot -p123456] 12docker exec -it bteye-mysql mysql -uroot -p123456docker exec -it mysql8 mysql -uroot -p 执行sql文件 1source /home/yoj.sql 2.进入数据库容器1docker exec -it containerID bash 数据库导入 12345678910mysql -h localhost -u root -p（进入mysql下面）create database abc;(创建数据库)show databases;(就可看到所有已经存在的数据库，以及刚刚创建的数据库abc)use abc;(进入abc数据库下面)show tables;(产看abc数据库下面的所有表,空的)source /var/test.sql（导入数据库表）show tables;(查看abc数据库下面的所有表,就可以看到表了)desc pollution;(查看表结构设计)select * from pollution;exit(或者ctrl + c)退出mysql 修改 Docker 中 MySQL 容器的编码https://blog.csdn.net/m0_37639542/article/details/72852875 1.查看字符集 1SHOW VARIABLES LIKE &apos;character_set_%&apos;;//查看数据库字符集 更新之后记得重启mysql服务 1service mysql restart 1. 进入MySQL容器1docker exec -it my-space-mysql /bin/bash 2. 备份当前 my.cnf 文件1mv /etc/mysql/my.cnf /etc/mysql/my.cnf.bak 3. 退出容器1exit 4. 在服务器创建配置文件(my.cnf)12345[client]default-character-set=utf8[mysqld]character-set-server=utf8collation-server=utf8_general_ci 5. 查看容器长ID1docker inspect -f '&#123;&#123;.ID&#125;&#125;' my-space-mysql my-space-mysql是容器的名称 6. 上传文件到容器1docker cp my.cnf &lt;容器长ID&gt;:/etc/mysql 7. 自行登录容器查看并提出容器8. 重启docker12docker stop my-space-mysqldocker start my-space-mysql 9. 查看数据库编码 进入数据库执行 1status 备份数据库1sudo docker exec -it mysql mysqldump -uroot -p123456 yoj &gt; /home/ubuntu/sql_bak/yoj_db.sql mysql使用mysqldump定时备份数据库https://www.jianshu.com/p/be1e581acb8e 3、数据库备份脚本功能：mysql 每天定时备份， 并删除7天以前的备份mysql_dumps.sh： 12345678910#!/bin/bashdocker_name = mysql57data_dir=\"/path/to/save/data/\"sudo docker exec -it $&#123;docker_name&#125; mysqldump -uroot -ppasswd --all-databases &gt; \"$data_dir/data_`date +%Y%m%d`.sql\"#if [ $? -ne 0 ];then # 任务失败，发送邮件# echo -e \"邮件正文\" | mail -s '标题' 123456@gmail.com# exit -1#fifind $data_dir -mtime +7 -name 'data_[1-9].sql' -exec rm -rf &#123;&#125; \\; my_version 1234#!/bin/bashdata_dir=\"/path/to/save/data/\"sudo docker exec mysql mysqldump -uroot -ppasswd --all-databases &gt; \"$data_dir/data_`date +%Y%m%d`.sql\"find $data_dir -mtime +7 -name 'data_[1-9].sql' -exec rm -rf &#123;&#125; \\; 4、通过linux cron设置定时任务crontab -e： 10 2 * * * sh /home/ubuntu/sql_bak/mysql_dumps.sh &gt; /home/ubuntu/sql_bak/mysql_dumps.log 2&gt;&amp;1 设置每分钟测试 1* * * * * sh /home/ubuntu/sql_bak/mysql_dumps.sh &gt; /home/ubuntu/sql_bak/mysql_dumps.log 2&gt;&amp;1 安装redis1runoob@runoob:~$ mkdir -p ~/redis ~/redis/data 1sudo docker run -p 6379:6379 -v $PWD/data:/data -d redis redis-server --appendonly yes 命令说明： -p 6379:6379 : 将容器的6379端口映射到主机的6379端口 -v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data redis-server –appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 连接、查看容器使用redis镜像执行redis-cli命令连接到刚启动的容器,主机IP为172.17.0.1 123456789101112runoob@runoob:~/redis$ docker exec -it 43f7a65ec7f8 redis-cli172.17.0.1:6379&gt; info# Serverredis_version:3.2.0redis_git_sha1:00000000redis_git_dirty:0redis_build_id:f449541256e7d446redis_mode:standaloneos:Linux 4.2.0-16-generic x86_64arch_bits:64multiplexing_api:epoll... 1docker exec -it 239fadb88042 redis-cli 官方文档配置文件映射Alternatively, you can specify something along the same lines with docker run options. 1$ docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name myredis redis redis-server /usr/local/etc/redis/redis.conf Where /myredis/conf/ is a local directory containing your redis.conffile. Using this method means that there is no need for you to have a Dockerfile for your redis container. 其他1docker run -d --privileged=true -p 6379:6379 --restart always -v /root/docker/redis/conf/redis.conf:/etc/redis/redis.conf -v /root/docker/redis/data:/data --name myredis redis redis-server /etc/redis/redis.conf --appendonly yes 12345678-d -&gt; 以守护进程的方式启动容器-p 6379:6379 -&gt; 绑定宿主机端口--name myredis -&gt; 指定容器名称--restart always -&gt; 开机启动--privileged=true -&gt; 提升容器内权限-v /root/docker/redis/conf:/etc/redis/redis.conf -&gt; 映射配置文件-v /root/docker/redis/data:/data -&gt; 映射数据目录--appendonly yes -&gt; 开启数据持久化","categories":[{"name":"note","slug":"note","permalink":"https://codeofli.github.io/categories/note/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://codeofli.github.io/tags/docker/"}]},{"title":"linux","slug":"linux/linux","date":"2019-11-12T06:20:26.000Z","updated":"2022-03-02T01:21:41.305Z","comments":true,"path":"2019/11/linux/linux/","link":"","permalink":"https://codeofli.github.io/2019/11/linux/linux/","excerpt":"[TOC]linux入门VM和Linux系统(CentOS)安装3.1安装vm和Centos学习Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习。1)先安装virtualmachine,vm122)再安装Linux(CentOS6.8)3)原理示意图，这里我们画图说明一下VM和CentOS的关系。","text":"[TOC]linux入门VM和Linux系统(CentOS)安装3.1安装vm和Centos学习Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习。1)先安装virtualmachine,vm122)再安装Linux(CentOS6.8)3)原理示意图，这里我们画图说明一下VM和CentOS的关系。 3.3VM安装的步骤 1)去BIOS里修改设置开启虚拟化设备支持（f2,f10） 2)安装虚拟机软件（vm12）看老师的具体演示：因为老师的电脑上已经安装了VM12，因此我先卸载然后再安装。 3.4CentOS安装的步骤 1)创建虚拟机(空间)这里在配置网络连接时，有三种形式，需要大家伙注意： CentOS的终端使用和联网1)终端的使用，点击鼠标右键，即可选择打开终端 2)配置网络，可以上网。点击上面右侧的；两个计算机图片，选择启用eth0,即可成功连接到网络，就可以上网。 vmtools的安装和使用3.7.1安装vmtools的步骤说明 1.进入centos 2.点击vm菜单的-&gt;installvmwaretools 3.centos会出现一个vm的安装包 4.点击右键解压,得到一个安装文件 5.进入该vm解压的目录，该文件在/root/桌面/vmware-tools-distrib/下 6.安装./vmware-install.pl 7.全部使用默认设置即可8.需要reboot重新启动即可生效 3.7.2使用vmtools来设置windows和linux的共享文件夹 1)菜单-&gt;vm-&gt;setting,如图设置即可注意:设置选项为alwaysenable,这样可以读写了 2)windows和centos可共享d:/share目录可以读写文件了 3)在centos的/mnt/hgfs/下 Linux的目录结构4.1基本介绍 linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。深刻理解linux树状文件目录是非常重要的，这里我给大家说明一下。 记住一句经典的话：==在Linux世界里，一切皆文件。== 具体的目录结构: /bin [重点] (/usr/bin、/usr/local/bin) •是Binary的缩写, 这个目录存放着最经常使用的命令 /home [重点] •存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /root [重点] •该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin(/usr/sbin、/usr/local/sbin) •s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /lib •系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found •这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /etc [重点](etcetera,等等) •所有的系统管理所需要的配置文件和子目录my.conf /usr [重点] •这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。 /boot [重点] •存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 /srv •service缩写，该目录存放一些服务启动之后需要提取的数据。 /sys •这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs /tmp •这个目录是用来存放一些临时文件的。 /dev •类似于windows的设备管理器，把所有的硬件用文件的形式存储。 /media [重点] •linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt [重点] •系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。d:/myshare /var [重点] •这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。 /opt •这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。 /usr/local [重点] •这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序 /selinux [security-enhanced linux] 360 •SELinux是一种安全子系统,它能控制程序只能访问特定文件。 Linux目录总结1)linux的目录中有且只要一个根目录/2)linux的各个目录存放的内容是规划好，不用乱放文件。3)linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。 4)linux的各个文件目录下存放什么内容，大家必须有一个认识。5)学习后，你脑海中应该有一颗linux目录树 远程登录Linux系统5.1为什么需要远程登录Linux 5.1.1示意图 为什么需要远程登录Linux说明: 公司开发时候，具体的情况是这样的 1) linux服务器是开发小组共享的.2) 正式上线的项目是运行在公网的.3) 因此程序员需要远程登录到centos进行项目管理或者开发.4) 画出简单的网络拓扑示意图(帮助理解)5) 远程登录客户端有Xshell5，Xftp5 , 我们学习使用Xshell5 和Xftp , 其它的远程工具大同小异. 远程登录Linux-Xshell5介绍: 说明:Xshell 是目前最好的远程登录到Linux操作的软件，流畅的速度并且完美解决了中文乱码的问题，是目前程序员首选的软件。Xshell[1]是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。 特别说明：如果希望安装好XShell5就可以远程访问Linux系统的话，需要有一个前提，就是Linux启用了SSHD服务，该服务会监听22号端口。 ==终端setup指令查看系统服务中ssh是否开启== 如果都有，还是不行，就重新建立连接 5.3安装XShell5并使用5.3.2XShell5的关键配置 5.3.3XShel5远程登录到Linux后，就可以使用指令来操作Linux系统 5.4远程上传下载文件Xftp55.4.1XFtp5软件介绍 是一个基于windows平台的功能强大的SFTP、FTP文件传输软件。使用了Xftp以后，windows用户能安全地在UNIX/Linux和WindowsPC之间传输文件。 5.4.2XFtp5软件的安装这个看老师的演示即可.5.4.3Xftp5的配置和使用 linux基本vi和vim编辑器6.1vi和vim的基本介绍所有的Linux系统都会内建vi文本编辑器。Vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 vi和vim的三种常见模式正常模式 在正常模式下，我们可以使用快捷键。以vim打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、贴上』来处理你的文件数据。 6.2.2插入模式/编辑模式 在模式下，程序员可以输入内容。按下i,I,o,O,a,A,r,R等任何一个字母之后才会进入编辑模式,一般来说按i即可 命令行模式 在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等的动作则是在此模式中达成的！ 命令行模式下，有:符号使用相关快捷键，如退出命令： 1:q vi和vim三种模式的相互转化图 *快捷键使用练习:1) 拷贝当前行yy , 拷贝当前行向下的5行5yy，并粘贴。 2) 删除当前行dd , 删除当前行向下的5行 5+dd 3) 在文件中查找某个单词[命令行下/关键字，回车查找, 输入n 就是查找下一个] 如查找bind 1/bind 4) 设置文件的行号，取消文件的行号. [命令行下: set nu 和:set nonu] 5) 编辑/etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg] 6) 在一个文件中输入”hello” ,然后又撤销这个动作u7) 编辑/etc/profile 文件，并将光标移动到20行shift+g8) 更多的看整理的文档 7)编辑/etc/profile文件，并将光标移动到第20行shift+g 第一步：显示行号:setnu 第二步：输入20这个数 第三步:输入（G）shift+g， ：20在按gg vim 到文件开头 结尾gg:命令将光标移动到文档开头 G:命令将光标移动到文档末尾 uu回退 vim和vi的快捷键键盘一览图 开机、重启和用户登录注销7.1关机&amp;重启命令 7.1.1基本介绍 shutdown shutdown-hnow:表示立即关机 shutdown-h1:表示1分钟后关机 shutdown-rnow:立即重启 halt 就是直接使用，效果等价于关机 reboot就是重启系统。 sync：把内存的数据同步到磁盘 7.1.2注意细节 当我们关机或者重启时，都应该先执行以下sync指令，把内存的数据写入磁盘，防止数据丢失。 7.2用户登录和注销 7.2.1基本介绍 1)登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用”su-用户名’命令来切换成系统管理员身份. 2)在提示符下输入logout即可注销用户 7.2.2使用细节 1)logout注销指令在图形运行级别无效，在运行级别3下有效. 2)运行级别这个概念，后面给大家介绍 用户管理8.1基本介绍 给大家画一个示意图，帮助大家理解用户管理的规则。 说明 1)Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 2)Linux的用户需要至少要属于一个组。 查看所有用户名1234567891011121314151617181920212223242526272829303132333435[root@hapdoop1 ~]## more /etc/passwd[root@hapdoop1 ~]## more /etc/passwd | cut -f 1 -d :rootbindaemonadmlpsyncshutdownhaltmailuucpoperatorgamesgopherftpnobodydbususbmuxdrtkitavahi-autoipdvcsaabrthaldaemonntpapachesaslauthpostfixgdmpulsesshdtcpdumpxmfoxtom 8.2添加用户 8.2.1基本语法 useradd [选项] 用户名 8.2.2实际案例 特别说明：==cd表示changedirectory==,切换目录. 8.2.3细节说明 1)当创建用户成功后，(加上-m参数)会自动的创建和用户同名的家目录 ==没有-m参数不会有缺省目录== 1root@iZuf6i77uwsb2oiszspgvkZ:~## useradd -m nicolas 2)也可以通过useradd-d指定目录新的用户名，给新创建的用户指定家目录 1[root@hapdoop1 home]## useradd -d /home/dog xh 指定/修改密码基本语法 passwd 用户名 删除用户基本语法userdel 用户名 应用案例1)删除用户xiaoming，但是要保留家目录 1[root@hapdoop1 ~]## userdel xm 2)删除用户以及用户主目录 1[root@hapdoop1 home]## userdel -r xh 8.4.3思考题在删除用户时，我们一般不会将家目录删除。 8.5查询用户信息 8.5.1基本语法 id 用户名 应用实例案例1：请查询root信息8.5.3 ![1565783310913](Linux/id username.png) 细节说明 1)当用户不存在时，返回”无此用户” 8.6切换用户8.6.1介绍(substitute user) 在操作Linux中，如果当前用户的权限不够，可以通过su-指令，切换到高权限用户，比如root 8.6.2基本语法(run a shell with substitute user and group IDs) su– 切换用户名 8.6.3应用实例 1)创建一个用户zf,，指定密码，然后切换到zf. 细节说明 1)从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。 2)当需要返回到原来用户时，使用exit指令 12[root@hapdoop1 ~]## whoamiroot 8.7用户组 8.7.1介绍类似于角色，系统可以对有共性的多个用户进行统一的管理。 8.7.2增加组 groupadd 组名 案例演示 1[root@hapdoop1 ~]## groupadd wudang 8.7.4删除组指令 (基本语法)groupdel 组名 8.7.5案例演示 1[root@hapdoop1 ~]## groupdel wudang 8.8增加用户时直接加上组8.8.1指令(基本语法) useradd -g 用户组 用户名 8.8.2案例演示 增加一个用户zwj,直接将他指定到wudang步骤看演示： ![1565786129905](Linux/useradd -g) 8.9修改用户的组 8.9.1指令(基本语法) usermod -g 用户组 用户名 8.9.2案例演示创建一个shaolin组，让将zwj用户修改到shaolin ![1565786180228](Linux/usermod -g.png) 8.10/etc/passwd文件 用户（user）的配置文件，记录用户的各种信息 每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 8.11/etc/shadow文件 口令的配置文件 每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 8.12/etc/group文件 组(group)的配置文件，记录Linux包含的组的信息 每行含义：组名:口令:组标识号:组内用户列表 9实用指令9.1指定运行级别运行级别说明： 0：关机 1：单用户【找回丢失密码】 2：多用户状态没有网络服务 3：多用户状态有网络服务4：系统未使用保留给用户 5：图形界面 6：系统重启 常用运行级别是3和5，要修改默认的运行级别可改文件/etc/inittab的id:5:initdefault:这一行中的数字运行级别的示意图： 9.2切换到指定运行级别的指令 9.2.1基本语法 init[012356] 9.2.2应用实例案例 1：通过init来切换不同的运行级别，比如动5-&gt;3，然后关机 12345init3init5init0 9.2.3面试题 如何找回root密码，如果我们不小心，忘记root密码，怎么找回。 思路：进入到单用户模式，然后修改root密码。 因为进入单用户模式，root不需要密码就可以登录。演示一把（注意观察）： 总结:开机-&gt;在引导时输入回车键-&gt;看到一个界面输入e-&gt;看到一个新的界面，选中第二行（编辑内核）在输入e-&gt;在这行最后输入1,再输入回车键-&gt;再次输入b,这时就会进入到单用户模式。这时，我们就进入到单用户模式，使用passwd指令来修改root密码。 2)请设置我们的运行级别，linux运行后，直接进入到命令行界面，即进入到3 运行级别vim/etc/inittab将id:5:initdefault:这一行中的数字,5这个数字改成对应的运行级别即可。 9.3帮助指令9.3.1介绍 当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。 9.3.2man(manual) 获得帮助信息 基本语法 man [命令或配置文件]（功能描述：获得帮助信息） 应用实例案例：查看ls命令的帮助信息 1[root@hapdoop1 ~]## man ls 9.3.3help指令 基本语法 help命令（功能描述：获得shell内置命令的帮助信息） 应用实例案例：查看cd命令的帮助信息 1[root@hapdoop1 ~]## help cd 4文件目录类9.4.1pwd 指令(print name of current/working directory) •基本语法 pwd (功能描述：显示当前工作目录的绝对路径) •应用实例案例：显示当前工作目录的绝对路径 12[root@hapdoop1 ~]## pwd/root 9.4.2ls指令 (list directory contents) •基本语法 ls [选项] [目录或是文件] •常用选项 -a：显示当前目录所有的文件和目录，包括隐藏的。 -l：以列表的方式显示信息 •应用实例案例:查看当前目录的所有内容信息 9.4.3cd指令•基本语法 cd [参数] (功能描述：切换到指定目录) •常用参数 绝对路径和相对路径 如何理解绝对路径和相对路径： cd~ 或者 cd：回到自己的家目录 cd.. : 回到当前目录的上一级目录 •应用实例 案例1：使用绝对路径切换到root目录 cd/root 案例2: 使用相对路径到/root目录 这里我们需要知道该用户目录在哪个目录下，才能写出这个指令，假设在/usr/lib 1cd../../root 案例3：表示回到当前目录的上一级目录cd..案例4：回到家目录 cd cd~ 9.4.4 mkdir指令mkdir指令用于创建目录(makedirectory) 基本语法 mkdir [选项] 要创建的目录 •常用选项 -p(–parents)：创建多级目录 •应用实例案例1:创建一个目录/home/dog 案例2:创建多级目录/home/animal/tiger 9.4.5rmdir指令介绍 rmdir指令删除空目录 基本语法 rmdir [选项] 要删除的空目录 应用实例案例1:删除一个目录/home/dog 使用细节 rmdir删除的是空目录，如果目录下有内容时无法删除的。 提示：如果需要删除非空目录，需要使用rm-rf要删除的目录 9.4.6touch指令touch指令 创建空文件 •基本语法 touch 文件名称 •应用实例案例 1:创建一个空文件hello.txt 123[root@hapdoop1 home]## touch ok1.txt ok2.txt[root@hapdoop1 home]## lsok1.txt ok2.txt xm 9.4.7cp指令[重要]cp指令 拷贝文件到指定目录 •基本语法 1cp [选项] source dest •常用选项-r：递归复制整个文件夹 •应用实例案例 1:将/home/aaa.txt拷贝到/home/bbb目录下[拷贝单个文件 案例2:递归复制整个文件夹，举例将/home/test整个目录拷贝到/home/zwj目录 •使用细节 强制覆盖不提示的方法：\\cp 9.4.8rm指令 rm 指令移除 【删除】文件或目录 •基本语法rm[选项]要删除的文件或目录 •常用选项 -r：递归删除整个文件夹 -f：强制删除不提示 •应用实例案例1:将/home/aaa.txt删除 案例2:递归删除整个文件夹/bb 12[root@hapdoop1 /]## rm -r bb/rm：是否删除目录 \"bb\"？y 使用细节 强制删除不提示的方法：带上-f参数即可 mv指令mv 移动文件与目录或重命名 •基本语法 1mv oldNameFile newNameFile (功能描述：重命名) 1mv /temp/movefile /targetFolder (功能描述：移动文件) •应用实例 案例1:将/home/aaa.txt文件重新命名为pig.txt 123[root@hapdoop1 home]## mv aaa.txt pig.txt[root@hapdoop1 home]## lsok1.txt ok2.txt pig.txt xm 案例2:将/home/pig.txt文件移动到/root目录下 123456[root@hapdoop1 home]## mv pig.txt /root[root@hapdoop1 home]## cd ~[root@hapdoop1 ~]## lsanaconda-ks.cfg install.log.syslog 公共的 视频 下载hello.java ok.txt 红1.jpg 图片 音乐install.log pig.txt 模板 文档 桌面 查看文件1.tail用于查看文件末尾内容-f 每当有新的内容 实时展示出来。 答： tail -n 10 文件名 : n=行数 10=查看多少行 tail -n 10 -f 文件名 : 用tail -f指令查看日志 10cat指令(concatenate)cat查看文件内容，是以只读的方式打开。 •基本语法 cat [选项] 要查看的文件 •常用选项-n：显示行号 •应用实例 案例1:/etc/profile文件内容，并显示行号 1[root@hapdoop1 ~]## cat -n /etc/profile | more •使用细节 cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令|more cat文件名|more[分页浏览] 11more指令more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。 more指令中内置了若干快捷键，详见操作说明 •基本语法 more 要查看的文件 •操作说明 •应用实例案例: 采用more查看文件/etc/profile 1[root@hapdoop1 ~]## more /etc/profile 12less指令 less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。 •基本语法 less 要查看的文件 •操作说明 •应用实例 案例:采用less查看一个大文件文件/opt/金庸-射雕英雄传txt精校版.txt 1[root@hapdoop1 opt]## less 金庸-射雕英雄传txt精校版.txt 9.4.13&gt;指令和&gt;&gt;指令介绍 指令和&gt;&gt;指令 &gt; 输出重定向:会将原来的文件的内容覆盖 &gt;&gt;追加：不会覆盖原来文件的内容，而是追加到文件的尾部。• 基本语法 1)ls-l&gt;文件（功能描述：列表的内容写入文件a.txt中（覆盖写）） 1[root@hapdoop1 home]## ls -l &gt; a.txt 说明：ls-l&gt;a.txt,将ls-l的显示的内容覆盖写入到a.txt文件，如果该文件不存在，就创建该文件。 2)ls-al&gt;&gt;文件（功能描述：列表的内容追加到文件aa.txt的末尾） 1[root@hapdoop1 home]## ls -al &gt;&gt; a.txt 3)cat文件1&gt;文件2（功能描述：将文件1的内容覆盖到文件2）相当于复制文件 1[root@hapdoop1 home]## cat /etc/profile &gt; c.txt 9.4.14echo指令 echo输出内容到控制台。 •基本语法echo[选项] [输出内容] •应用实例 案例:使用echo指令输出环境变量,输出当前的环境路径。 123[root@hapdoop1 ~]## echo $PATH[root@hapdoop1 ~]## echo \"hello\" 9.4.15head指令 head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容 •基本语法 head 文件(功能描述：查看文件头10行内容) head -n 5 文件 (功能描述：查看文件头5行内容，5可以是任意行数) •应用实例 案例:查看/etc/profile的前面5行代码 1[root@hapdoop1 ~]## head -n 5 /etc/profile 9.4.16tail指令 tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。 •基本语法 1)tail 文件（功能描述：查看文件后10行内容） 2)tail -n 5 文件（功能描述：查看文件后5行内容，5可以是任意行数）3)tail -f 文件（功能描述：实时追踪该文档的所有更新，工作经常使用） •应用实例 案例1:查看/etc/profile最后5行的代码 1[root@hapdoop1 ~]## tail -n 5 /etc/profile 案例2:实时监控mydate.txt,看看到文件有变化时，是否看到，实时的追加日期 1[root@hapdoop1 home]## tail -f mydate.txt 9.4.17ln指令 软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径 •基本语法 ln -s [原文件或目录] [软链接名]（功能描述：给原文件创建一个软链接） •应用实例 案例1:在/home目录下创建一个软连接linkToRoot，连接到/root目录 1[root@hapdoop1 home]## ln -s /root linkToRoot 案例2:删除软连接linkToRoot 1[root@hapdoop1 home]## rm linkToRoot •细节说明 当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录。 1234567[root@hapdoop1 home]## cd linkToRoot/[root@hapdoop1 linkToRoot]## pwd/home/linkToRoot[root@hapdoop1 linkToRoot]## lsanaconda-ks.cfg install.log.syslog 公共的 视频 下载hello.java ok.txt 红1.jpg 图片 音乐install.log pig.txt 模板 文档 9.4.18history指令查看已经执行过历史命令,也可以执行历史指令 •基本语法history（功能描述：查看已经执行过历史命令） •应用实例案例1:显示所有的历史命令 1[root@hapdoop1 home]## history 案例2:显示最近使用过的10个指令。 1[root@hapdoop1 home]## history 10 案例3：执行历史编号为5的指令 1[root@hapdoop1 home]## !111 9.5时间日期类9.5.1date指令-显示当前日期 •基本语法 1)date（功能描述：显示当前时间） 2)date+%Y（功能描述：显示当前年份） 3)date+%m（功能描述：显示当前月份） 4)date+%d（功能描述：显示当前是哪一天） 5)date”+%Y-%m-%d%H:%M:%S”（功能描述：显示年月日时分秒） •应用实例案例1:显示当前时间信息 12[root@hapdoop1 home]## date2019年 08月 15日 星期四 17:57:34 CST 案例2:显示当前时间年月日 12[root@hapdoop1 home]## date \"+%Y %m %d\"2019 08 15 案例3:显示当前时间年月日时分秒 12[root@hapdoop1 home]## date \"+%Y %m %d %H:%M:%S\"2019 08 15 18:04:05 9.5.2date指令 -设置日期 •基本语法 date -s 字符串时间 •应用实例 案例1:设置系统当前时间，比如设置成2018-10-1011:22:22 12[root@hapdoop1 home]## date -s \"2019-9-9 11:11:11\"2019年 09月 09日 星期一 11:11:11 CST 9.5.3cal指令(calendar) 查看日历指令 •基本语法cal[选项]（功能描述：不加选项，显示本月日历） •应用实例案例1:显示当前日历 1[root@hapdoop1 home]## cal 案例2:显示2020年日历 1[root@hapdoop1 ~]## cal 2020 9.6搜索查找类9.6.1find指令 find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。 •基本语法 find [搜索范围] [选项] •选项说明 •应用实例 案例1:按文件名：根据名称查找/home目录下的hello.txt文件 1[root@hapdoop1 ~]## find /home -name hello.txt 案例2：按拥有者：查找/opt目录下，用户名称为root的文件 1[root@hapdoop1 ~]## find /opt -user root 案例3：查找整个linux系统下大于20m的文件（+n大于-n小于n等于） 1[root@hapdoop1 ~]## find /opt -size +20M 查询/目录下，所有.txt的文件 1[root@hapdoop1 ~]## find / -name \\*.txt 9.6.2locate指令 locaate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。 •基本语法 locate 搜索文件 •特别说明由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库。 •应用实例 案例1:请使用locate指令快速定位hello.txt文件所在目录 9.6.3grep指令和管道符号|grep过滤查找，管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。 •基本语法 grep [选项] 查找内容源文件 •常用选项 •应用实例 案例1:请在hello.txt文件中，查找”yes”所在行，并且显示行号 123[root@hapdoop1 home]## cat hello.txt | grep -n yes#不区分大小写[root@hapdoop1 home]## cat hello.txt | grep -ni yes 压缩和解压类9.7.1gzip/gunzip指令 gzip用于压缩文件，gunzip用于解压的 •基本语法 gzip 文件（功能描述：压缩文件，只能将文件压缩为*.gz文件） gunzip 文件.gz（功能描述：解压缩文件命令） •应用实例 案例1:gzip压缩，将/home下的hello.txt文件进行压缩 1[root@hapdoop1 home]## gzip hello.txt 案例2:gunzip压缩，将/home下的hello.txt.gz文件进行解压缩 1[root@hapdoop1 home]## gunzip hello.txt.gz 细节说明 当我们使用gzip对文件进行压缩后，不会保留原来的文件。 9.7.2 zip/unzip指令 zip用于压缩文件，unzip用于解压的，这个在项目打包发布中很有用的 •基本语法 zip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）unzip [选项] XXX.zip（功能描述：解压缩文件） •zip常用选项 -r：递归压缩，即压缩目录 unzip的常用选项 -d &lt;目录&gt;：指定解压后文件的存放目录 •应用实例 案例1:将/home下的所有文件进行压缩成mypackage.zip 1[root@hapdoop1 home]## zip -r mypackge.zip /home/ 案例2:将mypackge.zip解压到/opt/tmp目录下 1[root@hapdoop1 home]## unzip -d /opt/tmp/ mypackge.zip tar指令tar指令是打包指令，最后打包后的文件是.tar.gz的文件。 •基本语法 1tar [选项] XXX.tar.gz(打包的内容) (功能描述：打包目录，压缩后的文件格式.tar.gz) •选项说明 选项 功能 -c(–create) 产生.tar打包文件 -v(verbose，adj. 冗长的；啰嗦的) 显示详细信息 -f(file) 指定压缩后的文件名 -z(gzip) 打包同时压缩 x(extract) 解包.tar文件 •应用实例 案例1:压缩多个文件，将/home/a1.txt和/home/a2.txt压缩成a.tar.gz 1[root@hapdoop1 home]## tar -zcvf a.tar.gz ok1.txt ok2.txt 案例3:将a.tar.gz解压到当前目录 1[root@hapdoop1 home]## tar -zxvf a.tar.gz 案例4:将myhome.tar.gz解压到/opt/目录下 1[root@hapdoop1 home]## tar -zxvf a.tar.gz -C /opt 10组管理和权限管理10.1Linux组 基本介绍 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。 1)所有者 2)所在组 3)其它组 4)改变用户所在的组 10.2文件/目录所有者 一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者。10.2.1查看文件的所有者 1)指令：ls -ahl 2)应用实例：创建一个组police,再创建一个用户tom,将tom放在police组,然后使用tom来创建一个文件ok.txt，看看情况如何 10.3组的创建10.3.1基本指令 groupadd 组名 10.3.2应用实例: 创建一个组,monster 创建一个用户fox，并放入到monster组中 12[root@hapdoop1 ~]## groupadd monster[root@hapdoop1 ~]## useradd -g monster fox 10.4文件/目录所在组当某个用户创建了一个文件后，默认这个文件的所在组就是该用户所在的组。#### 10.4.1查看文件/目录所在组 •基本指令 ls –ahl 10.4.2修改文件所在的组•基本指令 chgrp 组名 文件名 •应用实例 使用root用户创建文件orange.txt,看看当前这个文件属于哪个组，然后将这个文件所在组，修改到police组。 123[root@hapdoop1 ~]## chgrp police orange.txt [root@hapdoop1 ~]## ls -ahl-rw-r--r--. 1 root police 12 9月 16 02:17 orange.txt 10.5其它组 除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组. 10.6改变用户所在组 在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组。 10.6.1改变用户所在组 1)usermod –g 组名 用户名 2)usermod –d 目录名 用户名 改变该用户登陆的初始目录。 1[root@hapdoop1 ~]## usermod -g bandit fox 10.7权限的基本介绍ls -l中显示的内容如下： -rwxrw-r–1rootroot1213Feb209:39abc 0-9位说明 1)第0位确定文件类型(d,-,l,c,b) 2)第1-3位确定所有者（该文件的所有者）拥有该文件的权限。—User 3)第4-6位确定所属组（同用户组的）拥有该文件的权限，—Group 4)第7-9位确定其他用户拥有该文件的权限—Other 10.8rwx权限详解10.8.1rwx作用到文件 1)[r]代表可读(read):可以读取,查看 ： 数字4 2)[w]代表可写(write):可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件. ：数字2 3)[x]代表可执行(execute):可以被执行 ：数字1 10.8.2rwx作用到目录 1)[r]代表可读(read):可以读取，ls查看目录内容 2)[w]代表可写(write):可以修改,目录内创建+删除+重命名目录 3)[x]代表可执行(execute):可以进入该目录10.9文件及目录权限实际案例ls-l中显示的内容如下：(记住)-rwxrw-r–1rootroot1213Feb209:39abc 10个字符确定不同用户能对文件干什么 第一个字符代表文件类型：文件(-),目录(d),链接(l) 其余字符每3个一组(rwx)读(r)写(w)执行(x) 第一组rwx:文件拥有者的权限是读、写和执行 第二组rw-:与文件拥有者同一组的用户的权限是读、写但不能执行 第三组r–:不与文件拥有者同组的其他用户的权限是读不能写和执行 可用数字表示为:r=4,w=2,x=1因此rwx=4+2+1=7 1 文件：硬连接数或目录：子目录数 root 用户root组 1213 文件大小(字节)，如果是文件夹，显示4096字节 Feb209:39 最后修改日期 abc 文件名 10.9文件及目录权限ls-l中显示的内容如下：(记住) -rwxrw-r–1rootroot1213Feb209:39abc 10修改权限-chmod10.10.1基本说明： 通过chmod指令，可以修改文件或者目录的权限 10.10.2第一种方式：+、-、=变更权限 u:所有者g:所有组o:其他人a:所有人(u、g、o的总和) 1)chmod u=rwx,g=rx,o=x文件目录名 2)chmod o+w 文件目录名 3)chmod a-x 文件目录名 •案例演示 1)给abc文件的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限 1234[root@hapdoop1 ~]## chmod u=rwx,g=x,o=rx abc[root@hapdoop1 ~]## ls -l总用量 136drwx--xr-x. 2 root root 4096 9月 16 02:34 abc 2)给abc文件的所有用户添加读的权限 1[root@hapdoop1 ~]## chmod a+r abc 10.10.3第二种方式：通过数字变更权限 规则：r=4 w=2 x=1 ,rwx=4+2+1=7 chmod u=rwx, g=rx, o=x文件目录名 相当于 chmod 751 文件目录名 •案例演示 要求：将/home/abc.txt文件的权限修改成rwxr-xr-x,使用给数字的方式实现：rwx=4+2+1=7 r-x=4+1=5 r-x=4+1=5 指令：chmod 755 /home/abc.txt 1chmod -R 777 /home/ubuntu/static 10.11修改文件所有者-chown(chmod - change file mode bits) 10.11.1基本介绍 1chown newowner file 改变文件的所有者 1chown [-R] newowner:newgroupfile 改变用户的所有者和所有组 [-R] 如果是目录则使其下所有子文件或目录递归生效 10.11.2案例演示： 1)请将/home/abc.txt文件的所有者修改成tom 1[root@hapdoop1 ~]## chown fox abc.txt 2)请将/home/kkk目录下所有的文件和目录的所有者都修改成tom 1[root@hapdoop1 ~]## chown -R tom kkk/ 10.13最佳实践-警察和土匪游戏police，bandit jack,jerry:警察 xh,xq:土匪 (1)创建组 12[root@hapdoop1 ~]## groupadd police[root@hapdoop1 ~]## groupadd bandit (2)创建用户 crond任务调度11.1原理示意图 crontab进行定时任务的设置。 1.2概述 任务调度：是指系统在某个时间执行的特定的命令或程序。 任务调度分类： 1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等 2.个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。 11.3基本语法 crontab [选项] 11.3.1常用选项 快速入门11.4.1任务的要求 设置任务调度文件：/etc/crontab 设置个人任务调度。执行crontab–e命令。 接着输入任务到调度文件如：/1ls–l/etc/&gt;/tmp/to.txt意思说每小时的每分钟执行ls–l/etc/&gt;/tmp/to.txt命令 11.4.2步骤如下 1) 1[root@hapdoop1 ~]## crontab -e 2) */1 * * * * ls -l /etc &gt;&gt; /tmp/to.txt 3)当保存退出后就程序。 4)在每一分钟都会自动的调用 ls -l /etc &gt;&gt; /tmp/to.txt 11.4.3参数细节说明 11.5.1 案例1：每隔1分钟，就将当前的日期信息，追加到/tmp/mydate文件中 1)先编写一个文件/home/mytask1.sh 1date &gt;&gt; /tmp/mydate 2)给mytask1.sh一个可以执行权限 1[root@hapdoop1 home]## chmod 774 mytask1.sh 3)crontab-e 4) 1*/1 * * * * /home/mytask1.sh 11.5.2 案例2：每隔1分钟，将当前日期和日历都追加到/home/mycal文件中 1)先编写一个文件/home/mytask2.sh 12date &gt;&gt; /tmp/mycalcal &gt;&gt; /tmp/mycal 2)给mytask2.sh一个可以执行权限 1[root@hapdoop1 home]## chmod 774 mytask2.sh 3)crontab -e 4) 1*/1 * * * * /home/mytask2.sh 11.5.3 案例3:每天凌晨2:00将mysql数据库testdb，备份到文件中mydb.bak。 1)先编写一个文件/home/mytask2.sh 1/usr/local/mysql/bin/mysqldump -u root-proot testdb&gt;/tmp/mydb.bak 2)给mytask3.sh一个可以执行权限 1[root@hapdoop1 home]## chmod 774 mytask2.sh 3)crontab -e 4) 10 2 * * */home/mytask3.sh 11.6crond相关指令: 1)conrtab–r：终止任务调度。 2)crontab–l：列出当前有那些任务调度 3)service crond restart [重启任务调度] Linux磁盘分区、挂载分区基础知识12.1.1分区的方式： 1)mbr分区: 1.最多支持四个主分区 2.系统只能安装在主分区 3.扩展分区要占一个主分区4.MBR最大只支持2TB，但拥有最好的兼容性 2)gpt分区: 1.支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区） 2.最大支持18EB的大容量（1EB=1024PB，1PB=1024TB）3.windows764位以后支持gpt 12.1.2windows下的磁盘分区 12.2Linux分区12.2.1原理介绍 1)Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构,Linux中每个分区都是用来组成整个文件系统的一部分。 2)Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。 3)示意图 12.2.2硬盘说明 1)Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘 2)对于IDE硬盘，驱动器标识符为“hdx”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。 3)对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样 12.2.3使用lsblk指令查看当前系统的分区情况 12.5磁盘情况查询12.5.1查询系统整体磁盘使用情况 基本语法 df -h 应用实例 查询系统整体磁盘使用情况 123456[root@hapdoop1 ~]## df -lhFilesystem Size Used Avail Use% Mounted on/dev/sda3 18G 4.2G 13G 26% /tmpfs 1003M 80K 1003M 1% /dev/shm/dev/sda1 190M 39M 142M 22% /boot/dev/sr0 3.7G 3.7G 0 100% /media/CentOS_6.8_Final 12.5.2查询指定目录的磁盘占用情况 •基本语法 du -h/目录查询指定目录的磁盘占用情况，默认为当前目录 -s指定目录占用大小汇总 -h带计量单位 -a含文件 –max-depth=1子目录深度 -c列出明细的同时，增加汇总值 •应用实例查询/opt目录的磁盘占用情况，深度为1 123456789101112131415161718[root@hapdoop1 ~]## du -ach --max-depth=1 /opt4.0K /opt/Hello.java64K /opt/tmp147M /opt/jdk-7u79-linux-x64.gz35M /opt/mysql-5.6.14.tar.gz8.6M /opt/apache-tomcat-7.0.70.tar.gz298M /opt/jdk1.7.0_794.0K /opt/rh4.0K /opt/Hello.class0 /opt/ok2.txt28M /opt/金庸-射雕英雄传txt精校版.txt69M /opt/VMwareTools-10.0.5-3228253.tar.gz15M /opt/apache-tomcat-7.0.70214M /opt/vmware-tools-distrib0 /opt/ok1.txt274M /opt/eclipse-jee-mars-2-linux-gtk-x86_64.tar.gz1.1G /opt1.1G 总用量 12.6磁盘情况-工作实用指令1)统计/home文件夹下文件的个数 12[root@hapdoop1 home]## ll /home | grep \"^-\" | wc -l11 2)统计/home文件夹下目录的个数 12[root@hapdoop1 home]## ll /home | grep \"^d\" | wc -l3 3)统计/home文件夹下文件的个数，包括子文件夹里的 12[root@hapdoop1 home]## ls -lR /home | grep \"^-\" | wc -l11 4)统计文件夹下目录的个数，包括子文件夹里的 12[root@hapdoop1 home]## ls -lR /home | grep \"^d\" | wc -l3 5)以树状显示目录结构 1234567891011121314151617[root@hapdoop1 home]## yum install tree[root@hapdoop1 home]## tree.├── a.tar.gz├── a.txt├── c.txt├── fox├── hello.txt├── mydate.txt├── mydate.txt~├── mypackge.zip├── mytask1.sh├── mytask2.sh├── ok1.txt├── ok2.txt├── tom└── xm 网络配置13.1Linux网络配置 原理图(含虚拟机) 目前我们的网络配置采用的是NAT。 2查看网络IP和网关13.2.1查看虚拟网络编辑器 13.2.2修改ip地址(修改虚拟网络的ip) 3.2.3查看网关 13.2.4查看windows环境的中VMnet8网络配置(ipconfig指令) 1)使用ipconfig查看 2)界面查看 13.3ping测试主机之间网络连通 13.3.1基本语法ping目的主机（功能描述：测试当前服务器是否可以连接目的主机） 13.3.2应用实例测试当前服务器是否可以连接百度 [root@hadoop100桌面]#pingwww.baidu.com 1[root@hapdoop1 home]## vim /etc/sysconfig/network-scripts/ifcfg-eth0 4linux网络环境配置13.4.1第一种方法(自动获取) 缺点:linux启动后会自动获取IP,缺点是每次自动获取的ip地址可能不一样。这个不适用于做服务器，因为我们的服务器的ip需要时固定的。 13.4.2第二种方法(指定固定的ip) 说明直接修改配置文件来指定IP,并可以连接到外网(程序员推荐)，编辑vi/etc/sysconfig/network-scripts/ifcfg-eth0 要求：将ip地址配置的静态的，ip地址为192.168.184.130 修改后，一定要重启服务 1)service network restart 2)reboot重启系统 不推荐 进程管理14.1进程的基本介绍1)在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。 2)每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。 3)每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。 4)一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。 2显示系统执行的进程ps14.2.1说明： 查看进行使用的指令是ps,一般来说使用的参数是ps -aux ps显示的信息选项 字段 说明 PID 进程识别号 TTY 终端机号 TIME 此进程所消CPU时间 CMD 正在执行的命令或进程名 14.2.2ps指令详解1)指令： 1ps -aux | grep xxx ，比如我看看有没有sshd服务 2)指令说明 •SystemV展示风格•USER：用户名称 •PID：进程号•%CPU：进程占用CPU的百分比 •%MEM：进程占用物理内存的百分比 •VSZ：进程占用的虚拟内存大小（单位：KB） •RSS：进程占用的物理内存大小（单位：KB） •TT：终端名称,缩写 .•STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等 •STARTED：进程的启动时间 •TIME：CPU时间，即进程使用CPU的总时间•COMMAND：启动进程所用的命令和参数，如果过长会被截断显示 14.2.3应用实例 要求：以全格式显示当前所有的进程，查看进程的父进程。 ps -ef是以全格式显示当前所有的进程 -e显示所有进程(every)。 -f全格式(Do full-format listing)。 1ps -ef|grep xxx •是BSD风格 •UID：用户ID •PID：进程ID •PPID：父进程ID •C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高•STIME：进程启动的时间 •TTY：完整的终端名称 •TIME：CPU时间 •CMD：启动进程所用的命令和参数 思考题，如果我们希望查看sshd进程的父进程号是多少，应该怎样查询？ 1234[root@hapdoop1 ~]## ps -ef | grep sshdroot 14263 1 0 (ppid) 05:34 ? 00:00:00 /usr/sbin/sshdroot 16269 14263 0 06:07 ? 00:00:00 sshd: root@pts/1 root 16321 16273 0 06:19 pts/1 00:00:00 grep sshd 3终止进程kill和killall14.3.1介绍: 若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。 14.3.2基本语法： 1kill [选项] 进程号 （功能描述：通过进程号杀死进程） killall进程名称（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用） 14.3.3常用选项： -9:表示强迫进程立即停止 14.3.4最佳实践： 案例1：踢掉某个非法登录用户 12345678[root@hapdoop1 ~]## ps -aux | grep sshdWarning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.8/FAQroot 14263 0.0 0.0 66236 1200 ? Ss 05:34 0:00 /usr/sbin/sshdroot 16269 0.0 0.2 102084 4156 ? Ss 06:07 0:00 sshd: root@pts/1 root 16357 0.4 0.1 102084 4040 ? Ss 06:28 0:00 sshd: fox [priv] fox 16361 0.1 0.0 102084 1904 ? S 06:28 0:00 sshd: fox@pts/2 root 16387 0.0 0.0 103332 860 pts/1 S+ 06:29 0:00 grep sshd[root@hapdoop1 ~]## kill 16361 案例2:终止远程登录服务sshd,在适当时候再次重启sshd服 12345678[root@hapdoop1 ~]## ps -aux | grep sshdWarning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.8/FAQroot 14263 0.0 0.0 66236 1200 ? Ss 05:34 0:00 /usr/sbin/sshdroot 16269 0.0 0.2 102084 4156 ? Ss 06:07 0:00 sshd: root@pts/1 root 16357 0.4 0.1 102084 4040 ? Ss 06:28 0:00 sshd: fox [priv] fox 16361 0.1 0.0 102084 1904 ? S 06:28 0:00 sshd: fox@pts/2 root 16387 0.0 0.0 103332 860 pts/1 S+ 06:29 0:00 grep sshd[root@hapdoop1 ~]## kill 14263 案例3:终止多个gedit编辑器【killall,通过进程名称来终止进程】 1[root@hapdoop1 桌面]## killall gedit 案例4：强制杀掉一个终端 12345678[root@hapdoop1 桌面]## ps -aux |grep bashWarning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.8/FAQroot 15158 0.0 0.0 108348 1840 pts/0 Ss 05:37 0:00 /bin/bashroot 16273 0.0 0.0 108348 1820 pts/1 Ss+ 06:07 0:00 -bashroot 16398 0.0 0.0 108428 1828 pts/2 Ss+ 06:33 0:00 /bin/bashroot 16411 0.0 0.0 108348 1788 pts/3 Ss 06:33 0:00 /bin/bashroot 16438 0.0 0.0 103328 856 pts/3 S+ 06:37 0:00 grep bash[root@hapdoop1 桌面]## kill -9 16398 14.4查看进程树pstree14.4.1基本语法： pstree [选项] ,可以更加直观的来看进程信息 14.4.2常用选项： -p:显示进程的PID -u:显示进程的所属用户 14.4.3应用实例： 案例1：请你树状的形式显示进程的pid 123456789[root@hapdoop1 ~]## pstree -pinit(1)─┬─ManagementAgent(13688)─┬─&#123;ManagementAgen&#125;(13706) │ └─&#123;ManagementAgen&#125;(13707) ├─NetworkManager(14070)─┬─dhclient(16203) │ └─&#123;NetworkManager&#125;(14099) ├─VGAuthService(13576) ├─abrtd(14468) ├─acpid(14133) ├─atd(14495) 5服务(systemctl)管理在CentOS7.0后不再使用service,而是systemctl 4.5.1介绍: 服务(service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql,sshd防火墙等)，因此我们又称为守护进程，是Linux中非常重要的知识点。 【原理图】 2systemctl管理指令： systemctl命令 说明 systemctl start [unit type] 启动服务 systemctl stop [unit type] 停止服务 systemctl restart [unit type] 重启服务 14.5.3使用案例： 启动docker服务 1systemctl start docker 1)查看当前防火墙的状况，关闭防火墙和重启防火墙。 1234567891011121314151617[root@hapdoop1 ~]## service iptables status表格：filterChain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:8080 6 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT)num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT)num target prot opt source destination 1234567891011[root@hapdoop1 ~]## service iptables stopiptables：将链设置为政策 ACCEPT：filter [确定]iptables：清除防火墙规则： [确定]iptables：正在卸载模块： [确定][root@hapdoop1 ~]## service iptables statusiptables：未运行防火墙。[root@hapdoop1 ~]## service iptables startiptables：应用防火墙规则： [确定][root@hapdoop1 ~]## service iptables status表格：filterChain INPUT (policy ACCEPT) centos service iptables status 报错 12Redirecting to /bin/systemctl status iptables.serviceUnit iptables.service could not be found. 解决办法 1yum install iptables-services 14.5.4细节讨论： 1)关闭或者启用防火墙后，立即生效。[telnet测试某个端口即可]windows 1C:\\Users\\11623&gt;Telnet 192.168.163.129 22 2)这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。如果希望设置某个服务自启动或关闭永久生效，要使用chkconfig指令，马上讲 14.5.5查看服务名: 方式1：使用setup-&gt;系统服务就可以看到。 方式2:/etc/init.d/服务名称 123456root@hapdoop1 ~]## ll /etc/init.d/总用量 376-rwxr-xr-x. 1 root root 1288 5月 12 2016 abrt-ccpp-rwxr-xr-x. 1 root root 1628 5月 12 2016 abrtd-rwxr-xr-x. 1 root root 1642 5月 12 2016 abrt-oops-rwxr-xr-x. 1 root root 1818 2月 17 2016 acpid 14.5.6服务的运行级别(runlevel): 查看或者修改默认级别：vi/etc/inittab Linux系统有7种运行级别(runlevel)：常用的是级别3和5 •运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 •运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 •运行级别2：多用户状态(没有NFS)，不支持网络 •运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 •运行级别4：系统未使用，保留 •运行级别5：X11控制台，登陆后进入图形GUI模式 •运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 14.5.7开机的流程说明 14.5.8chkconfig指令 介绍 通过chkconfig命令可以给每个服务的各个运行级别设置自启动/关闭 基本语法 1)查看服务chkconfig –list| grep xxx 1234567[root@hapdoop1 ~]## chkconfig --list NetworkManager 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭abrt-ccpp 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭abrtd 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭....[root@hapdoop1 ~]## chkconfig --list | grep sshsshd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 2)chkconfig 服务名 –list 12[root@hapdoop1 ~]## chkconfig iptables --listiptables 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 3)chkconfig –level 5 服务名 on/off 12345[root@hapdoop1 ~]## chkconfig --list | grep sshsshd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭[root@hapdoop1 ~]## chkconfig --level 5 sshd off[root@hapdoop1 ~]## chkconfig sshd --listsshd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:关闭 6:关闭 14.5.9应用实例： 1)案例1：请显示当前系统所有服务的各个运行级别的运行状态bash&gt;chkconfig–list 2)案例2：请查看sshd服务的运行状态bash&gt;servicesshdstatus 3)案例3：将sshd服务在运行级别5下设置为不自动启动，看看有什么效果？bash&gt;chkconfig–level5sshdoff 4)案例4：当运行级别为5时，关闭防火墙。bash&gt;chkconfig–level5iptablesoff 5)案例5：在所有运行级别下，关闭防火墙bash&gt;chkconfigiptablesoff 6)案例6：在所有运行级别下，开启防火墙bash&gt;chkconfigiptableson 14.5.10•使用细节 1)chkconfig重新设置服务后自启动或关闭，需要重启机器reboot才能生效. 14.6动态监控进程14.6.1介绍： top与ps命令很相似。它们都用来显示正在执行的进程。Top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程。 14.6.2基本语法： top [选项] 14.6.3 选项说明： 14.6.4应用实例： 案例1.监视特定用户top：输入此命令，按回车键，查看执行的进程。 u：然后输入“u”回车，再输入用户名，即可 案例2：终止指定的进程。 top：输入此命令，按回车键，查看执行的进程。 k：然后输入“k”回车，再输入要结束的进程ID号 案例3:指定系统状态更新的时间(每隔10秒自动更新，默认是3秒)： bash&gt;top -d 10 14.6.5查看系统网络情况netstat(重要) •基本语法 netstat[选项] 1netstat -anp •选项说明 -an按一定顺序排列输出 -p显示哪个进程在调用 •应用案例 查看系统所有的网络服务 12345[root@hapdoop1 ~]## netstat -anp | moreActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 14263/sshd 请查看服务名为sshd的服务的信息。 1234567[root@hapdoop1 ~]## netstat -anp |grep sshd tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 14263/sshd tcp 0 0 127.0.0.1:6010 0.0.0.0:* LISTEN 16552/sshd tcp 0 0 192.168.163.129:22 192.168.163.1:61806 ESTABLISHED 16552/sshd tcp 0 0 :::22 :::* LISTEN 14263/sshd tcp 0 0 ::1:6010 :::* LISTEN 16552/sshd unix 2 [ ] DGRAM 48552 16552/sshd JavaEE篇搭建JavaEE环境 16.1概述16.1.1示意图： 16.2安装JDK16.2.1看老师演示，一会整理笔记： 16.2.2安装步骤 0)先将软件通过xftp5上传到/opt下 1)解压缩到/opt 1nicolas@ubuntu:~$ sudo tar -zxvf jdk-8u221-linux-x64.tar.gz -C /opt/jvm 2)配置环境变量的配置文件vim/etc/profile 123456unset iunset -f pathmungeJAVA_HOME=/opt/jdk1.7.0_79PATH=/opt/jdk1.7.0_79/bin:$PATHexport JAVA_HOME PATH 3)需要注销用户，环境变量才能生效。如果是在3运行级别，logout如果是在5运行级别， 4)在任何目录下就可以使用java和javac 16.2.3测试是否安装成功 编写一个简单的Hello.java输出”hello,world!” 12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(\"hello\"); &#125;&#125; 1234[root@hapdoop1 opt]# vim Hello.java[root@hapdoop1 opt]# javac Hello.java [root@hapdoop1 opt]# java Hellohello 16.3安装tomcat16.3.1步骤: 1)解压缩到/opt 1[root@hapdoop1 bin]# tar -zxvf apache-tomcat-7.0.70.tar.gz 2)启动tomcat./startup.sh 先进入到tomcat的bin目录 12[root@hapdoop1 bin]# cd apache-tomcat-7.0.70/bin/[root@hapdoop1 bin]# ./startup.sh 使用Linux本地的浏览是可以访问到tomcat 3)开放端口8080,这样外网才能访问到tomcat vim /etc/sysconfig/iptables 12-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 重启防火墙 12345678910111213141516171819202122[root@hapdoop1 bin]# service iptables restartiptables：将链设置为政策 ACCEPT：filter [确定]iptables：清除防火墙规则： [确定]iptables：正在卸载模块： [确定]iptables：应用防火墙规则： [确定][root@hapdoop1 bin]# service iptables status表格：filterChain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:8080 6 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT)num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT)num target prot opt source destination 16.4Eclipse的安装16.4.1步骤: 1)解压缩到/opt 1nicolas@ubuntu:~$ sudo tar -zxvf eclipse-java-2019-06-R-linux-gtk-x86_64.tar.gz -C /opt 2)启动eclipse，配置jre和server 12nicolas@ubuntu:/opt/sts-4.3.2.RELEASE$ sudo mkdir /opt/sts-4.3.2.RELEASE/jrenicolas@ubuntu:/opt/sts-4.3.2.RELEASE$ sudo ln -s /opt/jvm/jdk1.8.0_221/bin/ /opt/sts-4.3.2.RELEASE/jre/ 启动方法1:创建一个快捷方式 启动方式2:进入到eclipse解压后的文件夹，然后执行./eclipse即可 3)编写jsp页面,并测试成功! UbuntuUbuntu的介绍UbuntuPython：开发平台Ubuntu （友帮拓、优般图、乌班图）是一个以桌面应用为主的开源GNU/Linux操作系统，Ubuntu是基于GNU/Linux，支持x86、amd64（即x64）和ppc架构，由全球化的专业开发团队（CanonicalLtd）打造的。 专业的Python开发者一般会选择Ubuntu这款Linux系统作为生产平台. 温馨提示：Ubuntu和Centos都是基于GNU/Linux内核的，因此基本使用和Centos是几乎一样的，它们的各种指令可以通用，同学们在学习和使用Ubuntu的过程中，会发现各种操作指令在前面学习CentOS都使用过。只是界面和预安装的软件有所差别。 Ubuntu下载地址：http://cn.ubuntu.com/download/ Ubuntu的安装18.2.1安装的步骤 18.2.2设置Ubuntu支持中文 默认安装的ubuntu中只有英文语言，因此是不能显示汉字的。要正确显示汉字，需要安装中文语言包。安装中文支持步骤 1.单击左侧图标栏打开SystemSettings（系统设置）菜单，点击打开LanguageSupport（语言支持）选项卡。 2.点击Install/RemoveLanguages，在弹出的选项卡中下拉找到Chinese(Simplified)，即中文简体，在后面的选项框中打勾。然后点击ApplyChanges提交，系统会自动联网下载中文语言包。（保证ubuntu是联网的）。 3.这时“汉语（中国）”在最后一位因为当前第一位是”English”，所以默认显示都是英文。我们如果希望默认显示用中文，则应该将“汉语（中国）”设置为第一位。设置方法是拖动，鼠标单击“汉语（中国）”，当底色变化（表示选中了）后，按住鼠标左键不松手，向上拖动放置到第一位。 4.设置后不会即刻生效，需要下一次登录时才会生效。 ==如果中文包下载时间过长，可以给ubuntu换源（阿里源）；== Ubuntu的root用户18.3.1介绍 安装ubuntu成功后，都是普通用户权限，并没有最高root权限，如果需要使用root权限的时候，通常都会在命令前面加上sudo。 有的时候感觉很麻烦。我们一般使用su命令来直接切换到root用户的，但是如果没有给root设置初始密码，就会抛出su:Authentication failure这样的问题。所以，我们只要给root用户设置一个初始密码就好了。 18.3.2 给root用户设置密码并使用 1)输入sudo passwd命令，输入一般用户密码并设定root用户密码。 2)设定root密码成功后，输入su命令，并输入刚才设定的root密码，就可以切换成root了。提示符$代表一般用户，提示符#代表root用户。3)输入exit命令，退出root并返回一般用户4)以后就可以使用root用户了 123456789nicolas@ubuntu:~$ sudo passwd[sudo] nicolas 的密码： 对不起，请重试。[sudo] nicolas 的密码： 对不起，请重试。[sudo] nicolas 的密码： 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码 18.4Ubuntu下开发Python 18.4.1说明安装好Ubuntu后，默认就已经安装好Python的开发环境[Python2.7和Python3.5] 123456789nicolas@ubuntu:~$ pythonPython 2.7.12 (default, Nov 19 2016, 06:48:10) [GCC 5.4.0 20160609] on linux2Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; nicolas@ubuntu:~$ python3Python 3.5.2 (default, Nov 17 2016, 17:05:23) [GCC 5.4.0 20160609] on linuxType \"help\", \"copyright\", \"credits\" or \"license\" for more information. 18.4.2在Ubuntu下开发一个Python程序 1)vim hello.py[编写hello.py] 提示：如果Ubuntu没有vim我们可以根据提示信息安装一个vim 1sudo apt install vim apt软件管理和远程登录apt介绍apt是Advanced Packaging Tool的简称，是一款安装包管理工具。在Ubuntu下，我们可以使用apt命令可用于软件包的安装、删除、清理等，类似于Windows中的软件管理工具。 unbuntu软件管理的原理示意图： 19.2Ubuntu软件操作的相关命令 sudo apt-get update更新源 1sudo apt-get install package安装包 1234567891011sudo apt-get remove package删除包sudo apt-cache search package搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package -- reinstall重新安装包sudo apt-get -finstall修复安装sudo apt-get remove package --purge删除包，包括配置文件等sudo apt-get build -deppackage安装相关的编译环境 更新已安装的包系统最开始使用时尝试更新 1sudo apt-get upgrade 1sudo apt-get dist-upgrade升级系统 12345sudo apt-cache depends package了解使用该包依赖那些包sudo apt-cache rdepends package查看该包被哪些包依赖sudo apt-get source package下载该包的源代码 更新Ubuntu软件下载地址19.3.1原理示意图 19.3.2寻找国内镜像源 https://mirrors.tuna.tsinghua.edu.cn/ 所谓的镜像源：可以理解为提供下载软件的地方，比如Android手机上可以下载软件的安卓市场；iOS手机上可以下载软件的AppStore 19.3.3 备份Ubuntu默认的源地址 123456nicolas@ubuntu:/etc/apt$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup #拷贝root@ubuntu:/etc/apt## echo '' &gt; sources.list #清空root@ubuntu:/etc/apt## vim sources.list #拷贝清华镜像root@ubuntu:/etc/apt## exitexitnicolas@ubuntu:~$ sudo apt-get update #更新ubuntu软件列表 使用ssh远程登录Ubuntu19.5.1ssh介绍 SSH为SecureShell的缩写，由IETF的网络工作小组（NetworkWorkingGroup）所制定；SSH为建立在应用层和传输层基础上的安全协议。 SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。常用于远程登录，以及用户之间进行资料拷贝。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、DigitalUNIX、Irix，以及其他平台，都可运行SSH。 使用SSH服务，需要安装相应的服务器和客户端。客户端和服务器的关系：如果，A机器想被B机器远程控制，那么，A机器需要安装SSH服务器，B机器需要安装SSH客户端。和CentOS不一样，Ubuntu默认没有安装SSHD服务，因此，我们不能进行远程登录。 使用ssh远程登录Ubuntu19.6.1安装SSH和启用 1nicolas@ubuntu:~$ sudo apt-get install openssh-server 执行上面指令后，在当前这台Linux上就安装了SSH服务端和客户端。 1nicolas@ubuntu:~$ service sshd restart 执行上面的指令，就启动了sshd服务。会监听端口22 1234567891011121314151617181920212223242526nicolas@ubuntu:~$ netstat -anp | more（并非所有进程都能被检测到，所有非本用户的进程信息将不会显示，如果想看到所有信息，则必须切换到 root 用户）激活Internet连接 (服务器和已建立连接的)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 127.0.1.1:53 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp6 0 0 :::22 :::* LISTEN - udp 0 0 0.0.0.0:631 0.0.0.0:* - udp 0 0 0.0.0.0:36829 0.0.0.0:* - udp 0 0 127.0.1.1:53 0.0.0.0:* - udp 0 0 0.0.0.0:68 0.0.0.0:* - udp 0 0 0.0.0.0:5353 0.0.0.0:* - udp6 0 0 :::50035 :::* - udp6 0 0 :::5353 :::* - --更多-- 19.6.2在Windows使用XShell5/XFTP5登录Ubuntu 前面我们已经安装了XShell5，直接使用即可。 注意：使用atguigu用户登录，需要的时候再su-切换成root用户 19.6.3从linux系统客户机远程登陆linux 系统服务机首先，我们需要在linux的系统客户机也要安装openssh-server •基本语法：ssh 用户名@IP 例如：sshatguigu@192.168.188.131使用ssh访问，如访问出现错误。可查看是否有该文件～/.ssh/known_ssh尝试删除该文件解决。 •登出登出命令：exit或者logout 安装C++编译器打开终端输入sudo apt-get install build-essential 安装gcc和一些库函数。提供C/C++的编译环境 注意编译c++程序要用g++ 安装JDKhttps://blog.csdn.net/weixin_38924500/article/details/106215048 myLinux下rz/sz安装及使用方法能直接通过xshell拖拽文件到shell的当前目录 ubuntu 1apt-get install lrzsz 常见问题每次进入命令都要重新source /etc/profile 才能生效如java命令 1、也可以放在/.bashrc里面。或者在/.bashrc里面加一句source /etc/profile2、你可以把这几条命令写在 /etc/bash里面 就会自动执行了nohupnohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 nohup 是 no hang up 的缩写，就是不挂断的意思。 nohup命令： 如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。 在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。 案例 nohup command &gt; myout.file 2&gt;&amp;1 &amp; 在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ； 2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。 \\2. 0 22 * * * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py &gt; /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2&gt;&amp;1 这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中 ubuntu查看java安装路径和设置环境变量whereis java （java安装路径） which java （java执行路径） echo $JAVA_HOME（java环境变量） 环境变量路径 1echo $PATH","categories":[{"name":"note","slug":"note","permalink":"https://codeofli.github.io/categories/note/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://codeofli.github.io/tags/linux/"}]},{"title":"javaScript","slug":"js-note/javaScript/javaScript","date":"2019-11-12T02:18:21.000Z","updated":"2022-05-23T14:17:43.133Z","comments":true,"path":"2019/11/js-note/javaScript/javaScript/","link":"","permalink":"https://codeofli.github.io/2019/11/js-note/javaScript/javaScript/","excerpt":"github笔记下载地址[TOC]JavaScriptJavaScript负责页面中的的行为。 它是一门运行在浏览器端的脚本语言。 JavaScript MDN文档JS的编写的位置1.可以编写到标签的指定属性中 12&lt;button onclick=\"alert('hello');\"&gt;我是按钮&lt;/button&gt; &lt;a href=\"javascript:alert('aaa');\"&gt;超链接&lt;/a&gt;","text":"github笔记下载地址[TOC]JavaScriptJavaScript负责页面中的的行为。 它是一门运行在浏览器端的脚本语言。 JavaScript MDN文档JS的编写的位置1.可以编写到标签的指定属性中 12&lt;button onclick=\"alert('hello');\"&gt;我是按钮&lt;/button&gt; &lt;a href=\"javascript:alert('aaa');\"&gt;超链接&lt;/a&gt; 2.可以编写到script标签中 123&lt;script type=\"text/javascript\"&gt; //编写js代码 &lt;/script&gt; 3.可以将代码编写到外部的js文件中，然后通过标签将其引入 script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略 ,如果需要则可以在创建一个新的script标签用于编写内部代码 1&lt;script type=\"text/javascript\" src=\"文件路径\"&gt;&lt;/script&gt; 输出语句1alert(\"要输出的内容\"); 该语句会在浏览器窗口中弹出一个警告框 1document.write(\"要输出的内容\"); 该内容将会被写到body标签中，并在页面中显示 1console.log(\"要输出的内容\"); 该内容会被写到开发者工具的控制台中 基本的语法js函数声明不需要；分号，但是赋值语句要加；分号 123456function functionName(arg0,arg1,arg2)&#123; //函数声明 &#125; var functionName=function(arg0,arg1,arg2)&#123; //函数表达式 &#125;;(注意分号) 注释 单行注释 1//注释内容 多行注释 123/* 注释内容 */ JS严格区分大小写 JS中每条语句以分号(;)结尾如果不写分号，浏览器会自动添加，但是会消耗一些系统资源， 而且有些时候，浏览器会加错分号，所以在开发中分号必须写 JS中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。 字面量和变量字面量字面量实际上就是一些固定的值，比如 1 2 3 4 true false null NaN “hello”字面量都是不可以改变的。 由于字面量不是很方便使用，所以在JS中很少直接使用字面量 变量变量可以用来保存字面量，并且可以保存任意的字面量 一般都是通过变量来使用字面量，而不直接使用字面量，而且也可以通过变量来对字面量进行一个描述 声明变量 使用var关键字来声明一个变量 1var a; 为变量赋值 1a = 1; 声明和赋值同时进行 1var a = 456; 标识符在JS中所有的可以自主命名的内容，都可以认为是一个标识符，是标识符就应该遵守标识符的规范。 比如：变量名、函数名、属性名 规范：1.标识符中可以含有字母、数字、_、$2.标识符不能以数字开头3.标识符不能是JS中的关键字和保留字4.标识符一般采用驼峰命名法xxxYyyZzz 数据类型六种数据类型 JS中一共分成六种数据类型 5个基本数据类型+object String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 其中基本数据类型有 5个 typeof运算符检查数据类型 1.String 字符串JS中的字符串需要使用引号引起来双引号或单引号都行 在字符串中使用\\作为转义字符 12345\\' ==&gt; ' \\\" ==&gt; \" \\n ==&gt; 换行 \\t ==&gt; 制表符 \\\\ ==&gt; \\ 使用typeof运算符检查字符串时，会返回”string” 2.Number 数值 JS中所有的整数和浮点数都是Number类型 最大能表示的值：Number.MAX_VALUE= 1.7976931348623157e+308 特殊的数字：能赋值给变量 Infinity 正无穷 a = Infinity ,能赋值 -Infinity 负无穷 NaN 非法数字（Not A Number） 其他进制的数字的表示：0b 开头表示二进制，但是不是所有的浏览器都支持0 开头表示八进制0x 开头表示十六进制 使用typeof检查一个Number类型的数据时，会返回”number”（包括NaN 和 Infinity） 3.Boolean 布尔值 布尔值主要用来进行逻辑判断，布尔值只有两个 true 逻辑的真 false 逻辑的假 使用typeof检查一个布尔值时，会返回”boolean” 4.Null 空值 空值专门用来表示为空的对象，Null类型的值只有一个 null 使用typeof检查一个Null类型的值时会返回”object” 5.Undefined 未定义 如果声明一个变量但是没有为变量赋值此时变量的值就是undefined 该类型的值只有一个 undefined 使用typeof检查一个Undefined类型的值时，会返回”undefined” 引用数据类型 Object 对象 类型转换 类型转换就是指将其他的数据类型，转换为String Number 或 Boolean 转换为String方式一（强制类型转换）： 调用被转换数据的toString()方法 例子：var a = 123;a = a.toString(); 注意：这个方法不适用于null和undefined由于这两个类型的数据中没有方法，所以调用toString()时会报错 方式二（强制类型转换）： 调用String()函数 例子： 12var a = 123; a = String(a); 原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，对于null值，直接转换为字符串”null”。对于undefined直接转换为字符串”undefined” 方式三（隐式的类型转换）: 为任意的数据类型 +”” 例子： 12var a = true; a = a + \"\"; 原理：和String()函数一样 转换为Number方式一（强制类型转换）： 调用Number()函数 例子： 12var s = \"123\"; s = Number(s); 转换的情况： 字符串 &gt; 数字 如果字符串是一个合法的数字，则直接转换为对应的数字 如果字符串是一个非法的数字，则转换为NaN 如果是一个空串或纯空格的字符串，则转换为0 布尔值 &gt; 数字 true转换为1 false转换为0 空值 &gt; 数字 null转换为0 未定义 &gt; 数字 undefined 转换为NaN 方式二（强制类型转换）： 调用parseInt()或parseFloat() 这两个函数专门用来将一个字符串转换为数字的 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作 parseInt() 可以将一个字符串中的有效的整数位提取出来，并转换为Number 例子： 12var a = \"123.456px\"; a = parseInt(a); //123 如果需要可以在parseInt()中指定一个第二个参数，来指定进制parseFloat()可以将一个字符串中的有效的小数位提取出来，并转换为Number 例子： 12var a = \"123.456px\"; a = parseFloat(a); //123.456 方式三（隐式的类型转换）： 使用一元的+来进行隐式的类型转换 例子： 12var a = \"123\"; a = +a; 原理：和Number()函数一样 转换为布尔值方式一（强制类型转换）： 使用Boolean()函数 例子： 12var s = \"false\"; s = Boolean(s); //true 转换的情况字符串 &gt; 布尔 除了空串其余全是true 数值 &gt; 布尔 除了0和NaN其余的全是true null、undefined &gt; 布尔 都是false 对象 &gt; 布尔 都是true 方式二（隐式类型转换）： 为任意的数据类型做两次非运算，即可将其转换为布尔值 例子： 12var a = \"hello\"; a = !!a; //true 基础语法运算符 运算符也称为操作符 通过运算符可以对一个或多个值进行运算或操作 typeof运算符 用来检查一个变量的数据类型 语法：typeof 变量 它会返回一个用于描述类型的字符串作为结果 算数运算符 +&ensp;对两个值进行加法运算并返回结果 -&ensp;对两个值进行减法运算并返回结果 *&ensp;对两个值进行乘法运算并返回结果 /&ensp;对两个值进行除法运算并返回结果 （js的除法，不是c语言中的整除，因为数值用Number表示） %&ensp;对两个值进行取余运算并返回结果 除了加法以外，对非Number类型的值进行运算时，都会先转换为Number然后在做运算。而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。任何值和字符串做加法，都会先转换为字符串，然后再拼串 一元运算符 一元运算符只需要一个操作数 一元的+ 就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字 例子： 12var a = true; a = +a; 一元的- 就是负号，可以对一个数字进行符号位取反 例子： 12var a = 10; a = a; 自增 自增可以使变量在原值的基础上自增1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增1不同的是++a和a++的值是不同的， ++a的值是变量的新值（自增后的值） a++的值是变量的原值（自增前的值） 自减 自减可以使变量在原值的基础上自减1 自减使用 自减可以使用 前（a）后(a) 无论是a 还是 a都会立即使原变量自减1不同的是a和a的值是不同的， a的值是变量的新值（自减后的值） a的值是变量的原值（自减前的值） 逻辑运算符! 非运算可以对一个布尔值进行取反，true变false false边true 当对非布尔值使用!时，会先将其转换为布尔值然后再取反 我们可以利用!来将其他的数据类型转换为布尔值 &amp;&amp; &amp;&amp;可以对符号两侧的值进行与运算 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。 与是一个短路的与，如果第一个值是false，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为false，则返回第一个值 2.如果第一个值为true，则返回第二个值 || ||可以对符号两侧的值进行或运算 只有两端都是false时，才会返回false。只要有一个true，就会返回true。 或是一个短路的或，如果第一个值是true，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为true，则返回第一个值 2.如果第一个值为false，则返回第二个值 赋值运算符= 可以将符号右侧的值赋值给左侧变量+= 12a += 5 相当于 a = a+5 var str = \"hello\"; str += \"world\"; -= 1a -= 5 相当于 a = a-5 *= 1a *= 5 相当于 a = a*5 /= 1a /= 5 相当于 a = a/5 %= 1a %= 5 相当于 a = a%5 关系运算符 关系运算符用来比较两个值之间的大小关系的 &gt; &gt;= &lt; &lt;= 关系运算符的规则和数学中一致，用来比较两个值之间的关系， 如果关系成立则返回true，关系不成立则返回false。 如果比较的两个值是非数值，会将其转换为Number然后再比较。 如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。 相等运算符 相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false 相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，转换后相等它也会返回true，null == undifined != 不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false 不等也会做自动的类型转换。 === 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换， 如果两个值的类型不同，则直接返回false !== 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true 特殊的值： null和undefined 由于undefined衍生自null，所以null == undefined 会返回true。 但是 null === undefined 会返回false。NaN NaN不与任何值相等，报告它自身 NaN == NaN //false 判断一个值是否是NaN 使用isNaN()函数 三元运算符：?: 语法：条件表达式?语句1:语句2; 执行流程： 先对条件表达式求值判断， 如果判断结果为true，则执行语句1，并返回执行结果 如果判断结果为false，则执行语句2，并返回执行结果 优先级： 和数学中一样，JS中的运算符也是具有优先级的， 比如 先乘除 后加减 先与 后或 具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高， 优先级越高的越优先计算，优先级相同的，从左往右计算。 优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。 流程控制语句 程序都是自上向下的顺序执行的，通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。 条件分支语句 条件判断语句也称为if语句 语法一： 123if(条件表达式)&#123; 语句... &#125; 1234执行流程： if语句执行时，会先对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则不执行 语法二： 12345if(条件表达式)&#123; 语句... &#125;else&#123; 语句... &#125; 1234执行流程： if...else语句执行时，会对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则执行else后的语句 语法三： 1234567891011if(条件表达式)&#123; 语句... &#125;else if(条件表达式)&#123; 语句... &#125;else if(条件表达式)&#123; 语句... &#125;else if(条件表达式)&#123; 语句... &#125;else&#123; 语句... &#125; 12345执行流程 if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断， 如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。 如果判断结果为false，则继续向下判断，直到找到为true的为止。 如果所有的条件表达式都是false，则执行else后的语句 1.条件分支语句switch语句语法: 1234567891011switch(条件表达式)&#123; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; &#125; 执行流程： switch…case…语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较， 如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。 如果所有的case判断结果都为false，则从default处开始执行代码。 循环语句通过循环语句可以反复执行某些语句多次while循环 语法： 123while(条件表达式)&#123; 语句... &#125; 执行流程： while语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为false，则终止循环 如果判断结果为true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do…while循环 语法: 123do&#123; 语句... &#125;while(条件表达式) 执行流程 do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断， 如果判断判断结果为false，则终止循环。 如果判断结果为true，则继续执行循环体，依此类推 和while的区别： while：先判断后执行 do…while: 先执行后判断 do…while可以确保循环体至少执行一次。 for循环 语法： 123for(①初始化表达式 ; ②条件表达式 ; ④更新表达式)&#123; ③语句... &#125; 执行流程： 首先执行①初始化表达式，初始化一个变量， 然后对②条件表达式进行求值判断，如果为false则终止循环 如果判断结果为true，则执行③循环体 循环体执行完毕，执行④更新表达式，对变量进行更新。 更新表达式执行完毕重复② 死循环 1234567while(true)&#123; &#125; for(;;)&#123; &#125; 对象（Object）对象是JS中的引用数据类型对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性使用typeof检查一个对象时，会返回object 对象的分类：1.内建对象 - 由ES标准中定义的对象，在任何的ES的实现中都可以使用 - 比如：Math String Number Boolean Function Object…. 2.宿主对象 - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象 - 比如 BOM DOM 3.自定义对象 - 由开发人员自己创建的对象 创建对象 方式一： 1var obj = new Object(); 方式二： 1var obj = &#123;&#125;; 向对象中添加属性 语法： 对象.属性名 = 属性值; 对象[“属性名”] = 属性值; //这种方式能够使用特殊的属性名 对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。属性值也可以任意的数据类型。 读取对象中的属性 语法： 对象.属性名 对象[“属性名”] //“属性名”可以使字符串常量，也可以是字符串变量 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined 删除对象中的属性 语法： 12delete 对象.属性名 delete 对象[\"属性名\"] 遍历使用in检查对象中是否含有指定属性 语法：”属性名” in 对象 如果在对象中含有该属性，则返回true 如果没有则返回false 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性). 12345var obj = &#123;'0':'a','1':'b','2':'c'&#125;; for(var i in obj) &#123; console.log(i,\":\",obj[i]); &#125; ​使用对象字面量，在创建对象时直接向对象中添加属性语法： 12345var obj = &#123; 属性名:属性值, 属性名:属性值, 属性名:属性值&#125; 基本数据类型和引用数据类型 基本数据类型 String Number Boolean Null Undefined 引用数据类型 Object 基本数据类型的数据，变量是直接保存的它的值。 变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。 引用数据类型的数据，变量是保存的对象的引用（内存地址）。 如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。 比较两个变量时，对于基本数据类型，比较的就是值， 对于引用数据类型比较的是地址，地址相同才相同 函数（Function）函数也是一个对象，也具有普通对象的功能（能有属性）函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码使用typeof检查一个函数时会返回function创建函数 函数声明 123function 函数名([形参1,形参2...形参N])&#123; 语句... &#125; 函数表达式 123var 函数名 = function([形参1,形参2...形参N])&#123; 语句... &#125;; 调用函数 语法：函数对象([实参1,实参2…实参N]); fun() sum() alert() Number() parseInt() 当我们调用函数时，函数中封装的代码会按照编写的顺序执行 立即执行函数函数定义完，立即被调用，这种函数叫做立即执行函数立即执行函数往往只会执行一次 1234(function(a,b)&#123; console.log(\"a = \"+a); console.log(\"b = \"+b); &#125;)(123,456); 遍历对象 123for(var v in obj)&#123; document.write(\"property：name =\"+v+\"value=\"+obj[v]+\"&lt;br/&gt;\" ); &#125; 形参和实参 形参：形式参数 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开 定义形参就相当于在函数内声明了对应的变量但是并不赋值， 形参会在调用时才赋值。 实参：实际参数 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参, 调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。 如果实参的数量大于形参，多余实参将不会赋值， 如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined 返回值，就是函数执行的结果。 使用return 来设置函数的返回值。 语法：return 值; 该值就会成为函数的返回值，可以通过一个变量来接收返回值 return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。 return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。 如果return后不跟值，或者是不写return则函数默认返回undefined。 break、continue和return break 退出循环 continue 跳过当次循环 return 退出函数 参数，函数的实参也可以是任意的数据类型。 方法（method） 可以将一个函数设置为一个对象的属性， 当一个对象的属性是一个函数时， 我们称这个函数是该对象的方法。 对象.方法名(); 函数名() 函数的属性和方法call()apply() 这两个方法都是函数对象的方法需要通过函数对象来调用 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递arguments arguments和this类似，都是函数中的隐含的参数 arguments是一个类数组元素，它用来封装函数执行过程中的实参 所以即使不定义形参，也可以通过arguments来使用实参 arguments中有一个属性callee表示当前执行的函数对象 this（调用函数的那个对象） this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象 1.以函数的形式调用时，this是window 2.以方法的形式调用时，this是调用方法的对象 3.以构造函数的形式调用时，this是新建的那个对象 4.使用call和apply调用时，this是指定的那个对象 5.在全局作用域中this代表window 作用域作用域简单来说就是一个变量的作用范围。在JS中作用域分成两种： 1.全局作用域 直接在script标签中编写的代码都运行在全局作用域中全局作用域在打开页面时创建，在页面关闭时销毁。全局作用域中有一个全局对象window，window对象由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口。在全局作用域中创建的变量都会作为window对象的属性保存在全局作用域中创建的函数都会作为window对象的方法保存在全局作用域中创建的变量和函数可以在页面的任意位置访问。在函数作用域中也可以访问到全局作用域的变量。尽量不要在全局中创建变量 2.函数作用域 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。函数作用域在函数执行时创建，在函数执行结束时销毁。在函数作用域中创建的变量，不能在全局中访问。当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，如果找到了则使用，找不到则继续向上找，一直会 变量的声明提前 在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。 所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。 在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明， 如果没有使用var关键字声明变量，则变量会变成全局变量 函数的声明提前 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建， 也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。 this（上下文对象）我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。 指向当前对象 this的不同的情况：1.以函数的形式调用时，this是window2.以方法的形式调用时，this就是调用方法的对象3.以构造函数的形式调用时，this就是新创建的对象 4.构造函数构造函数是专门用来创建对象的函数一个构造函数我们也可以称为一个类通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例通过同一个构造函数创建的对象，我们称为一类对象构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数如果使用new来调用，则它就是一个构造函数 例子： 12345678function Person(name , age , gender)&#123; this.name = name; this.age = age; this.gender = gender; this.sayName = function()&#123; alert(this.name); &#125;; &#125; 构造函数的执行流程：1.创建一个新的对象2.将新的对象作为函数的上下文对象（this）3.执行函数中的代码4.将新建的对象返回 instanceof 用来检查一个对象是否是一个类的实例 语法：对象 instanceof 构造函数 如果该对象时构造函数的实例，则返回true，否则返回false Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true 枚举对象中的属性for…in语法： 123for(var 属性名 in 对象)&#123; &#125; for…in语句的循环体会执行多次，对象中有几个属性就会执行几次， 每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性 原型（prototype）所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法： Date 对象从 Date.prototype 继承。 Array 对象从 Array.prototype 继承。 Person 对象从 Person.prototype 继承。 所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。 JavaScript 对象有一个指向一个原型对象的链。 创建一个函数以后，解析器都会默认在函数中添加一个数prototype prototype属性指向的是一个对象，这个对象我们称为原型对象。 当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。 1这个隐含的属性可以通过对象.__proto__来访问。 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。 我们可以将对象中共有的属性和方法统一添加到原型对象中，这样我们只需要添加一次，就可以使所有的对象都可以使用。 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 Date 对象, Array 对象, 以及 Person 对象从 Object.prototype 继承。 添加属性和方法使用 prototype 属性就可以给对象的构造函数添加新的属性和方法。 有的时候我们想要在所有已经存在的对象添加新的属性或方法。 另外，有时候我们想要在对象的构造函数中添加属性或方法。 使用 prototype 属性就可以给对象的构造函数添加新的属性： 12345678function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125; Person.prototype.nationality = \"English\"; 当然我们也可以使用 prototype 属性就可以给对象的构造函数添加新的方法： 12345678910function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125; Person.prototype.name = function() &#123; return this.firstName + \" \" + this.lastName;&#125;; hasOwnProperty() 这个方法可以用来检查对象自身中是否含有某个属性 语法：对象.hasOwnProperty(“属性名”) toString方法当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值 如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法 1234//修改Person原型的toString Person.prototype.toString = function()&#123; return \"Person[name=\"+this.name+\",age=\"+this.age+\",gender=\"+this.gender+\"]\"; &#125;; 垃圾回收（GC）就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作我们需要做的只是要将不再使用的对象设置null即可 数组（Array） 数组也是一个对象，是一个用来存储数据的对象和Object类似，但是它的存储效率比普通对象要高 数组中保存的内容我们称为元素 数组使用索引（index）来操作元素 索引指由0开始的整数 数组的操作： 创建数组 12var arr = new Array(); var arr = []; 向数组中添加元素语法:数组对象[索引] = 值; 12arr[0] = 123; arr[1] = \"hello\"; 创建数组时直接添加元素 语法： 1var arr = [元素1,元素2....元素N]; 例子： 1var arr = [123,\"hello\",true,null]; 获取和修改数组的长度 使用length属性来操作数组的长度 获取长度： 数组.length length获取到的是数组的最大索引+1 对于连续的数组，length获取到的就是数组中元素的个数 修改数组的长度 数组.length = 新长度 如果修改后的length大于原长度，则多出的部分会空出来 如果修改后的length小于原长度，则原数组中多出的元素会被删除 向数组的最后添加元素 数组[数组.length] = 值; 数组的方法 functionName function usage push() 用来向数组的末尾添加一个或多个元素，并返回数组新的长度 语法：数组.push(元素1,元素2,元素N)pop() pop() 用来删除数组的最后一个元素，并返回被删除的元素 unshift() 向数组的开头添加一个或多个元素，并返回数组的新的长度 shift() 删除数组的开头的一个元素，并返回被删除的元素 reverse() 可以用来反转一个数组，它会对原数组产生影响 concat() 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回 slice() 选择数组的一部分，并返回新数组。 slice(sart,[end])定义和用法slice() 方法以新的数组对象，返回数组中被选中的元素。 slice() 方法选择从给定的 start 参数开始的元素，并在给定的 end 参数处结束，但不包括。 注释： slice() 方法不会改变原始数组。 123var fruits = [\"Banana\", \"Orange\", \"Lemon\", \"Apple\", \"Mango\"];var citrus = fruits.slice(1, 3);//citrus: Orange,Lemon splice()可以用来删除数组中指定元素，并使用新的元素替换 该方法会将删除的元素封装到新数组中返回 参数： 1.删除开始位置的索引 2.删除的个数 3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边 join([splitor]) 可以将一个数组转换为一个字符串 参数： 需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素 如果不指定连接符则默认使用, sort() 可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序 调用以后，会直接修改原数组。 可以自己指定排序的规则，需要一个回调函数作为参数： 我们可以自己来指定排序的规则我们可以在sort()添加一个回调函数，来指定排序规则， 回调函数中需要定义两个形参, 浏览器将会分别使用数组中的元素作为实参去调用回调函数 使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边 浏览器会根据回调函数的返回值来决定元素的顺序， 如果返回一个大于0的值，则元素会交换位置 如果返回一个小于0的值，则元素位置不变 如果返回一个0，则认为两个元素相等，也不交换位置 如果需要升序排列，则返回 a-b 如果需要降序排列，则返回b-a 1234567function(a,b)&#123; //升序排列 //return a-b; //降序排列 return b-a; &#125; 遍历数组 遍历数组就是将数组中元素都获取到 一般情况我们都是使用for循环来遍历数组 123for(var i=0 ; i&lt;数组.length ; i++)&#123; //数组[i] &#125; 使用forEach()方法来遍历数组（不兼容IE8） 123数组.forEach(function(value , index , obj)&#123; &#125;); forEach()方法需要一个回调函数作为参数，数组中有几个元素，回调函数就会被调用几次，每次调用时，都会将遍历到的信息以实参的形式传递进来，我们可以定义形参来获取这些信息。value:正在遍历的元素index:正在遍历元素的索引obj:被遍历对象 js获取数组中最大值1.es6拓展运算符… 1Math.max(...arr) 2.es5 apply(与方法1原理相同) 1Math.max.apply(null,arr) 3.for循环 1234let max = arr[0];for (let i = 0; i &lt; arr.length - 1; i++) &#123; max = max &lt; arr[i+1] ? arr[i+1] : max&#125; 常用类和方法包装类在JS中为我们提供了三个包装类：String() Boolean() Number() 通过这三个包装类可以创建基本数据类型的对象例子： 123var num = new Number(2); var str = new String(\"hello\"); var bool = new Boolean(true); 但是在实际应用中千万不要这么干。 当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，操作完成以后再将这个临时对象进行销毁。 Date日期的对象，在JS中通过Date对象来表示一个时间创建对象 创建一个当前的时间对象 1var d = new Date(); 创建一个指定的时间对象 1var d = new Date(\"月/日/年 时:分:秒\"); 方法： name getDate() 当前日期对象是几日（1-31） getDay() 返回当前日期对象时周几（0-6） 0 周日 1 周一 。。。 getMonth() 返回当前日期对象的月份（0-11） 0 一月 1 二月 。。。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回当前日期对象的时间戳 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数 计算机底层保存时间都是以时间戳的形式保存的。 Date.now() 可以获取当前代码执行时的时间戳 setHours() 设置 Date 对象中的小时 (0 ~ 23) MathMath属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法我们可以直接使用它来进行数学运算相关的操作方法：Math.PI 常量，圆周率Math.abs() 绝对值运算Math.ceil() 向上取整Math.floor() 向下取整Math.round() 四舍五入取整Math.random() 生成一个01之间的随机数 生成一个xy之间的随机数 Math.round(Math.random()*(y-x)+x);Math.pow(x,y) 求x的y次幂Math.sqrt() 对一个数进行开方Math.max() 求多个数中最大值Math.min() 求多个数中的最小值 Map 对象Map 对象存有键值对，其中的键可以是任何数据类型。 Map 对象记得键的原始插入顺序。 Map 对象具有表示映射大小的属性。 https://www.w3school.com.cn/js/js_object_maps.asp 字符串的相关的方法使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； length 获取字符串的长度 charAt() 根据索引获取指定的字符 charCodeAt() 根据索引获取指定的字符编码 String.fromCharCode() 根据字符编码获取字符 indexOf() lastIndexOf() 从一个字符串中检索指定内容 需要一个字符串作为参数，这个字符串就是要检索的内容， 如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。 可以指定一个第二个参数，来表示开始查找的位置 indexOf()是从前向后找 lastIndexOf()是从后向前找 slice(start,[end]) 可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量 参数： 第一个：截取开始的位置（包括开始） 第二个：截取结束的位置**（不包括结束）** 可以省略第二个参数，如果省略则一直截取到最后 可以传负数，如果是负数则从后往前数 substr() 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量 substring() 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0， substring()中如果第二个参数小于第一个，自动调整位置 toLowerCase() 将字符串转换为小写并返回 toUpperCase() 将字符串转换为大写并返回 正则表达相关方法split() 可以根据指定内容将一个字符串拆分为一个数组 参数： 需要一个字符串作为参数，将会根据字符串去拆分数组 可以接收一个正则表达式，此时会根据正则表达式去拆分数组 match() 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来 默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索 我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容 可以为一个正则表达式设置多个匹配模式，且顺序无所谓 match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果 replace() 可以将字符串中指定内容替换为新的内容 参数： 1.被替换的内容，可以接受一个正则表达式作为参数 2.新的内容 空串则为删除”” 默认只会替换第一个 search() 可以搜索字符串中是否含有指定内容 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回1 它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串 serach()只会查找第一个，即使设置全局匹配也没用 正则表达式正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，也可以将一个字符串中符合规则的内容提取出来。创建正则表达式 1var reg = new RegExp(\"正则\",\"匹配模式\"); 注意：使用构造函数时，由于它的参数是一个字符串，而\\是字符串中转义字符，如果要使用\\则需要使用\\\\来代替 var reg = /正则表达式/匹配模式 （匹配模式可以多个一起写：/gi） 语法：匹配模式： i:忽略大小写（ignore） g:全局匹配模式（默认为1次） 设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求 正则语法 | 或 [] 或 [^ ] 除了 [x-y] x的ascii到y的ascii码之间的值 [a-z] 小写字母 （也可以其中一部分，如[e-i])[A-Z] 大写字母[A-Za-z] 任意字母[0-9] 任意数字 元符号检查一个字符串中是否含有 . . 表示任意字符 在正则表达式中使用\\作为转义字符 . 来表示. \\ 表示\\ \\w (w-&gt;word)匹配包括下划线的任何单词字符，任意字母、数字、_ ，== [a-zA-Z_0-9] \\W ,匹配任何非单词字符,除了字母、数字、_ [ ^[a-zA-Z_0-9]] \\d (d-&gt;digit) 任意的数字 [0-9] \\D 除了数字 [ ^0-9] \\s (s-&gt;space) 空格 \\S 除了空格 \\b (b-&gt; boundary)单词边界 \\B 除了单词边界 小写字母包括，大写字母取反。 量词​ 通过量词可以设置一个内容出现的次数​ 量词只对它前边的一个内容起作用​ {n} 正好出现n次​ {m,n} 出现mn次​ {m,} m次以上 +至少一个，相当于{1,} *个或多个，相当于{0,} ? 0个或1个，相当于{0,1} 边界表达式（java中不能使用）​ ^:正则开始​ $:正则结束 ：注意结束前一个才是结束匹配 12reg = /^a/; reg = /b$/; 方法：test() 可以用来检查一个字符串是否符合正则表达式 如果符合返回true，否则返回false例子 去掉两端的空格: 12var s = \" f afa \"; s = s.replace(/^\\s*|\\s*$/g,\"\"); DOM,Document Object Model文档对象模型，通过DOM可以来任意来修改网页中各个内容 文档 文档指的是网页，一个网页就是一个文档 对象 对象指将网页中的每一个节点都转换为对象 转换完对象以后，就可以以一种纯面向对象的形式来操作网页了 模型 模型用来表示节点和节点之间的关系，方便操作页面 节点（Node） 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点 虽然都是节点，但是节点的类型却是不同的 常用的节点 文档节点 （Document），代表整个网页 元素节点（Element），代表网页中的标签 属性节点（Attribute），代表标签中的属性 文本节点（Text），代表网页中的文本内容 DOM操作 DOM查询 在网页中浏览器已经为我们提供了document对象， 它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。 document查询方法： 根据元素的id属性查询一个元素节点对象： document.getElementById(“id属性值”); 根据元素的name属性值查询一组元素节点对象: document.getElementsByName(“name属性值”); 根据标签名来查询一组元素节点对象： document.getElementsByTagName(“标签名”); 元素的属性： 读取元素的属性： 语法：元素.属性名 例子：ele.name ele.id ele.value ele.className 注意：class属性不能采用这种方式， 读取class属性时需要使用 元素.className 修改元素的属性： 语法：元素.属性名 = 属性值 innerHTML 使用该属性可以获取或设置元素内部的HTML代码 事件（Event） 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。 我们可以为事件来绑定回调函数来响应事件。 绑定事件的方式： 1.可以在标签的事件属性中设置相应的JS代码 例子： 1&lt;button onclick=\"js代码。。。\"&gt;按钮&lt;/button&gt; 2.可以通过为对象的指定事件属性设置回调函数的形式来处理事件 例子： 1234567&lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(\"btn\"); btn.onclick = function()&#123; &#125;; &lt;/script&gt; 文档的加载 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载， 此时将会无法正常获取到DOM对象，导致DOM操作失败。 解决方式一： 可以将js代码编写到body的下边 12345678910&lt;body&gt; &lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(\"btn\"); btn.onclick = function()&#123; &#125;; &lt;/script&gt; &lt;/body&gt; 解决方式二： 将js代码编写到window.onload = function(){}中 window.onload 对应的回调函数会在整个页面加载完毕以后才执行， 所以可以确保代码执行时，DOM对象已经加载完毕了 1234567&lt;script&gt; window.onload = function()&#123; var btn = document.getElementById(\"btn\"); btn.onclick = function()&#123; &#125;; &#125;; &lt;/script&gt; DOM查询通过具体的元素节点来查询元素.getElementsByTagName()通过标签名查询当前元素的指定后代元素 子节点包括便签元素中的文本，子元素自包含标签元素 元素.childNodes 获取当前元素的所有子节点 会获取到空白的文本子节点 childNodes属性会获取包括文本节点在呢的所有节点 根据DOM标签标签间空白也会当成文本节点 注意：在IE8及以下的浏览器中，不会将空白文本当成子节点， 所以该属性在IE8中会返回4个子元素而其他浏览器是9个 元素.children 获取当前元素的所有子元素 元素.firstChild 获取当前元素的第一个子节点，会获取到空白的文本子节点 元素.lastChild 获取当前元素的最后一个子节点 元素.parentNode 获取当前元素的父元素 元素.previousSibling 获取当前元素的前一个兄弟节点 previousElementSibling获取前一个兄弟元素，IE8及以下不支持 元素.nextSibling 获取当前元素的后一个兄弟节点 firstElementChild获取当前元素的第一个子元素 firstElementChild不支持IE8及以下的浏览器， 如果需要兼容他们尽量不要使用 innerHTML和innerText这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性两个属性作用类似，都可以获取到标签内部的内容，不同是innerHTML会获取到html标签，而innerText会自动去除标签如果使用这两个属性来设置标签内部的内容时，没有任何区别的 读取标签内部的文本内容 h1中的文本内容 元素.firstChild.nodeValue document对象的其他的属性和方法document.all 获取页面中的所有元素，相当于document.getElementsByTagName(“*”); document.documentElement 获取页面中html根元素 document.body 获取页面中的body元素 document.getElementsByClassName() 根据元素的class属性值查询一组元素节点对象 这个方法不支持IE8及以下的浏览器 document.querySelector() 根据CSS选择器去页面中查询一个元素 如果匹配到的元素有多个，则它会返回查询到的第一个元素 document.querySelectorAll() 根据CSS选择器去页面中查询一组元素 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个 DOM修改document.createElement(“TagName”) 可以用于创建一个元素节点对象， 它需要一个标签名作为参数，将会根据该标签名创建元素节点对象， 并将创建好的对象作为返回值返回document.createTextNode(“textContent”)可以根据文本内容创建一个文本节点对象 父节点.appendChild(子节点) 向父节点中添加指定的子节点父节点.insertBefore(新节点,旧节点) 将一个新的节点插入到旧节点的前边父节点.replaceChild(新节点,旧节点) 使用一个新的节点去替换旧节点 父节点.removeChild(子节点) 删除指定的子节点 推荐方式：子节点.parentNode.removeChild(子节点) 以上方法，实际就是改变了相应元素（标签）的innerHTML的值。 123456789101112131415161718myClick(\"btn07\",function()&#123; //向city中添加广州 var city = document.getElementById(\"city\"); /* * 使用innerHTML也可以完成DOM的增删改的相关操作 * 一般我们会两种方式结合使用 */ //city.innerHTML += \"&lt;li&gt;广州&lt;/li&gt;\"; //创建一个li var li = document.createElement(\"li\"); //向li中设置文本 li.innerHTML = \"广州\"; //将li添加到city中 city.appendChild(li); &#125;); DOM对CSS的操作读取和修改内联样式使用style属性来操作元素的内联样式 读取内联样式： 语法：元素.style.样式名例子： 元素.style.width 元素.style.height 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法将-去掉，然后后的字母改大写 比如：backgroundcolor &gt; backgroundColor borderwidth &gt; borderWidth修改内联样式：语法：元素.style.样式名 = 样式值 通过style修改和读取的样式都是内联样式，由于内联样式的优先级比较高， 所以我们通过JS来修改的样式，往往会立即生效， 但是如果样式中设置了!important，则内联样式将不会生效。 读取元素的当前样式正常浏览器 使用getComputedStyle() 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式 参数： 1.要获取样式的元素 2.可以传递一个伪元素，一般传null 例子： 获取元素的宽度 getComputedStyle(box , null)[“width”]; 通过该方法读取到样式都是只读的不能修改 IE8 使用currentStyle 语法： 元素.currentStyle.样式名 例子： box.currentStyle[“width”] 通过这个属性读取到的样式是只读的不能修改 实现兼容性 //对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错 1234567891011121314151617/* * 定义一个函数，用来获取指定元素的当前的样式 * 参数： * obj 要获取样式的元素 * name 要获取的样式名 */ function getStyle(obj , name)&#123; //对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错 if(window.getComputedStyle)&#123; //正常浏览器的方式，具有getComputedStyle()方法 return getComputedStyle(obj , null)[name]; &#125;else&#123; //IE8的方式，没有getComputedStyle()方法 return obj.currentStyle[name]; &#125; //return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name]; &#125; 其他的样式相关的属性注意：以下样式都是只读的,未指明偏移量都是相对于当前窗口左上角 clientHeight 元素的可见高度，包括元素的内容区和内边距的高度clientWidth 元素的可见宽度，包括元素的内容区和内边距的宽度offsetHeight 整个元素的高度，包括内容区、内边距、边框offfsetWidth 整个元素的宽度，包括内容区、内边距、边框offsetParent 当前元素的定位父元素 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回bodyoffsetLeftoffsetTop 当前元素和定位父元素之间的偏移量 offsetLeft水平偏移量 offsetTop垂直偏移量 scrollHeightscrollWidth 获取元素滚动区域的高度和宽度 scrollTopscrollLeft 获取元素垂直和水平滚动条滚动的距离 判断滚动条是否滚动到底 垂直滚动条 scrollHeight -scrollTop = clientHeight 水平滚动 scrollWidth -scrollLeft = clientWidth 事件（Event）事件对象当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。 可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存 例子： 12345678元素.事件 = function(event)&#123; event = event || window.event; &#125;; 元素.事件 = function(e)&#123; e = e || event; &#125;; 获取到鼠标的坐标 clientX和clientY 用于获取鼠标在当前的可见窗口的坐标 div的偏移量，是相对于整个页面的 pageX和pageY 可以获取鼠标相对于当前页面的坐标 但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用var left = event.clientX;var top = event.clientY; 事件的冒泡（Bubble） 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消 可以将事件对象的cancelBubble设置为true，即可取消冒泡 例子： 1234元素.事件 = function(event)&#123; event = event || window.event; event.cancelBubble = true; &#125;; 事件的委派 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能 我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的我们可以尝试将其绑定给元素的共同的祖先元素 target : event中的target表示的触发事件的对象 事件的绑定addEventListener() 通过这个方法也可以为元素绑定响应函数参数： 1.事件的字符串，不要on 2.回调函数，当事件触发时该函数会被调用 3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行 这个方法不支持IE8及以下的浏览器 1234567btn01.addEventListener(\"click\",function()&#123; alert(1); &#125;,false); btn01.addEventListener(\"click\",function()&#123; alert(2); &#125;,false); attachEvent() 在IE8中可以使用attachEvent()来绑定事件参数： 1.事件的字符串，要on 2.回调函数 这个方法也可以同时为一个事件绑定多个处理函数， 不同的是它是后绑定先执行，执行顺序和addEventListener()相反 1234567btn01.attachEvent(\"onclick\",function()&#123; alert(1); &#125;); btn01.attachEvent(\"onclick\",function()&#123; alert(2); &#125;); 12345678910111213141516171819202122232425262728//定义一个函数，用来为指定元素绑定响应函数 /* * addEventListener()中的this，是绑定事件的对象 * attachEvent()中的this，是window * 需要统一两个方法this */ /* * 参数： * obj 要绑定事件的对象 * eventStr 事件的字符串(不要on) * callback 回调函数 */ function bind(obj , eventStr , callback)&#123; if(obj.addEventListener)&#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr , callback , false); &#125;else&#123; /* * this是谁由调用方式决定 * callback.call(obj) */ //IE8及以下 obj.attachEvent(\"on\"+eventStr , function()&#123; //在匿名函数中调用回调函数 callback.call(obj); &#125;); &#125; &#125; 事件的传播 关于事件的传播网景公司和微软公司有不同的理解 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件， 然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件， 然后在向内传播给后代元素 W3C综合了两个公司的方案，将事件传播分成了三个阶段 1.捕获阶段 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件 2.目标阶段 事件捕获到目标元素，捕获结束开始在目标元素上触发事件 3.冒泡阶段 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true 一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false IE8及以下的浏览器中没有捕获阶段 常用事件鼠标事件拖拽事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #box1&#123; width: 100px; height: 100px; background-color: red; position: absolute; &#125; #box2&#123; width: 100px; height: 100px; background-color: yellow; position: absolute; left: 200px; top: 200px; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; /* * 拖拽box1元素 * - 拖拽的流程 * 1.当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown * 2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove * 3.当鼠标松开时，被拖拽元素固定在当前位置 onmouseup */ //获取box1 var box1 = document.getElementById(\"box1\"); var box2 = document.getElementById(\"box2\"); var img1 = document.getElementById(\"img1\"); //开启box1的拖拽 drag(box1); //开启box2的 drag(box2); drag(img1); &#125;; /* * 提取一个专门用来设置拖拽的函数 * 参数：开启拖拽的元素 */ function drag(obj)&#123; //当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown obj.onmousedown = function(event)&#123; //设置box1捕获所有鼠标按下的事件 /* * setCapture() * - 只有IE支持，但是在火狐中调用时不会报错， * 而如果使用chrome调用，会报错 */ /*if(box1.setCapture)&#123; box1.setCapture(); &#125;*/ obj.setCapture &amp;&amp; obj.setCapture(); event = event || window.event; //div的偏移量 鼠标.clentX - 元素.offsetLeft //div的偏移量 鼠标.clentY - 元素.offsetTop var ol = event.clientX - obj.offsetLeft; var ot = event.clientY - obj.offsetTop; //为document绑定一个onmousemove事件 document.onmousemove = function(event)&#123; event = event || window.event; //当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove //获取鼠标的坐标 var left = event.clientX - ol; var top = event.clientY - ot; //修改box1的位置 obj.style.left = left+\"px\"; obj.style.top = top+\"px\"; &#125;; //为document绑定一个鼠标松开事件 document.onmouseup = function()&#123; //当鼠标松开时，被拖拽元素固定在当前位置 onmouseup //取消document的onmousemove事件 document.onmousemove = null; //取消document的onmouseup事件 document.onmouseup = null; //当鼠标松开时，取消对事件的捕获 obj.releaseCapture &amp;&amp; obj.releaseCapture(); &#125;; /* * 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容， * 此时会导致拖拽功能的异常，这个是浏览器提供的默认行为， * 如果不希望发生这个行为，则可以通过return false来取消默认行为 * * 但是这招对IE8不起作用 */ return false; &#125;; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 我是一段文字 &lt;div id=\"box1\"&gt;&lt;/div&gt; &lt;div id=\"box2\"&gt;&lt;/div&gt; &lt;img src=\"img/an.jpg\" id=\"img1\" style=\"position: absolute;\"/&gt; &lt;/body&gt; &lt;/html&gt; 滚轮事件： onwheel都支持 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #box1&#123; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; //获取id为box1的div var box1 = document.getElementById(\"box1\"); //为box1绑定一个鼠标滚轮滚动的事件 /* * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发， * 但是火狐不支持该属性 * * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件 * 注意该事件需要通过addEventListener()函数来绑定 */ box1.onmousewheel = function(event)&#123; event = event || window.event; //event.wheelDelta 可以获取鼠标滚轮滚动的方向 //向上滚 120 向下滚 -120 //wheelDelta这个值我们不看大小，只看正负 //alert(event.wheelDelta); //wheelDelta这个属性火狐中不支持 //在火狐中使用event.detail来获取滚动的方向 //向上滚 -3 向下滚 3 //alert(event.detail); /* * 当鼠标滚轮向下滚动时，box1变长 * 当滚轮向上滚动时，box1变短 */ //判断鼠标滚轮滚动的方向 if(event.wheelDelta &gt; 0 || event.detail &lt; 0)&#123; //向上滚，box1变短 box1.style.height = box1.clientHeight - 10 + \"px\"; &#125;else&#123; //向下滚，box1变长 box1.style.height = box1.clientHeight + 10 + \"px\"; &#125; /* * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false * 需要使用event来取消默认行为event.preventDefault(); * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错 */ event.preventDefault &amp;&amp; event.preventDefault(); /* * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动， * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为 */ return false; &#125;; //为火狐绑定滚轮事件 bind(box1,\"DOMMouseScroll\",box1.onmousewheel); &#125;; function bind(obj , eventStr , callback)&#123; if(obj.addEventListener)&#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr , callback , false); &#125;else&#123; /* * this是谁由调用方式决定 * callback.call(obj) */ //IE8及以下 obj.attachEvent(\"on\"+eventStr , function()&#123; //在匿名函数中调用回调函数 callback.call(obj); &#125;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body style=\"height: 2000px;\"&gt; &lt;div id=\"box1\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 键盘事件键盘事件：onkeydown 按键被按下 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生。onkeyup 按键被松开 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document keyCode 可以通过keyCode来获取按键的编码通过它可以判断哪个按键被按下除了keyCode，事件对象中还提供了几个属性altKeyctrlKeyshiftKey这个三个用来判断alt ctrl 和 shift是否被按下如果按下则返回true，否则返回false 1234567//console.log(event.keyCode); //判断一个y是否被按下 //判断y和ctrl是否同时被按下 if(event.keyCode === 89 &amp;&amp; event.ctrlKey)&#123; console.log(\"ctrl和y都被按下了\"); &#125; 12345678910input.onkeydown = function(event) &#123; event = event || window.event; //数字 48 - 57 //使文本框中不能输入数字 if(event.keyCode &gt;= 48 &amp;&amp; event.keyCode &lt;= 57) &#123; //在文本框中输入内容，属于onkeydown的默认行为 //如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中 return false; &#125; &#125;; BOM，browser object model浏览器对象模型() BOM可以使我们通过JS来操作浏览器在BOM中为我们提供了一组对象，用来完成对浏览器的操作BOM对象 Window 代表的是整个浏览器的窗口，同时window也是网页中的全局对象 Navigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 Location 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面 History 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页 而且该操作只在当次访问时有效 Screen 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用 Navigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了 一般我们只会使用userAgent来判断浏览器的信息， userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容， 不同的浏览器会有不同的userAgent 火狐的userAgentMozilla5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko20100101 Firefox50.0 Chrome的userAgentMozilla5.0 (Windows NT 6.1; Win64; x64) AppleWebKit537.36 (KHTML, like Gecko) Chrome52.0.2743.82 Safari537.36 IE8Mozilla4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE9Mozilla5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE10Mozilla5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE11Mozilla5.0 (Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko 在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了 123456789101112131415alert(navigator.appName); var ua = navigator.userAgent; console.log(ua); if(firefoxi.test(ua))&#123; alert(\"你是火狐！！！\"); &#125;else if(chromei.test(ua))&#123; alert(\"你是Chrome\"); &#125;else if(msiei.test(ua))&#123; alert(\"你是IE浏览器~~~\"); &#125;else if(\"ActiveXObject\" in window)&#123; alert(\"你是IE11，枪毙了你~~~\"); &#125; History 对象可以用来操作浏览器向前或向后翻页 length 属性，可以获取到当成访问的链接数量 back() 可以用来回退到上一个页面，作用和浏览器的回退按钮一样 forward() 可以跳转下一个页面，作用和浏览器的前进按钮一样 go() 可以用来跳转到指定的页面 它需要一个整数作为参数 1:表示向前跳转一个页面 相当于forward() 2:表示向前跳转两个页面 -1:表示向后跳转一个页面 -2:表示向后跳转两个页面 Location 该对象中封装了浏览器的地址栏的信息如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）alert(location);如果直接将location属性修改为一个完整的路径，或相对路径则我们页面会自动跳转到该路径，并且会生成相应的历史记录location = “http:www.baidu.com&quot;;location = “01.BOM.html”;assign() 用来跳转到其他的页面，作用和直接修改location一样reload() 用于重新加载当前页面，作用和刷新按钮一样 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面location.reload(true);replace() 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面 不会生成历史记录，不能使用回退按钮回退 window定时器setInterval() 定时调用 可以将一个函数，每隔一段时间执行一次 参数： 1.回调函数，该函数会每隔一段时间被调用一次 2.每次调用间隔的时间，单位是毫秒 返回值： 返回一个Number类型的数据 这个数字用来作为定时器的唯一标识clearInterval()可以用来关闭一个定时器方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器 clearInterval()可以接收任意参数， 如果参数是一个有效的定时器的标识，则停止对应的定时器 如果参数不是一个有效的标识，则什么也不做 123456789101112var myVar = setInterval(function()&#123; myTimer() &#125;, 1000); function myTimer() &#123; var d = new Date(); var t = d.toLocaleTimeString(); document.getElementById(\"demo\").innerHTML = t;&#125;function myStopFunction() &#123; //关闭定时器 clearInterval(myVar);&#125; 延时调用setTimeout 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择 123456var timer = setTimeout(function()&#123; console.log(num++); &#125;,3000); //使用clearTimeout()来关闭一个延时调用 clearTimeout(timer); JSON JavaScript Object Notation， JS对象表示法 JSON 格式 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 JS中的对象只有JS自己认识，其他的语言都不认识JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互 JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号 其他的和JS语法一致JSON分类： 1.对象 {} 2.数组 [] JSON中允许的值： 1.字符串 2.数值 3.布尔值 4.null 5.对象 6.数组 举例： 12345var arr = '[1,2,3,\"hello\",true]'; var obj2 = '&#123;\"arr\":[1,2,3]&#125;'; var arr2 ='[&#123;\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"&#125;,&#123;\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"&#125;]'; JSON工具类 json &gt; js对象JSON.parse() 可以将以JSON字符串转换为js对象 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回 var o = JSON.parse(json);var o2 = JSON.parse(arr); var obj3 = {name:”猪八戒” , age:28 , gender:”男”}; JS对象 &gt; JSONJSON.stringify() -ify/fy，表示”使……化。 可以将一个JS对象转换为JSON字符串 需要一个js对象作为参数，会返回一个JSON字符串 var str = JSON.stringify(obj3);console.log(str); JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错 ​ otherlocalStorage只读的localStorage 属性允许你访问一个Document 源（origin）的对象 Storage；其存储的数据能在跨浏览器会话保留。localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除 。 eval()eval() 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回 如果使用eval()执行的字符串中含有{},它会将{}当成是代码块 如果不希望将其当成代码块解析，则需要在字符串前后各加一个() eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码， 但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患 var str = &apos;{&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;}&apos;; var obj = eval(&quot;(&quot;+str+&quot;)&quot;); 编码 12345678910111213141516171819202122&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; /* * 在字符串中使用转义字符输入Unicode编码 * \\u四位编码 */ console.log(\"\\u2620\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--在网页中使用Unicode编码 &amp;#编码; 这里的编码需要的是10进制 --&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9760;&lt;/h1&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9856;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; confirm()用于弹出一个带有确认和取消按钮的提示框需要一个字符串作为参数，该字符串将会作为提示文字显示出来如果用户点击确认则会返回true，如果点击取消则返回falsevar flag = confirm(“确认删除”+name+”吗?”); #类的操作 直接修改元素的类css： 通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面。 这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便 我希望一行代码，可以同时修改多个样式 我们可以通过修改元素的class属性来间接的修改样式.这样一来，我们只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好，并且这种方式，可以使表现和行为进一步的分离 1box.className += \" b2\"; //注意有空格，添加class属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445//定义一个函数，用来向一个元素中添加指定的class属性值 /* * 参数: * obj 要添加class属性的元素 * cn 要添加的class值 * */ function addClass(obj, cn) &#123; if (!hasClass(obj, cn)) &#123; obj.className += \" \" + cn; &#125; &#125; /* * 判断一个元素中是否含有指定的class属性值 * 如果有该class，则返回true，没有则返回false * */ function hasClass(obj, cn) &#123; var reg = new RegExp(\"\\\\b\" + cn + \"\\\\b\"); return reg.test(obj.className); &#125; /* * 删除一个元素中的指定的class属性 */ function removeClass(obj, cn) &#123; //创建一个正则表达式 var reg = new RegExp(\"\\\\b\" + cn + \"\\\\b\"); //删除class obj.className = obj.className.replace(reg, \"\"); &#125; /* * toggleClass可以用来切换一个类 * 如果元素中具有该类，则删除 * 如果元素中没有该类，则添加 */ function toggleClass(obj , cn)&#123; //判断obj中是否含有cn if(hasClass(obj , cn))&#123; //有，则删除 removeClass(obj , cn); &#125;else&#123; //没有，则添加 addClass(obj , cn); &#125; &#125; # 原生js原生js实现复制内容到剪切板1234567891011copy() &#123; const input = document.createElement(\"input\"); document.body.appendChild(input); input.setAttribute(\"value\",this.solution.code); input.select(); if (document.execCommand(\"copy\")) &#123; document.execCommand(\"copy\"); // console.log(\"复制成功\"); &#125; document.body.removeChild(input); &#125; github笔记下载地址 模板字符串js如何获取数字占的位数获取整数的长度可以用以下几种方法实现： 1.调用toString方法转为字符串后取长度 12var num = 123;alert(num.toString().length);","categories":[{"name":"js","slug":"js","permalink":"https://codeofli.github.io/categories/js/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://codeofli.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://codeofli.github.io/tags/js/"}]},{"title":"vue","slug":"js-note/vue/vue","date":"2019-11-11T15:23:44.000Z","updated":"2022-04-02T07:17:39.924Z","comments":true,"path":"2019/11/js-note/vue/vue/","link":"","permalink":"https://codeofli.github.io/2019/11/js-note/vue/vue/","excerpt":"第 1 章： Vue 核心1.1. Vue 的基本认识1.1.1. 官网1) 英文官网: https://vuejs.org/2) 中文官网: https://cn.vuejs.org/Vue 2.x官方教程1.1.2. 介绍描述1) 渐进式 JavaScript 框架2) 作者: 尤雨溪(一位华裔前 Google 工程师)3) 作用: 动态构建用户界面","text":"第 1 章： Vue 核心1.1. Vue 的基本认识1.1.1. 官网1) 英文官网: https://vuejs.org/2) 中文官网: https://cn.vuejs.org/Vue 2.x官方教程1.1.2. 介绍描述1) 渐进式 JavaScript 框架2) 作者: 尤雨溪(一位华裔前 Google 工程师)3) 作用: 动态构建用户界面 JavaScript框架 简化Dom操作 响应式数据驱动 1.1.3. Vue 的特点1) 遵循 MVVM 模式2) 编码简洁, 体积小, 运行效率高, 适合移动/PC 端开发3) 它本身只关注 UI, 可以轻松引入 vue 插件或其它第三库开发项目 1.1.4. 与其它前端 JS 框架的关联1) 借鉴 angular 的模板和数据绑定技术2) 借鉴 react 的组件化和虚拟 DOM 技术 1.1.5. Vue 扩展插件1) vue-cli: vue 脚手架2) vue-resource(axios): ajax 请求3) vue-router: 路由4) vuex: 状态管理5) vue-lazyload: 图片懒加载6) vue-scroller: 页面滑动相关7) mint-ui: 基于 vue 的 UI 组件库(移动端)8) element-ui: 基于 vue 的 UI 组件库(PC 端) 1.2. Vue 的基本使用简单案例： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Vue基础&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; message:\" 你好 小黑! \" &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; el:挂载点 el是用来设置Vue实例挂载（管理）的元素 Vue实例的作用范围是什么呢？ Vue会管理el选项命中的元素及其内部的后代元素 是否可以使用其他的选择器？ 可以使用其他的选择器,但是建议使用ID选择器 是否可以设置其他的dom元素呢？ 可以使用其他的双标签,不能使用HTML和BODY 数据与方法data:数据对象 能将data中的数据用在vue的挂载元素中 1&#123;&#123;xxx&#125;&#125; 当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 1.2.3. 使用 vue 开发者工具调试Vue.jsdevtools-翻墙安装方式-推荐 1.2.4.理解Vue的MVVM 1.3. 模板语法插值观看本节视频讲解 文本数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Mustache 标签将会被替代为对应数据对象上 msg property 的值。无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定： 1&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 原始 HTML双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令： 12&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=\"rawHtml\"&gt;&lt;/span&gt;&lt;/p&gt; Using mustaches: This should be red. Using v-html directive: This should be red. 这个 span 的内容将会被替换成为 property 值 rawHtml，直接作为 HTML——会忽略解析 property 值中的数据绑定。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。 AttributeMustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 v-bind 指令： ==v-bind指令== ==缩写：:== 123&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 对于布尔 attribute (它们只要存在就意味着值为 true)，v-bind 工作起来略有不同，在这个例子中： 1&lt;button v-bind:disabled=\"isButtonDisabled\"&gt;Button&lt;/button&gt; 如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled attribute 甚至不会被包含在渲染出来的 &lt;button&gt; 元素中。 使用 JavaScript 表达式迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 12345&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。 指令观看本节视频讲解 指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子： 1&lt;p v-if=\"seen\"&gt;现在你看到我了&lt;/p&gt; 这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 &lt;p&gt; 元素。 参数一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML attribute： 1&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt; 在这里 href 是参数，告知 v-bind 指令将该元素的 href attribute 与表达式 url 的值绑定。 另一个例子是 v-on 指令，它用于监听 DOM 事件： 1&lt;a v-on:click=\"doSomething\"&gt;...&lt;/a&gt; 在这里参数是监听的事件名。我们也会更详细地讨论事件处理。 动态参数 2.6.0 新增 从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数： 1234&lt;!--注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。--&gt;&lt;a v-bind:[attributeName]=\"url\"&gt; ... &lt;/a&gt; 这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data property attributeName，其值为 &quot;href&quot;，那么这个绑定将等价于 v-bind:href。 同样地，你可以使用动态参数为一个动态的事件名绑定处理函数： 1&lt;a v-on:[eventName]=\"doSomething\"&gt; ... &lt;/a&gt; 在这个示例中，当 eventName 的值为 &quot;focus&quot; 时，v-on:[eventName] 将等价于 v-on:focus。 对动态参数的值的约束动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。 对动态参数表达式的约束动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如： 12&lt;!-- 这会触发一个编译警告 --&gt;&lt;a v-bind:['foo' + bar]=\"value\"&gt; ... &lt;/a&gt; 变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。 在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写： 12345&lt;!--在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。除非在实例中有一个名为“someattr”的 property，否则代码不会工作。--&gt;&lt;a v-bind:[someAttr]=\"value\"&gt; ... &lt;/a&gt; 修饰符修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;...&lt;/form&gt; 在接下来对 v-on 和 v-for 等功能的探索中，你会看到修饰符的其它例子。 缩写v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，v- 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的单页面应用程序 (SPA - single page application) 时，v- 前缀也变得没那么重要了。因此，Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写： v-bind 缩写12345678&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt; v-on 缩写12345678&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 它们看起来可能与普通的 HTML 略有不同，但 : 与 @ 对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。 2.模板的理解1) 动态的 html 页面2) 包含了一些 JS 语法代码a. 双大括号表达式b. 指令(以 v-开头的自定义标签属性) 3. 双大括号表达式1) 语法: 2) 功能: 向页面输出数据3) 可以调用对象的方法 4. 指令一: 强制数据绑定Vue指令指的是,以v-开头的一组特殊语法 1) 功能: 指定变化的属性值2) 完整写法: v-bind:xxx=’yyy’ //yyy 会作为表达式解析执行*3) 简洁写法: * 1&lt;h :xxx=&apos;yyy&apos; &gt;&lt;/h&gt; 1.3.5. 指令二: 绑定事件监听1) 功能: 绑定指定事件名的回调函数2) 完整写法:v-on:keyup=’xxx’v-on:keyup=’xxx(参数)’v-on:keyup.enter=’xxx’3) 简洁写法:@keyup=’xxx’@keyup.enter=’xx 1.3.6. 编码123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;h2&gt;1. 双大括号表达式&lt;/h2&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;msg.toUpperCase()&#125;&#125;&lt;/p&gt; &lt;h2&gt;2. 指令一: 强制数据绑定&lt;/h2&gt; &lt;a href=\"url\"&gt;访问指定站点&lt;/a&gt;&lt;br&gt;&lt;!--不能使用--&gt; &lt;a v-bind:href=\"url\"&gt;访问指定站点 2&lt;/a&gt;&lt;br&gt; &lt;a :href=\"url\"&gt;访问指定站点 3&lt;/a&gt;&lt;br&gt; &lt;h2&gt;3. 指令二: 绑定事件监听&lt;/h2&gt; &lt;button v-on:click=\"handleClick\"&gt;点我&lt;/button&gt; &lt;button @click=\"handleClick\"&gt;点我 2&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123;// data 的所有属性都会成功 vm 对象的属性, 而模板页面中可以直接访问 msg: 'NBA I Love This Game!', url: 'http://www.baidu.com' &#125;, methods: &#123; handleClick () &#123; alert('处理点击') &#125; &#125; &#125;)&lt;/script&gt; 1.3.8 v-model和双向数据绑定`v-model 只能运用在 表单元素和组件中 12345678&lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt;&lt;!-- v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 --&gt;&lt;input type=\"text\" v-bind:value=\"msg\" style=\"width:100%;\"&gt;&lt;!-- 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 --&gt;&lt;!-- input(radio, text, address, email....) select checkbox textarea --&gt;&lt;input type=\"text\" style=\"width:100%;\" v-model=\"msg\"&gt; 1.4. 计算属性和监视1.4.2. 计算属性1) 在 computed 属性对象中定义计算属性的方法 2) 在页面中使用来显示计算的结果 1.4.3. 监视属性1) 通过通过 vm 对象的$watch()或 watch 配置来监视指定的属性2) 当属性变化时, 回调函数自动调用, 在函数内部进行计算 watch`属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 1.监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstName\"&gt; + &lt;input type=\"text\" v-model=\"lastName\"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; 'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 2.监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"app\"&gt; &lt;router-link to=\"/login\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: \"/login\", component: login &#125;, &#123; path: \"/register\", component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; '$route': function (newVal, oldVal) &#123; if (newVal.path === '/login') &#123; console.log('这是登录组件'); &#125; &#125; &#125; &#125;); &lt;/script&gt; 1.4.4. 计算属性高级1) 通过 getter/setter 实现对属性数据的显示和监视 2) 计算属性存在缓存, 多次读取只执行一次 getter 计算 computed计算属性的使用计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 注意1： 计算属性，在引用的时候，一定不要加 () 去调用，直接把它 当作 普通 属性去使用就好了； 注意2： 只要 计算属性，这个 function 内部，所用到的 任何 data 中的数据发送了变化，就会 立即重新计算 这个 计算属性的值 注意3： 计算属性的求值结果，会被缓存起来，方便下次直接使用； 如果 计算属性方法中，所以来的任何数据，都没有发生过变化，则，不会重新对 计算属性求值； 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstName\"&gt; + &lt;input type=\"text\" v-model=\"lastName\"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 2.定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstName\"&gt; &lt;input type=\"text\" v-model=\"lastName\"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=\"button\" value=\"修改fullName\" @click=\"changeName\"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; 1.4.5. 编码12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=\"demo\"&gt; 姓: &lt;input type=\"text\" placeholder=\"First Name\" v-model=\"firstName\"&gt;&lt;br&gt; 名: &lt;input type=\"text\" placeholder=\"Last Name\" v-model=\"lastName\"&gt;&lt;br&gt; 姓名 1(单向): &lt;input type=\"text\" placeholder=\"Full Name\" v-model=\"fullName1\"&gt;&lt;br&gt; 姓名 2(单向): &lt;input type=\"text\" placeholder=\"Full Name\" v-model=\"fullName2\"&gt;&lt;br&gt; 姓名 3(双向): &lt;input type=\"text\" placeholder=\"Full Name2\" v-model=\"fullName3\"&gt;&lt;br&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Kobe', lastName: 'bryant', fullName2: 'Kobe bryant' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + \" \" + this.lastName &#125;, fullName3: &#123; get: function () &#123; return this.firstName + \" \" + this.lastName &#125;, set: function (value) &#123; var names = value.split(' ') this.firstName = names[0] this.lastName = names[1] &#125; &#125; &#125;, watch: &#123; lastName: function (newVal, oldVal) &#123; this.fullName2 = this.firstName + ' ' + newVal &#125; &#125; &#125;) vm.$watch('firstName', function (val) &#123; this.fullName2 = val + ' ' + this.lastName &#125;) ``watch、computed和methods`之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； 1.5. class 与 style 绑定1.5.2. 理解1) 在应用界面中, 某个(些)元素的样式是变化的2) class/style 绑定就是专门用来实现动态样式效果的技术 1.5.3. class 绑定（使用class样式）1) :class=’xxx’2) 表达式是字符串: ‘classA’3) 表达式是对象: {classA:isA, classB: isB}4) 表达式是数组: [‘classA’, ‘classB’] 1.数组 1&lt;h1 :class=\"['red', 'thin']\"&gt;这是一个邪恶的H1&lt;/h1&gt; 2.数组中使用三元表达式 1&lt;h1 :class=\"['red', 'thin', isactive?'active':'']\"&gt;这是一个邪恶的H1&lt;/h1&gt; 3.数组中嵌套对象 1&lt;h1 :class=\"['red', 'thin', &#123;'active': isactive&#125;]\"&gt;这是一个邪恶的H1&lt;/h1&gt; 4.直接使用对象 1&lt;h1 :class=\"&#123;red:true, italic:true, active:true, thin:true&#125;\"&gt;这是一个邪恶的H1&lt;/h1&gt; 注意如果类名中有-，必须用&#39;&#39;括起来,不然没有用 1&lt;li :class=\"&#123;'page-item': true,active: true&#125;\"&gt;&lt;/li&gt; 1.5.4. style 绑定1) :style=”{ color: activeColor, fontSize: fontSize + ‘px’ }”2) 其中 activeColor/fontSize 是 data 属性 1.5.5. 编吗12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; .classA &#123; color: red; &#125; . classB &#123; background: blue; &#125; . classC &#123; font-size: 20px; &#125;&lt;/style&gt;&lt;div id=\"demo\"&gt; &lt;h2&gt;1. class 绑定: :class='xxx'&lt;/h2&gt; &lt;p class=\"classB\" :class=\"a\"&gt;表达式是字符串: 'classA'&lt;/p&gt; &lt;p :class=\"&#123;classA: isA, classB: isB&#125;\"&gt;表达式是对象: &#123;classA:isA, classB: isB&#125;&lt;/p&gt; &lt;p :class=\"['classA', 'classC']\"&gt; 表达式是数组: ['classA', 'classB']&lt;/p&gt; &lt;h2&gt;2. style 绑定&lt;/h2&gt; &lt;p :style=\"&#123;color, fontSize&#125;\"&gt;style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&lt;/p&gt; &lt;button @click=\"update\"&gt;更新&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el : '#demo', data : &#123; a: 'classA', isA: true, isB: false, color: 'red', fontSize: '20px' &#125;, methods : &#123; update () &#123; this.a = 'classC' this.isA = false this.isB = true this.color = 'blue' this.fontSize = '30px' &#125; &#125; &#125;)&lt;/script&gt; 1.6. 条件渲染1.6.2. 条件渲染指令1) v-if 与 v-else2) v-show 1.6.3. 比较 v-if 与 v-show3)如果需要频繁切换 v-show 较好4)当条件不成立时, v-if 的所有子节点不会解析(项目中使用) 1.6.4. 编码1234567891011121314151617&lt;div id=\"demo\"&gt; &lt;h2 v-if=\"ok\"&gt;表白成功&lt;/h2&gt; &lt;h2 v-else&gt;表白失败&lt;/h2&gt; &lt;h2 v-show=\"ok\"&gt;求婚成功&lt;/h2&gt; &lt;h2 v-show=\"!ok\"&gt;求婚失败&lt;/h2&gt; &lt;br&gt; &lt;button @click=\"ok=!ok\"&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#demo', data: &#123; ok: false &#125; &#125;)&lt;/script&gt; 1.7. 列表渲染1) 列表显示指令数组: v-for / index对象: v-for / key2) 列表的更新显示删除 item替换 item3) 列表的高级处理列表过滤列表排序 注意事项 由于 JavaScript 的限制，Vue 不能检测以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 1.7.2. 编码1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"demo\"&gt; &lt;h2&gt;测试: v-for 遍历数组&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"(p, index) in persons\" :key=\"index\"&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;p.name&#125;&#125;--&#123;&#123;p.age&#125;&#125; &lt;button @click=\"deleteItem(index)\"&gt;删除&lt;/button&gt; &lt;button @click=\"updateItem(index, &#123;name:'Jok',age:15&#125;)\"&gt;更新&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;测试: v-for 遍历对象&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"(value, key) in persons[0]\"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo', data: &#123; persons: [ &#123;id: 1, name: 'Tom', age: 13&#125;, &#123;id: 2, name: 'Jack', age: 12&#125;, &#123;id: 3, name: 'Bob', age: 14&#125; ] &#125;, methods: &#123; deleteItem(index) &#123; this.persons.splice(index, 1) &#125;, updateItem(index, p) &#123; // this.persons[index] = p // 页面不会更新 this.persons.splice(index, 1, p) &#125; &#125; &#125;)&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=\"demo\"&gt; &lt;input type=\"text\" name=\"searchName\" placeholder=\"搜索指定用户名\" v-model=\"searchName\"&gt; &lt;ul&gt; &lt;li v-for=\"(p, index) in filterPerson\" :key=\"index\"&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;p.name&#125;&#125;--&#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"setOrderType(1)\"&gt;年龄升序&lt;/button&gt; &lt;button @click=\"setOrderType(2)\"&gt;年龄降序&lt;/button&gt; &lt;button @click=\"setOrderType(0)\"&gt;原本顺序&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo', data: &#123; orderType: 0, //0 代表不排序, 1 为升序, 2 为降序 searchName: '', persons: [ &#123;id: 1, name: 'Tom', age: 13&#125;, &#123;id: 2, name: 'Jack', age: 12&#125;, &#123;id: 3, name: 'Bob', age: 17&#125;, &#123;id: 4, name: 'Cat', age: 14&#125;, &#123;id: 4, name: 'Mike', age: 14&#125;, &#123;id: 4, name: 'Monica', age: 16&#125; ] &#125;, methods: &#123; setOrderType (orderType) &#123; this.orderType = orderType &#125; &#125;, computed: &#123; filterPerson() &#123; let &#123;orderType, searchName, persons&#125; = this // 过滤 persons = persons.filter(p =&gt; p.name.indexOf(searchName)!=-1) // 排序 if(orderType!==0) &#123; persons = persons.sort(function (p1, p2) &#123; if(orderType===1) &#123; return p1.age-p2.age &#125; else &#123; return p2.age-p1.age &#125; &#125;) &#125; r eturn persons &#125; &#125; &#125;)&lt;/script&gt; 1.8. 事件处理1.8.2. 绑定监听1) v-on:xxx=”fun”2) @xxx=”fun”3) @xxx=”fun(参数)”4) 默认事件形参: event event 是原生 DOM 事件5) 隐含属性对象: $event 1.8.3. 事件修饰符1) .prevent : 阻止事件的默认行为 event.preventDefault()2) .stop : 停止事件冒泡 event.stopPropagation() 事件修饰符 .stop 阻止冒泡 1234&lt;!-- 使用 .stop 阻止冒泡 --&gt;&lt;div class=\"inner\" @click=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click.stop=\"btnHandler\"&gt;&lt;/div&gt; .prevent 阻止默认事件 12&lt;!-- 使用 .prevent 阻止默认行为 --&gt; &lt;a href=\"http://www.baidu.com\" @click.prevent=\"linkClick\"&gt;有问题，先去百度&lt;/a&gt; .capture 添加事件侦听器时使用事件捕获模式 1234&lt;!-- 使用 .capture 实现捕获触发事件的机制 --&gt;&lt;div class=\"inner\" @click.capture=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click=\"btnHandler\"&gt;&lt;/div&gt; .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 1234&lt;!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 --&gt;&lt;div class=\"inner\" @click=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click=\"btnHandler\"&gt;&lt;/div&gt; .once 事件只触发一次 12&lt;!-- 使用 .once 只触发一次事件处理函数 --&gt;&lt;a href=\"http://www.baidu.com\" @click.prevent.once=\"linkClick\"&gt;有问题，先去百度&lt;/a&gt; 1.8.4. 按键修饰符1) .keycode : 操作的是某个 keycode 值的键2) .keyName : 操作的某个按键名的键(少部分) 1.8.5. 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id=\"example\"&gt; &lt;h2&gt;1. 绑定监听&lt;/h2&gt; &lt;button v-on:click=\"test1\"&gt;Greet&lt;/button&gt; &lt;button @click=\"test1\"&gt;Greet2&lt;/button&gt; &lt;button @click=\"test2($event, 'hello')\"&gt;Greet3&lt;/button&gt; &lt;h2&gt;2. 事件修饰符&lt;/h2&gt; &lt;!-- 阻止事件默认行为 --&gt; &lt;a href=\"http://www.baidu.com\" @click.prevent=\"test3\"&gt;百度一下&lt;/a&gt; &lt;br/&gt; &lt;br/&gt; &lt;!-- 停止事件冒泡 --&gt; &lt;div style=\"width: 200px;height: 200px;background: red\" @click=\"test4\"&gt; &lt;div style=\"width: 100px;height: 100px;background: green\" @click.stop=\"test5\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;h2&gt;3. 按键修饰符&lt;/h2&gt; &lt;input @keyup.8=\"test6\"&gt; &lt;input @keyup.enter=\"test6\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(el: '#example', data: &#123; name: 'Vue.js' &#125;, methods: &#123; test1 (event) &#123; // 方法内 `this` 指向 vm // alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 alert(event.target.innerHTML) &#125;, test2 (event, msg) &#123; alert(event.target.innerHTML + '---' + msg) &#125;, test3() &#123; alert('阻止事件的默认行为') &#125;, test4() &#123; alert('out') &#125;, test5() &#123; alert('inner') &#125;, test6(event) &#123; alert(event.keyCode + '---' + event.target.value) &#125; &#125; &#125;)&lt;/script&gt; 9. 表单输入绑定基础用法表单输入绑定你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。 复选框多个复选框，绑定到同一个数组： 1234567891011121314&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;&lt;br&gt;&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;new Vue(&#123; el: &apos;...&apos;, data: &#123; checkedNames: [] &#125;&#125;) 单选按钮案例编码案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;div id=\"demo\"&gt; &lt;form @submit.prevent=\"handleSubmit\"&gt; &lt;span&gt;用户名: &lt;/span&gt; &lt;input type=\"text\" v-model=\"user.username\"&gt;&lt;br&gt; &lt;span&gt;密码: &lt;/span&gt; &lt;input type=\"password\" v-model=\"user.pwd\"&gt;&lt;br&gt; &lt;span&gt;性别: &lt;/span&gt; &lt;input type=\"radio\" id=\"female\" value=\"female\" v-model=\"user.sex\"&gt; &lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;input type=\"radio\" id=\"male\" value=\"male\" v-model=\"user.sex\"&gt; &lt;label for=\"male\"&gt;男&lt;/label&gt;&lt;br&gt; &lt;span&gt;爱好: &lt;/span&gt; &lt;input type=\"checkbox\" id=\"basket\" value=\"basketball\" v-model=\"user.likes\"&gt; &lt;label for=\"basket\"&gt;篮球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"foot\" value=\"football\" v-model=\"user.likes\"&gt; &lt;label for=\"foot\"&gt;足球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"pingpang\" value=\"pingpang\" v-model=\"user.likes\"&gt; &lt;label for=\"pingpang\"&gt;乒乓&lt;/label&gt;&lt;br&gt; &lt;span&gt;城市: &lt;/span&gt; &lt;select v-model=\"user.cityId\"&gt; &lt;option value=\"\"&gt;未选择&lt;/option&gt; &lt;option v-for=\"city in allCitys\" :value=\"city.id\"&gt; &#123;&#123; city.name &#125;&#125; &lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;span&gt;介绍: &lt;/span&gt; &lt;textarea v-model=\"user.desc\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#demo', data: &#123; user: &#123; username: '', pwd: '', sex: 'female', likes: [], cityId: '', desc: '', &#125;, allCitys: [&#123;id: 1, name: 'BJ'&#125;, &#123;id: 2, name: 'SZ'&#125;,&#123;id: 4, name: 'SH'&#125;], &#125;, methods: &#123; handleSubmit (event) &#123; alert(JSON.stringify(this.user)) &#125; &#125; &#125;)&lt;/script&gt; 值绑定对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)： 12345678910&lt;!-- 当选中时，`picked` 为字符串 \"a\" --&gt;&lt;input type=\"radio\" v-model=\"picked\" value=\"a\"&gt;&lt;!-- `toggle` 为 true 或 false --&gt;&lt;input type=\"checkbox\" v-model=\"toggle\"&gt;&lt;!-- 当选中第一个选项时，`selected` 为字符串 \"abc\" --&gt;&lt;select v-model=\"selected\"&gt; &lt;option value=\"abc\"&gt;ABC&lt;/option&gt;&lt;/select&gt; 但是有时我们可能想把值绑定到 Vue 实例的一个动态 property 上，这时可以用 v-bind 实现，并且这个 property 的值可以不是字符串。 复选框 单选按钮 选择框的选项 修饰符.lazy在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步： 12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot;&gt; .number如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符： 1&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; 这通常很有用，因为即使在 type=&quot;number&quot; 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。 .trim如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符： 1&lt;input v-model.trim=&quot;msg&quot;&gt; 自定义组件的 v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。 1.10. Vue 实例生命周期1.10.2. 生命周期流程图 vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 1.10.3. vue 生命周期分析1)初始化显示 beforeCreate() created() beforeMount() mounted() 2)更新状态: this.xxx = value beforeUpdate()updated() 3)销毁 vue 实例: vm.$destory() beforeDestory()estoryed() 1.10.4. 常用的生命周期方法1) created()/mounted(): 发送 ajax 请求, 启动定时器等异步任务2) beforeDestory(): 做收尾工作, 如: 清除定时器 1.10.5. 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div&gt; &lt;button @click=\"destoryVue\"&gt;destory vue&lt;/button&gt; &lt;p v-show=\"isShowing\"&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vue = new Vue(&#123; el: 'div', data: &#123; msg: '尚硅谷 IT 教育', isShowing: true, persons: [] &#125;, beforeCreate () &#123; console.log('beforeCreate() msg=' + this.msg) e.log('created() msg='+this.msg) this.intervalId = setInterval(() =&gt; &#123; console.log('-----') this.isShowing = !this.isShowing &#125;, 1000) &#125;, beforeMount () &#123; console.log('beforeMount() msg='+this.msg) &#125;, mounted () &#123; console.log('mounted() msg='+this.msg) &#125;, beforeUpdate() &#123; console.log('beforeUpdate isShowing='+this.isShowing) &#125;, updated () &#123; console.log('updated isShowing='+this.isShowing) &#125;, beforeDestroy () &#123; console.log('beforeDestroy() msg='+this.msg) clearInterval(this.intervalId) &#125;, destroyed () &#123; console.log('destroyed() msg='+this.msg) &#125;, methods: &#123; destoryVue () &#123; vue.$destroy() &#125; &#125; &#125;)&lt;/script&gt; 1.11. 过渡&amp;动画1.11.2. vue 动画的理解1) 操作 css 的 trasition 或 animation2) vue 会给目标元素添加/移除特定的 class3) 过渡的相关类名xxx-enter-active: 指定显示的 transitionxxx-leave-active: 指定隐藏的 transitionxxx-enter/xxx-leave-to: 指定隐藏时的样式 1.11.3. 基本过渡动画的编码1) 在目标元素外包裹&lt;transition name=&quot;xxx&quot;&gt;2) 定义 class 样式指定过渡样式: transition指定隐藏时的样式: opacity/其它 1.11.4. 编码 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt; .fade-enter-active, .fade-leave-active &#123; transition: opacity .5s &#125; . fade-enter, .fade-leave-to &#123; opacity: 0 &#125; / * 可以设置不同的进入和离开动画 */ .slide-fade-enter-active &#123; transition: all .3s ease; &#125; . slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0); &#125; . slide-fade-enter, .slide-fade-leave-to &#123; transform: translateX(10px); opacity: 0; &#125;&lt;/style&gt;&lt;div id=\"demo1\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle1 &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;div id=\"demo2\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle2 &lt;/button&gt; &lt;transition name=\"slide-fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo1', data: &#123; show: true &#125; &#125;) new Vue(&#123; el: '#demo2', data: &#123; show: true &#125; &#125;)&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435361.11.5. 编码 2&lt;style&gt; .bounce-enter-active &#123; animation: bounce-in .5s; &#125; . bounce-leave-active &#123; animation: bounce-in .5s reverse; &#125; @ keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125;&lt;/style&gt;&lt;div id=\"test2\"&gt; &lt;button @click=\"show = !show\"&gt;Toggle show&lt;/button&gt; &lt;br&gt; &lt;transition name=\"bounce\"&gt; &lt;p v-if=\"show\" style=\"display: inline-block\"&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: '#test2', data: &#123; show: true &#125; &#125;)&lt;/script&gt; 1.12. 过滤器1.12.2. 理解过滤器1) 功能: 对要显示的数据进行特定格式化后再显示2) 注意: 并没有改变原本的数据, 可是产生新的对应的数据 1.12.3. 定义和使用过滤器1) 定义过滤器 1234Vue.filter(filterName, function(value[,arg1,arg2,...])&#123; // 进行一定的数据处理 return newValue&#125;) 2)使用过滤器 12&lt;div&gt;&#123;&#123;myData | filterName&#125;&#125;&lt;/div&gt;&lt;div&gt;&#123;&#123;myData | filterName(arg)&#125;&#125;&lt;/div&gt; 1.12.4. 编码123456789101112131415161718192021&lt;div id=\"test\"&gt; &lt;p&gt;当前时间为: &#123;&#123;currentTime&#125;&#125;&lt;/p&gt; &lt;p&gt;当前时间 1 为: &#123;&#123;currentTime | dateStr&#125;&#125;&lt;/p&gt; &lt;p&gt;当前时间 2 为: &#123;&#123;currentTime | dateStr('YYYY-MM-DD')&#125;&#125;&lt;/p&gt; &lt;p&gt;当前时间 3 为: &#123;&#123;currentTime | dateStr('HH:mm:ss')&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://cdn.bootcss.com/moment.js/2.19.0/moment.js\"&gt;&lt;/script&gt;&lt;script&gt; // 注册过滤器 Vue.filter('dateStr', function (value, format) &#123; return moment(value).format(format || 'YYYY-MM-DD HH:mm:ss') &#125;) new Vue(&#123; el: '#test', data: &#123; currentTime: new Date() &#125; &#125;)&lt;/script&gt; 1.13. 内置指令与自定义指令1.13.2. 常用内置指令1) v:text : 更新元素的 textContent2) v-html : 更新元素的 innerHTML3) v-if : 如果为 true, 当前标签才会输出到页 面 4) v-else: 如果为 false, 当前标签才会输出到页面5) v-show : 通过控制 display 样式来控制显示/隐藏6) v-for : 遍历数组/对象7) v-on : 绑定事件监听, 一般简写为@8) v-bind : 强制绑定解析表达式, 可以省略 v-bind9) v-model : 双向数据绑定10) ref : 指定唯一标识, vue 对象通过$els 属性访问这个元素对象11) v-cloak : 防止闪现, 与 css 配合: [v-cloak] { display: none } 1.13.3. 自定义指令1) 注册全局指令 123Vue.directive('my-directive', function(el, binding)&#123; el.innerHTML = binding.value.toupperCase()&#125;) 2) 注册局部指令 1234567directives : &#123; 'my-directive' : &#123; bind (el, binding) &#123; el.innerHTML = binding.value.toupperCase() &#125; &#125;&#125; 3) 使用指令 1v-my-directive='xxx' 1.13.4. 编码 1(内置指令 ）1234567891011121314151617181920212223242526272829303132&lt;style&gt; [v-cloak] &#123; display: none &#125;&lt;/style&gt;&lt;div id=\"example\"&gt; &lt;p v-text=\"url\"&gt;&lt;/p&gt; &lt;p v-html=\"url\"&gt;&lt;/p&gt; &lt;img :id=\"myid\" :src=\"imageSrc\"&gt; &lt;p&gt; &lt;span ref=\"message\"&gt;atguigu.com&lt;/span&gt; &lt;button @click=\"showMsg\"&gt;显示左侧文本&lt;/button&gt; &lt;/p&gt; &lt;p v-cloak&gt;&#123;&#123;url&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; alert('模拟加载慢') new Vue(&#123; el: '#example', data: &#123; url: '&lt;a href=\"http://www.atguigu.com\"&gt;尚硅谷&lt;/a&gt;', myid: 'abc123', imageSrc: 'http://cn.vuejs.org/images/logo.png' &#125;, methods: &#123; showMsg: function () &#123; alert(this.$refs.message.textContent) &#125; &#125; &#125;)&lt;/script&gt; 1.13.5. 编码 2(自定义指令)需求: 自定义 2 个指令 功能类型于 v-text, 但转换为全大写 功能类型于 v-text, 但转换为全小写123456789101112131415161718192021222324252627282930313233&lt;div id=\"demo1\"&gt; &lt;p v-upper-text=\"msg\"&gt;&lt;/p&gt; &lt;p v-lower-text=\"msg\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;div id=\"demo2\"&gt; p v-upper-text=\"msg2\"&gt;&lt;/p&gt;&lt;p v-lower-text=\"msg2\"&gt;&lt;/p&gt; &lt;!--局部指令, 此处不能使用--&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //注册全局指令 Vue.directive('upper-text', function (el, binding) &#123; el.innerHTML = binding.value.toUpperCase() &#125;) new Vue(&#123; el: '#demo1', data: &#123; msg: 'NBA love this game!' &#125;, directives: &#123; // 注册局部指令 'lower-text': &#123; bind (el, binding) &#123; el.innerHTML = binding.value.toLowerCase() &#125; &#125; &#125; &#125;) new Vue(&#123; el: '#demo2', data: &#123; msg2: 'I Like You' &#125; &#125;)&lt;/script 1.14. 自定义插件1.14.2. 说明1) Vue 插件是一个包含 install 方法的对象2) 通过 install 方法给 Vue 或 Vue 实例添加方法, 定义全局指令等 1.14.3. 编码1) 插件 JS 12345678910111213141516171819202122/**- 自定义 Vue 插件 */(function () &#123; const MyPlugin = &#123;&#125; MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; alert('Vue 函数对象方法执行') &#125; // 2. 添加全局资源 Vue.directive('my-directive', function (el, binding) &#123; el.innerHTML = \"MyPlugin my-directive \" + binding.value &#125;) // 3. 添加实例方法 Vue.prototype.$myMethod = function () &#123; alert('vue 实例对象方法执行') &#125; &#125; window.MyPlugin = MyPlugin&#125;)() 2) 页面使用插件 1234567891011121314151617181920&lt;div id=\"demo\"&gt; &lt;!--使用自定义指令--&gt; &lt;p v-my-directive=\"ms》g\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"vue-myPlugin.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //使用自定义插件 Vue.use(MyPlugin) var vm = new Vue(&#123; el: '#demo', data: &#123; msg: 'atguigu' &#125; &#125;) //调用自定义的静态方法 Vue.myGlobalMethod() //调用自定义的对象方法 vm.$myMethod()&lt;/script&gt; 2.组件化编码（vue-cli ）组件基础组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 &lt;button-counter&gt;。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： …. 因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、 computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。 每个组件必须只有一个根元素 data 必须是一个函数当我们定义这个 &lt;button-counter&gt; 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象： 123data: &#123; count: 0&#125; 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： 12345data: function () &#123; return &#123; count: 0 &#125;&#125; 如果 Vue 没有这条规则，就可能会影响到其它所有实例 在组件上使用 v-model自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住： 1&lt;input v-model=\"searchText\"&gt; 等价于： 1234&lt;input v-bind:value=\"searchText\" v-on:input=\"searchText = $event.target.value\"&gt; 当用在组件上时，v-model 则会这样： 1234&lt;custom-input v-bind:value=\"searchText\" v-on:input=\"searchText = $event\"&gt;&lt;/custom-input&gt; 为了让它正常工作，这个组件内的 &lt;input&gt; 必须： 将其 value attribute 绑定到一个名叫 value 的 prop 上 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出 写成代码之后是这样的： 12345678Vue.component(&apos;custom-input&apos;, &#123; props: [&apos;value&apos;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt;`&#125;) 现在 v-model 就应该可以在这个组件上完美地工作起来了： 1&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 到目前为止，关于组件自定义事件你需要了解的大概就这些了，如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把自定义事件读完。 动态组件有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里： 深入了解组件组件注册组件名在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了： 1Vue.component(&apos;my-component-name&apos;, &#123; /* ... */ &#125;) 该组件名就是 Vue.component 的第一个参数。 你给予组件的名字可能依赖于你打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，我们强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。 你可以在风格指南中查阅到关于组件名的其它建议。 组件名大小写定义组件名的方式有两种： 使用 kebab-case1Vue.component('my-component-name', &#123; /* ... */ &#125;) 当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 &lt;my-component-name&gt;。 使用 PascalCase1Vue.component('MyComponentName', &#123; /* ... */ &#125;) 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 &lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。 2.1. 使用 vue-cli 创建模板项目说明1) vue-cli 是 vue 官方提供的脚手架工具2) github: https://github.com/vuejs/vue-cli3) 作用: 从 https://github.com/vuejs-templates 下载模板项目 2.1.2. 创建 vue 项目1npm install -g @vue/cli cli 2.x安装拉取 2.x 模板 (旧版本) Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具： 1npm install -g @vue/cli-init 1234vue init webpack vue_demo(project_name)cd vue_demonpm installnpm run dev 注: 访问: http://localhost:8080/ 2.1.3. 模板项目的结构|– build : webpack 相关的配置文件夹(基本不需要修改)|– dev-server.js : 通过 express 启动后台服务器|– config: webpack 相关的配置文件夹(基本不需要修改)|– index.js: 指定的后台服务的端口号和静态资源文件夹|– node_modules|– src : 源码文件夹|– components: vue 组件及其相关资源文件夹|– App.vue: 应用根主组件|– main.js: 应用入口 js|– static: 静态资源文件夹（build打包原封不动的放到dist文件夹中）|– .babelrc: babel 的配置文件|– .eslintignore: eslint 检查忽略的配置|– .eslintrc.js: eslint 检查的配置|– .gitignore: git 版本管制忽略的配置|– index.html: 主页面文件|– package.json: 应用包配置文件|– README.md: 应用描述说明的 readme 文件 .editorconfig配置格式 cli 3.x安装 创建项目 1vue create hello-world 在c:user/xxx/.vuerc里可以删除预设的vuecli配置 rc-&gt; run command vuecli3配置文件的查看和修改1vue ui 自定义配置文件vue.config.js 1234// vue.config.jsmodule.exports = &#123; // 选项...&#125; 2.2. 项目的打包与发布2.2.1. 打包:1npm run build 2.2.2. 发布 1: 使用静态服务器工具包npm install -g serveserve dist访问: http://localhost:5000 2.2.3. 发布 2: 使用动态 web 服务器(tomcat)修改配置: .config/index.js 123456789build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: '/vue_demo',&#125; 重新打包:npm run build修改 dist 文件夹为项目名称: xxx将 xxx 拷贝到运行的 tomcat 的 webapps 目录下访问: http://localhost:8080/xx 2.3. eslint2.3.1. 说明1) ESLint 是一个代码规范检查工具2) 它定义了很多特定的规则, 一旦你的代码违背了某一规则, eslint会作出非常有用的提示3) 官网: http://eslint.org/4) 基本已替代以前的 JSLint 2.3.2. ESLint 提供以下支持1) ES2) JSX3) style 检查4) 自定义错误和提示 2.3.3. ESLint 提供以下几种校验1) 语法错误校验2) 不重要或丢失的标点符号， 如分号3) 没法运行到的代码块（使用过 WebStorm 的童鞋应该了解）4) 未被使用的参数提醒5) 确保样式的统一规则， 如 sass 或者 less6) 检查变量的命名 2.3.4. 规则的错误等级有三种1) 0： 关闭规则。2) 1： 打开规则， 并且作为一个警告（信息打印黄色字体）3) 2： 打开规则， 并且作为一个错误（信息打印红色字体 ) 2.3.5. 相关配置文件1) .eslintrc.js : 全局规则配置文件‘rules’: {‘no-new’: 1}2) 在 js/vue 文件中修改局部规则/* eslint-disable no-new */new Vue({el: ‘body’,components: { App }})3) .eslintignore: 指令检查忽略的文件*.js*.vu 2.4. 组件定义与使用2.4.1. vue 文件的组成(3 个部分)1) 模板页面 123&lt;template&gt;页面模板&lt;/template&gt; 2) JS 模块对象 12345678&lt;script&gt; export default &#123; data() &#123;return &#123;&#125;&#125;, methods: &#123;&#125;, computed: &#123;&#125;, components: &#123;&#125; &#125;&lt;/script&gt; 3) 样式 1234&lt;style&gt; 样式定义&lt;/style&gt; 2.4.2. 基本使用1) 引入组件2) 映射成标签3) 使用组件标签 123456789101112&lt;template&gt; &lt;HelloWorld&gt;&lt;/HelloWorld&gt; &lt;hello-world&gt;&lt;/hello-world&gt;&lt;/template&gt;&lt;script&gt; import HelloWorld from './components/HelloWorld' export default &#123; components: &#123; HelloWorld &#125; &#125;&lt;/script&gt; 2.4.3. 关于标签名与标签属性名书写问题 1) 写法一: 一模一样2) 写法二: 大写变小写, 并用-连接 2.5. 组件间通信2.5.1. 组件间通信基本原则1) 不要在子组件中直接修改父组件的状态数据2) 数据在哪, 更新数据的行为(函数)就应该定义在哪 2.5.2. vue 组件间通信方式1) props2) vue 的自定义事件3) 消息订阅与发布(如: pubsub 库)4) slot5) vuex(后面单独讲) 2.6. 组件间通信 1: props2.6.1. 使用组件标签时 1&lt;my-component name='tom' :age='3' :set-name='setName'&gt;&lt;/my-component&gt; 2.6.2. 定义 MyComponent 时1) 在组件内声明所有的 props2) 方式一: 只指定名称(类型要为字符串) 1props: ['name', 'age', 'setName'] 3) 方式二: 指定名称和类型 12345props: &#123; name: String, age: Number, setNmae: Function&#125; 4) 方式三: 指定名称/类型/必要性/默认值 123props: &#123;name: &#123;type: String, required: true, default:xxx&#125;,&#125; 2.6.3. 注意1) 此方式用于父组件向子组件传递数据2) 所有标签属性都会成为组件对象的属性, 模板页面可以直接引用3) 问题:a. 如果需要向非子后代传递数据必须多层逐层传递b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以 2.7. 组件间通信 2: vue 自定义事件子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func=\"getMsg\"&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id=\"app\"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func=\"getMsg\"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type=\"x-template\" id=\"son\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"向父组件传值\" @click=\"sendMsg\" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 使用 this.$refs 来获取元素和组件注：元素中的ref属性=xx与this.$refs.xx相对应。 123456789101112131415161718192021222324252627282930313233343536&lt;div id=\"app\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=\"myh1\"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=\"mycom\"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 2.7.1. 绑定事件监听使用 this.$refs 来获取元素和组件 12345678910111213141516171819202122232425262728293031323334&lt;div id=\"app\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=\"myh1\"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=\"mycom\"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 123456// 方式一: 通过 v-on 绑定@delete_todo=\"deleteTodo\"// 方式二: 通过$on()this.$refs.xxx.$on('delete_todo', function (todo) &#123; this.deleteTodo(todo)&#125;) 2.7.2. 触发事件12// 触发事件(只能在父组件中接收)this.$emit(eventName, data) 2.7.3. 注意:1) 此方式只用于子组件向父组件发送消息(数据)2) 问题: 隔代组件或兄弟组件间通信此种方式不合适 2.8. 组件间通信 3: 消息订阅与发布(PubSubJS 库)1npm install pubsub-js 1import PubSub from 'pubsub-js' 2.8.1. 订阅消息 1PubSub.subscribe('msg', function(msg, data)&#123;&#125;) 2.8.2. 发布消息 1PubSub.publish('msg', data) 2.8.3. 注意 1) 优点: 此方式可实现任意关系组件间通信(数据)2.8.4. 事件的 2 个重要操作(总结) 1) 绑定事件监听 (订阅消息)目标: 标签元素 &lt;button&gt;事件名(类型): click/focus回调函数: function(event){}2) 触发事件 (发布消息)DOM 事件: 用户在浏览器上对应的界面上做对应的操作自定义: 编码手动触发 组件间通信 插槽4: slot2.9.1. 理解此方式用于父组件向子组件传递标签数据 编译作用域父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 2.9.2. 子组件: Child.vue 1234567&lt;template&gt; &lt;div&gt; &lt;slot name=\"xxx\"&gt;不确定的标签结构 1&lt;/slot&gt; &lt;div&gt;组件确定的标签结构&lt;/div&gt; &lt;slot name=\"yyy\"&gt;不确定的标签结构 2&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 2.9.3. 父组件: Parent.vue 1234&lt;child&gt; &lt;div slot=\"xxx\"&gt;xxx 对应的标签结构&lt;/div&gt; &lt;div slot=\"yyy\"&gt;yyy 对应的标签结构&lt;/div&gt;&lt;/child&gt; 自定义组件的 v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突： 12345678910111213141516Vue.component('base-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=\"checkbox\" v-bind:checked=\"checked\" v-on:change=\"$emit('change', $event.target.checked)\" &gt; `&#125;) 现在在这个组件上使用 v-model 的时候： 1&lt;base-checkbox v-model=\"lovingVue\"&gt;&lt;/base-checkbox&gt; 这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 &lt;base-checkbox&gt; 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的属性将会被更新。 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。 第 3 章： vue-ajax3.1. vue 项目中常用的 2 个 ajax 库3.1.1. vue-resourcevue 插件, 非官方库, vue1.x 使用广泛 3.1.2. axios通用的 ajax 请求库, 官方推荐, vue2.x 使用广泛 3.2. vue-resource 的使用3.2.1. 在线文档https://github.com/pagekit/vue-resource/blob/develop/docs/http.md3.2.2. 下载 1npm install vue-resource --save 3.2.3. 编码 12345678910111213// 引入模块import VueResource from 'vue-resource'// 使用插件Vue.use(VueResource)// 通过 vue/组件对象发送 ajax 请求this.$http.get('/someUrl').then((response) =&gt; &#123;// success callbackconsole.log(response.data) //返回结果数据&#125;, (response) =&gt; &#123;// error callbacbconsole.log(response.statusText) //错误信息&#125;) 3.3. axios 的使用3.3.1. 效果ajax_test.gif3.2. 在线文档https://github.com/pagekit/vue-resource/blob/develop/docs/http.md3.3. 下载: 1npm install axios --save 3.4. 编码 12345678910// 引入模块import axios from 'axios'// 发送 ajax 请求axios.get(url).then(response =&gt; &#123;console.log(response.data) // 得到返回结果数据&#125;).catch(error =&gt; &#123;console.log(error.message)&#125; ) 第 4 章： vue UI 组件库4.1. 常用1) Mint UI:a. 主页: http://mint-ui.github.io/#!/zh-cnb. 说明: 饿了么开源的基于 vue 的移动端 UI 组件库2) Elmenta. 主页: http://element-cn.eleme.io/#/zh-CNb. 说明: 饿了么开源的基于 vue 的 PC 端 UI 组件库4.2. 使用 Mint UI4.2.1. 下载: 1npm install --save mint-ui 4.2.2. 实现按需打包 下载 1npm install --save-dev babel-plugin-component 2.修改 babel 配置 123456\"plugins\": [\"transform-runtime\",[\"component\", [ &#123; \"libraryName\": \"mint-ui\", \"style\": true &#125;]]] 4.2.3. mint-ui 组件分类 1) 标签组件 2) 非标签组件 4.2.4. 使用 mint-ui 的组件 1)index.html 1234567891011121314151617&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\" /&gt;&lt;script src=\"https://as.alipayobjects.com/g/component/fastclick/1.0.6/fastclick.js\"&gt;&lt;/scrip t&gt; &lt;script&gt; if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false); &#125; i f(!window.Promise) &#123; document.writeln('&lt;script src=\"https://as.alipayobjects.com/g/component/es6-promise/3.2.2/es6-promise.min.js\" '+'&gt;'+'&lt;'+'/'+'script&gt;'); &#125;&lt;/script &gt; 2) main.jsimport {Button} from ‘mint-ui’Vue.component(Button.name, Button)3) App.vue 12345678910111213&lt;template&gt; &lt;mt-button @click=\"handleClick\" type=\"primary\" style=\"width: 100%\"&gt;Test&lt;/mt-button&gt;&lt;/template&gt;&lt;script&gt; import &#123;Toast&#125; from 'mint-ui' export default &#123; methods: &#123; handleClick () &#123; Toast('点击了测试'); &#125; &#125; &#125;&lt;/script&gt; 第 5 章： vue-router5.1. 理解5.1.1. 说明 1) 官方提供的用来实现 SPA 的 vue 插件2) github: https://github.com/vuejs/vue-router3) 中文文档: http://router.vuejs.org/zh-cn/4) 下载: 1npm install vue-router --save 5.1.2. 相关 API 说明1) 1234VueRouter(): 用于创建路由器的构建函数new VueRouter(&#123; // 多个配置项&#125;) 2) 路由配置 12345678910routes: [ &#123; // 一般路由 path: '/about', component: About &#125;, &#123; // 自动跳转路由 path: '/', redirect: '/about' &#125;] 3) 注册路由器 1234import router from './router'new Vue(&#123; router&#125;) 4) 使用路由组件标签 12341. &lt;router-link&gt;: 用来生成路由链接 &lt;router-link to=\"/xxx\"&gt;Go to XXX&lt;/router-link&gt;2. &lt;router-view&gt;: 用来显示当前路由组件界面 &lt;router-view&gt;&lt;/router-view&gt; 编程式路由导航1) this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面) 1router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) 2) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)3) this.$router.back(): 请求(返回)上一个记录路由4) this.$router.go(-1): 请求(返回)上一个记录路由5) this.$router.go(1): 请求下一个记录路由 5.2. 基本路由5.2.2. 路由组件Home.vueAbout.vue5.2.3. 应用组件: App.vue 1234567&lt;div&gt; &lt;!--路由链接--&gt; &lt;router-link to=\"/about\"&gt;About&lt;/router-link&gt; &lt;router-link to=\"/home\"&gt;Home&lt;/router-link&gt; &lt;!--用于渲染当前路由组件--&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 5.2.4. 路由器模块: src/router/index.js 12345678910111213141516171819202122232425// 声明使用vue-router插件/*内部定义并注册了2个组件标签(router-link/router-view),给组件对象添加了2个属性: 1. $router: 路由器 2. $route: 当前路由 */Vue.use(VueRouter)export default new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/about' &#125;, &#123; path: '/about', component: About &#125;, &#123; path: '/home', component: Home &#125; ]&#125;） 5.2.5. 注册路由器: main.js12345678import Vue from 'vue'import router from './router'// 创建 vue 配置路由器new Vue(&#123;el: '#app',router,render: h =&gt; h(app)&#125;) 5.2.6. 优化路由器配置linkActiveClass: ‘active’, // 指定选中的路由链接的 class5.2.7. 总结: 编写使用路由的 3 步 1) 定义路由组件2) 注册路由3) 使用路由 12&lt;router-link&gt;&lt;router-view&gt; 注意注册VueRouter路由是的属性不是routers是==routes== 1234567Vue.use(VueRouter)export default new VueRouter(&#123; routes: [ &#123;&#125; ]&#125;） 5.3. 嵌套路由嵌套路由，通常是在page里放component使用 5.3.2. 子路由组件News.vueMessage.vue 5.3.3. 配置嵌套路由: router.js123456789101112path: '/home', component: home, children: [ &#123; path: 'news', component: News &#125;, &#123; path: 'message', component: Message &#125; ] 5.3.4. 路由链接: Home.vue123&lt;router-link to=\"/home/news\"&gt;News&lt;/router-link&gt;&lt;router-link to=\"/home/message\"&gt;Message&lt;/router-link&gt;&lt;router-view&gt;&lt;/route-view 默认子路由redirect：重定向到默认子路由的路径 123456789101112131415161718&#123; path: \"/contest/view/:id\", component: ContestView, redirect: '/contest/view/:id/contestProblem', name: 'contestView', children: [ &#123; // 当 /contest/view/:id/contestProblem 匹配成功， path: 'contestProblem', component: ContestProblem &#125;, &#123; // 当 /contest/view/:id/contestProblem 匹配成功， path: 'contestSolution', component: SolutionSet &#125; ]&#125; 5.4. 向路由组件传递数据5.4.2. 方式 1: 路由路径携带参数(param/query)1) 配置路由 123456children: [ &#123; path: 'mdetail/:id', component: MessageDetail &#125;] 2) 路由路径 1&lt;router-link :to=\"'/home/message/mdetail/'+m.id\"&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; 3) 路由组件中读取请求参数 123456789this.$route.params.idwatch: &#123; $route: function () &#123; // 改变当前路由组件参数数据时自动调用 console.log('$route()') const id = this.$route.params.id this.detail = messageDetails.find(detail =&gt; detail.id===id*1) &#125;&#125; $route.query 类型: Object 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。 5.4.3. 方式 2: &lt;router-view&gt;属性携带数据1&lt;router-view :msg=\"msg\"&gt;&lt;/router-view&gt; 5.5. 缓存路由组件对象5.5.1. 理解 1) 默认情况下, 被切换的路由组件对象会死亡释放, 再次回来时是重新创建的2) 如果可以缓存路由组件对象, 可以提高用户体验5.5.2. 编码实现 123&lt;keep-alive&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 实现跳转时判断是否登录main.js 1234567891011121314151617181920212223242526272829303132router.beforeEach((to, from, next) =&gt; &#123; if (to.meta.title) &#123; document.title = to.meta.title &#125; const flag = to.meta.withOutLogin console.log(flag) console.log(store.state.user) // 判断该路由是否需要登录权限 if (!flag &amp;&amp; !store.state.user) &#123; request(&#123; url: \"/user/info\", method: \"GET\" &#125;) .then(res =&gt; &#123; console.log(res); if(res.data.success)&#123; next() const user = res.data.extend.user; store.commit(RECEIVE_USER, &#123; user &#125;) &#125;else&#123; next('/login') &#125; &#125;) .catch(err =&gt; &#123; console.log(err); &#125;); &#125; else &#123; next() // 确保一定要有next()被调用 &#125;&#125;) 5.7 reoute.routes里的meta属性meta能给每个route指定附加值. 可以实现通过路径判断是否显示组件 1234567&#123; path: '/msite', component: Msite, meta: &#123; showFooter: true &#125;&#125; 1&lt;FooterGuide v-show=\"$route.meta.showFooter\"&gt;&lt;/FooterGuide&gt; 第 6 章： vuex6.1. vuex 理解6.1.1. vuex 是什么 1) github 站点: https://github.com/vuejs/vuex2) 在线文档: https://vuex.vuejs.org/zh-cn/3) 简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)6.1.2. 状态自管理应用 1) state: 驱动应用的数据源 2) view: 以声明方式将 state 映射到视图3) actions: 响应在 view 上的用户输入导致的状态变化(包含 n 个更新状态的方法) 6.1.3. 多组件共享状态的问题 1) 多个视图依赖于同一状态2) 来自不同视图的行为需要变更同一状态3) 以前的解决办法a. 将数据以及操作数据的行为都定义在父组件b. 将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)4) vuex 就是用来解决这个问题的 6.2. vuex 核心概念和 API6.2.1. state1) vuex 管理的状态对像 2) 它应该是唯一的 123const state = &#123; xxx: initValue&#125; 12345import &#123; mapState, mapActions &#125; from \"vuex\";computed: mapState([ // 映射 this.count 为 store.state.count 'count']) 6.2.2. mutations1) 包含多个直接更新 state 的方法(回调函数)的对象2) 谁来触发: action 中的 commit(‘mutation 名称’)3) 只能包含同步的代码, 不能写异步代码 12345const mutations = &#123; yyy (state, &#123;data1&#125;) &#123; // 更新 state 的某个属性 &#125;&#125; 6.2.3. actions1) 包含多个事件回调函数的对象2) 通过执行: commit()来触发 mutation 的调用, 间接更新 state3) 谁来触发: 组件中: $store.dispatch(‘action 名称’, data1) // ‘zzz’4) 可以包含异步代码(定时器, ajax) 12345const actions = &#123; zzz (&#123;commit, state&#125;, data1) &#123; commit('yyy', &#123;data1&#125;) &#125;&#125; 6.2.4. getters1) 包含多个计算属性(get)的对象2) 谁来读取: 组件中: $store.getters.xxx 123456const getters = &#123; mmm (state) &#123; return .. &#125;&#125; 6.2.5. modules1) 包含多个 module2) 一个 module 是一个 store 的配置对象3) 与一个组件(包含有共享数据)对应 6.2.6. 向外暴露 store 对象123456export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;) 6.2.7. 组件中123456789import &#123;mapState, mapGetters, mapActions&#125; from 'vuex'export default &#123; computed: &#123; ...mapState(['xxx']), ...mapGetters(['mmm']), &#125; m ethods: mapActions(['zzz'])&#125; &#123; &#123;xxx&#125;&#125; &#123;&#123;mmm&#125;&#125; @click=\"zzz(data)\" 6.2.8. 映射 store1234import store from './store'new Vue(&#123; store&#125; 6.2.9. store 对象1) 所有用 vuex 管理的组件中都多了一个属性$store, 它就是一个 store 对象2) 属性: 12state: 注册的 state 对象getters: 注册的 getters 对象 3) 方法:dispatch(actionName, data): 分发调用 action 6.3使用案例使用时安装 1npm install --save vuex 6.3. demo1: 计数器5.3.1 定义store模块store.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*** vuex 的 store 对象模块*/import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)/*state 对象类似于 data*/const state = &#123; count: 0 // 初始化状态数据&#125; /* mutations 对象包含个方法: 能直接更新 state一个方法就是一个 mutationmutation 只能包含更新 state 的同步代码, 也不会有逻辑mutation 由 action 触发调用: commit('mutationName') */const mutations = &#123; INCREMENT(state) &#123; state.count++ &#125;, DECREMENT (state) &#123; // ctrl + shift + x state.count-- &#125;&#125;/* actions 对象 包含个方法: 触发 mutation 调用, 间接更新 state 一个方法就是一个 action action 中可以有逻辑代码和异步代码 action 由组件来触发调用: this.$store.dispatch('actionName') */const actions = &#123; increment (&#123;commit&#125;) &#123; commit('INCREMENT') &#125;, decrement (&#123;commit&#125;) &#123; commit('DECREMENT') &#125;, incrementIfOdd (&#123;commit, state&#125;) &#123; if(state.count%2===1) &#123; commit('INCREMENT') &#125; &#125;, incrementAsync (&#123;commit&#125;) &#123; setTimeout(() =&gt; &#123; commit('INCREMENT') &#125;, 1000) &#125;&#125;/*getters 对象包含多个 get 计算计算属性方法*/const getters = &#123; oddOrEven (state) &#123; return state.count%2===0 ? '偶数' : '奇数' &#125;, count (state) &#123; return state.count &#125;&#125; //向外暴露 store 实例对象export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;） 6.3.2 在vue中注册 main.js 123456789import Vue from 'vue'import app from './app1.vue'// import app from './app.vue'import store from './store'new Vue(&#123; el: '#app', render: h =&gt; h(app), store // 所有组件都多个一个属性: $store&#125;) 6.3.3. app.vue(未优化前)12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;p&gt;clicked: &#123;&#123;$store.state.count&#125;&#125; times, count is &#123;&#123;oddOrEven&#125;&#125;&lt;/p&gt;&lt;button @click=\"increment\"&gt;+&lt;/button&gt;&lt;button @click=\"decrement\"&gt;-&lt;/button&gt;&lt;button @click=\"incrementIfOdd\"&gt;increment if odd&lt;/button&gt;&lt;button @click=\"incrementAsync\"&gt;increment async&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;computed: &#123; oddOrEven () &#123; return this.$store.getters.oddOrEven &#125;&#125;, methods: &#123; increment () &#123; this.$store.dispatch('increment') &#125;, decrement () &#123; this.$store.dispatch('decrement') &#125;, incrementIfOdd () &#123; this.$store.dispatch('incrementIfOdd') &#125;, incrementAsync () &#123; this.$store.dispatch('incrementAsync') &#125; &#125;&#125; &lt;/script&gt;&lt;style&gt; &lt;/style&gt; 6.3.4. app2.vue(优化后) 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;p&gt;clicked: &#123;&#123;count&#125;&#125; times, count is &#123;&#123;oddOrEven2&#125;&#125;&lt;/p&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;button @click=\"incrementIfOdd\"&gt;increment if odd&lt;/button&gt; &lt;button @click=\"incrementAsync\"&gt;increment async&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123;mapGetters, mapActions&#125; from 'vuex' export default &#123; computed: mapGetters(&#123; // 名称不一样 oddOrEven2: 'oddOrEven', count: 'count' &#125;), methods: mapActions(['increment', 'decrement', 'incrementIfOdd', 'incrementAsync']) // 名称一样 &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 6.5. vuex 结构分析 使用注意只有当前组件使用的数据不需要使用vuex管理 vue使用-me使用bootstarp1安装 需要安装jquery,因为bootstrap是依赖于jquery的。我们同样使用npm安装jquery。bootstrap也需要安装popper.js 123npm install --save jquerynpm install --save popper.jsnpm install --save bootstrap@4 2.在 vue.config.js 文件写入以下内容： 1234567891011121314151617/**Vue-CLI项目的核心配置文件*/const webpack = require(\"webpack\");module.exports = &#123; configureWebpack: &#123; plugins: [ new webpack.ProvidePlugin(&#123; $: \"jquery\", jQuery: \"jquery\", \"window.jQuery\": \"jquery\", Popper: [\"popper.js\", \"default\"] &#125;) ] &#125;&#125;; 2引入 12345678//使用bootstarpimport $ from 'jquery'import \"bootstrap/dist/css/bootstrap.css\";import \"bootstrap/dist/js/bootstrap.min.js\";new Vue(&#123; $, render: h =&gt; h(App),&#125;).$mount('#app') 使用 Font AwesomeFont Awesome：http://fontawesome.dashgame.com/ npm 安装 font-awesome 1npm install font-awesome --save-dev 1font-awesome引入在 mani.js 文件中引入 font-awesome 1import 'font-awesome/css/font-awesome.css' or 1import 'font-awesome/scss/font-awesome.scss' 1然后在组件中使用即可实现： 1&lt;span class=\"fa fa-camera-retro fa-lg\"&gt;&lt;/span&gt; vue-cli 3.x配置跨域代理1234567891011121314151617181920// vue.config.jsmodule.exports = &#123; // 修改的配置 // 将baseUrl: '/api',改为baseUrl: '/', baseUrl: '/', devServer: &#123; proxy: &#123; '/api': &#123; target: 'http://www.example.org', changeOrigin: true, ws: true, pathRewrite: &#123; '^/api': '' &#125; &#125; &#125; &#125;&#125;// .env.developmentVUE_APP_BASE_API=/api vue项目使用.env文件配置全局环境变量官方文档 关于文件名：必须以如下方式命名，不要乱起名，也无需专门手动控制加载哪个文件 .env 全局默认配置文件，不论什么环境都会加载合并 .env.development 开发环境下的配置文件 .env.production 生产环境下的配置文件 关于文件名：必须以如下方式命名，不要乱起名，也无需专门手动控制加载哪个文件 .env 全局默认配置文件，不论什么环境都会加载合并 .env.development 开发环境下的配置文件 .env.production 生产环境下的配置文件 更新package-lock.json如果要升级package-lock.json里面的库包，怎么操作呢？ 1npm install XXX@x.x.x package.json和package-lock.json到底是什么npm官方文档：http://caibaojian.com/npm/files/package.json.html 我们每次，去npm install xxx会把内容记录到package.json文件中，下载的包都会发生变化，为了系统的稳定性考虑，每次执行完npm install之后会对应生成package-lock文件，该文件记录了上一次安装的具体的版本号。 根据官方文档，package-lock.json 是生成的系统当前安装的库的具体来源和版本号，锁定版本。 当你执行npm install的时候， node会先从package.json文件中读取所有dependencies信息，然后根据dependencies中的信息与node_modules中的模块进行对比，没有的直接下载，node是从package.json文件读取模块名称，从package-lock.json文件中获取版本号，然后进行下载或者更新。 当package.json与package-lock.json都不存在，执行”npm install”时，node会重新生成package-lock.json文件，然后把node_modules中的模块信息全部记入package-lock.json文件，但不会生成package.json文件。但是，你可以通过”npm init –yes”来生成package.json文件 vue打包在官网有说，comments当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。 https://segmentfault.com/a/1190000019499007 分析12vuecli 2.x`自带了分析工具只要运行`npm run build --report 如果是vuecli 3的话，先安装插件 1npm install webpack-bundle-analyzer -save-dev 然后在vue.config.js中对webpack进行配置 1234567891011chainWebpack: (config) =&gt; &#123; /* 添加分析工具*/ if (process.env.NODE_ENV === 'production') &#123; if (process.env.npm_config_report) &#123; config .plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin) .end(); config.plugins.delete('prefetch') &#125; &#125; &#125; 再运行npm run build --report 会在浏览器打开一个项目打包的情况图，便于直观地比较各个bundle文件的大小 可以看到 项目中所有的依赖，所有的路由，都被打包进了同一个文件中 另外，在浏览器中，也可以通过converge来查看代码的使用状况 路由懒加载 当打包构建应用时，JavaScript包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 如果是在vuecli 3中，我们还需要多做一步工作因为vuecli 3默认开启prefetch(预先加载模块)，提前获取用户未来可能会访问的内容在首屏会把这十几个路由文件，都一口气下载了所以我们要关闭这个功能，在vue.config.js中设置参考官网的做法： Vue建议使用规范-使用引用路径“@”,而不是相关路径。相对于相关路径更好写，毕竟直接自顶向下。 Vue CLIvue.config.js官方文档 在vue项目中配置引用路径“@”配置引用路径（以“@”引用为项目的src目录为例）可拆分为如下两步操作配置webpack打包时将“@”解析为项目的src目录配置vsCode在路径中输入“@”时的路径提示本贴着重讲解“配置webpack打包时将‘@’解析为项目的src目录”的操作和溯源操作在项目根目录的vue.config.js文件中做如下配置 12345678910const path = require('path')module.exports = &#123; configureWebpack: &#123; resolve: &#123; alias: &#123; '@': path.resolve(__dirname, 'src') &#125; &#125; &#125;&#125; 说明：如果没有这段配置但引用路径“@”依然生效，则是环境内置了这段配置。 说明：如果没有这段配置但引用路径“@”依然生效，则是环境内置了这段配置。 溯源 来到Vue CLI官网（webpack 相关 | Vue CLI），我们可以找到如何通过“简单的方式”配置webpack的说明。 继而来到webpack官网（解析(Resolve) | webpack 中文文档），在resolve配置项中alias关键字的配置中，找到了关于“创建import或require的别名”的配置的说明。 综合以上两处文档，可以溯源“配置webpack打包时将‘@’解析为项目的src目录”的语法出处。 关于如何“配置vsCode在路径中输入‘@’时的路径提示” 可以参考这篇帖子——vsCode配置import@路径提示_SunnyRun-CSDN博客 特别提醒：在样式中使用引用路径时，前面需要加“~” 示例代码 @import \"~@/styles/variables.less\"; .test { background: url('~@/assets/images/logo.png') } 溯源 在less官网（Less 快速入门 | Less.js 中文文档 - Less 中文网），可以找到关于引入less文件的语法出处，但并未发现有关使用引用路径前面需要加“~”的说明。 继而来到Vue CLI官网（CSS 相关 | Vue CLI），找到了使用引用路径时需要在路径前加上“~”的相关说明。 但其实，这个规则从根本上了来讲，由webpack官网（less-loader | webpack 中文文档）的less-loader部分文档决定，因为Vue CLI的打包功能是由webpack实现的。 ————————————————原文链接：https://blog.csdn.net/m0_60692814/article/details/120242411 configureWebpack# Type: Object | Function 如果这个值是一个对象，则会通过 webpack-merge 合并到最终的配置中。 如果这个值是一个函数，则会接收被解析的配置作为参数。该函数既可以修改配置并不返回任何东西，也可以返回一个被克隆或合并过的配置版本。 更多细节可查阅：[配合 webpack &gt; 简单的配置方式](","categories":[{"name":"js","slug":"js","permalink":"https://codeofli.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://codeofli.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://codeofli.github.io/tags/vue/"}]},{"title":"pythonSpider","slug":"python/pythonSpider/pythonSpider","date":"2019-11-10T14:21:09.000Z","updated":"2021-10-23T02:19:04.278Z","comments":true,"path":"2019/11/python/pythonSpider/pythonSpider/","link":"","permalink":"https://codeofli.github.io/2019/11/python/pythonSpider/pythonSpider/","excerpt":"[TOC]安装1pip install requests安装chromedrivehttps://www.cnblogs.com/lfri/p/10542797.html1、查看自己chrome浏览器的版本。 浏览器地址栏输入以下地址 chrome://version通过自己的版本下载相应的chromedriver.exe","text":"[TOC]安装1pip install requests安装chromedrivehttps://www.cnblogs.com/lfri/p/10542797.html1、查看自己chrome浏览器的版本。 浏览器地址栏输入以下地址 chrome://version通过自己的版本下载相应的chromedriver.exe 下载地址：http://npm.taobao.org/mirrors/chromedriver/ 配置解压压缩包，找到chromedriver.exe复制到chrome的安装目录（其实也可以随便放一个文件夹）。复制chromedriver.exe文件的路径并加入到电脑的环境变量中去。 在shell中输入 1chromedriver 显示： 123Starting ChromeDriver 78.0.3904.105 (60e2d8774a8151efa6a00b1f358371b1e0e07ee2-refs/branch-heads/3904@&#123;#877&#125;) on port 9515Only local connections are allowed.Please protect ports used by ChromeDriver and related test frameworks to prevent access by malicious code. 则安装成功 使用python selenium测试 123import seleniumfrom selenium import webdriverdriver = webdriver.Chrome() 能打开浏览器则安装成功 phantomjs已经没人用了，都是headless chrome 爬虫基本原理讲解爬虫——请求网站并提取数据的自动化程序 爬取代码 12345678910import requests# response = requests.get('http://www.baidu.com')# print(response.text)response = requests.get('http://www.baidu.com/img/baidu_jgylogo3.gif')print(response.content)with open('baidu.jpg','wb') as f: f.write(response.content) f.close Urlliburllib提供了一系列用于操作URL的功能。 Python内置的HTTP请求库 urllib.request 请求模块 urllib.error 异常处理理模块urllib.parse url解析模块urllib.robotparser robots.txt解析模块 123import urllib.requestresponse = urllib.request.urlopen('http://www.baidu.com')print(response.read().decode('utf-8')) 123456import urllib.parseimport urllib.requestdata = bytes(urllib.parse.urlencode(&#123;'word': 'hello'&#125;), encoding='utf8')response = urllib.request.urlopen('http://httpbin.org/post', data=data)print(response.read()) 1234import urllib.requestresponse = urllib.request.urlopen('http://httpbin.org/get', timeout=1)print(response.read()) 1234import urllib.requestresponse = urllib.request.urlopen('http://httpbin.org/get', timeout=1)print(response.read()) 响应响应类型1234import urllib.requestresponse = urllib.request.urlopen('https://www.python.org')print(type(response)) 状态码、响应头123456import urllib.requestresponse = urllib.request.urlopen('https://www.python.org')print(response.status)print(response.getheaders())print(response.getheader('Server')) 1234import urllib.requestresponse = urllib.request.urlopen('https://www.python.org')print(response.read().decode('utf-8')) Request12345import urllib.requestrequest = urllib.request.Request('https://python.org')response = urllib.request.urlopen(request)print(response.read().decode('utf-8')) 1234567891011121314from urllib import request, parseurl = 'http://httpbin.org/post'headers = &#123; 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)', 'Host': 'httpbin.org'&#125;dict = &#123; 'name': 'Germey'&#125;data = bytes(parse.urlencode(dict), encoding='utf8')req = request.Request(url=url, data=data, headers=headers, method='POST')response = request.urlopen(req)print(response.read().decode('utf-8')) Handler代理12345678910import urllib.requestproxy_handler = urllib.request.ProxyHandler(&#123; 'http': 'http://127.0.0.1:9743', 'https': 'https://127.0.0.1:9743'&#125;)opener = urllib.request.build_opener(proxy_handler)response = opener.open('http://httpbin.org/get')print(response.read()) Cookie12345678import http.cookiejar, urllib.requestcookie = http.cookiejar.CookieJar()handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')for item in cookie: print(item.name+\"=\"+item.value) 1234567import http.cookiejar, urllib.requestfilename = \"cookie.txt\"cookie = http.cookiejar.MozillaCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')cookie.save(ignore_discard=True, ignore_expires=True) 1234567import http.cookiejar, urllib.requestfilename = 'cookie.txt'cookie = http.cookiejar.LWPCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')cookie.save(ignore_discard=True, ignore_expires=True) 1234567891048import http.cookiejar, urllib.requestcookie = http.cookiejar.LWPCookieJar()cookie.load('cookie.txt', ignore_discard=True, ignore_expires=True)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')print(response.read().decode('utf-8')) 异常处理12345from urllib import request, errortry: response = request.urlopen('http://cuiqingcai.com/index.htm')except error.URLError as e: print(e.reason) 12345678910from urllib import request, errortry: response = request.urlopen('http://cuiqingcai.com/index.htm')except error.HTTPError as e: print(e.reason, e.code, e.headers, sep='\\n')except error.URLError as e: print(e.reason)else: print('Request Successfully') 12345678910import socketimport urllib.requestimport urllib.errortry: response = urllib.request.urlopen('https://www.baidu.com', timeout=0.01)except urllib.error.URLError as e: print(type(e.reason)) if isinstance(e.reason, socket.timeout): print('TIME OUT') 12&lt;class 'socket.timeout'&gt;TIME OUT URL解析urlparse1234567urllib.parse.urlparse(urlstring, scheme='', allow_fragments=True)52from urllib.parse import urlparseresult = urlparse('http://www.baidu.com/index.html;user?id=5#comment')print(type(result), result) 1234567&lt;class 'urllib.parse.ParseResult'&gt; ParseResult(scheme='http', netloc='www.baidu.com', path='/index.html', params='user', query='id=5', fragment='comment')53from urllib.parse import urlparseresult = urlparse('www.baidu.com/index.html;user?id=5#comment', scheme='https')print(result) 1234567ParseResult(scheme='https', netloc='', path='www.baidu.com/index.html', params='user', query='id=5', fragment='comment')54from urllib.parse import urlparseresult = urlparse('http://www.baidu.com/index.html;user?id=5#comment', scheme='https')print(result) 1234567ParseResult(scheme='http', netloc='www.baidu.com', path='/index.html', params='user', query='id=5', fragment='comment')55from urllib.parse import urlparseresult = urlparse('http://www.baidu.com/index.html;user?id=5#comment', allow_fragments=False)print(result) 1234567ParseResult(scheme='http', netloc='www.baidu.com', path='/index.html', params='user', query='id=5#comment', fragment='')56from urllib.parse import urlparseresult = urlparse('http://www.baidu.com/index.html#comment', allow_fragments=False)print(result) 1ParseResult(scheme='http', netloc='www.baidu.com', path='/index.html#comment', params='', query='', fragment='') urlunparse1234from urllib.parse import urlunparsedata = ['http', 'www.baidu.com', 'index.html', 'user', 'a=6', 'comment']print(urlunparse(data)) 1http://www.baidu.com/index.html;user?a=6#comment urljoin12345678910111258from urllib.parse import urljoinprint(urljoin('http://www.baidu.com', 'FAQ.html'))print(urljoin('http://www.baidu.com', 'https://cuiqingcai.com/FAQ.html'))print(urljoin('http://www.baidu.com/about.html', 'https://cuiqingcai.com/FAQ.html'))print(urljoin('http://www.baidu.com/about.html', 'https://cuiqingcai.com/FAQ.html?question=2'))print(urljoin('http://www.baidu.com?wd=abc', 'https://cuiqingcai.com/index.php'))print(urljoin('http://www.baidu.com', '?category=2#comment'))print(urljoin('www.baidu.com', '?category=2#comment'))print(urljoin('www.baidu.com#comment', '?category=2')) 12345678http://www.baidu.com/FAQ.htmlhttps://cuiqingcai.com/FAQ.htmlhttps://cuiqingcai.com/FAQ.htmlhttps://cuiqingcai.com/FAQ.html?question=2https://cuiqingcai.com/index.phphttp://www.baidu.com?category=2#commentwww.baidu.com?category=2#commentwww.baidu.com?category=2 urlencode123456789from urllib.parse import urlencodeparams = &#123; 'name': 'germey', 'age': 22&#125;base_url = 'http://www.baidu.com?'url = base_url + urlencode(params)print(url) 1http://www.baidu.com?name=germey&amp;age=22 Requests库什么是RequestsRequests 是用Python语言编写，基于 urllib，采⽤用Apache2 Licensed 开源协议的 HTTP 库。它比 urllib 更加方便，可以节约我们大量的工作，完全满⾜足HTTP 测试需求。⼀一句句话——Python实现的简单易易用的HTTP库 实例引入12345678import requestsresponse = requests.get('https://www.baidu.com/')print(type(response))print(response.status_code)print(type(response.text))print(response.text)print(response.cookies) 各种请求方式123456import requestsrequests.post('http://httpbin.org/post')requests.put('http://httpbin.org/put')requests.delete('http://httpbin.org/delete')requests.head('http://httpbin.org/get')requests.options('http://httpbin.org/get') 请求基本GET请求基本写法1234import requestsresponse = requests.get('http://httpbin.org/get')print(response.text) 带参数GET请求123import requestsresponse = requests.get(\"http://httpbin.org/get?name=germey&amp;age=22\")print(response.text) 12345678import requestsdata = &#123; 'name': 'germey', 'age': 22&#125;response = requests.get(\"http://httpbin.org/get\", params=data)print(response.text) 解析json12345678import requestsimport jsonresponse = requests.get(\"http://httpbin.org/get\")print(type(response.text))print(response.json())print(json.loads(response.text))print(type(response.json())) 获取二进制数据123456import requestsresponse = requests.get(\"https://github.com/favicon.ico\")print(type(response.text), type(response.content))print(response.text)print(response.content) 123456import requestsresponse = requests.get(\"https://github.com/favicon.ico\")with open('favicon.ico', 'wb') as f: f.write(response.content) f.close() 添加headers1234import requestsresponse = requests.get(\"https://www.zhihu.com/explore\")print(response.text) 1234567import requestsheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'&#125;response = requests.get(\"https://www.zhihu.com/explore\", headers=headers)print(response.text) 基本POST请求12345import requestsdata = &#123;'name': 'germey', 'age': '22'&#125;response = requests.post(\"http://httpbin.org/post\", data=data)print(response.text) 12345678import requestsdata = &#123;'name': 'germey', 'age': '22'&#125;headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'&#125;response = requests.post(\"http://httpbin.org/post\", data=data, headers=headers)print(response.json()) 响应reponse属性12345678import requestsresponse = requests.get('http://www.jianshu.com')print(type(response.status_code), response.status_code)print(type(response.headers), response.headers)print(type(response.cookies), response.cookies)print(type(response.url), response.url)print(type(response.history), response.history) 状态码判断1234import requestsresponse = requests.get('http://www.jianshu.com/hello.html')exit() if not response.status_code == requests.codes.not_found else print('404 Not Found') 1234import requestsresponse = requests.get('http://www.jianshu.com')exit() if not response.status_code == 200 else print('Request Successfully') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475100: ('continue',),101: ('switching_protocols',),102: ('processing',),103: ('checkpoint',),122: ('uri_too_long', 'request_uri_too_long'),200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\\\o/', '✓'),201: ('created',),202: ('accepted',),203: ('non_authoritative_info', 'non_authoritative_information'),204: ('no_content',),205: ('reset_content', 'reset'),206: ('partial_content', 'partial'),207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),208: ('already_reported',),226: ('im_used',),# Redirection.300: ('multiple_choices',),301: ('moved_permanently', 'moved', '\\\\o-'),302: ('found',),303: ('see_other', 'other'),304: ('not_modified',),305: ('use_proxy',),306: ('switch_proxy',),307: ('temporary_redirect', 'temporary_moved', 'temporary'),308: ('permanent_redirect', 'resume_incomplete', 'resume',), # These 2 to be removed in 3.0# Client Error.400: ('bad_request', 'bad'),401: ('unauthorized',),402: ('payment_required', 'payment'),403: ('forbidden',),404: ('not_found', '-o-'),405: ('method_not_allowed', 'not_allowed'),406: ('not_acceptable',),407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),408: ('request_timeout', 'timeout'),409: ('conflict',),410: ('gone',),411: ('length_required',),412: ('precondition_failed', 'precondition'),413: ('request_entity_too_large',),414: ('request_uri_too_large',),415: ('unsupported_media_type', 'unsupported_media', 'media_type'),416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),417: ('expectation_failed',),418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),421: ('misdirected_request',),422: ('unprocessable_entity', 'unprocessable'),423: ('locked',),424: ('failed_dependency', 'dependency'),425: ('unordered_collection', 'unordered'),426: ('upgrade_required', 'upgrade'),428: ('precondition_required', 'precondition'),429: ('too_many_requests', 'too_many'),431: ('header_fields_too_large', 'fields_too_large'),444: ('no_response', 'none'),449: ('retry_with', 'retry'),450: ('blocked_by_windows_parental_controls', 'parental_controls'),451: ('unavailable_for_legal_reasons', 'legal_reasons'),499: ('client_closed_request',),# Server Error.500: ('internal_server_error', 'server_error', '/o\\\\', '✗'),501: ('not_implemented',),502: ('bad_gateway',),503: ('service_unavailable', 'unavailable'),504: ('gateway_timeout',),505: ('http_version_not_supported', 'http_version'),506: ('variant_also_negotiates',),507: ('insufficient_storage',),509: ('bandwidth_limit_exceeded', 'bandwidth'),510: ('not_extended',),511: ('network_authentication_required', 'network_auth', 'network_authentication'), 高级操作文件上传12345import requestsfiles = &#123;'file': open('favicon.ico', 'rb')&#125;response = requests.post(\"http://httpbin.org/post\", files=files)print(response.text) 12 获取cookie123456import requestsresponse = requests.get(\"https://www.baidu.com\")print(response.cookies)for key, value in response.cookies.items(): print(key + '=' + value) 会话维持模拟登录 12345import requestsrequests.get('http://httpbin.org/cookies/set/number/123456789')response = requests.get('http://httpbin.org/cookies')print(response.text) 123456import requestss = requests.Session()s.get('http://httpbin.org/cookies/set/number/123456789')response = s.get('http://httpbin.org/cookies')print(response.text) 12 证书验证12 1234import requestsresponse = requests.get('https://www.12306.cn')print(response.status_code) 12 12345import requestsfrom requests.packages import urllib3urllib3.disable_warnings()response = requests.get('https://www.12306.cn', verify=False)print(response.status_code) 12 1234import requestsresponse = requests.get('https://www.12306.cn', cert=('/path/server.crt', '/path/key'))print(response.status_code) 12 代理设置12 123456789import requestsproxies = &#123; \"http\": \"http://127.0.0.1:9743\", \"https\": \"https://127.0.0.1:9743\",&#125;response = requests.get(\"https://www.taobao.com\", proxies=proxies)print(response.status_code) 12 1234567import requestsproxies = &#123; \"http\": \"http://user:password@127.0.0.1:9743/\",&#125;response = requests.get(\"https://www.taobao.com\", proxies=proxies)print(response.status_code) 12 1pip3 install 'requests[socks]' 12 12345678import requestsproxies = &#123; 'http': 'socks5://127.0.0.1:9742', 'https': 'socks5://127.0.0.1:9742'&#125;response = requests.get(\"https://www.taobao.com\", proxies=proxies)print(response.status_code) 12 超时设置12 1234567import requestsfrom requests.exceptions import ReadTimeouttry: response = requests.get(\"http://httpbin.org/get\", timeout = 0.5) print(response.status_code)except ReadTimeout: print('Timeout') 12 认证设置12 12345import requestsfrom requests.auth import HTTPBasicAuthr = requests.get('http://120.27.34.24:9001', auth=HTTPBasicAuth('user', '123'))print(r.status_code) 12 1234import requestsr = requests.get('http://120.27.34.24:9001', auth=('user', '123'))print(r.status_code) 12 异常处理1234567891011121345import requestsfrom requests.exceptions import ReadTimeout, ConnectionError, RequestExceptiontry: response = requests.get(\"http://httpbin.org/get\", timeout = 0.5) print(response.status_code)except ReadTimeout: print('Timeout')except ConnectionError: print('Connection error')except RequestException: print('Error') 1Connection error BeautifulSoup解析库 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, “html.parser”) Python的内置标准库、执行速度适中 、文档容错能力强 Python 2.7.3 or 3.2.2)前的版本中文容错能力差 lxml HTML 解析器 BeautifulSoup(markup, “lxml”) 速度快、文档容错能力强 需要安装C语言库 lxml XML 解析器 BeautifulSoup(markup, “xml”) 速度快、唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, “html5lib”) 最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档 速度慢、不依赖外部扩展 基本使用12345678910111213141516171html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.prettify())print(soup.title.string) 12345678910111213141516171819202122232425262728293031323334&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"title\" name=\"dromouse\"&gt; &lt;b&gt; The Dormouse's story &lt;/b&gt; &lt;/p&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt; &lt;!-- Elsie --&gt; &lt;/a&gt; , &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt; ;and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;The Dormouse's story 12 1No output 标签选择器12 选择元素123456789101112131415161718192html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.title)print(type(soup.title))print(soup.head)print(soup.p) 1234&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;class 'bs4.element.Tag'&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; 获取名称123456789101112131415163html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.title.name) 1title 获取属性12345678910111213141516174html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.attrs['name'])print(soup.p['name']) 12dromousedromouse 获取内容123456789101112131415165html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p clss=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.string) 1The Dormouse's story 嵌套选择123456789101112131415166html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.head.title.string) 1The Dormouse's story 子节点和子孙节点12345678910111213141516171819202122237html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.contents) 12345678910111213141516171819202122232425262728['\\n Once upon a time there were three little sisters; and their names were\\n ', &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;, '\\n', &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;, ' \\n and\\n ', &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;, '\\n and they lived at the bottom of a well.\\n ']8html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.children)for i, child in enumerate(soup.p.children): print(i, child) 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;list_iterator object at 0x1064f7dd8&gt;0 Once upon a time there were three little sisters; and their names were 1 &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 3 &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;4 and 5 &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;6 and they lived at the bottom of a well. 9html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.descendants)for i, child in enumerate(soup.p.descendants): print(i, child) 123456789101112131415161718192021222324&lt;generator object descendants at 0x10650e678&gt;0 Once upon a time there were three little sisters; and their names were 1 &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 3 &lt;span&gt;Elsie&lt;/span&gt;4 Elsie5 6 7 &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;8 Lacie9 and 10 &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;11 Tillie12 and they lived at the bottom of a well. 父节点和祖先节点123456789101112131415161718192021222310html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.a.parent) 123456789101112131415161718192021222324252627282930313233&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;11html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(list(enumerate(soup.a.parents))) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[(0, &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;), (1, &lt;body&gt;&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;&lt;/body&gt;), (2, &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;), (3, &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;)] 兄弟节点12345678910111213141516171819202122232412html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(list(enumerate(soup.a.next_siblings)))print(list(enumerate(soup.a.previous_siblings))) 12[(0, '\\n'), (1, &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;), (2, ' \\n and\\n '), (3, &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;), (4, '\\n and they lived at the bottom of a well.\\n ')][(0, '\\n Once upon a time there were three little sisters; and their names were\\n ')] 标准选择器12 find_all( name , attrs , recursive , text , **kwargs )12 可根据标签名、属性、内容查找文档 12 name12345678910111213141516171819202122232413html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all('ul'))print(type(soup.find_all('ul')[0])) 123456789101112131415161718192021222324252627282930313233[&lt;ul class=\"list\" id=\"list-1\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;, &lt;ul class=\"list list-small\" id=\"list-2\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;/ul&gt;]&lt;class 'bs4.element.Tag'&gt;14html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.find_all('ul'): print(ul.find_all('li')) 12[&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;, &lt;li class=\"element\"&gt;Jay&lt;/li&gt;][&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;] attrs12345678910111213141516171819202122232415html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\" name=\"elements\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(attrs=&#123;'id': 'list-1'&#125;))print(soup.find_all(attrs=&#123;'name': 'elements'&#125;)) 12345678910111213141516171819202122232425262728293031323334[&lt;ul class=\"list\" id=\"list-1\" name=\"elements\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;][&lt;ul class=\"list\" id=\"list-1\" name=\"elements\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;]16html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(id='list-1'))print(soup.find_all(class_='element')) 123456[&lt;ul class=\"list\" id=\"list-1\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;][&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;, &lt;li class=\"element\"&gt;Jay&lt;/li&gt;, &lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;] text123456789101112131415161718192021222317html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(text='Foo')) 1['Foo', 'Foo'] find( name , attrs , recursive , text , **kwargs )12 find返回单个元素，find_all返回所有元素 1234567891011121314151617181920212223242518html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find('ul'))print(type(soup.find('ul')))print(soup.find('page')) 1234567&lt;ul class=\"list\" id=\"list-1\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;&lt;class 'bs4.element.Tag'&gt;None find_parents() find_parent()12 find_parents()返回所有祖先节点，find_parent()返回直接父节点。 12 find_next_siblings() find_next_sibling()12 find_next_siblings()返回后面所有兄弟节点，find_next_sibling()返回后面第一个兄弟节点。 12 find_previous_siblings() find_previous_sibling()12 find_previous_siblings()返回前面所有兄弟节点，find_previous_sibling()返回前面第一个兄弟节点。 12 find_all_next() find_next()12 find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点 12 find_all_previous() 和 find_previous()12 find_all_previous()返回节点后所有符合条件的节点, find_previous()返回第一个符合条件的节点 12 CSS选择器12 通过select()直接传入CSS选择器即可完成选择 123456789101112131415161718192021222324252619html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.select('.panel .panel-heading'))print(soup.select('ul li'))print(soup.select('#list-2 .element'))print(type(soup.select('ul')[0])) 123456789101112131415161718192021222324252627282930[&lt;div class=\"panel-heading\"&gt;&lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;][&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;, &lt;li class=\"element\"&gt;Jay&lt;/li&gt;, &lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;][&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;]&lt;class 'bs4.element.Tag'&gt;20html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.select('ul'): print(ul.select('li')) 12[&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;, &lt;li class=\"element\"&gt;Jay&lt;/li&gt;][&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;] 获取属性1234567891011121314151617181920212223242521html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.select('ul'): print(ul['id']) print(ul.attrs['id']) 1234list-1list-1list-2list-2 获取内容12345678910111213141516171819202122232423html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for li in soup.select('li'): print(li.get_text()) 12345FooBarJayFooBar 总结12 推荐使用lxml解析库，必要时使用html.parser 标签选择筛选功能弱但是速度快 建议使用find()、find_all() 查询匹配单个结果或者多个结果 如果对CSS选择器熟悉建议使用select() 记住常用的获取属性和文本值的方法 pyquery安装 1pip install pyquery 官方文档http://pyquery.readthedocs.io/ 初始化字符串初始化1doc = pq(html) 1234567891011121314html = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)print(doc('li')) 12345&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; URL初始化123from pyquery import PyQuery as pqdoc = pq(url='http://www.baidu.com')print(doc('head')) 1&lt;head&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"/&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"/&gt;&lt;meta content=\"always\" name=\"referrer\"/&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css\"/&gt;&lt;title&gt;ç¾åº¦ä¸ä¸ï¼ä½ å°±ç¥é&lt;/title&gt;&lt;/head&gt; 文件初始化123from pyquery import PyQuery as pqdoc = pq(filename='demo.html')print(doc('li')) 12345&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; 基本CSS选择器py产生的对象能和jquery对象一样使用css选择器 1234567891011121314html = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)print(doc('#container .list li')) 12345&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; 查找元素子元素12345678910111213141516171819html = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)items = doc('.list')print(type(items))print(items)lis = items.find('li')print(type(lis))print(lis) 123lis = items.children()print(type(lis))print(lis) 12lis = items.children('.active')print(lis) 12&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; 父元素1.parent() 1234567891011121314151617html = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)items = doc('.list')container = items.parent()print(type(container))print(container) 12345678910&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 12345678910111213141516171819html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)items = doc('.list')parents = items.parents()print(type(parents))print(parents) 12345678910111213141516171819202122232425&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 10parent = items.parents('.wrap')print(parent) 1234567891011&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; 兄弟元素1234567891011121314151617181911html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.list .item-0.active')print(li.siblings()) 123456789101112131415161718192021222324&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; 12html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.list .item-0.active')print(li.siblings('.active')) 1&lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; 遍历12 单个元素1234567891011121314151617html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')print(li) 1234567891011121314151617181920212223&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 14html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)lis = doc('li').items()print(type(lis))for li in lis: print(li) 12345678910&lt;class 'generator'&gt;&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; 获取信息获取属性1item.attr() 12345678910111213141516171819html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)a = doc('.item-0.active a')print(a)print(a.attr('href'))print(a.attr.href) 123&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;link3.htmllink3.html 获取文本1item.text() 获取HTML1item.html() DOM操作addClass、removeClass123456789101112131415161718192021222319html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')print(li)li.removeClass('active')print(li)li.addClass('active')print(li) 12345&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; attr、css123456789101112131415161718192021222320html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')print(li)li.attr('name', 'link')print(li)li.css('font-size', '14px')print(li) 12345&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\" name=\"link\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\" name=\"link\" style=\"font-size: 14px\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; remove123456789101112131421html = '''&lt;div class=\"wrap\"&gt; Hello, World &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)wrap = doc('.wrap')print(wrap.text())wrap.find('p').remove()print(wrap.text()) 12Hello, World This is a paragraph.Hello, World 其他DOM方法12 http://pyquery.readthedocs.io/en/latest/api.html 12 伪类选择器123456789101112131415161718192021222324252627282923html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('li:first-child')print(li)li = doc('li:last-child')print(li)li = doc('li:nth-child(2)')print(li)li = doc('li:gt(2)')print(li)li = doc('li:nth-child(2n)')print(li)li = doc('li:contains(second)')print(li) 12345678910111213&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; 更多CSS选择器可以查看http://www.w3school.com.cn/css/index.asp Selenium官方文档 中文官网 安装 1pip install selenium 基本使用12345678910111213141516171819from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitbrowser = webdriver.Chrome()try: browser.get('https://www.baidu.com') input = browser.find_element_by_id('kw') input.send_keys('Python') input.send_keys(Keys.ENTER) wait = WebDriverWait(browser, 10) wait.until(EC.presence_of_element_located((By.ID, 'content_left'))) print(browser.current_url) print(browser.get_cookies()) print(browser.page_source)finally: browser.close() 1234567https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=Python&amp;rsv_pq=c94d0df9000a72d0&amp;rsv_t=07099xvun1ZmC0bf6eQvygJ43IUTTUOl5FCJVPgwG2YREs70GplJjH2F%2BCQ&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=6&amp;rsv_sug2=0&amp;inputT=87&amp;rsv_sug4=87[&#123;'secure': False, 'value': 'B490B5EBF6F3CD402E515D22BCDA1598', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BDORZ', 'expiry': 1491688071.707553&#125;, &#123;'secure': False, 'value': '22473_1441_21084_17001', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'H_PS_PSSID'&#125;, &#123;'secure': False, 'value': '531', 'domain': 'www.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BDSVRTM'&#125;, &#123;'secure': False, 'value': '1', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'PSINO'&#125;, &#123;'secure': False, 'value': '2759B6BCB05A61360E722492B5ADE01F:FG=1', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BAIDUID', 'expiry': 3639085317.693848&#125;, &#123;'secure': False, 'value': '1', 'domain': 'www.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BD_CK_SAM'&#125;, &#123;'secure': False, 'value': '2759B6BCB05A61360E722492B5ADE01F', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BIDUPSID', 'expiry': 3639085317.693914&#125;, &#123;'secure': False, 'value': '1491601670', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'PSTM', 'expiry': 3639085317.693932&#125;, &#123;'secure': False, 'value': 'd69fIn5RRf0Bp01TcnTIY15NEdl5QudrAwHpE1x1AjuuYXbVOQkXABYVF5M', 'domain': 'www.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'H_PS_645EC', 'expiry': 1491604263&#125;, &#123;'secure': False, 'value': '123253', 'domain': 'www.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BD_UPN', 'expiry': 1492465670&#125;, &#123;'secure': False, 'value': '0', 'domain': 'www.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BD_HOME'&#125;, &#123;'secure': False, 'value': '12883875381399993259_00_0_I_R_2_0303_C02F_N_I_I_0', 'domain': '.www.baidu.com', 'path': '/', 'httpOnly': False, 'name': '__bsi', 'expiry': 1491601676.69722&#125;]&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;script type=\"text/javascript\" charset=\"gb2312\" src=\"//www.baidu.com/cache/aladdin/ui/tabs5/tabs5.js?v=20170208\" data-for=\"A.ui\"&gt;&lt;/script&gt;&lt;script charset=\"utf-8\" async=\"\" src=\"https://ss0.bdstatic.com/-0U0bnSm1A5BphGlnYG/tam-ogel/1c5d7b26-f3f0-4dd7-a025-8c79809fecac.js\"&gt;&lt;/script&gt; ......&lt;/body&gt;&lt;/html&gt; 声明浏览器对象1234567from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari() 访问页面123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')print(browser.page_source)browser.close() 查找元素单个元素 find_element_by_id find_element_by_name find_element_by_xpath find_element_by_link_text find_element_by_partial_link_text find_element_by_tag_name find_element_by_class_name find_element_by_css_selector 1find_element(By.ID, 'q') 123456789from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input_first = browser.find_element_by_id('q')input_second = browser.find_element_by_css_selector('#q')input_third = browser.find_element_by_xpath('//*[@id=\"q\"]')print(input_first, input_second, input_third)browser.close() 1&lt;selenium.webdriver.remote.webelement.WebElement (session=\"5e53d9e1c8646e44c14c1c2880d424af\", element=\"0.5649563096161541-1\")&gt; &lt;selenium.webdriver.remote.webelement.WebElement (session=\"5e53d9e1c8646e44c14c1c2880d424af\", element=\"0.5649563096161541-1\")&gt; &lt;selenium.webdriver.remote.webelement.WebElement (session=\"5e53d9e1c8646e44c14c1c2880d424af\", element=\"0.5649563096161541-1\")&gt; 12345678from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input_first = browser.find_element(By.ID, 'q')print(input_first)browser.close() 1&lt;selenium.webdriver.remote.webelement.WebElement (session=\"1f209c0d11551c40d9d20ad964fef244\", element=\"0.07914603542731591-1\")&gt; 多个元素 find_elements_by_name find_elements_by_xpath find_elements_by_link_text find_elements_by_partial_link_text find_elements_by_tag_name find_elements_by_class_name find_elements_by_css_selector 1driver.find_elements(By.CSS_SELECTOR, '.service-bd li') 1234567from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')lis = browser.find_elements_by_css_selector('.service-bd li')print(lis)browser.close() 123[&lt;selenium.webdriver.remote.webelement.WebElement (session=\"c26290835d4457ebf7d96bfab3740d19\", element=\"0.09221044033125603-1\")&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=\"c26290835d4457ebf7d96bfab3740d19\", element=\"0.09221044033125603-2\")&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=\"c26290835d4457ebf7d96bfab3740d19\", element=\"0.09221044033125603-3\")&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=\"c26290835d4457ebf7d96bfab3740d19\", element=\"0.09221044033125603-4\")&gt;, .........&lt;selenium.webdriver.remote.webelement.WebElement (session=\"c26290835d4457ebf7d96bfab3740d19\", element=\"0.09221044033125603-16\")&gt;] 12345678from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.taobao.com')lis = browser.find_elements(By.CSS_SELECTOR, '.service-bd li')print(lis)browser.close() 元素交互操作对获取的元素调用交互方法 123456789101112from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input = browser.find_element_by_id('q')input.send_keys('iPhone')time.sleep(1)input.clear()input.send_keys('iPad')button = browser.find_element_by_class_name('btn-search')button.click() 更多操作: http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement 交互动作将动作附加到动作链中串行执行 123456789101112from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'browser.get(url)browser.switch_to.frame('iframeResult')source = browser.find_element_by_css_selector('#draggable')target = browser.find_element_by_css_selector('#droppable')actions = ActionChains(browser)actions.drag_and_drop(source, target)actions.perform() 更多操作: http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains 执行JavaScript123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')browser.execute_script('alert(\"To Bottom\")') 获取元素信息获取属性1logo.get_attribute('class') 123456789from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)logo = browser.find_element_by_id('zh-top-link-logo')print(logo)print(logo.get_attribute('class')) 12&lt;selenium.webdriver.remote.webelement.WebElement (session=\"e08c0f28d7f44d75ccd50df6bb676104\", element=\"0.7236390660048155-1\")&gt;zu-top-link-logo 获取文本值1获取元素.text 1234567from selenium import webdriverbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')print(input.text) 获取ID、位置、标签名、大小12345678910from selenium import webdriverbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')print(input.id)print(input.location)print(input.tag_name)print(input.size) 12340.6822924344980397-1&#123;'y': 7, 'x': 774&#125;button&#123;'height': 32, 'width': 66&#125; Frame123456789101112131415161718import timefrom selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionbrowser = webdriver.Chrome()url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'browser.get(url)browser.switch_to.frame('iframeResult')source = browser.find_element_by_css_selector('#draggable')print(source)try: logo = browser.find_element_by_class_name('logo')except NoSuchElementException: print('NO LOGO')browser.switch_to.parent_frame()logo = browser.find_element_by_class_name('logo')print(logo)print(logo.text) 1234&lt;selenium.webdriver.remote.webelement.WebElement (session=\"4bb8ac03ced4ecbdefef03ffdc0e4ccd\", element=\"0.44746093888932004-1\")&gt;NO LOGO&lt;selenium.webdriver.remote.webelement.WebElement (session=\"4bb8ac03ced4ecbdefef03ffdc0e4ccd\", element=\"0.13792611320464965-2\")&gt;RUNOOB.COM 等待隐式等待当使用了隐式等待执行测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常, 换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是0 1234567from selenium import webdriverbrowser = webdriver.Chrome()browser.implicitly_wait(10)browser.get('https://www.zhihu.com/explore')input = browser.find_element_by_class_name('zu-top-add-question')print(input) 1&lt;selenium.webdriver.remote.webelement.WebElement (session=\"b29214772d59e912f1ac52e96ed29abe\", element=\"0.12886805191194894-1\")&gt; 显式等待12345678910111219from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECbrowser = webdriver.Chrome()browser.get('https://www.taobao.com/')wait = WebDriverWait(browser, 10)input = wait.until(EC.presence_of_element_located((By.ID, 'q')))button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, '.btn-search')))print(input, button) 1&lt;selenium.webdriver.remote.webelement.WebElement (session=\"07dd2fbc2d5b1ce40e82b9754aba8fa8\", element=\"0.5642646294074107-1\")&gt; &lt;selenium.webdriver.remote.webelement.WebElement (session=\"07dd2fbc2d5b1ce40e82b9754aba8fa8\", element=\"0.5642646294074107-2\")&gt; title_is 标题是某内容 title_contains 标题包含某内容 presence_of_element_located 元素加载出，传入定位元组，如(By.ID, ‘p’) visibility_of_element_located 元素可见，传入定位元组 visibility_of 可见，传入元素对象 presence_of_all_elements_located 所有元素加载出 text_to_be_present_in_element 某个元素文本包含某文字 text_to_be_present_in_element_value 某个元素值包含某文字 frame_to_be_available_and_switch_to_it frame加载并切换 invisibility_of_element_located 元素不可见 element_to_be_clickable 元素可点击 staleness_of 判断一个元素是否仍在DOM，可判断页面是否已经刷新 element_to_be_selected 元素可选择，传元素对象 element_located_to_be_selected 元素可选择，传入定位元组 element_selection_state_to_be 传入元素对象以及状态，相等返回True，否则返回False element_located_selection_state_to_be 传入定位元组以及状态，相等返回True，否则返回False alert_is_present 是否出现Alert 详细内容：http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions 前进后退1234567891011import timefrom selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com/')browser.get('https://www.taobao.com/')browser.get('https://www.python.org/')browser.back()time.sleep(1)browser.forward()browser.close() Cookies123456789from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')print(browser.get_cookies())browser.add_cookie(&#123;'name': 'name', 'domain': 'www.zhihu.com', 'value': 'germey'&#125;)print(browser.get_cookies())browser.delete_all_cookies()print(browser.get_cookies()) 这些键名都代表什么意思呢？参考博文《selenium3.7+ python3 添加cookie模拟登陆》，罗列如下 name：cookie的名称 value：cookie对应的值，动态生成的 domain：服务器域名 expiry：Cookie有效终止日期 path：Path属性定义了Web服务器上哪些路径下的页面可获取服务器设置的Cookie httpOnly：防脚本攻击 secure:在Cookie中标记该变量，表明只有当浏览器和Web Server之间的通信协议为加密认证协议时 选项卡管理(浏览器页面)123456789101112import timefrom selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.execute_script('window.open()')print(browser.window_handles)browser.switch_to_window(browser.window_handles[1])browser.get('https://www.taobao.com')time.sleep(1)browser.switch_to_window(browser.window_handles[0])browser.get('https://python.org') 1['CDwindow-4f58e3a7-7167-4587-bedf-9cd8c867f435', 'CDwindow-6e05f076-6d77-453a-a36c-32baacc447df'] 异常处理12345from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.find_element_by_id('hello') 1234567891011121314from selenium import webdriverfrom selenium.common.exceptions import TimeoutException, NoSuchElementExceptionbrowser = webdriver.Chrome()try: browser.get('https://www.baidu.com')except TimeoutException: print('Time Out')try: browser.find_element_by_id('hello')except NoSuchElementException: print('No Element')finally: browser.close() 详细文档：http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions Chrome options参数获取 12from selenium import webdriveroptions = webdriver.ChromeOptions() 针对编码格式的操作 12345# 设置默认编码为 utf-8from selenium import webdriveroptions = webdriver.ChromeOptions()options.add_argument('lang=zh_CN.UTF-8')driver = webdriver.Chrome(chrome_options = options) python selenium设置chrome的下载路径python可以通过ChromeOptions设置chrome参数，如下载路径等，代码如下(python 3.6.7)： 123456789101112#-*-coding=utf-8-*-from selenium import webdriverimport timedef set_chrome_pref(): chromeOptions = webdriver.ChromeOptions() prefs = &#123;\"download.default_directory\":\"D:\\\\\"&#125; chromeOptions.add_experimental_option(\"prefs\", prefs) driver = webdriver.Chrome(chrome_options=chromeOptions) time.sleep(10) 退出浏览器和退出窗口selenium中driver.close()和driver.quit()的不同点 driver.quit()与driver.close()的不同：driver.quit(): Quit this driver, closing every associated windows;driver.close(): Close the current window, quiting the browser if it is the last window currently open. 翻译成中文： driver.close() – 关闭当前窗口，如果是当前打开的最后一个窗口，则退出浏览器 driver.quit() – 退出驱动，关闭所有相关的窗口 pymongo安装 1pip install pymongo 使用 12345678910111213import pymongofrom config import *client = pymongo.MongoClient(MONGO_URL)db = client[MONGO_DB]def save_to_mongo(result): try: if db[MONGO_TABLE].insert(result): print('save to mongoDB successfully', result) except Exception: print('save to mongoDB fail',result) config.py 123MONGO_URL = 'localhost'MONGO_DB = 'taobao'MONGO_TABLE = 'product' 实战Requests+正则表达式爬取猫眼电影TOP100https://github.com/Germey/MaoYan Selenium+Chrome爬取淘宝美食https://github.com/codeOflI/TaobaoMeishi PhantomJS phantomjs已经没人用了，都是headless chrome 使用技巧chrome有copy selector选项，能直接copy元素的选择器。 还有xpath选项 learn-issue正则——豆瓣读书实战练习豆瓣读书源码改了，现在不好爬取了 跳过beautifulSoup和Pyquery跳过分析Ajax来抓取今⽇日头条街拍美图结构不一样了？ 跳过Taobao美食的phantomjs，因为停更了 跳过pySpider在python3.7中关键字与pyspider中的函数冲突，需要更改async关键字 跳过代理proxy和cookies [http://www.selenium.org.cn/]:","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/tags/python/"}]},{"title":"ssm-crud","slug":"java-note/ssm-crud/ssm-crud","date":"2019-10-21T07:25:49.000Z","updated":"2021-10-23T02:19:04.206Z","comments":true,"path":"2019/10/java-note/ssm-crud/ssm-crud/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/ssm-crud/ssm-crud/","excerpt":"[TOC]web路径 web路径： 1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题 2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名; 就是http//localhost/端口号/crud/…12345&lt;% pageContext.setAttribute(\"WEB_PATH\", request.getContextPath());%&gt; $&#123;WEB_PATH&#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css --&gt;","text":"[TOC]web路径 web路径： 1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题 2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名; 就是http//localhost/端口号/crud/…12345&lt;% pageContext.setAttribute(\"WEB_PATH\", request.getContextPath());%&gt; $&#123;WEB_PATH&#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css --&gt; 注：pageContext.setAttribute需要jsp_api.jar maven配置文件D:\\apache-maven-3.6.1\\conf\\settings.xml 设置镜像阿里mirrors 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 配置maven的jdk 12345678910111213&lt;profile&gt; &lt;id&gt;jdk18&lt;/id&gt; &lt;activation&gt; &lt;activaByDefault&gt;true&lt;/activaByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; maven使用spring单元测试test写在src/test/mapper/目录下 推荐Spring的项目就可以使用spring的单元测试，可以依赖注入我们需要的组件 1.导入springTest模块(meven导包) 2.@ContextConfiguration指定spring配置文件内容,@RunWith(SpringJUnit4ClassRunner.class) 3.直接autoWrited要使用的组件即可 1234567** * 测试dao工作层 * @author test */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:applicationContext.xml\"&#125;)public class MapperTest &#123; mybatis不在同一目录下如果需要mapper和mapper.xml文件不在一个文件夹里还能映射成功的话，需要在spring配置文件中，分别将mapper和mapper.xml的包添加扫描； 1234567891011121314151617&lt;!-- ============配置和mybatis的整合============== --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;property name=\"dataSource\" ref=\"pooledDataSource\"&gt;&lt;/property&gt; &lt;!-- 指定mybatis的mapper文件位置 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置扫描器，将mapper接口实现加入ioc容器 --&gt; &lt;!-- 批量生成mapper代理对象 批量产生的mapper对象在SpringIOC容器中的id值默认就是接口mapper名(首字母小写） --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.atguigu.crud.dao\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; maven中classpath路径在Maven工程中，classpath的路径指java resources路径下的目录，即 src/main/java、 src/main/resource、src/test/java 、src/test/resource 四个目录 所以在配置路径时需要注意文件名是否重名，导致加载文件失败 数据校验jsr303数据校验12345678910&lt;!--jsr303数据检验支持 （Hibernate Validator Engine Relocation Artifact） --&gt; &lt;!-- jrs303数据校验支持：tomcat7以上的服务器，tomcat7以下的服务器：el表达式，不是最新的。额外给服务器的lib包中替换新的标准的el--&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt;&lt;/dependency&gt; JSR303Hibernate Validator JSR 303提供的标准注解如表所示。 注解 简介 @Null 被注释的元素必须为 null。 @NotNull 被注释的元素必须不为 null。 @AssertTrue 被注释的元素必须为 true。 @AssertFalse 被注释的元素必须为 false。 @Min(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @Max(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @Size(max, min) 被注释的元素的取值范围必须是介于min和max之间。 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内。 @Past 被注释的元素必须是一个过去的日期。 @Future 被注释的元素必须是一个将来的日期。 @Pattern(value) 被注释的元素必须符合指定的正则表达式。 表JSR 303注解 Hibernate Validator 是JSR 303的扩展。Hibernate Validator 提供了 JSR 303中所有内置的注解，以及自身扩展的4个注解，如表所示。 注解 简介 @Email 被注释的元素值必须是合法的电子邮箱地址。 @Length 被注释的字符串的长度必须在指定的范围内。 @NotEmpty 被注释的字符串的必须非空。 @Range 被注释的元素必须在合适的范围内。 表 Hibernate Validator扩展注解 使用Hibernate Validator步骤： a.jar（注意各个jar之间可能存在版本不兼容）hibernate-validator-5.0.0.CR2.jar classmate-0.8.0.jar jboss-logging-3.1.1.GA.jarvalidation-api-1.1.0.CR1.jar hibernate-validator-annotation-processor-5.0.0.CR2.jar b配置 1&lt;mvc:annotation-driven &gt;&lt;/mvc:annotation-driven&gt; 此时mvc:annotation-driven的作用：要实现Hibernate Validator/JSR303 校验（或者其他各种校验），必须实现SpringMVC提供的一个接口：ValidatorFactory LocalValidatorFactoryBean是ValidatorFactory的一个实现类。&lt;mvc:annotation-driven &gt;会在springmvc容器中 自动加载一个LocalValidatorFactoryBean类，因此可以直接实现数据校验。 c.直接使用注解 12345678public class Student &#123;```@Past//当前时间以前private Date birthday ;```&#125; 在校验的Controller中 ，给校验的对象前增加 @Valid 12public String testDateTimeFormat(@Valid Student student, BindingResult result ,Map&lt;String,Object&gt; map) &#123; &#123;...&#125; mybatis分页插件PageHleper1234567891011121314151617181920212223/** * 导入jackson包 * * @author lmz * @date 2019年7月15日-上午8:59:36 * @param pageNumber * @return */ @RequestMapping(\"/emps\") @ResponseBody // 告诉SpringMVC，此时的返回 不是一个 View页面，而是一个 ajax调用的返回值（Json数组） public Msg getEmpsWithJson(@RequestParam(value = \"pageNumber\", defaultValue = \"1\") Integer pageNumber) &#123; // 引入分页插件PageHleper // 在查询之前调用即可 PageHelper.startPage(pageNumber, 5); // startPage之后紧跟着的查询就是分页查询 List&lt;Employee&gt; emps = employeeService.getAll(); // 用PageInfo对结果进行包装 // 将pagaInfo交给页面就可以了，封装了详细的分页信息，包括有我们的查询数据 // 传入连续显示的页数 PageInfo&lt;Employee&gt; page = new PageInfo&lt;Employee&gt;(emps, 5); return Msg.success().add(\"pageInfo\", page); &#125; 在mybatis中配置合理化参数，超过页数，返回最后一页 12345678910&lt;configuration&gt; &lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;!-- 分页参数合理化 --&gt; &lt;property name=\"reasonable\" value=\"true\" /&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; sprigMVC自带HttpputFormContentFilter12345678910111213141516171819/** * 解决方案 * 要能支持直接发送PUT之类的请求，还要封装请求体中的数据 * 1、配置上HttpputFormContentFilter； * 2、作用：将请求体中的数据解析包装成一个map。 * 3、request被重新包装，request.getParameter()被重写，就会从自己封装的map中取数据 * 员工更新方法 * @param employee * @return */@PutMapping(\"/emp/&#123;empId&#125;\")@ResponseBodypublic Msg saveEmp(Employee employee,HttpServletRequest request)&#123; System.out.println(\"requestScope中的值：\"+request.getParameter(\"email\")); System.out.println(employee); employeeService.updateEmp(employee); return Msg.success();&#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"ssm","slug":"ssm","permalink":"https://codeofli.github.io/tags/ssm/"}]},{"title":"springMvc","slug":"java-note/springMvc/springMvc","date":"2019-10-20T07:24:32.000Z","updated":"2021-10-23T02:19:04.204Z","comments":true,"path":"2019/10/java-note/springMvc/springMvc/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/springMvc/springMvc/","excerpt":"[TOC]springmvc:1.jarspring-aop.jarspring-bean.jarspring-context.jarspring-core.jarspring-web.jarspring-webmvc.jarcommons-logging.jar报错NoClassDefFoundError：缺少jar","text":"[TOC]springmvc:1.jarspring-aop.jarspring-bean.jarspring-context.jarspring-core.jarspring-web.jarspring-webmvc.jarcommons-logging.jar报错NoClassDefFoundError：缺少jar 2.第一个SpringMVC程序Servet - Springmvcjsp -&gt;Servlet (Springmvc)-&gt;Jsp url springmvc配置文件 springmvc.xml选中常用的命名空间：beans aop context mvc 普通的servlet流程：请求-url-pattern -交给对应的servlet去处理 如果现在想用springmvc，而不是普通的servlet，如何告知程序？-如何让springmvc 介入程序：需要配置一个 Springmvc自带的servlet 通过以下配置，拦截所有请求，交给SpringMVC处理： 1234567891011121314 &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 其中：.action /:一切请求 ，注意不是 /*/user:拦截以 /user开头的请求/user/abc.do :只拦截该请求.action:只拦截 .action结尾的请求 项目中同时兼容 springMVC和Servlet 1234567891011121314&lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 通过 1234&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; 123456&lt;context:component-scan base-package=\"pers.nicolas.handler\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器(InternalResourceViewResolver) --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/views/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; 指定springmvc配置文件的路径，如果要省略，必须放到 默认路径：/WEB-INF/（web.xml配置中）servetname的值-servlet.xml 可以提示工具自动生成alt+/ ,选 映射是 去匹配@RequestMapping注解可以和方法名、类名不一致通过method指定 请求方式（get post delete put） @RequestMapping(value=”welcome”,method=RequestMethod.POST)//映射 设置name=”xxxx”的情况：params= {“name2=zs”,”age!=23”} name2:必须有name=”name2”参数 age!=23 : a.如果有name=”age”，则age值不能是23 b.没有age!name2 ：不能name=”name2”的属性 ant风格的请求路径? 单字符 任意个字符（0或多个） 任意目录 @RequestMapping(value=”welcome3/**/test”)接受示例： a href=”welcome3/abc/xyz/abccc/test” … 通过@PathVariable获取动态参数**12345@RequestMapping(value = \"welcome5/&#123;name&#125;\")public String welcome5(@PathVariable(\"name\") String name ) &#123; System.out.println(name); return \"success\" ;&#125; 1234567891011121314151617181920212223//接口/类、注解、配置@Controller@RequestMapping(\"handler\") // 映射public class SpringMVCHandler &#123; @RequestMapping(value = \"welcome\", method = RequestMethod.POST, params = &#123; \"name=zs\", \"age!=23\", \"!height\" &#125;) // 映射 public String welcome() &#123; return \"success\"; // /views/success.jsp &#125; @RequestMapping(value = \"welcome2\", headers = &#123; \"Accept=text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Encoding=gzip, deflate\" &#125;) // 映射 public String welcome2() &#123; return \"success\"; // /views/success.jsp &#125; @RequestMapping(value = \"welcome3/**/test\") public String welcome3() &#123; return \"success\"; // /views/success.jsp &#125;@RequestMapping(value = \"welcome4/&#123;name&#125;\") // 映射public String welcome4(@PathVariable(\"name\") String name) &#123; System.out.println(name); return \"success\"; // /views/success.jsp &#125;&#125; 请求方式和获取参数REST风格 ：软件编程风格 Springmvc:GET :查POST ：增DELETE ：删PUT ：改 普通浏览器 只支持get post方式 ；其他请求方式 如 delelte|put请求是通过 过滤器新加入的支持。 springmvc实现 ：put|post请求方式的步骤a.增加过滤器 123456789&lt;!-- 增加HiddenHttpMethodFilte过滤器：目的是给普通浏览器 增加 put|delete请求方式 --&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilte&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilte&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; b.表单 1234&lt;form action=\"handler/testRest/1234\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"DELETE\"/&gt; &lt;input type=\"submit\" value=\"删\"&gt;&lt;/form&gt; i:必须是post方式ii:通过隐藏域 的value值 设置实际的请求方式 DELETE|PUT c.控制器 123456@RequestMapping(value=\"testRest/&#123;id&#125;\",method=RequestMethod.DELETE)public String testDelete(@PathVariable(\"id\") Integer id) &#123; System.out.println(\"delete：删 \" +id); //Service层实现 真正的增 return \"success\" ;//默认使用了请求转发的跳转方式&#125; 通过 method=RequestMethod.DELETE 匹配具体的请求方式 此外，可以发现 ，当映射名相同时@RequestMapping(value=”testRest)，可以通过method处理不同的请求。 过滤器中 处理put|delete请求的部分源码： 1234567891011protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;HttpServletRequest requestToUse = request; if (\"POST\".equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) &#123; String paramValue = request.getParameter(this.methodParam); if (StringUtils.hasLength(paramValue)) &#123; requestToUse = new HttpMethodRequestWrapper(request, paramValue); &#125; &#125; filterChain.doFilter(requestToUse, response);&#125; 原始请求：request，改请求默认只支持get post header但是如果 是”POST” 并且有隐藏域 则，过滤器 将原始的请求 request加入新的请求方式DELETE，并将原始请求 转为 requestToUse 请求（request+Delete请求）最后将requestToUse 放入 请求链中， 后续再事情request时 实际就使用改造后的 requestToUse 获取参数方法2@RequestParam(“uname”) String name,@RequestParam(value=”uage”,required=false,defaultValue=”23”) @RequestParam(“uname”):接受前台传递的值，等价于request.getParameter(“uname”); required=false:该属性 不是必须的。defaultValue=”23”：默认值23 获取请求头信息 @RequestHeaderpublic String testRequestHeader(@RequestHeader(“Accept-Language”) String al ) { 通过@RequestHeader(“Accept-Language”) String al 获取请求头中的Accept-Language值，并将值保存再al变量中 通过mvc获取cookie值（JSESSIONID）@CookieValue(前置知识： 服务端在接受客户端第一次请求时，会给该客户端分配一个session （该session包含一个sessionId）),并且服务端会在第一次响应客户端时 ，请该sessionId赋值给JSESSIONID 并传递给客户端的cookie中 小结： SpringMVC处理各种参数的流程/逻辑：请求： 前端发请求a-&gt; @RequestMappting(“a”)处理请求中的参数xyz： @RequestMappting(“a”) public String aa(@Xxx注解(“xyz”) xyz) { }使用对象（实体类Student）接受请求参数12345 @RequestMapping(value = \"testObjectProperties\") // 映射public String testObjectProperties(Student student) &#123; //student属性必须和from表单中的属性name值一致（支持级联属性） System.out.println(student); return \"success\"; &#125; 1234567&lt;form action=\"handler/testObjectProperties\" method=\"post\"&gt; id:&lt;input type=\"text\" name=\"id\"&gt;&lt;br/&gt; name:&lt;input type=\"text\" name=\"name\"&gt;&lt;br/&gt; homeAddress:&lt;input type=\"text\" name=\"address.homeAddress\"&gt;&lt;br/&gt; schoolAddress:&lt;input type=\"text\" name=\"address.schoolAddress\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"submit\"&gt;&lt;br/&gt;&lt;/form&gt; 在SpringMVC中使用原生态的Servlet APIHttpServletRequest ：直接将 servlet-api中的类、接口等 写在springMVC所映射的方法参数中即可： 12345@RequestMapping(value=\"testServletAPI\")public String testServletAPI(HttpServletRequest request,HttpServletResponse response) &#123; System.out.println(request); return \"success\" ;&#125; 1.处理模型数据如果跳转时需要带数据：V、M,则可以使用以下方式：ModelAndView、ModelMap 、Map(java.tuil.map)、Model -数据放在了request作用域 @SessionAttributes、@ModelAttribute 示例：public String testModel(Model model| Map&lt;String,Object&gt; m) { m.put(x,”..”); 就会将x对象 放入request域中 1234567891011121314151617@RequestMapping(value = \"testModelAndView\")public ModelAndView testModelAndView() &#123; // ModelAndView:既有数据，又有视图 ModelAndView mv = new ModelAndView(\"success\"); Student student = new Student(); student.setId(3); student.setName(\"zs\"); mv.addObject(\"student\", student); // 相当于request.setAtrribute(); return mv;&#125;@RequestMapping(value = \"testModelMap\") // 映射public String testModelMap(ModelMap mm) &#123; Student student1 = new Student(); student1.setId(3); student1.setName(\"zs\"); mm.put(\"student1\", student1); // request域 return \"success\"; // view&#125; 如何将上述数据放入session中？@SessionAttributes(..)在类上声明 1@SessionAttributes(value = &#123;\"student3\",\"student2\"&#125;) //如果在request域中存放studen3,student2对象，则同时放在session域中 1@SessionAttributes(types =&#123;Student.class,Address.class&#125;) //如果在request域中存放student,address类的对象，则同时放在session域中 @ModelAttributei.经常在 更新时使用ii.在不改变原有代码的基础之上，插入一个新方法。 通过@ModelAttribute修饰的方法 ，会在每次请求前先执行；并且该方法的参数map.put()可以将 对象 放入 即将查询的参数中；必须满足的约定：map.put(k,v) 其中的k 必须是即将查询的方法参数 的首字母小写testModelAttribute(Student xxx) ，即student；如果不一致，需要通过@ModelAttribute声明。如下： 1234567891011121314151617@ModelAttribute//在任何一次请求前，都会先执行@ModelAttribute修饰的方法// 在请求该类的每个方法前均会被调用的设计是基于一个思想：一个控制器一个功能public void queryStudentById(Map&lt;String,Object&gt; map) &#123; //模拟调用三层查询数据库的操作 Student student = new Student(); student.setId(31); student.setName(\"zs\"); student.setAge(23); map.put(\"stu\", student) ;//约定：map的key 就是方法参数 类型的首字母小写&#125;//修改:Zs-ls@RequestMapping(value=\"testModelAttribute\")public String testModelAttribute(@ModelAttribute(\"stu\")Student student) &#123; student.setName(student.getName());//将名字修改为ls System.out.println(student.getId()+\",\"+student.getName()+\",\"+student.getAge()); return \"success\";&#125; 一个Servlet 对应一个功能：增删改查 对应于 4个Servlet 更新： Servlet - SpringMVC的Controller 查询@ModelAttributepublic void query(){ } 修改public String update(){ } @ModelAttribute会在 该类的每个方法执行前 均被执行一次，因为使用时需要注意。 2.视图、视图解析器视图的顶级接口:View视图解析器：ViewResolver 常见的视图和解析器：InternalResourceView、InternalResourceViewResolver public class JstlView extends InternalResourceView： springMVC解析jsp时 会默认使用InternalResourceView，如果发现Jsp中包含了jstl语言相关的内容，则自动转为JstlView。 JstlView 可以解析jstl\\实现国际化操作 国际化： 针对不同地区、不同国家 ，进行不同的显示 中国:（大陆、香港） 欢迎美国： welcome i18n_zh_CN.propertiesresource.welcome=你好resource.exit=退出 i18n.properties 具体实现国际化步骤：a.创建资源文件基名_语言_地区.properties基名_语言.properties 常见的资源文件命名 资源文件名 简介 基名_en.properties 所有英文语言的资源 基名_en_US.properties 针对美国地区、英文语言的资源 基名_zh.properties 所有的中文语言的资源 基名_zh_CN.properties 针对中国大陆的、中文语言的资源 基名_zh_HK.properties 针对中国香港的、中文语言的资源 基名.properties 默认资源文件。如果请求相应语言的资源文件不存在，将使用此资源文件。例如，若是中国大陆地区用户，应该访问“基名_zh_CN.properties”，而如果不存在此文件，就会去访问默认的“基名.properties”。 b.配置springmvc.xml，加载资源文件 12345&lt;!-- 加载国际化资源文件 1.将ResourceBundleMessageSource在程序加载时 加入springmvc： springmvc在启动时，会自动查找一个叫messageSource的bean，如果有则自动加载 2.如果配置了ResourceBundleMessageSource，程序会在响应时介入 --&gt;&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt; &lt;property name=\"basename\" value=\"i18n\"&gt;&lt;/property&gt;&lt;/bean&gt; ResourceBundleMessageSource会在springmvc响应程序时 介入（解析国际化资源文件） c.通过jstl使用国际化 jstl.jar standar.jar springmvc在启动时，会自动查找一个id=”messageSource”的bean，如果有 则自动加载 InternalResourceViewResolver其他功能：1.&lt;mvc:view-controller …&gt;index.jsp -&gt; Controller(@RequsetMapping(“a”)) -&gt;succes.jsp 要用SpringMVC实现：index.jsp -&gt; succes.jsp ： 12&lt;!-- view-name也会被视图解析器添加前缀和后缀 --&gt;&lt;mvc:view-controller path=\"testMvcViewController\" view-name=\"success\"/&gt; 以上注解 ，会让所有的请求 转入mvc:..中匹配映射地址，而会忽略调@RequsetMapping()；如果想让 @RequsetMapping(“a”) 和mvc:..共存，则需要加入一个注解：&lt;1234```xml&lt;!--此配置是springmvc的基础配置，很多功能都需要该注解来调整 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 2.指定请求方式指定跳转方式：return “forward:/views/success.jsp”; forward(请求转发): redirect（重定向）: ，需要注意 此种方式，不会被视图解析器加上前缀(/views)、后缀(.jsp) 3.处理静态资源：html css js 图片 视频可以与用户交互、因为时间/地点的不同 而结果不同的内容：动态（百度：天气 ） 在SpringMVC中，如果直接访问静态资源：404 。原因：之前将所有的请求 通过通配符“/” 拦截，进而交给 SPringMVC的入口DispatcherServlet去处理：找该请求映射对应的 @requestMapping http://localhost:8888/SpringMVCProject/img.png @RequsetMapping(“img.png”)return sucess 解决：如果是 需要mvc处理的，则交给@RequsetMapping(“img.png”)处理；如果不需要springmvc处理，则使用 tomcat默认的Servlet去处理。tomcat默认的Servlet去处理：如果有 对应的请求拦截,则交给相应的Servlet去处理；如果没有对应的servlet，则直接访问。tomcat默认的Servlet在哪里？在tomcat配置文件\\conf\\web.xml中 &lt;servlet&gt; &lt;servlet-name&gt;abc&lt;/servlet-name&gt; &lt;servlet-class&gt;xxx.xxx.xx.ABCServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;abc&lt;/servlet-name&gt; &lt;url-pattern&gt;/abc&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;解决静态资源方案：如果有springmvc对应的@requestMapping则交给spring处理；如果没有对应@requestMapping,则交给服务器tomcat默认的servlet去处理 ：实现方法，只需要增加2个注解即可 springmvc.xml： 1234&lt;!-- 该注解会让springmvc在接受请求没有对应映射时，将该请求交给服务器默认的servlet处理(直接访问) --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--此配置是springmvc的基础配置，很多功能都需要该注解来调整 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 总结：要让springmvc访问静态资源，只需要加入以下2个注解： 1234&lt;!-- 该注解会让springmvc在接受请求没有对应映射时，将该请求交给服务器默认的servlet处理(直接访问) --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--此配置是springmvc的基础配置，很多功能都需要该注解来调整 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 4.类型转换a.Spring自带一些 常见的类型转换器：public String testDelete(@PathVariable(“id”) String id) ，即可以接受int类型数据id 也可以接受String类型的id b.可以自定义类型转换器i.编写 自定义类型转器的类 （实现Converter接口） 123456789101112public class MyConverter implements Converter&lt;String,Student&gt;&#123;@Override public Student convert(String source) &#123;//source:2-zs-23 //source接受前端传来的String:2-zs-23 String[] studentStrArr = source.split(\"-\") ; Student student = new Student(); student.setId( Integer.parseInt( studentStrArr[0]) ); student.setName(studentStrArr[1]); student.setAge(Integer.parseInt(studentStrArr[2] )); return student; &#125;&#125; ii.配置：将MyConverter加入到springmvc中 1234567891011121314&lt;!-- 1将 自定义转换器 纳入SpringIOC容器 --&gt; &lt;bean id=\"myConverter\" class=\"org.lanqiao.converter.MyConverter\"&gt;&lt;/bean&gt;&lt;!-- 2将myConverter再纳入 SpringMVC提供的转换器Bean --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;ref bean=\"myConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 3将conversionService注册到annotation-driven中 --&gt;&lt;!--此配置是SpringMVC的基础配置，很功能都需要通过该注解来协调 --&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\"&gt;&lt;/mvc:annotation-driven&gt; 测试转换器： 1234@RequestMapping(value=\"testConverter\")public String testConverter(@RequestParam(\"studentInfo\") Student student) &#123;// 前端：2-zs-23 System.out.println(student.getId()+\",\"+student.getName()+\",\"+student.getAge()); return \"success\"; &#125; 其中@RequestParam(“studentInfo”)是触发转换器的桥梁：@RequestParam(“studentInfo”)接受的数据 是前端传递过来的：2-zs-23 ，但是 需要将该数据 复制给 修饰的目的对象Student；因此SPringMVC可以发现 接收的数据 和目标数据不一致，并且 这两种数据分别是 String、Student,正好符合public Student convert(String source)转换器。 5.数据格式化​ SimpleDateForamt sdf = new SimpleDateFormat(“yyyy-MM-dd hh:mm:ss”);SPringMVC提供了很多注解，方便我们数据格式化实现步骤：a.配置 123456789&lt;!-- 配置数据格式化注解所依赖的beanFormattingConversionServiceFactoryBean既能实现数据日期格式化，又能实现类型转换 --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\" &gt; &lt;set&gt; &lt;ref bean=\"myConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; b.通过注解使用 12@DateTimeFormat(pattern = \"yyyy-MM-dd\") //接受前台传来的数据，转换为日期private Date birthday;//相应实体bean的属性 1234567891011@RequestMapping(value=\"testDateTimeStringFormat\")//如果student的格式化错误，会将错误转入BindingResult中public String testDateTimeStringFormat(Student student,BindingResult result) &#123; System.out.println(student); if(result.getErrorCount() &gt; 0) &#123; for (FieldError error : result.getFieldErrors()) &#123; System.out.println(error.getDefaultMessage()); &#125; &#125; return \"success\";&#125; @NumberFormat(parttern=”###,#”) 1.错误消息：public String testDateTimeFormat(Student student, BindingResult result ,Map&lt;String,Object&gt; map) {需要验证的数据是 Student中的birthday, SPringMVC要求 如果校验失败 则将错误信息自动放入该对象之后紧挨着的 BindingResult中。即Student student, BindingResult result之间 不能有其他参数。 如果要将控制台的错误消息 传到jsp中显示，则可以将 错误消息对象放入request域中，然后 在jsp中 从request中获取。 2.数据校验JSR303Hibernate Validator JSR 303提供的标准注解如表所示。 注解 简介 @Null 被注释的元素必须为 null。 @NotNull 被注释的元素必须不为 null。 @AssertTrue 被注释的元素必须为 true。 @AssertFalse 被注释的元素必须为 false。 @Min(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @Max(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @Size(max, min) 被注释的元素的取值范围必须是介于min和max之间。 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内。 @Past 被注释的元素必须是一个过去的日期。 @Future 被注释的元素必须是一个将来的日期。 @Pattern(value) 被注释的元素必须符合指定的正则表达式。 表JSR 303注解 Hibernate Validator 是JSR 303的扩展。Hibernate Validator 提供了 JSR 303中所有内置的注解，以及自身扩展的4个注解，如表所示。 注解 简介 @Email 被注释的元素值必须是合法的电子邮箱地址。 @Length 被注释的字符串的长度必须在指定的范围内。 @NotEmpty 被注释的字符串的必须非空。 @Range 被注释的元素必须在合适的范围内。 表 Hibernate Validator扩展注解 使用Hibernate Validator步骤： a.jar（注意各个jar之间可能存在版本不兼容）hibernate-validator-5.0.0.CR2.jar classmate-0.8.0.jar jboss-logging-3.1.1.GA.jarvalidation-api-1.1.0.CR1.jar hibernate-validator-annotation-processor-5.0.0.CR2.jar b配置 1&lt;mvc:annotation-driven &gt;&lt;/mvc:annotation-driven&gt; 此时mvc:annotation-driven的作用：要实现Hibernate Validator/JSR303 校验（或者其他各种校验），必须实现SpringMVC提供的一个接口：ValidatorFactory LocalValidatorFactoryBean是ValidatorFactory的一个实现类。&lt;mvc:annotation-driven &gt;会在springmvc容器中 自动加载一个LocalValidatorFactoryBean类，因此可以直接实现数据校验。 c.直接使用注解 123public class Student &#123;​ @Past//当前时间以前private Date birthday ;​12&#125; ​ 在校验的Controller中 ，给校验的对象前增加 @Valid 12public String testDateTimeFormat(@Valid Student student, BindingResult result ,Map&lt;String,Object&gt; map) &#123; &#123;...&#125; 3.Ajax请求SpringMVC，并且JSON格式的数据a.jarjackson-annotations-2.8.9.jarjackson-core-2.8.9.jarjackson-databind-2.8.9.jar b。@ResponseBod修饰的方法，会将该方法的返回值 以一个json数组的形式返回给前台 ​ 123456789101112131415@ResponseBody//告诉SpringMVC，此时的返回 不是一个 View页面，而是一个 ajax调用的返回值（Json数组） @RequestMapping(value=\"testJson\") public List&lt;Student&gt; testJson() &#123; //Controller-Service-dao //StudentService studentService = new StudentServiceImp();// List&lt;Student&gt; students = studentService.qeuryAllStudent(); //模拟调用service的查询操作... List&lt;Student&gt; students = new ArrayList&lt;&gt;(); students.add(stu1) ; students.add(stu2) ; students.add(stu3) ; return students; &#125; 前台：服务端将返回值结果 以json数组的形式 传给了result。 1234567891011$(\"#testJson\").click(function()&#123; //通过ajax请求springmvc $.post( \"handler/testJson\",//服务器地址 //&#123;\"name\":\"zs\",\"age\":23&#125; function(result)&#123;//服务端处理完毕后的回调函数 List&lt;Student&gt; students， 加上@ResponseBody后， students实质是一个json数组的格式 for(var i=0;i&lt;result.length ;i++)&#123; alert(result[i].id +\"-\"+result[i].name +\"-\"+result[i].age); &#125; &#125; ); 1.SpringMVC实现文件上传：和Servlet方式的本质一样，都是通过commons-fileupload.jar和commons-io.jarSpringMVC可以简化文件上传的代码，但是必须满足条件：实现MultipartResolver接口 ；而该接口的实现类SpringMVC也已经提供了CommonsMultipartResolver 具体步骤：（直接使用CommonsMultipartResolver实现上传）a.jar包commons-fileupload.jar、commons-io.jarb.配置CommonsMultipartResolver将其加入SpringIOC容器 12345678&lt;!-- 配置CommonsMultipartResolver,用于实现文件上传 springIoc容器在初始化时，会自动Id=\"multipartResolver\"的bean，并自动加入容器中 --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"&gt;&lt;/property&gt; &lt;!-- 上传单个文件的最大值，单位Byte;如果-1，表示无限制 --&gt; &lt;property name=\"maxUploadSize\" value=\"102400\"&gt;&lt;/property&gt;&lt;/bean&gt; c.处理方法 12345678910111213141516171819//文件上传处理方法@RequestMapping(value=\"testUpload\") //abc.pngpublic String testUpload(@RequestParam(\"desc\") String desc , @RequestParam(\"file\") MultipartFile file ) throws IOException &#123; System.out.println(\"文件描述信息：\"+desc); //jsp中上传的文件：file InputStream input = file.getInputStream() ;//IO String fileName = file.getOriginalFilename() ; OutputStream out = new FileOutputStream(\"d:\\\\\"+fileName) ; byte[] bs = new byte[1024]; int len = -1; while(( len = input.read(bs)) !=-1 ) &#123; out.write(bs, 0, len); &#125; out.close(); input.close(); //将file上传到服务器中的 某一个硬盘文件中 System.out.println(\"上传成功！\"); return \"success\";&#125; 123456&lt;!-- enctype=\"mulipart/form-data\"告诉浏览器我是要上传文件不是普通的请求 --&gt;&lt;form action=\"handler/testUpload\" method=\"post\" enctype=\"mulipart/form-data\"&gt; describe:&lt;input type=\"text\" name=\"desc\"&gt;&lt;br /&gt; file:&lt;input type=\"file\" name=\"file\"&gt;&lt;br /&gt; &lt;input type=\"submit\" value=\"upload\"&gt;&lt;br /&gt;&lt;/form&gt; 框架： 将原来自己写的1000行代码，变成：框架帮你写900行，剩下100行自己写 控制器：handler servlet controller action 2拦截器拦截器的原理和过滤器相同。SpringMVC：要想实现拦截器，必须实现一个接口HandlerInterceptor ctrl+shift+r ：自己编写的代码.java .jsp .htmlctrl+shift+t ：jar中的代码 a.编写拦截器implements HandlerInterceptorb.配置：将自己写的拦截器 配置到springmvc中（spring） 1234&lt;!-- 将自己写的拦截器 配置到springmvc中（spring）,默认拦截全部请求 --&gt;&lt;mvc:interceptors &gt; &lt;bean class=\"pers.nicolas.interceptor.MyInterceptor\"&gt;&lt;/bean&gt;&lt;/mvc:interceptors&gt; 1234567891011&lt;!-- 将自己写的拦截器 配置到springmvc中（spring）,默认拦截全部请求 --&gt;&lt;mvc:interceptors &gt; &lt;!-- 配置具体的拦截路径 --&gt; &lt;mvc:interceptor&gt; &lt;!--指定拦截的路径，ant风格 --&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--指定不拦截的路径，ant风格 --&gt; &lt;mvc:exclude-mapping path=\"/handler/testInterceptor\"/&gt; &lt;bean class=\"pers.nicolas.interceptor.MyInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 拦截器1拦截请求- 拦截器2拦截请求 - 请求方法 - 拦截器2处理相应-拦截器1处理相应- 拦截器2的afterCompletion()拦截-拦截器1的afterCompletion()拦截 如果有多个拦截器，则每个拦截器的preHandle postHandle afterCompletion都会在相应时机各被触发一次. 3.异常处理SpringMVC： HandlerExceptionResolver接口， 该接口的每个实现类 都是异常的一种处理方式： a.@ExceptionHandler注解ExceptionHandler,ExceptionResolver： 主要提供了@ExceptionHandler注解，并通过该注解处理异常 123456//该方法 可以捕获本类中 抛出的ArithmeticException异常@ExceptionHandler(&#123;ArithmeticException.class,ArrayIndexOutOfBoundsException.class &#125;)public String handlerArithmeticException(Exception e) &#123; System.out.println(e +\"============\"); return \"error\" ;&#125; @ExceptionHandler标识的方法的参数 必须在异常类型(Throwable或其子类) ，不能包含其他类型的参数(Model可以，可以查看官方文档) 异常处理路径：最短（接近的）优先如果有方法抛出一个ArithmeticException异常，而该类中 有2个对应的异常处理法你发： 12345@ExceptionHandler(&#123;Exception.class &#125;)public ModelAndView handlerArithmeticException2(Exception e) &#123;&#125;@ExceptionHandler(&#123;ArithmeticException.class &#125;)public ModelAndView handlerArithmeticException1(Exception e) &#123;&#125; 则优先级： 最短（接近的）优先。 @ExceptionHandler默认只能捕获 当前类中的异常方法。如果发生异常的方法 和处理异常的方法 不在同一个类中：@ControllerAdvice 总结：如果一个方法用于处理异常，并且只处理当前类中的异常：@ExceptionHandler 如果一个方法用于处理异常，并且处理所有类中的异常： 类前加@ControllerAdvice、 处理异常的方法前加@ExceptionHandler b.@ResponseStatusResponseStatusExceptionResolver：自定义异常显示页面 @ResponseStatus 1234567891011@ResponseStatus(value=HttpStatus.FORBIDDEN,reason=\"数组越界222!!!\")public class MyArrayIndexOutofBoundsException extends Exception &#123;//自定义异常&#125;@RequestMapping(\"testMyException\") public String testMyException(@RequestParam(\"i\") Integer i) throws MyArrayIndexOutofBoundsException &#123; if(i == 3) &#123; throw new MyArrayIndexOutofBoundsException();//抛出异常 &#125; return \"success\" ;&#125; 12345678910111213@RequestMapping(\"testMyException2\")public String testMyException2(@RequestParam(\"i\") Integer i) &#123; if(i == 3) &#123; return \"redirect:testResponseStatus\" ;//跳转到某一个 异常处理方法里 &#125; return \"success\" ;&#125;@ResponseStatus(value = HttpStatus.CONFLICT, reason = \"test exception！\")@RequestMapping(\"testResponseStatus\")public String testResponseStatus()&#123; return \"success\";&#125; c.DefaultHandlerExceptionResolver异常处理的实现类：DefaultHandlerExceptionResolver:SPringMVC在一些常见异常的基础上（300 500 404），新增了一些异常，例如： @see org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler @see #handleNoSuchRequestHandlingMethod @see #handleHttpRequestMethodNotSupported ：如果springmvc的处理方法限制为post方式，如果实际请求为get,则会触发此异常显示的页面 @see #handleHttpMediaTypeNotSupported @see #handleMissingServletRequestParameter @see #handleServletRequestBindingException @see #handleTypeMismatch @see #handleHttpMessageNotReadable @see #handleHttpMessageNotWritable @see #handleMethodArgumentNotValidException @see #handleMissingServletRequestParameter @see #handleMissingServletRequestPartException @see #handleBindException d.SimpleMappingExceptionResolver：通过配置来实现异常的处理 12345678910111213141516&lt;!--SimpleMappingExceptionResolver:以配置的方式处理异常 --&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;!-- 如果发生异常，异常对象会被保存在 exceptionAttribute的value值中；并且会放入request域中 ；异常变量的默认值是 exception--&gt; &lt;!--&lt;property name=\"exceptionAttribute\" value=\"exception\"&gt;&lt;/property&gt;--&gt; &lt;property name=\"exceptionMappings\"&gt; &lt;props&gt; &lt;!-- 相当于catch(ArithmeticException ex)&#123; 跳转：error &#125; --&gt; &lt;prop key=\"java.lang.ArithmeticException\"&gt; error &lt;/prop&gt; &lt;prop key=\"java.lang.NullPointerException\"&gt; error &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; SSM整合：Spring - SpringMVC - MyBatis 1.Spring - MyBatis : 需要整合：将MyBatis的SqlSessionFactory 交给Spring 2Spring - SpringMVC ： 就是将Spring - SpringMVC 各自配置一遍 思路： SqlSessionFactory -&gt; SqlSession -&gt;StudentMapper -&gt;CRUD可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据库，Spring整合MyBatis 其实就是 将MyBatis的SqlSessionFactory 交给Spring SM整合步骤：1.jarmybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jarspring-context-support.jar spring-core.jar spring-context.jarspring-beans.jar spring-aop.jar spring-web.jar commons-logging.jarcommons-dbcp.jar ojdbc.jar mybatis.jar log4j.jar commons-pool.jar 2.类-表 Student类 -student表 3.-（与Spring整合时，conf.xml可省）–MyBatis配置文件conf.xml（数据源、mapper.xml） –可省，将该文件中的配置 全部交由spring管理 spring配置文件 applicationContext.xml 4.通过mapper.xml将 类、表建立映射关系 5.之前使用MyBatis: conf.xml -&gt;SqlSessionFacotry 1234567891011&lt;!-- web项目中，spring介入项目 --&gt;&lt;!-- needed for ContextLoaderListener --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- Bootstraps the root web application context before servlet initialization --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 现在整合的时候，需要通过Spring管理SqlSessionFacotry ，因此 产生qlSessionFacotry 所需要的数据库信息 不在放入conf.xml 而需要放入spring配置文件中 配置Spring配置文件（applicationContext.xml） （Web项目）：web.xml 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 6.使用Spring整合MyBatis ：将MyBatis的SqlSessionFactory 交给Spring 注意xml文件路径有classpath:存在,和整合sm最大不同 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 加载db.properties文件 --&gt;&lt;bean id=\"config\" class=\"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;array&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 数据库信息(替代了mybatis中的配置文件conf.xml) --&gt;&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxActive\" value=\"$&#123;maxActive&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxIdle\" value=\"$&#123;maxIdle&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- cof.xml: 数据源、mapper.xml --&gt;&lt;!-- 在SpringIoc容器中 创建Mybatis的核心类SqlSessionFactory --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- 加载mapper.xml配置文件 --&gt; &lt;!-- 注意有classpath:存在,和整合sm最大不同 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:pers/nicolas/mapper/*.xml\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 将mybatis的SqlSessionFactory交给spring --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;!-- xxxxMapper --&gt; &lt;property name=\"basePackage\" value=\"pers.nicolas.mapper\"&gt;&lt;/property&gt;&lt;/bean&gt; 7.继续整合SpringMVC：将springmvc加入项目即可a.加入SpringMVC需要的jarspring-webmvc.jar b.给项目加入SpringMVC支持web.xml: dispatcherServlet（alt+/） 1234567891011121314151617&lt;!-- web项目整合springmvc --&gt;&lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-controller.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- Map all requests to the DispatcherServlet for handling --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; c.编写springmvc配置文件：applicationContext-controller.xml：视图解析器、基础配置 12345678910&lt;!-- 将控制器所在的包加入springIOC容器 --&gt;&lt;context:component-scan base-package=\"pers.nicolas.controller\"&gt;&lt;/context:component-scan&gt;&lt;!-- 配置视图解析器 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/views/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- springMVC基础配置、标配 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; d.示例","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://codeofli.github.io/tags/spring/"},{"name":"springMvc","slug":"springMvc","permalink":"https://codeofli.github.io/tags/springMvc/"}]},{"title":"spring","slug":"java-note/spring/spring","date":"2019-10-19T07:23:24.000Z","updated":"2022-04-02T10:29:05.192Z","comments":true,"path":"2019/10/java-note/spring/spring/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/spring/spring/","excerpt":"2002 Rod Johnon Spring 2003 ,IOC AopSpring data,spring boot,spring cloud,spring framework ,spring social [TOC]IOC :控制反转Inversion of Control（DI：，Dependency Injection，依赖注入）","text":"2002 Rod Johnon Spring 2003 ,IOC AopSpring data,spring boot,spring cloud,spring framework ,spring social [TOC]IOC :控制反转Inversion of Control（DI：，Dependency Injection，依赖注入） 1.搭建Spring环境开发spring至少需要使用的jar(5个+1个): spring-aop.jar 开发AOP特性时需要的JAR spring-beans.jar 处理Bean的jar spring-context.jar 处理spring上下文的jar spring-core.jar spring核心jar spring-expression.jar spring表达式 第三方提供的日志jar commons-logging.jar 日志 123456789101112131415161718192021222324&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt; 2.编写配置文件为了编写时有一些提示、自动生成一些配置信息：方式一：增加sts插件可以给eclipse增加 支持spring的插件：spring tool suite(https://spring.io/tools/sts/all)下载springsource-tool-suite-3.9.4.RELEASE-e4.7.3a-updatesite.zip,然后在Eclipse中安装：Help-Install new SoftWare.. - Add 方式二： 直接下载sts工具（相当于一个集合了Spring tool suite的Eclipse）: https://spring.io/tools/sts/ 新建：bean configuration .. - applicationContext.xml 3.开发Spring程序(IOC)通过ioc容器获取对象123ApplicationContext conext = new ClassPathXmlApplicationContext(\"applicationContext.xml\") ; //执行从springIOC容器中获取一个 id为student的对象Student student = (Student)conext.getBean(\"student\") ; 可以发现，springioc容器 帮我们new了对象，并且给对象赋了值 SpringIOC发展史：1.Student student = new Student();student.setXxx(); 2.简单工厂 3.ioc （超级工厂） IOC（控制反转,Inversion of Control）也可以称之为DI（依赖注入,Dependency Injection）：控制反转：将 创建对象、属性值 的方式 进行了翻转，从new、setXxx() 翻转为了 从springIOC容器getBean()依赖注入：将属性值 注入给了属性，将属性 注入给了bean，将bean注入给了ioc容器； ​总结：ioc/di ，无论要什么对象，都可以直接去springioc容器中获取，而不需要自己操作（new\\setXxx()） 因此之后的ioc分为2步：1 先给springioc中存放对象并赋值 2 拿 DI:依赖注入 ，Teacher Course : cname teacher IOC容器赋值：如果是简单类型（8个基本+String），value； 如果是对象类型，ref=”需要引用的id值”，因此实现了 对象与对象之间的依赖关系 conext.getBean(需要获取的bean的id值) 依赖注入3种方式：1.set注入：通过setXxx()赋值赋值，默认使用的是 set方法();依赖注入底层是通过反射实现的。 12345&lt;bean id=\"cat\" class=\"com.qst.pojo.Cat\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"color\" value=\"red\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"llmz\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.构造器注入：通过构造方法赋值需要注意：如果 的顺序 与构造方法参数的顺序不一致，则需要通过type或者index或name指定。 1&lt;constructor-arg value=\"ls\" type=\"String\" index=\"0\" name=\"name\"&gt;&lt;/constructor-arg&gt; 12345&lt;bean id=\"student\" class=\"com.qst.pojo.Student\"&gt; &lt;constructor-arg name=\"id\" value=\"0\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"studentName\" value=\"lmz\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"studentScore\" value=\"100\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 3.p命名空间注入1234引入p命名空间 xmlns:p=\"http://www.springframework.org/schema/p\"&lt;bean id=\"course\" class=\"org.lanqiao.entity.Course\" p:courseHour=\"300\" p:courseName=\"hadoop\" p:teacher-ref=\"teacher\"&gt; 本质也是反射 简单类型： p:属性名=”属性值”引用类型（除了String外）： p:属性名-ref=”引用的id”注意多个 p赋值的时候 要有空格。 注意：无论是String还是Int/short/long，在赋值时都是 value=”值” ，当参数重载时默认为String优先因此建议 此种情况 需要配合 name\\type进行区分 示例： 注入各种集合数据类型: List Set map properties set、list、数组 各自都有自己的标签 ，但是也可以混着用 ###value与注入方式的区别： 使用子元素注入 而使用value属性注入 参数值位置 写在首尾标签（）的中间(不加双引号) 写在value的属性值中（必须加双引号） type属性 有（可选） 可以通过type属性指定数据类型 无 参数值包含特殊字符（&lt;， &amp;）时的处理方法 两种处理方法。 一、使用标记 二、使用XML预定义的实体引用 一种处理方法。即使用XML预定义的实体引用 其中，XML预定义的实体引用，如表所示。 实体引用 表示的符号 &lt; &lt; &amp; &amp; &gt; &gt; 给对象类型赋值null ： 123&lt;property name=\"name\" &gt; &lt;null/&gt; --&gt;注意 没有&lt;value&gt; &lt;/property&gt; 赋空值 “” 123&lt;property name=\"name\" &gt; &lt;value&gt;&lt;/value&gt; &lt;/property&gt; 在ioc中定义bean的前提：该bean的类 必须提供了 无参构造 4.自动装配（只适用于 ref类型 ）：​ 约定优于配置 自动装配：&lt;bean … class=”org.lanqiao.entity.Course” autowire=”byName|byType|constructor|no” &gt; byName本质是byIdbyName: 自动寻找：其他bean的id值=该Course类的属性名byType: 其他bean的类型(class) 是否与 该Course类的ref属性类型一致 （注意，此种方式 必须满足：当前Ioc容器中 只能有一个Bean满足条件 ）constructor： 其他bean的类型(class) 是否与 该Course类的构造方法参数 的类型一致；此种方式的本质就是byType 可以在头文件中 一次性将该ioc容器的所有bean 统一设置成自动装配：&lt;beans xmlns=”http://www.springframework.org/schema/beans&quot;…default-autowire=”byName”&gt; 自动装配虽然可以减少代码量，但是会降低程序的可读性，使用时需要谨慎。 使用注解定义bean：通过注解的形式 将bean以及相应的属性值 放入ioc容器 1&lt;context:component-scan base-package=\"pers.nicolas.aop\"&gt;&lt;/context:component-scan&gt; 在启动的时候，会根据base-package在 该包中扫描所有类，查找这些类是否有注解@Component(“studentDao”),如果有，则将该类 加入spring Ioc容器。 @Component细化： dao层注解：@Repositoryservice层注解：@Service控制器层注解：@Controller 12345678910@Service(\"StudentService\") //注意添加scan扫描包public class StudentServiceImpl implements IStudentService&#123; @Autowired //自动装配，byType @Qualifier(\"stuDao\") // byIdName IStudentDao studentDao = new StudentDaoImp(); public void setStudentDao(IStudentDao studentDao) &#123; this.studentDao = studentDao; &#125;&#125; 使用注解实现事务（声明式事务） 目标：通过事务 使以下方法 要么全成功、要么全失败public void addStudent(){ //增加班级 //增加学生 //crdu} a. jar包spring-tx-4.3.9.RELEASEojdbc.jarcommons-dbcp.jar 连接池使用到数据源commons-pool.jar 连接池spring-jdbc-4.3.9.RELEASE.jaraopalliance.jar b.配置jdbc\\mybatis\\spring增加事务tx的命名空间 123456789101112131415161718192021&lt;!-- 配置数据库 --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"oracle.jdbc.OracleDriver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@localhost:1521:MLDN\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"scott\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"tigger\"&gt;&lt;/property&gt; &lt;property name=\"maxActive\" value=\"10\"&gt;&lt;/property&gt; &lt;property name=\"maxIdle\" value=\"6\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器txManager --&gt; &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 增加对事务的支持 --&gt; &lt;tx:annotation-driven transaction-manager=\"txManager\" /&gt; c.使用 将需要 成为事务的方法 前增加注解：@Transactional(readOnly=false,propagation=Propagation.REQUIRED) AOP：面向方面编程一个普通的类 -&gt; 有特定功能的类 a.继承类 b.实现接口 c.注解 d.配置 public class MyFilter exntends/implements Xx{ } 类 -&gt; “通知” ：实现接口 前置通知实现步骤：ThrowsAdvice a.jar aopaliance.jar aspectjweaver.jar b.配置 c.编写 aop：每当之前add()之前 自动执行一个方法log(); addStudent(); 业务方法（IStudentService.java中的 addStudent()） before(); 自动执行的通知，即aop前置通知12345678910111213&lt;!-- 前置通知类 --&gt; &lt;bean id=\"LogBefore\" class=\"pers.nicolas.aop.LogBefore\"&gt; &lt;/bean&gt; &lt;!-- 将方法和通知进行关联 --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点（在哪里执行通知） --&gt; &lt;aop:pointcut expression=\"execution(public void pers.nicolas.service.StudentServiceImpl.deleteStudentByNo(int)) or execution(public void pers.nicolas.service.StudentServiceImpl.addStudent(pers.nicolas.entity.Student))\" id=\"pointcut\" /&gt; &lt;!-- advisor相当于连接切入点和切面的线 --&gt; &lt;aop:advisor advice-ref=\"LogBefore\" pointcut-ref=\"pointcut\" /&gt;&lt;/aop:config&gt; 表达式expression的常见示例如表所示。expression=*”execution(…)”* 举例 含义 public boolean addStudent(org.lanqiao.entity.Student)) 所有返回类型为boolean、参数类型为org.lanqiao.entity.Student的addStudent()方法。 public boolean org.lanqiao.service.IStudentService. addStudent(org.lanqiao.entity.Student) org.lanqiao.service.IStudentService类（或接口）中的addStudent()方法，并且返回类型是boolean、参数类型是org.lanqiao.entity.Student public * addStudent(org.lanqiao.entity.Student) “*”代表任意返回类型 public void *( org.lanqiao.entity.Student) “*”代表任意方法名 public void addStudent(..) “..”代表任意参数列表 * org.lanqiao.service..(..) org.lanqiao.service.IStudentService包中，包含的所有方法（不包含子包中的方法） * org.lanqiao.service...(..) org.lanqiao.service.IStudentService包中，包含的所有方法（包含子包中的方法） execution(* com.atguigu.crud.service..*(..)) expression常见示例 org.lanqiao.service org.lanqiao.service.impl public class Xxx{ @Test a(){}} 如果出现异常：类似java.lang.NoClassDefFoundError: org/apache/commons/pool/impl/GenericObjectPool则说明缺少jar 后置通知：AfterReturningAdvice a.通知类 ，普通实现接口b.业务类、业务方法 StudentServiceImpl中的addStudent()c.配置： 将业务类、通知 纳入springIOC容器 定义切入点（一端）、定义通知类（另一端），通过pointcut-ref将两端连接起来 异常通知：ThrowsAdvice ​ 根据异常通知接口的定义可以发现，异常通知的实现类 必须编写以下方法：​ public void afterThrowing([Method, args, target], ThrowableSubclass)： a.public void afterThrowing(Method, args, target, ThrowableSubclass) b.public void afterThrowing( ThrowableSubclass)环绕通知：MethodInterceptor 在目标方法的前后、异常发生时、最终等各个地方都可以 进行的通知，最强大的一个通知； 可以获取目标方法的 全部控制权（目标方法是否执行、执行之前、执行之后、参数、返回值等） 在使用环绕通知时，目标方法的一切信息 都可以通过invocation参数获取到环绕通知 底层是通过拦截器实现的。 1234567891011121314151617public Object invoke(MethodInvocation invocation) throws Throwable &#123; Object result = null; try &#123; System.out.println(\"around advice[before advice]\"); // invocation.proceed()之前后的代码：前后置通知 result = invocation.proceed();// 控制目标方法的执行 xxx(),result就是目标方法的返回值 // invocation.proceed()之后的代码：后置通知 System.out.println(\"\"); System.out .println(\"around advice[after advice]: traget object :\" + invocation.getThis() + \", function name:=\" + invocation.getMethod().getName() + \",returnValue=\" + result + \",args=\" + invocation.getArguments()); &#125; catch (Exception e) &#123; // 异常通知 System.out.println(\"around advice[exception advice]\"); &#125; return result; &#125; 二、实现注解实现 通知 aopa.jar 与 实现接口 的方式相同b.配置 将业务类、通知 纳入springIOC容器 开启注解对AOP的支持aop:aspectj-autoproxy 业务类 addStudent - 通知 c.编写 通知：@Aspect //声明该类 是一个 通知public class LogBeforeAnnotation { } 注意：通过注解形式 将对象增加到 ioc容器时，需要设置 扫描器&lt;context:component-scan base-package=”org.lanqiao.aop”&gt; 扫描器 会将 指定的包 中的 @Componet @Service @Respository @Controller修饰的类产生的对象 增加到IOC容器中@Aspect不需要 加入扫描器，只需要开启即可：aop:aspectj-autoproxy 通过注解形式 实现的aop，如果想获取 目标对象的一些参数，则需要使用一个对象：JoinPoint 注解形式的返回值：a.声明返回值 的参数名： @AfterReturning( pointcut= “execution(public * addStudent(..))” ,returning=”returningValue” ) public void myAfter(JoinPoint jp,Object returningValue) {//returningValue是返回值，但需要告诉spring System.out.println(“返回值：”+returningValue );注解形式实现aop时，通知的方法的参数不能多、少 实现接口形式、注解形式 只捕获声明的特定类型的异常，而其他类型异常不捕获。cath() 1234567891011121314151617181920212223242526272829303132333435363738394041@Component(\"logAnnotaiton\")@Aspect // 声明此类是一个通知public class LogAopAnnotation &#123; //前置通知 @Before(\"execution(public * addStudent(..))\") // 属性：定义切点 public void MyBefore(JoinPoint jp) &#123; System.out.println(\"&lt;[Annotation]前置 advice&gt;: target object:\" + jp.getTarget() + \",methodName:\" + jp.getSignature().getName() + \",arguments:\" + Arrays.toString(jp.getArgs())); &#125; //后置通知 @AfterReturning(pointcut = \"execution(public * addStudent(..))\",returning = \"returningValue\") // 属性：定义切点,要得到返回值必须通过注解声明 public void AfterReturning(JoinPoint jp,Object returningValue) &#123; System.out.println(\"&lt;[Annotation]后置advice&gt; target object:\" + jp.getTarget() + \",methodName:\" + jp.getSignature().getName() + \",arguments:\" + Arrays.toString(jp.getArgs())+\",returnVlaue:\"+returningValue); &#125; //Exception Advice:如果只捕获指定异常，可以通过通过注解throwing指定 @AfterThrowing(pointcut = \"execution(public * addStudent(..))\",throwing = \"e\") public void MyException(JoinPoint jp,NullPointerException e) &#123; System.out.println(\"&lt;[Annotation]exception advice&gt; e:\"+e.getMessage()); &#125; //环绕通知,参数ProceedingJoinPoint @Around(\"execution(public * addStudent(..))\") public void MyAroud(ProceedingJoinPoint jp)&#123; try &#123; System.out.println(\"&lt;[Annotation【Around】]前置 advice&gt;\"); //方法之前，前置通知 jp.proceed();//方法执行 //方法之后，后前置通知 System.out.println(\"&lt;[Annotation【Around】]后置 advice&gt;\"); &#125;catch(Throwable e) &#123;//方法异常，异常通知 System.out.println(\"&lt;[Annotation【Around】]exception advice&gt;\"); &#125;finally &#123;//最终执行，最终通知 System.out.println(\"&lt;[Annotation【Around】]最终 advice&gt;\"); &#125; &#125; //最终通知 @After(\"execution(public * addStudent(..))\") public void MyAfter() &#123; System.out.println(\"&lt;[Annotation]最终advice&gt;\"); &#125;&#125; 三、通过 配置将 类-&gt;通知基于Schema配置类似 于 实现接口的方式 接口方式通知：public class LogAfter implements AfterReturningAdviceSchema方式通知： a.编写一个普通类 public class LogAfter {} b.将该类 通过配置，转为一个“通知” 如果要获取目标对象信息：注解、schema：JoinPoint接口：Method method, Object[] args, Object target schema形式 和注解形式相似，不同之处： 注解形式 使用了注册@After， schmema形式进行了多余的配置 12345678910111213141516&lt;aop:config&gt; &lt;!-- 配置切入点（在哪里执行通知） --&gt; &lt;aop:pointcut expression=\"execution(public void pers.nicolas.service.StudentServiceImpl.addStudent(pers.nicolas.entity.Student))\" id=\"pointcut_schema\" /&gt; &lt;!-- schema方式 --&gt; &lt;aop:aspect ref=\"LogSchema\"&gt; &lt;aop:before method=\"before\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;aop:after-returning method=\"afterReturning\" returning=\"returnValue\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;aop:after-throwing method=\"MyException\" throwing=\"e\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;aop:around method=\"around\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 1.Spring开发Web项目 及 拆分Spring配置文件a.Spring开发Web项目 Web项目如何初始化SpringIOC容器 ：思路：当服务启动时（tomcat），通过监听器将SpringIOC容器初始化一次（该监听器 spring-web.jar已经提供） 因此用spring开发web项目 至少需要7个jar： spring-java的6个jar + spring-web.jar，注意：web项目的jar包 是存入到WEB-INF/lib中 web项目启动时 ，会自动加载web.xml，因此需要在web.xml中加载 监听器（ioc容器初始化）。 Web项目启动时，启动实例化Ioc容器： 1234567891011121314&lt;!-- 指定 Ioc容器（applicationContext.xml）的位置--&gt; &lt;context-param&gt; &lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;!-- 配置spring-web.jar提供的监听器，此监听器 可以在服务器启动时 初始化Ioc容器。 初始化Ioc容器（applicationContext.xml） ， 1.告诉监听器 此容器的位置：context-param 2.默认约定的位置 :WEB-INF/applicationContext.xml --&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; b.拆分Spring配置文件​ java项目：​ applicationContext1.xml​ applicationContext2.xml​ applicationContext3.xml ApplicationContext conext = new ClassPathXmlApplicationContext(“applicationContext3.xml”) ; Web项目： 根据什么拆分？ i.三层结构 UI(html/css/jsp 、Servlet) applicationController.xml Service :applicationService.xml Dao:applicationDao.xml 公共 数据库:applicationDB.xml ii.功能结构 学生相关配置 applicationContextStudent.xml 班级相关配置 applicationContextClass.xml 合并：如何将多个配置文件 加载 （1） 12345678910&lt;context-param&gt; &lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml, classpath:applicationContext-Dao.xml, classpath:applicationContext-Service.xml, classpath:applicationContext-Controller.xml &lt;/param-value&gt;&lt;/context-param&gt; ​ （2）推荐 12345678&lt;context-param&gt; &lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml, classpath:applicationContext-*.xml &lt;/param-value&gt;&lt;/context-param&gt; （3）只在web.xml中加载主配置文件， 123&lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt; ​ 然后在主配置问加中，加载其他配置文件: 1&lt;import resource=\"applicationContext-*.xml\"/&gt; Web项目： 2.Spring整合MyBatisSpring - MyBatis 思路： SqlSessionFactory -&gt; SqlSession -&gt;StudentMapper -&gt;CRUD可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据库，Spring整合MyBatis 其实就是 将MyBatis的SqlSessionFactory 交给Spring SM整合步骤：1.jarmybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jarspring-context-support.jar spring-core.jar spring-context.jarspring-beans.jar spring-aop.jar spring-web.jar commons-logging.jarcommons-dbcp.jar ojdbc.jar mybatis.jar log4j.jar commons-pool.jar 2.类-表 3.MyBatis配置文件conf.xml 4.通过mapper.xml将 类、表建立映射关系 5.之前使用MyBatis: conf.xml -&gt;SqlSessionFacotry 现在整合的时候，需要通过Spring管理SqlSessionFacotry ，因此 产生qlSessionFacotry 所需要的数据库信息 不在放入conf.xml 而需要放入spring配置文件中 配置Spring配置文件（applicationContext.xml） 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 加载db.properties文件 --&gt; &lt;bean id=\"config\"class=\"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;array&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 数据库信息(替代了mybatis中的配置文件conf.xml) --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxActive\" value=\"$&#123;maxActive&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxIdle\" value=\"$&#123;maxIdle&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 在SpringIoc容器中 创建mybatis的核心类SqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;!-- 加载mybatis配置文件，如果只有映射，不需要写conf.xml文件--&gt;&lt;!-- &lt;property name=\"configLocation\" value=\"classpath:conf.xml\"&gt;&lt;/property&gt; --&gt; &lt;!-- 加载mapper.xml配置文件 --&gt; &lt;property name=\"mapperLocations\" value=\"pers/nicolas/mapper/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 第3种方式批量生成mapper代理对象批量产生的mapper对象在SpringIOC容器中的id值默认就是接口mapper名(首字母小写）--&gt;&lt;bean id=\"mappers\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"pers.nicolas.mapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; 6.使用Spring-MyBatis整合产物开发程序 目标：通过spring产生mybatis最终操作需要的 动态mapper对象(StudentMapper对象) Spring产生 动态mapper对象 有3种方法： a.第一种方式DAO层实现类 继承 SqlSessionDaoSupport类 1234567 SqlSessionDaoSupport类提供了一个属性 SqlSession &lt;!-- 第一种方式生成mapper代理对象 --&gt;&lt;bean id=\"studentMapper\" class=\"pers.nicolas.dao.impl.StudentDaoImpl\"&gt;&lt;!-- 将Spring配置的sqlSessionFactory交给Mapper（Dao) --&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; b.第二种方式 就是省略掉 第一种方式的 实现类 直接MyBatis提供的 Mapper实现类：org.mybatis.spring.mapper.MapperFactoryBean 缺点：每个mapper都需要一个配置一次 12345&lt;!-- 第二种方式生成mapper代理对象 --&gt;&lt;bean id=\"studentMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;property name=\"mapperInterface\" value=\"pers.nicolas.mapper.StudentMapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; c.第三种方式 批量配置 实现类 1234567&lt;!-- 第3种方式批量生成mapper代理对象批量产生的mapper对象在SpringIOC容器中的id值默认就是接口mapper名(首字母小写）--&gt;&lt;bean id=\"mappers\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"pers.nicolas.mapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; # spring注解版一个接口指定实现类接口定义 12345package com.yoj.used;public interface MyInterface &#123; void className();&#125; 实现类1 1234567@Service(\"impl1\")public class Implement1 implements MyInterface&#123; @Override public void className() &#123; System.out.println(Implement1.class); &#125;&#125; 实现类2 1234567@Service(\"impl2\")public class Implement2 implements MyInterface &#123; @Override public void className() &#123; System.out.println(Implement2.class); &#125;&#125; 1.@AutoWired+@Qualifier(“impl2”)指定 123@Autowired@Qualifier(\"impl2\")MyInterface myInterface; 2.使用@Resource注入，根据@Service指定的名称区分 12@Resource(name = \"impl2\")MyInterface myInterface; my同一类中内部调用aop失效Spring Bean初始化之后执行指定方法https://blog.csdn.net/forever7107/article/details/76446544/ 在运用Spring进行实际项目开发过程中，经常会有一种需求就是想要在Bean实例化完成后，自动执行指定方法，包括加载初始值，初始化缓存等。通过简单的XML配置或者使用注解即可实现。本文仅用于记录简单的使用介绍，不阐述详细的技术实现细节，达到抛砖引玉的效果。 Spring注解方式如果项目中bean是通过注解方式管理的，需要在初始化完成后，执行指定方法，仅仅需要在需要执行的方法上添加@PostConstruct注解即可，修改后的JAVA类如下： 123456789@Componentpublic class InitMethodTest &#123; @PostConstruct public void initMethod()&#123; System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;initMethod&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"); &#125;&#125; Spring注解","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://codeofli.github.io/tags/spring/"}]},{"title":"python-crawler","slug":"python/python-crawler/python-crawler","date":"2019-10-16T13:27:10.000Z","updated":"2021-10-23T02:19:04.268Z","comments":true,"path":"2019/10/python/python-crawler/python-crawler/","link":"","permalink":"https://codeofli.github.io/2019/10/python/python-crawler/python-crawler/","excerpt":"requests库requests库的安装http://www.python-requests.org Win平台: “以管理员身份运行” cmd，执行 pip install requests requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get(url, params=None, **kwargs) 获取HTML网页的主要方法，对应于HTTP的GET requests.head(url, **kwargs) 获取HTML网页头信息的方法，对应于HTTP的HEAD requests.post(url, data=None, json=None, **kwargs) 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put(url, data=None, **kwargs) 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch(url, data=None, **kwargs) 向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete(url, **kwargs) 向HTML页面提交删除请求，对应于HTTP的DELETE","text":"requests库requests库的安装http://www.python-requests.org Win平台: “以管理员身份运行” cmd，执行 pip install requests requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get(url, params=None, **kwargs) 获取HTML网页的主要方法，对应于HTTP的GET requests.head(url, **kwargs) 获取HTML网页头信息的方法，对应于HTTP的HEAD requests.post(url, data=None, json=None, **kwargs) 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put(url, data=None, **kwargs) 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch(url, data=None, **kwargs) 向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete(url, **kwargs) 向HTML页面提交删除请求，对应于HTTP的DELETE requests库的get方法： requests.get(url, params=None, kwargs)∙ url : 拟获取页面的url链接∙ params : url中的额外参数，字典或字节流格式，可选∙ kwargs: 12个控制访问的参数 123456789101112def get(url, params=None, **kwargs): r\"\"\"Sends a GET request. :param url: URL for the new :class:`Request` object. :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`. :param \\*\\*kwargs: Optional arguments that ``request`` takes. :return: :class:`Response &lt;Response&gt;` object :rtype: requests.Response \"\"\" kwargs.setdefault('allow_redirects', True) return request('get', url, params=params, **kwargs) 主要方法解析requests.request(method, url, kwargs)∙ method : 请求方式，对应get/put/post等7种∙ url : 拟获取页面的url链接∙ kwargs: 控制访问的参数，共13个 method : 请求方式 1234567r = requests.request('GET', url, **kwargs) r = requests.request('HEAD', url, **kwargs) r = requests.request('POST', url, **kwargs) r = requests.request('PUT', url, **kwargs) r = requests.request('PATCH', url, **kwargs) r = requests.request('delete', url, **kwargs) r = requests.request('OPTIONS', url, **kwargs) \\kwargs: 控制访问的参数，均为可选项**params : 字典或字节序列，作为参数增加到url中data : 字典、字节序列或文件对象，作为Request的内容 json : JSON格式的数据，作为Request的内容 headers : 字典， HTTP定制头 cookies : 字典或CookieJar， Request中的cookie auth : 元组，支持HTTP认证功能 files : 字典类型，传输文件 timeout : 设定超时时间，秒为单位 proxies : 字典类型，设定访问代理服务器，可以增加登录认证 allow_redirects : True/False，默认为True，重定向开关stream : True/False，默认为True，获取内容立即下载开关verify : True/False，默认为True，认证SSL证书开关cert : 本地SSL证书路径 Response对象Response对象包含服务器返回的所有信息，也包含请求的Request信息 Response 对象的属性 属性 说明 r.status_code HTTP请求的返回状态， 200表示连接成功， 404表示失败 r.text HTTP响应内容的字符串形式，即， url对应的页面内容 r.encoding 从HTTP header中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） r.content HTTP响应内容的二进制形式 Response的编码 r.encoding 从HTTP header中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） r.encoding：如果header中不存在charset，则认为编码为ISO‐8859‐1r.text根据r.encoding显示网页内容r.apparent_encoding ：根据网页内容分析出的编码方式可以看作是r.encoding的备选 request库的异常 异常 说明 requests.ConnectionError 网络连接错误异常，如DNS查询失败、拒绝连接等 requests.HTTPError HTTP错误异常 requests.URLRequired URL缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器超时异常 requests.Timeout 请求URL超时，产生超时异常 r.raise_for_status() 如果不是200，产生异常 requests.HTTPError r.raise_for_status()在方法内部判断r.status_code是否等于200，不需要增加额外的if语句，该语句便于利用try‐except进行异常处理 爬取网页通用的代码(块)框架1234567891011121314151617import requests def getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return 'processing exception' if __name__ == \"__main__\": url = 'https://www.baidu.com/' print(getHTMLText(url)) response = requests.get('https://www.baidu.com/') print(type(response)) HTTP协议HTTP， Hypertext Transfer Protocol，超文本传输协议HTTP是一个基于“请求与响应”模式的、无状态的应用层协议HTTP协议采用URL作为定位网络资源的标识， URL格式如下：http://host[:port][path]host: 合法的Internet主机域名或IP地址port: 端口号，缺省端口为80path: 请求资源的路径 HTTP URL的理解：URL是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源 http协议对资源的操作 方法 说明 GET 请求获取URL位置的资源 HEAD 请求获取URL位置资源的响应消息报告，即获得该资源的头部信息 POST 请求向URL位置的资源后附加新的数据 PUT 请求向URL位置存储一个资源，覆盖原URL位置的资源 PATCH 请求局部更新URL位置的资源，即改变该处资源的部分内容 DELETE 请求删除URL位置存储的资源 理解patch和put的区别假设URL位置有一组数据UserInfo，包括UserID、 UserName等20个字段需求：用户修改了UserName，其他不变• 采用PATCH，仅向URL提交UserName的局部更新请求• 采用PUT，必须将所有20个字段一并提交到URL，未提交字段被删除PATCH的最主要好处：节省网络带宽 http协议与requests库 TTP协议方法 Requests库方法 功能一致性 GET requests.get() 一致 HEAD requests.head() 一致 POST requests.post() 一致 PUT requests.put() 一致 PATCH requests.patch() 一致 DELETE requests.delete() 一致 Requests库网络爬取实战实例2：亚马逊商品页面的爬取 12345678910import requests url = 'https://item.jd.com/2967929.html' kv = &#123;'user-agent':'Mozilla/5.0'&#125; try: r = requests.get(url,headers=kv) r.raise_for_status() r.encoding = r.apparent_encoding print(r.status_code) except: 'processing exception' 实例3：百度/360搜索关键字提交 百度的关键词接口：http://www.baidu.com/s?wd=keyword 123456789101112# https://item.jd.com/2967929.html import requests url = 'http://www.baidu.com/s' kv = &#123;'wd':'python'&#125; try: r = requests.get(url,params=kv) r.raise_for_status() r.encoding = r.apparent_encoding print(len(r.text)) print(r.status_code) except: 'processing exception' 实例4：网络图片的爬取和存储 123456789101112131415161718import requests,os url = 'http://image.nationalgeographic.com.cn/2017/0211/20170211061910157.jpg' root = 'E://img//' path = root + url.split('/')[-1] try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(url) r.raise_for_status() with open(path,'wb') as f: f.write(r.content) f.close() print('save file successfully') else: print('file exist') except: 'processing exception' 网络爬虫的相关问题 网络爬虫的限制来源审查：判断User‐Agent进行限制检查来访HTTP协议头的User‐Agent域，只响应浏览器或友好爬虫的访问• 发布公告： Robots协议告知所有爬虫网站的爬取策略，要求爬虫遵守 Robots协议Robots Exclusion Standard，网络爬虫排除标准 作用：网站告知网络爬虫哪些页面可以抓取，哪些不行形式：在网站根目录下的robots.txt文件 http://www.baidu.com/robots.txthttp://news.sina.com.cn/robots.txthttp://www.qq.com/robots.txthttp://news.qq.com/robots.txthttp://www.moe.edu.cn/robots.txt （无robots协议） Robots协议使用网络爬虫：自动或人工识别robots.txt，再进行内容爬取约束性：Robots协议是建议但非约束性，网络爬虫可以不遵守，但存在法律风险 beautifulSoup库https://www.crummy.com/software/BeautifulSoup/ https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/ Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库. 安装 1pip install beautifulsoup4 使用 12345678910111213141516from bs4 import BeautifulSoup html_doc = \"\"\" &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;, &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;; and they lived at the bottom of a well.&lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; \"\"\" soup = BeautifulSoup(html_doc, 'html.parser') print(soup.prettify()) Beautiful Soup库解析器1soup = BeautifulSoup('&lt;html&gt;data&lt;/html&gt;'， 'html.parser') 解析器 使用方法 条件 bs4的HTML解析器 BeautifulSoup(mk,’html.parser’) 安装bs4库 lxml的LXML解析器 BeautifulSoup(mk,’lxml’) pip install lxml lxml的XML解析器 BeautifulSoup(mk,’xml’) pip install lxml html5lib的解析器 BeautifulSoup(mk,’html5lib’) pip install html5lib BeautifulSoup类的基本元素 1&lt;p class=\"title\"&gt; … &lt;/p&gt; 基本元素 说明 Tag 标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;标明开头和结尾 Name 标签的名字， …的名字是’p’，格式： .name Attributes 标签的属性，字典形式组织，格式： .attrs NavigableString 标签内非属性字符串， &lt;&gt;…&lt;/&gt;中字符串，格式： .string Comment 标签内字符串的注释部分，一种特殊的Comment类型 Tag 标签 基本元素 说明 Tag 标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;标明开头和结尾 Name 标签的名字， …的名字是’p’，格式： .name Attributes 标签的属性，字典形式组织，格式： .attrs NavigableString 标签内非属性字符串， &lt;&gt;…&lt;/&gt;中字符串，格式： .string Comment 标签内字符串的注释部分，一种特殊的Comment类型 任何存在于HTML语法中的标签都可以用soup.&lt;tag&gt;访问获得当HTML文档中存在多个相同&lt;tag&gt;对应内容时， soup.&lt;tag&gt;返回第一个 基于bs4库的HTML内容遍历方法 标签树的下行遍历 属性 说明 .contents 子节点的列表，将所有儿子节点存入列表 .children 子节点的迭代类型，与.contents类似，用于循环遍历儿子节点 .descendants 子孙节点的迭代类型，包含所有子孙节点，用于循环遍历 BeautifulSoup类型是标签树的根节点 标签树的下行遍历 1234for child in soup.body.children: print(child) 遍历儿子节点 for child in soup.body.descendants: print(child) 遍历子孙节点 标签树的上行遍历 属性 说明 .parent 节点的父亲标签 .parents 节点先辈标签的迭代类型，用于循环遍历先辈节点 标签树的上行遍历 遍历所有先辈节点，包括soup本身，所以要区别判断 标签树的平行遍历 属性 说明 .next_sibling 返回按照HTML文本顺序的下一个平行节点标签 .previous_sibling 返回按照HTML文本顺序的上一个平行节点标签 .next_siblings 迭代类型，返回按照HTML文本顺序的后续所有平行节点标签 .previous_siblings 迭代类型，返回按照HTML文本顺序的前续所有平行节点标签 1234567标签树的平行遍历 for sibling in soup.a.next_sibling: print(sibling) for sibling in soup.a.previous_sibling: print(sibling) 遍历后续节点 遍历前续节点 信息标记和提取方法信息标记标记后的信息可形成信息组织结构，增加了信息维度标记的结构与信息一样具有重要价值标记后的信息可用于通信、存储或展示标记后的信息更利于程序理解和运用 信息标记的三种信息xml，json，yaml html的信息标记HTML是WWW(World Wide Web)的信息组织方式 HTML通过预定义的&lt;&gt;…&lt;/&gt;标签形式组织不同类型的信息 xml eXtensible Markup Language 空元素的缩写形式 1&lt;img src=“china.jpg” size=“10” /&gt; 注释书写形式 1&lt;!‐‐ This is a comment, very useful ‐‐&gt; json JavsScript Object Notation有类型的键值对 key:value yaml YAML Ain’t Markup Language无类型键值对 key:value 1234缩进表达所属关系 name : newName : 北京理工大学 oldName : 延安自然科学院 1234‐ 表达并列关系 name : ‐北京理工大学 ‐延安自然科学院 123456| 表达整块数据 # 表示注释 text: | #学校介绍 北京理工大学创立于1940年，前身是延安自然科学院， 是中国共产党创办的第一所理工科大学，毛泽东同志亲 自题写校名，李富春、徐特立、李强等老一辈无产阶级革命家先后担任学校主要领导。学校是新中国成立以来 国家历批次重点建设的高校，首批进入国家“211工程”和“985工程”建设行列；在全球具有广泛影响力的英 国QS“世界大学500强”中，位列入选的中国大陆高校第15位。学校现隶属于工业和信息化部。 XMLJSONYAML最早的通用信息标记语言，可扩展性好，但繁琐信息有类型，适合程序处理(js)，较XML简洁信息无类型，文本信息比例最高，可读性好 XMLJSONYAMLInternet上的信息交互与传递移动应用云端和节点的信息通信，无注释各类系统的配置文件，有注释易读 信息提取融合方法：结合形式解析与搜索方法，提取关键信息XML JSON YAML 搜索需要标记解析器及文本查找函数 12345678from bs4 import BeautifulSoup import requests r =requests.get('http://python123.io/ws/demo.html') demo = r.text soup = BeautifulSoup(demo, 'html.parser') for link in soup('a'): print(link) &lt;&gt;.find_all(name, attrs, recursive, string, **kwargs)∙ name : 对标签名称的检索字符串返回一个列表类型，存储查找的结果 attrs: 对标签属性值的检索字符串，可标注属性检索 recursive: 是否对子孙全部检索，默认True string: &lt;&gt;…&lt;/&gt;中字符串区域的检索字符串 &lt;tag&gt;(..) 等价于 &lt;tag&gt;.find_all(..)soup(..) 等价于 soup.find_all(..) 方法 说明 &lt;&gt;.find() 搜索且只返回一个结果，同.find_all()参数 &lt;&gt;.find_parents() 在先辈节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_parent() 在先辈节点中返回一个结果，同.find()参数 &lt;&gt;.find_next_siblings() 在后续平行节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_next_sibling() 在后续平行节点中返回一个结果，同.find()参数 &lt;&gt;.find_previous_siblings() 在前序平行节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_previous_sibling() 在前序平行节点中返回一个结果，同.find()参数 中国大学定向排名实例http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html 技术路线： requests‐bs4定向爬虫：仅对输入URL进行爬取，不扩展爬取 12345678910111213141516171819202122232425262728293031323334353637# CrawUnivRankingB.py import requests from bs4 import BeautifulSoup import bs4 def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return \"\" def fillUnivList(ulist, html): soup = BeautifulSoup(html, \"html.parser\") for tr in soup.find('tbody').children: if isinstance(tr, bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string, tds[1].string, tds[3].string]) def printUnivList(ulist, num): tplt = \"&#123;0:^10&#125;\\t&#123;1:&#123;3&#125;^10&#125;\\t&#123;2:^10&#125;\" print(tplt.format(\"排名\", \"学校名称\", \"总分\", chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0], u[1], u[2], chr(12288))) def main(): uinfo = [] url = 'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html' html = getHTMLText(url) fillUnivList(uinfo, html) printUnivList(uinfo, 20) # 20 univs main() 当中文字符宽度不够时，采用西文字符填充；中西文字符占用宽度不同采用中文字符的空格填充 chr(12288) 正则表达式regular expression, regex, RE 正则表达式是用来简洁表达一组字符串的表达式 正则表达式在文本处理中十分常用：表达文本类型的特征（病毒、入侵等）同时查找或替换一组字符串匹配字符串的全部或部分……最主要应用在字符串匹配中 正则表达式语法由字符和操作符构成 正则表达式常用操作符 操作符 说明 实例 . 表示任何单个字符 [ ] 字符集，对单个字符给出取值范围 [abc]表示a、 b、 c， [a‐z]表示a到z单个字符 [^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc* 表示 ab、 abc、 abcc、 abccc等 + 前一个字符1次或无限次扩展 abc+ 表示 abc、 abcc、 abccc等 ? 前一个字符0次或1次扩展 abc? 表示 ab、 abc | 左右表达式任意一个 abc|def 表示 abc、 def {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次（含n） ab{1,2}c表示abc、 abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 ( ) 分组标记，内部只能使用 | 操作符 (abc)表示abc， (abc|def)表示abc、 def \\d 数字，等价于[0‐9] \\w 单词字符，等价于[A‐Za‐z0‐9_] 经典正则表达式1234567^[A‐Za‐z]+$ 由26个字母组成的字符串 ^[A‐Za‐z0‐9]+$ 由26个字母和数字组成的字符串 ^‐?\\d+$ 整数形式的字符串 ^[0‐9]*[1‐9][0‐9]*$ 正整数形式的字符串 [1‐9]\\d&#123;5&#125; 中国境内邮政编码， 6位 [\\u4e00‐\\u9fa5] 匹配中文字符 \\d&#123;3&#125;‐\\d&#123;8&#125;|\\d&#123;4&#125;‐\\d&#123;7&#125; 国内电话号码， 010‐68913536 ip地址正则P地址字符串形式的正则表达式（ IP地址分4段，每段0‐255） 123456 精确写法 0‐99： [1‐9]?\\d 100‐199: 1\\d&#123;2&#125; 200‐249: 2[0‐4]\\d 250‐255: 25[0‐5] (([1‐9]?\\d|1\\d&#123;2&#125;|2[0‐4]\\d|25[0‐5]).)&#123;3&#125;([1‐9]?\\d|1\\d&#123;2&#125;|2[0‐4]\\d|25[0‐5]) re库Re库是Python的标准库，主要用于字符串匹配 正则表达式的表示类型raw string类型（原生字符串类型）库采用类型表示正则表达式，表示为： 1例如： r'[1‐9]\\d&#123;5&#125;' r'\\d&#123;3&#125;‐\\d&#123;8&#125;|\\d&#123;4&#125;‐\\d&#123;7&#125;' raw string是不包含对转义符再次转义的字符串 re库也可以采用string类型表示正则表达式，但更繁琐例如：‘[1‐9]\\d{5}’‘\\d{3}‐\\d{8}|\\d{4}‐\\d{7}’建议：当正则表达式包含转义符时，使用raw string Re库的主要功能函数 函数 说明 re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 re.match() 从一个字符串的开始位置起匹配正则表达式，返回match对象 re.findall() 搜索字符串，以列表类型返回全部能匹配的子串 re.split() 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re.finditer() 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 re.sub() 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 re.search(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记在一个字符串中搜索匹配正则表达式的第一个位置返回match对象 常用标记 说明 re.I re.IGNORECASE 忽略正则表达式的大小写， [A‐Z]能够匹配小写字符 re.M re.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始 re.S re.DOTALL 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符 1234import re match = re.search(r'[1-9]\\d&#123;5&#125;','bit 100001') if match: print(match.group(0)) re.match(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记从一个字符串的开始位置起匹配正则表达式返回match对象 re.findall(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记搜索字符串，以列表类型返回全部能匹配的子串 re.split(pattern, string, maxsplit=0, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ maxsplit: 最大分割数，剩余部分作为最后一个元素输出∙ flags : 正则表达式使用时的控制标记将一个字符串按照正则表达式匹配结果进行分割返回列表类型 re.finditer(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 1import refor m in re.finditer(r'[1-9]\\d&#123;5&#125;','bit100001 lmz312552'): if m: print(m.group(0)) re.sub(pattern, repl, string, count=0, flags=0)在一个字符串中替换所有匹配正则表达式的子串返回替换后的字符串 ∙ pattern 正则表达式的字符串或原生字符串表示: ∙ repl : 替换匹配字符串的字符串∙ string : 待匹配字符串∙ count∙ flags : 匹配的最大替换次数正则表达式使用时的控制标记 1import resub = re.sub(r'[1-9]\\d&#123;5&#125;', 'bitzip', 'bit100001 lmz312552')print(sub) 正则表达式对象123rst = re.search(r'[1‐9]\\d&#123;5&#125;', 'BIT 100081') pat = re.compile(r'[1‐9]\\d&#123;5&#125;') rst = pat.search('BIT 100081') 面向对象用法：编译后的多次操作函数式用法：一次性操作 regex = re.compile(pattern, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ flags : 正则表达式使用时的控制标记 regex = re.compile(r’[1‐9]\\d{5}’)将正则表达式的字符串形式编译成正则表达式对象 re库的match对象Match对象是一次匹配的结果，包含匹配的很多信息 属性 说明 .string 待匹配的文本 .re 匹配时使用的patter对象（正则表达式） .pos 正则表达式搜索文本的开始位置 .endpos 正则表达式搜索文本的结束位置 re库的贪婪匹配和最小匹配123match = re.search(r'PY.*N', 'PYANBNCNDN') print(match.group(0)) 'PYANBNCNDN' Re库默认采用贪婪匹配，即输出匹配最长的子串 操作符 说明 *? 前一个字符0次或无限次扩展，最小匹配 +? 前一个字符1次或无限次扩展，最小匹配 ?? 前一个字符0次或1次扩展，最小匹配 {m,n}? 扩展前一个字符m至n次（含n），最小匹配 *只要长度输出可能不同的，都可以通过在操作符后增加?变成最小匹配 * ScrapyScrapy是一个快速功能强大的网络爬虫框架 爬虫框架是实现爬虫功能的一个软件结构和功能组件集合。爬虫框架是一个半成品，能够帮助用户实现专业网络爬虫。 scrapy的安装 Win平台: “以管理员身份运行” cmd执行 1pip install scrapy 1conda install scrapy 安装后小测：执行 1scrapy Scrapy结构 Engine(1) 控制所有模块之间的数据流(2) 根据条件触发事件不需要用户修改 Downloader根据请求下载网页不需要用户修改 Scheduler对所有爬取请求进行调度管理不需要用户修改 Downloader Middleware目的：实施Engine、 Scheduler和Downloader之间进行用户可配置的控制功能：修改、丢弃、新增请求或响应用户可以编写配置代码 Spider(1) 解析Downloader返回的响应（ Response）(2) 产生爬取项（ scraped item）(3) 产生额外的爬取请求（ Request）需要用户编写配置代码 Item Pipelines(1) 以流水线方式处理Spider产生的爬取项(2) 由一组操作顺序组成，类似流水线，每个操作是一个Item Pipeline类型(3) 可能操作包括：清理、检验和查重爬取项中的HTML数据、将数据存储到数据库需要用户编写配置代码 Spider Middleware目的：对请求和爬取项的再处理功能：修改、丢弃、新增请求或爬取项用户可以编写配置代码 requests和scrapy相同点：两者都可以进行页面请求和爬取， Python爬虫的两个重要技术路线两者可用性都好，文档丰富，入门简单两者都没有处理js、提交表单、应对验证码等功能（可扩展） requests scrapy 页面级爬虫 网站级爬虫 功能库 框架 并发性考虑不足，性能较差 并发性好，性能较高 重点在于页面下载 重点在于爬虫结构 定制灵活 一般定制灵活，深度定制困难 上手十分简单 入门稍难 scrapy常用命令Scrapy是为持续运行设计的专业爬虫框架，提供操作的Scrapy命令行Win下，启动cmd控制台 为什么Scrapy采用命令行创建和运行爬虫？命令行（不是图形界面）更容易自动化，适合脚本控制本质上， Scrapy是给程序员用的，功能（而不是界面）更重要 1scrapy &lt;command&gt; [options] [args] 命令 说明 格式 startproject 创建一个新工程 scrapy startproject [dir] genspider 创建一个爬虫 scrapy genspider [options] settings 获得爬虫配置信息 scrapy settings [options] crawl 运行一个爬虫 scrapy crawl list 列出工程中所有爬虫 scrapy list shell 启动URL调试命令行 scrapy shell [url] 产生的步骤应用Scrapy爬虫框架主要是编写配置型代码 步骤1：建立一个Scrapy爬虫工程选取一个目录（ D:\\pycodes\\），然后执行如下命令： 1scrapy startproject python123demo 生成的工程目录12345678910python123demo/ 外层目录 scrapy.cfg 部署Scrapy爬虫的配置文件 python123demo/ Scrapy框架的用户自定义Python代码 __init__.py 初始化脚本 items.py Items代码模板（继承类） middlewares.py Middlewares代码模板（继承类） pipelines.py Pipelines代码模板（继承类） settings.py Scrapy爬虫的配置文件 spiders/ Spiders代码模板目录（继承类） 目录结构 __pycache__/ 缓存目录，无需修改 内层目录结构 用户自定义的spider代码增加在此处 123spiders/ Spiders代码模板目录（继承类） __init__.py 初始文件，无需修改 __pycache__/ 缓存目录，无需修改 步骤2：在工程中产生一个Scrapy爬虫进入工程目录（ D:\\pycodes\\python123demo），然后执行如下命令： 123You can start your first spider with: cd python123demo scrapy genspider example example.com 1E:\\Codes\\Python\\reptile\\python123demo&gt;scrapy genspider demo python123.io 该命令作用：(1) 生成一个名称为demo的spider(2) 在spiders目录下增加代码文件demo.py 该命令仅用于生成demo.py，该文件也可以手工生成 demo.py文件 12345678910# -*- coding: utf-8 -*- import scrapy class DemoSpider(scrapy.Spider): name = 'demo' allowed_domains = ['python123.io'] start_urls = ['http://python123.io/'] #parse()用于处理响应，解析内容形成字典，发现新的URL爬取请求 def parse(self, response): pass 步骤3：配置产生的spider爬虫配置：（ 1）初始URL地址 （ 2）获取页面后的解析方式 1234567891011121314# -*- coding: utf-8 -*- import scrapy class DemoSpider(scrapy.Spider): name = 'demo' # allowed_domains = ['python123.io'] 可选 start_urls = ['http://python123.io/ws/demo.html'] def parse(self, response): fname = response.url.split('/')[-1] with open(fname,\"wb\") as f: f.write(response.body) self.log('Saved file %s.' % fname) 步骤4：运行爬虫，获取网页在命令行下，执行如下命令： 1scrapy crawl demo 完整版代码： 123456789101112131415161718# -*- coding: utf-8 -*- import scrapy class DemoSpider(scrapy.Spider): name = 'demo' def start_requests(self): urls = [ 'http://python123.io/ws/demo.html' ] for url in urls: yield scrapy.Request(url=url,callback=self.parse) def parse(self, response): fname = response.url.split('/')[-1] with open(fname,\"wb\") as f: f.write(response.body) self.log('Saved file %s.' % fname) 数据类型Request类class scrapy.http.Request()Request对象表示一个HTTP请求由Spider生成，由Downloader执行 属性或方法 说明 .url Request对应的请求URL地址 .method 对应的请求方法， ‘GET’ ‘POST’等 .headers 字典类型风格的请求头 .body 请求内容主体，字符串类型 .meta 用户添加的扩展信息，在Scrapy内部模块间传递信息使用 .copy() 复制该请求 Response类class scrapy.http.Response()Response对象表示一个HTTP响应由Downloader生成，由Spider处理 属性或方法 说明 .url Response对应的URL地址 .status HTTP状态码，默认是200 .headers Response对应的头部信息 .body Response对应的内容信息，字符串类型 .flags 一组标记 .request 产生Response类型对应的Request对象 .copy() 复制该响应 Item类class scrapy.item.Item()Item对象表示一个从HTML页面中提取的信息内容由Spider生成，由Item Pipeline处理Item类似字典类型，可以按照字典类型操作 scrapy基本使用使用步骤步骤1：创建一个工程和Spider模板步骤2：编写Spider步骤3：编写Item Pipeline步骤4：优化配置策略 Scrapy爬虫支持多种HTML信息提取方法：• Beautiful Soup• lxml• re• XPath Selector• CSS Selector CSS Selector 1&lt;HTML&gt;.css('a::attr(href)').extract() CSS Selector由W3C组织维护并规范标签名称 标签属性 配置并发连接选项 settings.py文件 选项 说明 CONCURRENT_REQUESTS Downloader最大并发请求下载数量，默认32 CONCURRENT_ITEMS Item Pipeline最大并发ITEM处理数量，默认100 CONCURRENT_REQUESTS_PER_DOMAIN 每个目标域名最大的并发请求数量，默认8 CONCURRENT_REQUESTS_PER_IP 每个目标IP最大的并发请求数量，默认0，非0有效","categories":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/tags/python/"},{"name":"crawler","slug":"crawler","permalink":"https://codeofli.github.io/tags/crawler/"}]},{"title":"html-css","slug":"front-end/html-css/html-css","date":"2019-10-14T14:19:09.000Z","updated":"2021-10-23T02:19:02.839Z","comments":true,"path":"2019/10/front-end/html-css/html-css/","link":"","permalink":"https://codeofli.github.io/2019/10/front-end/html-css/html-css/","excerpt":"[TOC]HTMLHTML，超文本标记语言负责页面中的结构，定义出页面中的各个组成部分HTML是采用纯文本的形式的编写，采用HTML标签来标识出页面中的不同部分 HTML页面的基本结构一个网页有三个部分组成：结构html、表现css、行为js结构:html结构是页面的整体结构，哪里是标题，哪里是段落，哪里是图片结构使用HTML来编写","text":"[TOC]HTMLHTML，超文本标记语言负责页面中的结构，定义出页面中的各个组成部分HTML是采用纯文本的形式的编写，采用HTML标签来标识出页面中的不同部分 HTML页面的基本结构一个网页有三个部分组成：结构html、表现css、行为js结构:html结构是页面的整体结构，哪里是标题，哪里是段落，哪里是图片结构使用HTML来编写 123456789&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 表现css表现是页面的外在的样式，比如字体，字体大小，字体颜色，背景…使用CSS来设置页面中元素的样式 行为js页面和用户之间的交互行为使用JavaScript来设置页面的行为一个设计优良的网页要求结构、表现、行为三者分离在开发中总是要面临一个问题，就是程序之间的耦合，三者分离就是为了解耦合 标签(元素)成对出现 1&lt;标签名&gt;&lt;/标签名&gt; 自结束标签 1&lt;标签名 /&gt; 块元素和内联元素块元素块元素会独占页面中的一行，无论他的内容的多少一般使用块元素对页面进行布局常见的块元素divph1~h6 内联元素内联元素只占用自身的大小，不会独占一行内联元素也叫行内元素（inline）一般内联元素都是用来为文本来设置效果常见的内联 span a img包裹规则一般都是使用块元素去包裹内联元素，而不会使用内联去包裹块元素a元素可以包含任意元素，除了a本身p元素不能包含任何块元素 元素之间的关系父元素 直接包含子元素的的元素叫做父元素子元素 直接被父元素包含的元素叫做子元素祖先元素 直接或间接包含后代元素的元素叫做祖先元素，父元素也是祖先元素后代元素 直接或间接被祖先元素包含的元素叫后代元素，子元素也是后代元素兄弟元素 拥有相同父元素的元素叫做兄弟元素 属性通过属性可以设置标签的效果属性需要定义在开始标签中或这自结束标签中属性实际上是一组一组名值对结构例子： 12&lt;标签名 属性名=\"属性值\" 属性名=\"属性值\"&gt;&lt;/标签名&gt; &lt;标签名 属性名=\"属性值\" 属性名=\"属性值\" /&gt; 常用标签&lt;!doctype html&gt;文档声明用来标识当前页面的html的版本该声明用来告诉浏览器，当前的页面是使用HTML5的标准编写的&lt;html&gt;网页的根标签一个页面中有且只有一个根标签网页中的所有内容都需要写在html标签的内部 &lt;head&gt;网页的头部该标签中的内容不会在网页中直接显示该标签用于帮助浏览器解析页面子标签&lt;title&gt;用来设置网页的标题默认会在浏览器的标题栏中显示搜索引擎检索网页时，会主要检索title中的内容，它会影响到页面在搜索引擎中的排名&lt;meta&gt;用来设置网页的元数据，比如网页使用的字符集&lt;meta charset=&quot;utf-8&quot; /&gt;设置网页的关键字&lt;meta name=&quot;keywords&quot; content=&quot;关键字,关键字,关键字,关键字&quot;/&gt;设置网页的描述&lt;meta name=&quot;description&quot; content=&quot;网页的描述&quot;/&gt;请求的重定向&lt;meta http-equiv=&quot;refresh&quot; content=&quot;秒数;url=地址&quot; /&gt; &lt;body&gt;网页的主体网页中所有的可见部分都需要在body中编写&lt;h1&gt; ~ &lt;h6&gt;标题标签在html中一共有六级标题六级标题中，h1最重要，h6最不重要，一般页面中只会使用h1~h3h1的重要性仅次于title，浏览器也会主要检索h1中的内容，以判断页面的主要内容一般一个页面中只能写一个h1&lt;p&gt;段落标签&lt;br /&gt;换行标签&lt;hr /&gt;水平线标签内联框架可以向一个页面中引入其他的外部页面&lt;iframe&gt;``&lt;/iframe&gt;属性src外部页面的地址，可以使用相对路径width和height可以设置框架的宽度和高度name可以为内联框架指定一个名字可以将该属性值设置为超链接的target属性的值这样当点击超链接时，页面将会在相应的内联框架中打开内联框架中的内容不会被搜索引擎所检索，所以开发中尽量不要使用内联框架 &lt;a&gt;超链接可以使当前页面跳转到其他的页面&lt;a&gt;链接的文字&lt;/a&gt;属性href 指向链接跳转的目标地址，可以是一个相对路径 还可以是#id属性值，这样当点击超链接以后，将会跳转到当前页面的指定位置 可以使用mailto:来创建一个发送电子邮件的超链接target 指定在哪个窗口中打开链接 可选值 _self 默认值，默认在当前窗口打开链接 _blank 在新窗口中打开链接 内联框架的name属性值 在指定的内联框架中打开链接 语法注释&lt;!-- 注释内容 --&gt; 注释中的内容不会在页面中显示，但是会在源码中显示，我们可以通过注释来说明网页的代码也可以通过注释隐藏一些页面中不想显示的内容 实体在HTML页面中一些特殊符号是不能直接使用，需要使用实体来代替这些特殊符号实体也可以称为转义字符实体的语法 &amp;实体名;常用的实体 空格&amp;nbsp; Non-Breaking Space” 的缩写， &lt;&amp;lt; 、&gt;&amp;gt;、版权符号&copy;&amp;copy; 图片标签 使用图片标签可以向页面中引入一个外部图片 属性 src 指向一个外部图片的路径，可以使用相对路径 alt 指定一个在图片无法加载时对图片的描述 搜索引擎主要通过该属性来识别图片的内容 如果不写该属性则搜索引擎会对图片进行收录 width 设置图片的宽度 height 设置图片的高度 图片的格式 JPEG 颜色丰富的图片，如，照片 GIF 颜色单一，简单透明的图片，动态图 PNG 颜色丰富，复杂透明的图片 图片选择的原则 效果一致，用小的 效果不一致，用效果好的相对路径 相对于当前资源所在的目录的路径 可以使用../返回一级目录，返回几级使用几个../xHtml语法规范 1.HTML中不区分大小写，但是尽量使用小写 2.HTML的注释不能嵌套 3.标签必须结构完整 要么成对出现 要么自结束标签 4.标签可以嵌套但是不能交叉嵌套 5.属性必须有值，且值必须加引号，单引号双引号都可以 文本标签 `&lt;em&gt;` 表示语气上的强调 `&lt;strong&gt;` 表示内容的重要性 `&lt;i&gt;` 表示单纯的斜体 `&lt;b&gt;` 表示单纯的加粗 `&lt;small&gt;` 表示细则一类的内容 `&lt;cite&gt;` 表示参考的内容，凡是加书名号的都可以使用cite `&lt;q&gt;` 短引用，行内引用 &lt; blockquote&gt; 长引用，块级引用 &lt;sup&gt;上标&lt;sub&gt;下标&lt;del&gt;删除的内容&lt;ins&gt;插入的内容 &lt; pre&gt;预格式标签，可以保留代码中空格换行这些格式&lt; code&gt;表示程序代码 css基础Cascading（级联） Style Sheets(薄片，纸张，覆盖)，层叠样式表 css样式三种方式内联样式可以将css样式编写到元素的style属性中将样式直接编写在style属性中，这样的样式成为内联样式只对当前元素（标签）有效，不方便复用内联样式属于结构与表现耦合，不方便后期维护 12&lt;p style=\"color: red; font-size: 40px\"&gt;锄禾日当午，汗滴禾下土&lt;/p&gt; &lt;p&gt;谁知盘中餐，粒粒皆辛苦&lt;/p&gt; head编写style便签也可以将CSS样式编写到head中的style标签里将样式表编写的style标签中，然后通过CSS选择器选中指定元素然后可以同时为这些元素一起设置样式，这样可以使样式进一步的复用将样式表编写到style标签中，也可以使表现和结构进一步分离它也是我们推荐的使用方式 12345&lt;style type=\"text/css\"&gt; p&#123; color: red; font-size: 40px; &#125; &lt;/style&gt; 外部的CSS文件还可以将样式表编写到外部的CSS文件中,然后通过link标签来将外部的CSS文件引入到当前页面中，这样外部文件中的css样式表将会应用到当前页面中。 将CSS样式统一编写到外部的样式表中，完全使结构和表现分离，可以是样式表可以在不同的页面中使用，最大限度的使样式可以进行复用，将样式统一写在样式表中，然后通过link标签引入，可以利用浏览器的缓存加快用户访问的速度提高了用户体验，所以在开发中我们最推荐使用的方式就是外部的CSS文件 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" /&gt; css语法简介:选择器：通过选择器可以选中页面中指定的元素，并且将声明块中的样式应用到选择器对应的元素上 声明块：声明块紧跟在选择器的后边，使用一对{}括起来，声明块中实际上就是一组一组的名值对结构，这一组一组的名值对我们称为声明，在一个声明块中可以写多个声明，多个声明之间使用;隔开，声明的样式名和样式值之间使用:来连接 1234p&#123; color:red; font-size:50px; &#125; 注释123/* CSS的注释，作用和HTML注释类似，只不过它必须编写在style标签中，或者是css文件中 */ 单位长度单位px 像素，像素就是构成一个图片的最小的单位，我们的屏幕就是由一个一个像素点构成 一个像素指的就是一个像素点 在不同的显示器中，一个像素的大小是不同的，越清晰的屏幕像素越小% 可以将一个元素的样式值设置为一个百分比的值，这样浏览器将会根据父元素的值去计算出相应的值 当父元素的值改变时，子元素的值会按照一定比例一起改变，经常用于自适应的页面em em会相对于当前元素的字体大小来计算 1em = 1font-size em经常用于设置文字相关的一些样式，因为当文字大小发生改变时，em会随之改变 rem…. 颜色单位颜色单词 直接使用英文单词来表示颜色 red green blue orangeRGB值 所谓RGB值就是通过红 绿 蓝三元色的不同组合来搭配出各种不同的颜色语法：rgb(红色,绿色,蓝色)这三个值需要一个0-255之间的值 0表示没有 255表示最大 rgb(50,200,30)也可以使用百分数来设置RGB值，需要0%-100%之间的值 百分数最终也是转换为0-255的 0%相当于0 100%相当于255 rgb(100%,0%,0%)十六进制RGB值也是一种RGB值的表示方式，不同的是它使用的是16进制数字来表示而不是语法： #红色绿色蓝色这里的颜色需要一个00-ff之间的值例子： #ff0000如果颜色的是两位两位重复的，可以进行简写 比如 #aabbcc 可以写成 #abc 比如 #bbffaa 可以写成 #bfa 文本样式字体color 字体的颜色font-size 字体的大小 浏览器中默认的字体大小一般都是16px，而我们开发时一般会统一为12pxfont-family 设置文字的字体font-style 设置斜体font-weight 设置文字的加粗font-variant 小型大写字母font文字的简写属性可以同时设置所有的字体相关的样式语法： font: [加粗 斜体 小大字母] 大小[/行高] 字体加粗，斜体，小大字母，顺序无所谓，写不写都行，如果不写在使用默认值文本大小，和字体必须写，且大小必须是倒数第二个，字体必须是最后一个大小后可以设置行高，可写可不写，如果不写则使用默认值 文本样式 line-height 行高** 文本默认都是在行高中垂直居中的 通过line-height可以修改行高 行间距 = 行高 - 字体大小** text-transform 设置文本的大小写 可选值： none 默认值，该怎么显示就怎么显示，不做任何处理 capitalize 单词的首字母大写，通过空格来识别单词 uppercase 所有的字母都大写 lowercase 所有的字母都小写 text-decoration 设置文本修饰 123456a &#123; /*超链接会默认添加下划线，也就是超链接的text-decoration的默认值是underline 如果需要去除超链接的下划线则需要将该样式设置为none * */ text-decoration: none; &#125; text-align 设置文本对齐text-indent 设置首行缩进 它需要一个长度单位，如果是正值则首行向右移动，如果是负值则向左移动 1234567/* * text-indent用来设置首行缩进 * 当给它指定一个正值时，会自动向右侧缩进指定的像素 * 如果为它指定一个负值，则会向左移动指定的像素, * 通过这种方式可以将一些不想显示的文字隐藏起来 * 这个值一般都会使用em作为单位 */ letter-spacing 字符间距word-spacing 单词间距 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * 在CSS并没有为我们提供一个直接设置行间距的方式， * 我们只能通过设置行高来间接的设置行间距，行高越大行间距越大 * 使用line-height来设置行高 * 行高类似于我们上学单线本，单线本是一行一行，线与线之间的距离就是行高， * 网页中的文字实际上也是写在一个看不见的线中的，而文字会默认在行高中垂直居中显示 * * 行间距 = 行高 - 字体大小 */ .p1&#123; font-size: 20px; /* * 通过设置line-height可以间接的设置行高， * 可以接收的值： * 1.直接就收一个大小 * 2.可以指定一个百分数，则会相对于字体去计算行高 * 3.可以直接传一个数值，则行高会设置字体大小相应的倍数 */ /*line-height: 200%;*/ line-height: 2; &#125; .box&#123; width: 200px; height: 200px; round-color: #bfa; /* * 对于单行文本来说，可以将行高设置为和父元素的高度一致， * 这样可以是单行文本在父元素中垂直居中 */ line-height: 200px; &#125; .p2&#123; /* * 在font中也可以指定行高 * 在字体大小后可以添加/行高，来指定行高，该值是可选的，如果不指定则会使用默认值 */ font: 30px \"微软雅黑\"; line-height: 50px; &#125; 选择器通过选择器可以选中页面中的一组元素，然后为其设置样式 基础选择器元素选择器根据标签名，选中页面中的指定元素语法：标签名{ }例子： 123div&#123;&#125; p&#123;&#125; h1&#123;&#125; id选择器根据元素的id属性值选中一个唯一的元素语法：#id {}例子： 12#box1&#123;&#125; #hello&#123;&#125; 类选择器我们可以为元素设置class属性， class属性和id属性类似，只不过class属性可以重复 拥有相同class属性值的元素，我们说他们是一组元素 可以同时为一个元素设置多个class属性值，多个值之间使用空格隔开 根据元素的class属性值，选中一组元素语法：.class{}例子： 12.hello&#123;&#125; .box&#123;&#125; 通配选择器选中页面中的所有元素语法：*{}通配选择器的性能比较差，尽量避免使用 并集选择器可以同时选中符合多个选择器的元素语法：选择器1,选择器2,选择器N{}例子： 1div,p,#box,.hello&#123;&#125; 交集选择器对于id选择器来说，不建议使用复合选择器,因为id已经能唯一标识 可以选中满足多个条件的元素 先元素再类 语法：选择器1选择器2选择器N{} 例子： 1p.hello&#123;&#125; 后代元素选择器选中指定元素的指定后代元素语法：祖先元素 （空格）后代元素{}例子： 12div span &#123;&#125; div p&#123;&#125; 子元素选择器选中指定元素的指定子元素语法：父元素 &gt; 子元素 {}例子： 12div &gt; span &#123;&#125; div &gt; p&#123;&#125; 声明块声明块中实际上就是一个一个CSS声明声明每一个CSS声明都是一个样式，实际上就是一个名值对的结构名和值之间使用:链接:左边是样式的名字:右边是样式的值每一个声明以;结尾例子 12color:red; font-size:20px; 伪类和伪元素伪类和伪元素用来表示元素所处的一个特殊的状态，或者是一个特殊的位置 伪类：:link 表示一个普通的链接（未访问过的链接）:visited 表示访问过的链接 浏览器是通过历史记录来判断一个链接是否访问过,由于涉及到用户的隐私问题，所以使用visited伪类只能设置字体的颜色 :hover（盘旋，徘徊） 鼠标移入的链接，也可以为其他元素设置hover :active 正在被点击的链接，也可以为其他元素设置active :focus 表示元素获取焦点的状态，一般用于文本框 ::selection（注意有两个冒号） 表示内容被选中的状态 在火狐中使用::-moz-selection来代替 伪元素：:first-letter 表示第一个字符 :first-line 表示文字的第一行 :before 选中元素的最前边 一般该伪类都会结合content一起使用，通过content可以向指定位置添加内容 :after 选中元素的最后边 一般该伪类都会结合content一起使用，通过content可以向指定位置添加内容 属性选择器根据元素的属性选择指定元素 [属性名] 选取含有指定属性的元素 [属性名=&quot;属性值&quot;] 选取属性值等于指定值的元素 [属性名^=&quot;属性值&quot;] 选取属性值以指定内容**开头的元素** [属性名$=&quot;属性值&quot;] 选取属性值以指定内容结尾的元素 [属性名*=&quot;属性值&quot;] 选取属性值中**包含指定内容的元素** 子元素的伪类:first-child 寻找父元素的第一个子元素，**在所有的子元素中排序**（前面不指定特定元素就表示全部元素,指定就是交集选择器） :last-child 寻找父元素的最后一个子元素，在所有的子元素中排序 :nth-child 寻找父元素中的指定位置子元素，在所有的子元素中排序 例子 p:nth-child(3) 可以使用even，来找到偶数的子元素 可以使用odd，来找到奇数的子元素 :first-of-type 寻找指定类型中的第一个子元素 :last-of-type 寻找指定类型中的最后一个子元素 :nth-of-type 寻找指定类型中的指定子元素 :empty Selects elements that don’t have any other elements inside of them. div:empty selects all empty elements. :nth-of-type(A) Selects a specific element based on its type and order in another element - or even or odd instances of that element. div:nth-of-type(2) selects the second instance of a div. .example:nth-of-type(odd) selects all odd instances of a the example class. :only-child You can select any element that is the only element inside of another one. :nth-last-child(A) Selects the children from the bottom of the parent. This is like nth-child, but counting from the back! Nth-of-type Selector with Formula :nth-of-type(An+B) The nth-of-type formula selects every nth element, starting the count at a specific instance of that element. span:nth-of-type(6n+2) selects every 6th instance of a span, starting from (and including) the second instance. :only-of-type Selects the only element of its type within another element. p span:only-of-type selects a span within any p if it is the only span in there. 兄弟元素选择器**选取后一个兄弟元素** 前一个 + 后一个 选取后边所有的兄弟元素 前一个 ~ 后边所有 否定伪类从一组元素中将符合要求的元素剔除出去 语法： :not(选择器) 例子： .abc:not(div) 样式的继承为祖先元素设置样式，会同时应用到它的后代元素上，这一特性称为样式的继承。 通过样式的继承可以将一些样式统一设置个祖先元素，这样所有的后代都会应用到相同的样式。 但是并不是所有的样式都会继承，比如：背景相关的，边框相关的，定位相关的。具体参考文档 选择器的优先级当使用选择器为元素设置样式时，如果样式发生了冲突，采用哪个样式由选择器的优先级（权重）来决定。 越精准，越优先 优先级 内联样式1000 id选择器100 类和伪类选择器10 元素选择器1 通配选择器0 继承的样式：没有优先级 当样式发生冲突时，需要将相关的选择器优先级进行求和计算，优先级高的优先显示，如果优先级一样，则显示靠后的样式（覆盖） 优先级计算时，总大小不能超过他的最大的数量级 可以在样式后边添加一个!important，如果样式中添加了该内容，则该样式将会获取最大的优先级，将会优先于所有的样式显示，包括内联样式，但是这个属性要慎用。 盒子模型CSS 框模型Box Model CSS中将每一个元素都设置为了一个矩形的盒子将所有的元素都设置为盒子，是为了方便页面的布局当这些元素都是盒子以后，我们的布局就变成了在页面中摆放盒子 盒子模型构成每个盒子都由如下几部分构成 4 内容区： content内容区相当于盒子存放东西的空间内容区在盒子的最里边元素的所有的子元素都是放在父元素的内容区内容区设置 1234width 内容区的宽度 height 内容区的高度 边框 border边框盒子可见框最外侧，边框是盒子的边缘设置边框设置边框需要同时设置三个样式，缺一不可border-width 边框的宽度 可以同时指定四个边框的宽度，也可以分别指定 规则 123456789101112四个值 border-width : 10px 20px 30px 40px; border-width : 上 右 下 左;(顺时针) 三个值 border-width : 10px 20px 30px; border-width : 上 左右 下; 两个值 border-width : 10px 20px; border-width : 上下 左右; 一个值 border-width : 10px; border-width : 上下左右; border-color 边框的颜色border-style 边框的样式除了这三个样式，CSS中还提供了 border-xxx-width border-xxx-color border-xxx-style xxx可以是 top right bottom left 通过这些样式可以单独指定四个边的颜色，宽度和样式边框的简写属性 12345border border-left border-top border-right border-bottom 12border: red solid 10px ; border-left: red solid 10px ; 这个几个属性可以同时设置边框相关的的样式border可以同时设置四个边的颜色，宽度，样式border-xxx可以单独设置某一个边规则 使用这些样式可以同时设置border-width border-style border-color，不同的属性使用空格隔开，并且没有顺序要求 内边距： padding内边距指的是内容区和边框之间的距离，内边距会影响盒子的大小盒子中一共有四个方向的内边距 1234padding-top padding-right padding-bottom padding-left padding 可以同时设置四个方向的内边距，规则和border-width一致 1234padding:上 右 下 左 padding:上 左右 下 padding:上下 左右 padding:上下左右 盒子的可见框大小由内容区、内边距和边框共同决定 外边距 margin外边距盒子和其他盒子之间的距离，外边距不会影响可见框的大小，但是会影响盒子的位置也是具有四个方向的外边距 1234margin-top margin-right margin-bottom margin-left 简写属性margin规则和padding一致margin值可以设置为auto 如果单独将左右外边距设置为auto，则会将左或右外边距设置为最大值 如果同时将左右外边距设置为auto，则会将左右外边距设置为一个相等的值，通过这种方式使一个子元素在它的父元素中水平居中 margin:0 auto可以设置为负值 如果将margin设置为负值，则元素会向相反的方向移动 外边距的重叠 相邻的垂直外边距会发生重叠现象 相邻元素的外边距会取最大值 子元素的外边距会传递给父元素 水平外边距不会重叠，而是取和 内联元素的盒子模型内联元素不能设置width和heightpadding 支持水平方向的padding 垂直方向的padding也支持，但是不会影响布局border 支持四个方向边框，但是垂直的边框不会影响布局margin 支持水平方向外边距，水平方向的相邻外边距不会重叠，而是求和 不支持垂直方向的盒模型相关的样式 CSS 定位属性（Positioning）display设置元素的显示类型可选值none 元素不会在页面中显示，并且不会占据页面的位置block 元素会作为块元素显示inline 元素会作为内联元素显示inline-block 元素会作为行内块元素显示 既具有内联元素的特点也具有块元素的特点 既不独占一行，又可以设置宽高 visibility设置元素是否在页面中显示可选值visible 默认值，元素在页面中正常显示hidden 元素不在页面中显示，但是依然在页面中占据位置 overflow设置元素如何处理溢出内容可选值visible 默认值，不会处理溢出的内容，在父元素以外的地方显示hidden 溢出的内容会被隐藏不会显示scroll 在父元素中同时添加水平和垂直方向的滚动条 不内容是否溢出都会添加滚动条auto 根据需要自动生成滚动条 布局文档流文档流指的是网页中的一个位置文档流是网页的基础，是网页的最底层，所有的元素默认都是在文档流中排列元素在文档流中默认自左向右，自上向下排列（和我们的书写习惯一致）块元素 1.块元素在文档流中自上向下排列 2.块元素在文档流中宽度默认是父元素的100%(auto) 3.块元素在文档流中高度默认被内容撑开内联元素 1.内联元素在文档流中自左向右排列，如果一行中不足以容下所有的内联元素，则换到下一行，继续自左至右排列 2.内联元素在文档流中宽度和高度默认都被内容撑开 浮动使用float来设置元素浮动可选值none 默认值，不浮动，元素在文档流中left 元素向左浮动right 元素向右浮动特点1.元素浮动以后会完全脱离文档流2.浮动以后元素会一直向父元素的最上方移动3.直到遇到父元素的边框或者其他的浮动元素，会停止移动4.如果浮动元素的上边是一个块元素，则浮动元素不会覆盖块元素5.浮动元素不会超过他上边的浮动的兄弟元素，最多一边齐6.浮动元素不会覆盖文字，文字会自动环绕在浮动元素的周围，可以通过浮动来实现文字环绕的效果浮动以后元素的特点元素浮动以后，会使其完全脱离文档流。块元素 块元素脱离文档流以后 1.不会独占一行 2.宽度和高度都被内容撑开内联元素 内联元素脱离文档流以后会变成块元素 高度塌陷父元素在文档流中高度默认是被子元素撑开的，当子元素脱离文档流以后，将无法撑起父元素的高度，也就会导致父元素的高度塌陷父元素的高度一旦塌陷所有元素的位置将会上移，导致整个页面的布局混乱 我们可以将父元素的高度写死，以避免塌陷的问题出现，但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。 方法一 开启父元素的BFC或hasLayoutBFC:Block Formatting Context,块级格式化环境 BFC是元素的隐含属性，默认是在关闭状态的可以通过一些特殊的样式，来开启BFC开启BFC以后元素将会具有如下特性1、父元素的垂直外边距不会与子元素重叠2、开启BFC的元素不会被浮动元素所覆盖3、开启BFC的元素可以包含浮动子元素 开启BFC的方式1.设置元素浮动 使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失 且使用这种方式也会导致下边的元素上移，不能解决问题2.设置元素绝对定位3.设置元素为inline-block 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式4.将元素的overflow设置为一个非visible的值 推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。 一般都是使用overflow:hidden来开启BFChasLayout 在IE6中没有BFC，但是有一个和BFC类似的hasLayout 在IE6中可以通过开启hasLayout来解决高度塌陷的问题 副作用最小的开启方式 zoom:1 当为元素设置宽度非默认值时，会自动开启hasLayout 方法二：清除浮动clear可以用来清除其他浮动元素对当前元素的影响可选值：none，默认值，不清除浮动left，清除左侧浮动元素对当前元素的影响right，清除右侧浮动元素对当前元素的影响both，清除两侧浮动元素对当前元素的影响 清除对他影响最大的那个元素的浮动清除浮动以后，元素会回到其他元素浮动之前的位置 塌陷的父元素的最后添加一个空白的div，然后对该div进行**清除浮动** 然基本没有副作用，使用这种方式会在页面中添加多余的结构 方法三用after伪类，向父元素后添加一个块元素，并对其清除浮动 种方式的原理和方法二原理一样，但是不用向页面中添加对于的结构,这是我们最推荐使用的方式，几乎没有副作用 12345678.clearfix:after&#123; /*添加一个内容*/ content: \"\"; /*转换为一个块元素*/ display: block; /*清除两侧的浮动*/ clear: both; &#125; 定位通过定位可以将页面中的元素，摆放到页面的任意位置使用position来设置元素的定位 123456789可选值 static 默认值，元素没有开启定位 relative 开启元素的相对定位 absolute 开启元素的绝对定位 fixed 开启元素的固定定位 偏移量当元素开启了定位以后，可以通过偏移量来设置元素的位置。 靠近中心是正数，远离是负数。 12345678left 元素距离定位位置的左侧距离 top 元素距离定位位置的上边距离 right 元素距离定位位置的右侧距离 bottom 元素距离定位位置的底部距离 一般情况下，只使用两个值即可定义一个元素的位置。 相对定位：ralative1.开启元素的相对定位后，如果不设置偏移量元素不会发生任何变化2.相对定位元素相对于其自身在文档流中的位置来定位3.相对定位的元素不会脱离文档流4.相对定位不会改变元素的性质，块元素还是块元素，内联元素还是内联元素5.相对定位的元素会提升一个层级，会覆盖其他元素 绝对定位： absolute1.元素设置绝对定位以后，如果不设置偏移量，元素的位置不会发生变化2.绝对定位的元素是相对于距离他最近的开启了定位的祖先元素进行定位（一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位，子绝父相），如果所有的祖先元素都没开启定位，则相对于浏览器窗口进行定位。3.绝对定位的元素会完全脱离文档流4.绝对定位会改变元素的性质。内联变块，块的高度和宽度都被内容撑开，并且不独占一行5.绝对定位会使元素提升一个层级，会覆盖其他元素 固定定位:fixed固定定位是一种特殊的绝对定位，它的特点大部分都和绝对定位一样.不同的是，固定定位的元素永远都是相对于浏览器窗口进行定位的。并且他不会随滚动条滚动IE6不支持固定定位 层级定位元素 &gt; 浮动元素 &gt; 文档流中的元素 如果定位元素的层级是一样，则下边的元素会盖住上边的 当元素开启了定位以后，可以通过z-index来设置元素的层级1.z-index值越高元素越优先显示2.如果z-index值一样，或者都没有z-index则优先显示下边的元素3.父元素永远不会盖住子元素 弹性(Flex)布局详见Flex笔记 其他 css属性cursor 属性https://www.w3school.com.cn/cssref/pr_class_cursor.asp 定义和用法cursor 属性规定要显示的光标的类型（形状）。 该属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状 transform 属性https://www.w3school.com.cn/cssref/pr_transform.asp transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。 设置元素的透明背景opacity可以用来设置元素背景的透明，它需要一个0-1之间的值 0 表示完全透明 1 表示完全不透明 0.5 表示半透明 opacity属性在IE8及以下的浏览器中不支持IE8及以下的浏览器需要使用如下属性代替alpha(opacity=透明度) filter: alpha(opacity=50);透明度，需要一个0-100之间的值 0 表示完全透明 100 表示完全不透明 50 半透明 background属性使用backgroundimage来设置背景图片 语法：backgroundimage:url(相对路径); 如果背景图片大于元素，默认会显示图片的左上角 如果背景图片和元素一样大，则会将背景图片全部显示 如果背景图片小于元素大小，则会默认将背景图片平铺以充满元素 可以同时为一个元素指定背景颜色和背景图片，这样背景颜色将会作为背景图片的底色一般情况下设置背景图片时都会同时指定一个背景颜色 1backgroundimage:url(img2.jpg); backgroundrepeat用于设置背景图片的重复方式可选值： repeat，默认值，背景图片会双方向重复（平铺） norepeat ，背景图片不会重复，有多大就显示多大 repeatx， 背景图片沿水平方向重复 repeaty，背景图片沿垂直方向重复 background-position背景图片默认是贴着元素的左上角显示通过background-position可以调整背景图片在元素中的位置可选值：该属性可以使用 top right left bottom center中的两个值 来指定一个背景图片的位置 top left 左上 bottom right 右下 如果只给出一个值，则第二个值默认是center 也可以直接指定两个偏移量， 第一个值是水平偏移量 如果指定的是一个正值，则图片会向右移动指定的像素 如果指定的是一个负值，则图片会向左移动指定的像素 第二个是垂直偏移量 如果指定的是一个正值，则图片会向下移动指定的像素 如果指定的是一个负值，则图片会向上移动指定的像素 background-attachment用来设置背景图片是否随页面一起滚动可选值： scroll，默认值，背景图片随着窗口滚动 fixed，背景图片会固定在某一位置，不随页面滚动 不随窗口滚动的图片，我们一般都是设置给body，而不设置给其他元素 当背景图片的backgroundattachment设置为fixed时，背景图片的定位永远相对于浏览器的窗口 backgroundattachment: fixed; 常用标签span没有任何的语义，span标签专门用来选中文字，然后为文字来设置样式 a元素可以包含任意元素，除了他本身 p元素不可以包含任何块元素 div这个标签没有任何语义，就是一个纯粹的块元素，并且不会为它里边的元素设置任何的默认样式， div元素主要用来对页面进行布局的 form表单表单的作用就是用来将用户信息提交给服务器的 比如：百度的搜索框 注册 登录这些操作都需要填写表单 使用form标签创建一个表单 action属性 *form标签中必须指定一个，该属性指向的是一个服务器的地址** 我们提交表单时将会提交到action属性对应的地址 input框 使用input来创建一个文本框，它的type属性是text 如果希望表单项中的数据会提交到服务器中，还必须给表单项指定一个name属性 name表示提交内容的名字 用户填写的信息会附在url地址的后边以查询字符串的形式发送给服务器 url地址?查询字符串格式： 属性名=属性值&amp;属性名=属性值&amp;属性名=属性值&amp;属性名=属性值在文本框中也可以指定value属性值，该值将会作为文本框的默认值显示 单选按钮 使用input来创建一个单选按钮，它的type属性使用radio 单选按钮通过name属性进行分组，name属性相同是一组按钮 像这种需要用户选择但是不需要用户直接填写内容的表单项， 还必须指定一个value属性，这样被选中的表单项的value属性值将会最终提交给服务器 如果希望在单选按钮或者是多选框中指定默认选中的选项， 则可以在希望选中的项中添加checked=”checked”属性 多选框 使用input创建一个多选框，它的type属性使用checkbox 下拉列表 使用select来创建一个下拉列表下拉列表的name属性需要指定给select，而value属性需要指定给option可以通过在option中添加selected=”selected”来将选项设置为默认选中 当为select添加一个multiple=”multiple”，则下拉列表变为一个多选的下拉列表 12345678910111213141516171819202122 你喜欢的明星 &lt;select name=\"star\"&gt; &lt;!-- 在select中可以使用optgroup对选项进行分组 同一个optgroup中的选项是一组 可以通过label属性来指定分组的名字 --&gt; &lt;optgroup label=\"女明星\"&gt; &lt;!-- 在下拉列表中使用option标签来创建一个一个列表项 --&gt; &lt;option value=\"fbb\"&gt;范冰冰&lt;/option&gt; &lt;option value=\"lxr\"&gt;林心如&lt;/option&gt; &lt;option value=\"zw\"&gt;赵薇&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=\"男明星\"&gt; &lt;option value=\"ldh\"&gt;刘德华&lt;/option&gt; &lt;option value=\"pcj\"&gt;潘长江&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt; &lt;br /&gt;&lt;br /&gt; textarea使用textarea创建一个文本域按钮 提交按钮可以将表单中的信息提交给服务器使用input创建一个提交按钮,它的type属性值是submit在提交按钮中可以通过value属性来指定按钮上的文字 可以创建一个重置按钮， 点击重置按钮以后表单中内容将会恢复为默认值 使用input type=button可以用来创建一个单纯的按钮， 这个按钮没有任何功能，只能被点击 除了使用input，也可以使用button标签来创建按钮这种方式和使用input类似，只不过由于它是成对出现的标签 使用起来更加的灵活 123&lt;button type=\"submit\"&gt;提交&lt;/button&gt; &lt;button type=\"reset\"&gt;重置&lt;/button&gt; &lt;button type=\"button\"&gt;按钮&lt;/button&gt; 标签label 在html中还为我们提供了一个标签，专门用来选中表单中的提示文字的label标签该标签可以指定一个for属性，该属性的值需要指定一个表单项的id值 在点击标签时，相当于对for的表单向选中 12&lt;label for=\"um\"&gt;用户名&lt;/label&gt; &lt;input id=\"um\" type=\"text\" name=\"username\" /&gt; &lt;br/&gt; fieldset 在表单中可以使用fieldset来为表单项进行分组，可以将表单项中的同一组放到一个fieldset中 12345678&lt;fieldset&gt; &lt;!-- 在fieldset可以使用legend子标签，来指定组名 --&gt; &lt;legend&gt;用户信息&lt;/legend&gt; &lt;label for=\"um\"&gt;用户名&lt;/label&gt; &lt;input id=\"um\" type=\"text\" name=\"username\" /&gt; &lt;br /&gt; &lt;label for=\"pwd\"&gt;密码 &lt;/label&gt; &lt;input id=\"pwd\" type=\"pwd\" name=\"password\"/&gt;&lt;br /&gt; &lt;/fieldset&gt; table表格CSS border-collapse 属性 123table&#123; border-collapse:collapse; &#125; separate 默认值。边框会被分开。不会忽略 border-spacing 和 empty-cells 属性。 collapse 如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性。 inherit 规定应该从父元素继承 border-collapse 属性的值。 标签的 colspan. rowspan 属性 值 描述 number 设置单元格可横跨的列(行）数。 caption 元素定义表格标题。caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。 列表列表就相当于去超市购物时的那个购物清单， 在HTML也可以创建列表，在网页中一共有三种列表： 1.无序列表 2.有序列表 3.定义列表 无序列表使用ul(unordered list)来创建一个无序列表，在列表中使用li来表示一个列表项无序列表使用符号作为项目符号序列表使用ol(ordered list)来创建一个无序列表，在列表中使用li来表示一个列表项使用有序的序号作为项目符号义列表表相关的元素都是块元素，他们之间可以互相嵌套除项目符号list-style:none frameset框架集框架集和内联框架的作用类似，都是用于在一个页面中引入其他的外部的页面， 框架集可以同时引入多个页面，而内联框架只能引入一个， 在h5标准中，推荐使用框架集，而不使用内联框架 使用frameset来创建一个框架集，注意frameset不能和body出现在同一个页面中 所以要使用框架集，页面中就不可以使用body标签 属性： rows，指定框架集中的所有的框架，一行一行的排列 cols， 指定框架集中的所有的页面，一列一列的排列 这两个属性frameset必须选择一个，并且需要在属性中指定每一部分所占的大小 frameset中也可以再嵌套frameset frameset和iframe一样，它里边的内容都不会被搜索引擎所检索， 所以如果搜索引擎检索到的页面是一个框架页的话，它是不能去判断里边的内容的使用框架集则意味着页面中不能有自己的内容，只能引入其他的页面，而我们每单独加载一个页面 浏览器都需要重新发送一次请求，引入几个页面就需要发送几次请求，用户的体验比较差如果非得用建议使用frameset而不使用iframe 1234567891011121314151617181920&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;frameset cols=\"30% , * , 30%\"&gt; &lt;!-- 在frameset中使用frame子标签来指定要引入的页面 引入几个页面就写几个frame --&gt; &lt;frame src=\"table.html\" /&gt; &lt;frame src=\"form.html\" /&gt; &lt;!-- 嵌套一个frameset --&gt; &lt;frameset rows=\"30%,50%,*\"&gt; &lt;frame src=\"04.表格的布局.html\" /&gt; &lt;frame src=\"05.完善clearfix.html\" /&gt; &lt;frame src=\"06.表单.html\" /&gt; &lt;/frameset&gt; &lt;/frameset&gt; &lt;/html&gt; meCSS3 @media 查询如果文档宽度小于 300 像素则修改背景颜色(background-color): 12345@media screen and (max-width: 300px) &#123; body &#123; background-color:lightblue; &#125; &#125; min-height 属性设置元素的最小高度。设置以后：不能修改为小于此高度的距离 css hack 能有效识别低版本ie，具体八度 clearfix 1234567891011121314151617解决父子元素的外边距重叠 .box1:before&#123; content: \"\"; display:table可以将一个元素设置为表格显示 display: table; &#125; 解决父元素高度塌陷 .clearfix:after&#123; content: \"\"; display: block; clear: both; &#125; 经过修改后的clearfix是一个多功能的既可以解决高度塌陷，又可以确保父元素和子元素的垂直外边距不会重叠 123456.clearfix:before, .clearfix:after&#123; content: \"\"; display: table; clear: both; &#125; 长表格有一些情况下表格是非常的长的， 这时就需要将表格分为三个部分，表头，表格的主体，表格底部在HTML中为我们提供了三个标签： thead 表头 tbody 表格主体 tfoot 表格底部 这三个标签的作用，就来区分表格的不同的部分，他们都是table的子标签， 都需要直接写到table中，tr需要写在这些标签当中 thead中的内容，永远会显示在表格的头部tfoot中的内容，永远都会显示表格的底部tbody中的内容，永远都会显示表格的中间 如果表格中没有写tbody，浏览器会自动在表格中添加tbody并且将所有的tr都放到tbody中，所以注意tr并不是table的子元素，而是tbody的子元素通过table &gt; tr 无法选中行 需要通过tbody &gt; tr css精灵图CSS-Sprite 做完功能以后，发现在第一次切换图片时，会发现图片有一个非常快的闪烁，这个闪烁会造成一次不佳的用户体验。产生问题的原因：背景图片是以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独的发送一次请求，但是我们外部资源并不是同时加载，浏览器会在资源被使用才去加载资源我们这个练习，一上来浏览器只会加载link.png由于hover和active的状态没有马上触发， 所以hover.png和active.png并不是立即加载的当hover被触发时，浏览器才去加载hover.png当active被触发时，浏览器才去加载active.png由于加载图片需要一定的时间，所以在加载和显示过程会有一段时间，背景图片无法显示，导致出现闪烁的情况 为了解决该问题，可以将三个图片整合为一张图片，这样可以同时将三张图片一起加载，就不会出现闪烁的问题了，然后在通过background-position来切换要显示的图片的位置，这种技术叫做图片整合技术（CSS-Sprite,css精灵图）优点： 1 将多个图片整合为一张图片里，浏览器只需要发送一次请求，可以同时加载多个图片， 提高访问效率，提高了用户体验。 2 将多个图片整合为一张图片，减小了图片的总大小，提高请求的速度，增加了用户体验 title属性**，这个属性可以给任何标签指定当鼠标移入到元素上时，元素中的title属性的值将会作为提示文字显示 我是一个段落 ### **浏览器默认样式** 浏览器为了在页面中没有样式时，也可以有一个比较好的显示效果，所以为很多的元素都设置了一些默认的margin和padding，而它的这些默认样式，正常情况下我们是不需要使用的。所以我们往往在编写样式之前需要将浏览器中的默认的margin和padding统统的去掉清除浏览器的默认样式 1234*&#123; margin: 0; padding: 0; &#125; 这种方式支持IE6，但是这种效果在IE Tester中无法测试","categories":[{"name":"前端","slug":"前端","permalink":"https://codeofli.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://codeofli.github.io/tags/前端/"},{"name":"html","slug":"html","permalink":"https://codeofli.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"https://codeofli.github.io/tags/css/"}]},{"title":"git","slug":"git/git","date":"2019-10-13T14:19:09.000Z","updated":"2022-05-23T15:08:07.674Z","comments":true,"path":"2019/10/git/git/","link":"","permalink":"https://codeofli.github.io/2019/10/git/git/","excerpt":"[TOC]特点：分布式版本控制系统优势： SVN在开发过程中必须保证需要与SVN服务器连接才能使用，需要联网git官方文档git bookgit安装Git安装教程（2.30.1详细教程）https://www.cnblogs.com/hdlan/p/14395189.html基础操作1、设置全局信息","text":"[TOC]特点：分布式版本控制系统优势： SVN在开发过程中必须保证需要与SVN服务器连接才能使用，需要联网git官方文档git bookgit安装Git安装教程（2.30.1详细教程）https://www.cnblogs.com/hdlan/p/14395189.html基础操作1、设置全局信息 1234567设置开发者的用户名 git config --global user.name nicolas设置开发者邮箱 git config --global user.email 1162314270@qq.com取得全部的全局信息 git config --list git config -l 2、创建仓库1、创建目录当做仓库目录2、进入目录中配置将目录变为仓库目录，需要进入目录中配置3、初始化仓库方法一：创建一个包含有配置信息目录的仓库文件夹 12git initInitialized empty Git repository in E:/gitpro/.git/ 文件区域 工作区用户编写代码的文件夹所有的文件操作以工作区为主GIT仓库 暂存库只是将工作中的未保存文件保存到暂存区中，有GIT维护；保存的内容是暂时需要的 Git 目录（版本库Master） 真正发布的代码 git stage 3、仓库基本操作1、观察仓库的状态 1git status 2、将文件添加到git暂存区 1git add 文件名称 4、批量添加新文件到暂存区 1git add . 添加所有在仓库目录中创建的新文件到暂存区3、将文件提交到版本库中 1git commit -m \"注释信息Comment\" 现在才表示将新的文件提交到了GIT之中进行管理（这个代码才能被项目使用）自动增加并提交修改到版本库中 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤： 1git commit -a -m \"注释Comment\" 4、修改仓库文件 ​ 查看修改历史 12git log 文件名git log ​ 每次提交时都会自动生成一个Commit ID（在日后版本恢复中使用） 比较同一文件12git diffgit diff 文件名 比对暂存区和工作区中readme.txt文件的差异 版本穿越​ 查看日志信息 12git loggit log --pretty=oneline 简化查看可以按q结束查看整个日志记录是用栈来记录的master库存在head指针回退到上一个版本 1git reset --hard head~1 查看所有删除的日志 1git reflog ​ 到指定版本 1git reset --hard 1fc9d3f（Commit id） 撤销修改撤销工作区修改显示那些文件发生了改变 1git checkout 恢复单个文件 1git checkout 文件名 恢复多个文件 1git checkout . 修改已在暂存区将暂存区的文件撤回到工作区 1git reset HEAD &lt;file&gt;... 将暂存区的文件撤回到工作区 :多个文件 1git reset HEAD . 文件删除 1del 文件名 删除工作区中的文件恢复 1git checkout -- 文件名 ​ 因为版本库中任存在，可以直接删除​ git commit -a -m “Commet”​ 提交之后，库中相应的文件也没有了​ 只能通过版本穿越恢复 远程仓库：GITHUB … git-book:github章节 远程仓库的使用git-book:Git-基础-远程仓库的使用 problemgithub每次push都要密码 原因是使用了https方式 push这种方式产生的原因，一般是我们clone是一定是使用了http的方式例如我们在github上创建了一个项目，然后我们clone到本地时使用了http而非git (ssh) 12git remote rm origingit remote add origin git@github.com:codeOflI/MyDouban.git 查看远程仓库1git remote [-v] 选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 添加远程仓库git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库 1git remote add origin https://github.com/codeOflI/rep.git 从远程仓库中抓取与拉取这个命令会访问远程仓库，从中拉取所有你还没有的数据。 1git fetch [remote-name] 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 Git 分支 了解更多信息），可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程仓库git push [remote-name] [branch-name]。 当你想要将 master 分支推送到 origin 服务器时 1git push origin master 查看某个远程仓库使用 git remote show [remote-name] 命令 可以通过 git remote show 看到更多的信息。 远程仓库的移除与重命名如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做： 1234$ git remote rename pb paul$ git remoteoriginpaul 移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 git remote rm ： 123$ git remote rm paul$ git remoteorigin 远程推送一般开发分支和master分支都在服务器上 1git push -u origin 分支名 删除分支 1git branch -d 分支名 删除远程分支 1git push origin --delete 分支名 推送空的分支 1git push origin:dev 打标签Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 列出标签https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE 配置远程仓库ssh通信模式1.启动git bash 在此之中可以使用linux命令2、生成ssh key密钥 1ssh-keygen -t rsa -C &quot;1162314270@qq.com&quot; 1234命令输入后，首先询问用户密钥的保存位置 /c/Users/11623/.ssh/id_rsa 默认为公钥和私钥保存在：用户/.ssh/id_rsa瑞后询问是否设置保护密码 3、将公钥内容保存到GITHUB 公钥文件，保存在外部使用==(保存到github的ssh密匙中)== id_rsa.pub 私钥文件，做本机标识 id_rsa 打开github的setting页面添加ssh key 将公钥内容复制到key内容中 1ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDDaUZOQterXD2TZWb9VMO/s4jaIBIp0GIlsBlMZ+fl50NWbua4R8EtudIPIiMDGxsE7UmE/HGBMedsCjo1nS6h5OLz9ZT0n5h4FYOqurQWsyfdm+tgZK5mK/t1e93WlF+cjja+KiCMbntMYq7o/FGPWnlFlfiz9KiVos+oRWgC3RUx4hDqZoKFmfTxAiXQMJy2/pVYmHqliZ9+6mOvRJoe2C1mmTClTU5y9KLw8AWF0jTykUAeAfZjX1lwub8xkJ34QSNZFaBiouWcA7sz/Qa8kDGdFbZwR41Ugc+P4KYli72pecsbj2eVTZoHuCkW5GxxupV9jSbj/MePZPHHhhdH lmz 1234567891011121314151617181920212223C:\\Users\\11623&gt;ssh-keygen -t rsa -C \"lmz\"Generating public/private rsa key pair.Enter file in which to save the key (C:\\Users\\11623/.ssh/id_rsa):C:\\Users\\11623/.ssh/id_rsa already exists.Overwrite (y/n)? yEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in C:\\Users\\11623/.ssh/id_rsa.Your public key has been saved in C:\\Users\\11623/.ssh/id_rsa.pub.The key fingerprint is:SHA256:722mRw92N2R2fb71Yr3tBEgSQORYxzzzF6n4xRkh7Mk lmzThe key's randomart image is:+---[RSA 2048]----+| o=+o.. .o || + .=...+ || . . .B.+ +.|| .oE.=++|| S ..o=.o|| . = .o+|| .o + o*|| . .+ +o+|| o=.. ++|+----[SHA256]-----+ 4、在github上建立远程仓库信息 不选择：Initialize this repository with a README 创建仓库后界面上就给出了仓库的访问地址 SSH，有了SSH key直接连接 https://github.com/NicolasCoder/rep.git HRRPS,所有人都可以连接 https://github.com/NicolasCoder/rep.git删除github仓库 仓库的setting 客服端访问本地代码同步到远程仓库中 12345Either specify the URL from the command-line or configure a remote repository using git remote add &lt;name&gt; &lt;url&gt;and then push using the remote name git push &lt;name&gt; 2、连接成功后将本地仓库全部代码推送到服务器端 1git push -u origin master 强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容 12git push -fgit push -u origin master -f ：使用这个强制的方法 1git pull origin master --allow-unrelated-histories 后面加上 --allow-unrelated-histories ， 把两段不相干的 分支进行强行合并 提高本地修改 首先将修改提高到master分支上，然后推送代码到服务器 3、git pull的作用是从一个仓库或者本地的分支拉取并且整合代码。 1git pull [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…]] 实例：默认使用方式 1git pull 按照git branch 设置的默认跟踪的服务器和分支来拉取。 实例： 拉取远程服务器origin的master分支 1git pull origin master 删除远程分支 1git remote rm origin 克隆远程仓库已经初始化完成的仓库 已执行 Initialize this repository with a README克隆远程仓库：（直接在当前目录新建远程仓库的项目文件） 1git clone （HTTPS）https://github.com/codeOflI/ssm-crud ​ 分支操作分支管理1).基础操作1、查看当前仓库中可用的分支 1git branch 1234git branchiss53* mastertesting 注意 master 分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。 每一个分支的最后一次提交，可以运行 git branch -v 命令 1234$ git branch -viss53 93b412c fix javascript issue* master 7a98805 Merge branch 'iss53'testing 782fd34 add scott to the author list in the readmes --merged 与 --no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch –merged： 123$ git branch --mergediss53* master 因为之前已经合并了 iss53 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。 2、创建新的分支 1git branch 分支名 3、切换分支 1git checkout 分支名 要想进行开发，一定不能再master中开发，必须在子分支开发 合并分支回到master进行合并分支 1git merge dev ​ 合并后提示Fast-forward​ 快速合并方式 合并git分支时，如何避免提交日志分支？你可以用几种方式做到这一点，但最明显的是使用压扁的合并。 12345 git merger # 参数，--squash 创建单个提交，而不是进行合并 --squash create a single commit instead of doing a mergegit merge --squash &lt;other_branch&gt; git commit 注意，git会预填充合并提交的消息从压扁提交的日志消息，但你可以自由地修改或删除的邮件，以适应自己。 squash ：v. 压扁，压碎； 12git merge --squash testgit commit -m \"one commit\" 在执行了git merge --squash test后，在test branch上做的提交都变成修改到了master分支， 故需要再提交一次。 2）合并操作冲突解决 创建并切换到dev分支 1git checkout -b dev 两个分支修改了同一文件 提交到master后会提示conflict和文件名 打开文件会发现相应的冲突都写在了里面 修改后再次提交即可分支合并模式 通过图形化的方式查看所有分支合并记录 1git log --graph --pretty=oneline 1Fast forwaed(默认)合并 ​ 不会产生新的提交点添加参数 -no-ff(Not Fast Forward) 1git merge --no-ff -m \"use no-ff merge\" dev –no-ff的作用： git merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。 git merge 则不会显示 feature，只保留单条分支记录。 ​ master不予许修改，dev分支如果有多人共享，需要在创建自己的分支在进行开发，合并时使用no-ff方式bug分支,暂挂工作区​ 有错误的代码不能保存在暂存区​ 保存当前工作区的状态​ git stash​ 查看所有暂时挂起的工作区​ git stash list​ 两步​ 恢复挂起的工作区​ git stash apply​ 清除保存的工作区​ git stash drop​ 一步​ 恢复并清除保存区​ git stash popfeature,扩展分支​ 已经开发，但不准备使用的功能等​ 强制删除有不同修改的分支​ git branch -D feature补丁 比较分支区别​ git diff master &gt; patch​ 通过命令行的管道流，将diff保存再来patch文件里​ 通过补丁合并分支​ git apply patch​ 当项目很大的时候，效率更高​ 不便于开发者沟通​ git format-patch -M master​ 通知master​ 应用分支补丁​ git am （补丁路劲）”E:\\gitpro\\0001-git-apply-patch.patch” orphan分支创建一个新的分支（空）而不是从原分支拷贝 1git checkout --orphan branchName 可以将A和B两个完全不同的工程，可以作为两个分支放到git中。 这时候还是一个分支 12git branchmaster 1.创建orphan分支，名为dev（本地和远程都需要) 1$ git checkout --orphan dev 注： 如果不提交东西，这个分支实际上没有创建 2.修改一些东西，并提交 注意： 远程分支和本地分支保持名称一致，可减少不必要麻烦 123$ git add .$ git commit -m &quot;init&quot;$ git push origin dev 注： git push origin source表示把本地代码（origin）提交到source分支 git push origin master表示把本地代码（origin）提交到master分支 3.现在就有两个分支了master和source .gitignore的操作下面是一些.gitignore文件忽略的匹配规则： 123456*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 目的是忽略指定类型的文件或者某个文件夹 a、新建.gitignore文件： b、输入要忽略的文件（可用通配符） 利用git status 查看，可以看出排除了写入的文件，避免了其提交 12345678910111213141516171819202122232425262728293031323334353637HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**!**/src/test/**### xxx ###application.properties### STS ###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache### IntelliJ IDEA ###.idea*.iws*.iml*.ipr.mvn/mvnwmvnw.cmd### NetBeans ###/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/### VS Code ###.vscode/ 删除git上已经提交的文件1.先查看有哪些文件可以删除,但是不真执行删除 1git rm -r -n job-executor-common/target/* -r 递归移除目录 -n 加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览，所以一般用这个参数先看看要删除哪些文件，防止误删，确认之后，就去掉此参数，真正的删除文件。 上面这个命令就是先查看 job-executor-common/target/* 下有哪些可以删除的内容 2.执行删除 1git rm -r job-executor-common/target/* 此时,就把指定目录下所有内容从本地版本库中删除了 如果只想从版本库中删除,但是本地仍旧保留的话,加上 –cached 参数 1git rm -r --cached job-executor-common/target/* 3.删除远程版本库中的文件 再执行提交操作即可 12git commit -m\"移除target目录下所有文件\"git push origin dev其中origin dev为分支名称 git-me开发时不使用master(保存)分支 开发时添加大型文件，如果在主分支添加，将很难删除其占用的空间，通过合并分支，或者删除分支，很容易办到。 添加大型文件请慎重git commit之后git会保存此时所有文件，如果此时添加了不必要的大型文件，会不必要的增加文件大小。特别是master分支。 [https://git-scm.com/docs/git-checkout]: Git 修改已提交的commit注释两种情况： 1.已经将代码push到远程仓库 2.还没将代码push到远程仓库，还在本地的仓库中 这两种情况下的修改大体相同，只是第一种情况最后会多一步 下面来说怎么修改 先搞清楚你要修改哪次的提交注释或者哪几次的提交注释 修改最后一次注释如果你只想修改最后一次注释（就是最新的一次提交），那好办： git commit --amend 出现有注释的界面（你的注释应该显示在第一行）， 输入i进入修改模式，修改好注释后，按Esc键 退出编辑模式，输入:wq保存并退出。ok，修改完成。 例如修改时编辑界面的图： 编辑commit注释.png 修改之前的注释修改之前的某次注释 输入： git rebase -i HEAD~2 最后的数字2指的是显示到倒数第几次 比如这个输入的2就会显示倒数的两次注释（最上面两行） 显示倒数两次的commit注释.png 你想修改哪条注释 就把哪条注释前面的pick换成edit。方法就是上面说的编辑方式：i—编辑，把pick换成edit—Esc—:wq. 然后：（接下来的步骤Terminal会提示） git commit --amend 修改注释，保存并退出后，输入： git rebase --continue 提示输入的命令.png 其实这个原理我的理解就是先版本回退到你想修改的某次版本，然后修改当前的commit注释，然后再回到本地最新的版本 修改之前的某几次注释修改多次的注释其实步骤和上面的一样，不同点在于： 同上 你可以将多个想修改的commit注释前面的pick换成edit 依次修改你的注释（顺序是从旧到新），Terminal基本都会提示你接下来的操作，每修改一个注释都要重复上面的3和4步，直到修改完你所选择的所有注释 已经将代码push到远程仓库首先，你把最新的版本从远程仓库先pull下来，修改的方法都如上，最后修改完成后，强制push到远程仓库： git push --force origin master 注：很重要的一点是，你最好保证在你强制push之前没有人提交代码，如果在你push之前有人提交了新的代码到远程仓库，然后你又强制push，那么会被你的强制更新覆盖！！！ 最后，可以检查一下远程的提交记录~~ 参考链接 githubGithub 网页上 更新 Fork别人的 Repository github查看代码方式： github.com改成github1s.com /github1s.com/codeOflI/JudgeServer/blob/HEAD/src/main/java/com/yoj/judge_server/aspect/JudgePermitAspect.java git cherry-pick 教程http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html","categories":[],"tags":[]},{"title":"varay","slug":"v2ray/v2ray","date":"2019-10-13T14:19:09.000Z","updated":"2022-03-17T11:13:53.904Z","comments":true,"path":"2019/10/v2ray/v2ray/","link":"","permalink":"https://codeofli.github.io/2019/10/v2ray/v2ray/","excerpt":"[TOC]github仓库v2ray.comV2Ray一键安装脚本首先买个服务器解析域名能在国内ping到当前服务器1lmz.mookeyes.tk1ping ow.yestojudge.cnlinux 安装脚本1bash &lt;(curl -s -L https://git.io/v2ray.sh)","text":"[TOC]github仓库v2ray.comV2Ray一键安装脚本首先买个服务器解析域名能在国内ping到当前服务器1lmz.mookeyes.tk1ping ow.yestojudge.cnlinux 安装脚本1bash &lt;(curl -s -L https://git.io/v2ray.sh) 自行配置 12(默认协议: TCP):4 V2Ray 传输协议 = WebSocket + TLS 1234567891011121314151617---------- 安装信息 ------------- V2Ray 传输协议 = WebSocket + TLS V2Ray 端口 = 56911 你的域名 = lmz.yestojudge.cn 域名解析 = 我确定已经有解析了 自动配置 TLS = 打开 路径分流 = /233blog 是否配置 Shadowsocks = 未配置---------- END ------------- 123456789101112131415161718192021222324..由于你的 VPS 内核支持开启 BBR ...已经为你启用 BBR 优化....---------- V2Ray 配置信息 ------------- 地址 (Address) = lmz.yestojudge.cn 端口 (Port) = 443 用户ID (User ID / UUID) = 347b6ad3-8e14-492a-b05f-241cf9679401 额外ID (Alter Id) = 233 传输协议 (Network) = ws 伪装类型 (header type) = none 伪装域名 (host) = lmz.yestojudge.cn 路径 (path) = /233blog TLS (Enable TLS) = 打开---------- END ------------- 123456789101112131415161718192021---------- V2Ray 配置信息 ------------- 地址 (Address) = lmz.yestojudge.cn 端口 (Port) = 443 用户ID (User ID / UUID) = c0cc4cce-0993-4b40-a956-162ebee3d3e2 额外ID (Alter Id) = 233 传输协议 (Network) = ws 伪装类型 (header type) = none 伪装域名 (host) = lmz.yestojudge.cn 路径 (path) = /233blog TLS (Enable TLS) = 打开---------- END ------------- 获取连接1v2ray url 12345678910111213141516171819202122232425---------- V2Ray 配置信息 ------------- 地址 (Address) = lmz.mookeyes.tk 端口 (Port) = 443 用户ID (User ID / UUID) = d18116c8-8535-470b-80be-47aae169c2b3 额外ID (Alter Id) = 233 传输协议 (Network) = ws 伪装类型 (header type) = none 伪装域名 (host) = lmz.mookeyes.tk 路径 (path) = /233blog TLS (Enable TLS) = 打开---------- END -------------V2Ray 客户端使用教程: https://233v2.com/post/4/提示: 输入 v2ray url 可生成 vmess URL 链接 / 输入 v2ray qr 可生成二维码链接 v2ray局域网共享如果多个设备连接同一个wifi也在同一个局域网。但v2ray的局域网共享有独有的端口，故最好用设备（手机、电脑设置热点）。 1首先在相应开启热点设备的v2ray的软件上开启局域网代理选项 ipad在其连接wifi（无限局域网）中设置代理为手动并输入设备（设置热点的手机、电脑）的ip和v2ray监控的端口（通常默认为10809）， MyProblem:ListenIP6 https://www.linodovultr.com/post/resolve-v2ray-after-install-can-not-connect.html?replytocom=69 时间不同步，误差要小于90shttps://www.529i.com/archives/363.html 12date -R #查看系统时间dpkg-reconfigure tzdata #设置时区 1date -s \"2020-05-10 9:05:30\" #设置时间 123456hwclock --systohc #同步到硬件时间hwclock #chak查看硬件时间service v2ray stopservice v2ray start Ubuntu 18.04/18.10快速开启Google BBR的方法https://www.moerats.com/archives/612/ 12root@nicolas:~# cat /etc/issueUbuntu 18.04.2 LTS \\n \\l","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"javaDev","slug":"java-note/javaDev/javaDev","date":"2019-10-13T14:19:09.000Z","updated":"2021-10-23T02:19:04.193Z","comments":true,"path":"2019/10/java-note/javaDev/javaDev/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/javaDev/javaDev/","excerpt":"[TOC]CGLIB什么是CGLIBCGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。CGLIB作为一个开源项目，其代码托管在github，地址为：https://github.com/cglib/cglib","text":"[TOC]CGLIB什么是CGLIBCGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。CGLIB作为一个开源项目，其代码托管在github，地址为：https://github.com/cglib/cglib 为什么使用CGLIBCGLIB代理主要通过对字节码的操作，为对象引入间接级别，以控制对象的访问。我们知道Java中有一个动态代理也是做这个事情的，那我们为什么不直接使用Java动态代理，而要使用CGLIB呢？答案是CGLIB相比于JDK动态代理更加强大，JDK动态代理虽然简单易用，但是其有一个致命缺陷是，只能对接口进行代理。如果要代理的类为一个普通类、没有接口，那么Java动态代理就没法使用了。关于Java动态代理，可以参者这里Java动态代理分析 model模型层分类概念： VO**（View Object**）：视图对象**，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。 DTO**（Data Transfer Object**）：数据传输对象**，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。 DO**（Domain Object**）：领域对象**，就是从现实世界中抽象出来的有形或无形的业务实体。 PO**（Persistent Object**）：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成**一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"maven","slug":"java-note/maven/maven","date":"2019-10-13T07:09:35.000Z","updated":"2022-03-23T15:34:29.643Z","comments":true,"path":"2019/10/java-note/maven/maven/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/maven/maven/","excerpt":"[TOC]maven菜鸟教程-mavenMaven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。","text":"[TOC]maven菜鸟教程-mavenMaven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。 maven中的概念POMPOM是项目对象模型(Project Object Model)的简称,它是Maven项目中的文件,使用XML表示,名称叫做pom.xml。 Maven 功能Maven 能够帮助开发者完成以下工作： 构建 文档生成 报告 依赖 SCMs 发布 分发 邮件列表 约定配置Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示： 目录 目的 ${basedir} 存放pom.xml和所有的子目录 ${basedir}/src/main/java 项目的java源代码 ${basedir}/src/main/resources 项目的资源，比如说property文件，springmvc.xml ${basedir}/src/test/java 项目的测试类，比如说Junit代码 ${basedir}/src/test/resources 测试用的资源 ${basedir}/src/main/webapp/WEB-INF web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面 ${basedir}/target 打包输出目录 ${basedir}/target/classes 编译输出目录 ${basedir}/target/test-classes 测试编译输出目录 Test.java Maven只会自动运行符合该命名规则的测试类 ~/.m2/repository Maven默认的本地仓库目录位置 Maven 特点 项目设置遵循统一的规则。 任意工程中共享。 依赖管理包括自动更新。 一个庞大且不断增长的库。 可扩展，能够轻松编写 Java 或脚本语言的插件。 只需很少或不需要额外配置即可即时访问新功能。 基于模型的构建 − Maven能够将任意数量的项目构建到预定义的输出类型中，如 JAR，WAR 或基于项目元数据的分发，而不需要在大多数情况下执行任何脚本。 项目信息的一致性站点 − 使用与构建过程相同的元数据，Maven 能够生成一个网站或PDF，包括您要添加的任何文档，并添加到关于项目开发状态的标准报告中。 发布管理和发布单独的输出 − Maven 将不需要额外的配置，就可以与源代码管理系统（如 Subversion 或 Git）集成，并可以基于某个标签管理项目的发布。它也可以将其发布到分发位置供其他项目使用。Maven 能够发布单独的输出，如 JAR，包含其他依赖和文档的归档，或者作为源代码发布。 向后兼容性 − 您可以很轻松的从旧版本 Maven 的多个模块移植到 Maven 3 中。 子项目使用父项目依赖时，正常情况子项目应该继承父项目依赖，无需使用版本号， 并行构建 − 编译的速度能普遍提高20 - 50 %。 更好的错误报告 − Maven 改进了错误报告，它为您提供了 Maven wiki 页面的链接，您可以点击链接查看错误的完整描述。 Maven 环境配置Maven 是一个基于 Java 的工具，所以要做的第一件事情就是安装 JDK。 Maven POM Java 开发环境配置 maven配置文件设置xxx\\apache-maven-3.6.1\\conf\\settings.xml 设置镜像阿里mirrors 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 配置maven的jdk 1234567891011&lt;profile&gt; &lt;id&gt;jdk18&lt;/id&gt; &lt;activation&gt; &lt;activaByDefault&gt;true&lt;/activaByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; Maven 仓库在 Maven 的术语中，仓库是一个位置（place）。 Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。 在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。 Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。 Maven 仓库有三种类型： 本地（local） 中央（central） 远程（remote） 本地仓库Maven 的本地仓库，在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建。 运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。 默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/respository/ 的仓库目录。 Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。 1234567&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;D:/maven/MyLocalRepository&lt;/localRepository&gt; &lt;/settings&gt; 当你运行 Maven 命令，Maven 将下载依赖的文件到你指定的路径中。 中央仓库Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。 中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。 中央仓库的关键概念： 这个仓库由 Maven 社区管理。 不需要配置。 需要通过网络才能访问。 要浏览中央仓库的内容，maven 社区提供了一个 URL：http://search.maven.org/#browse。使用这个仓库，开发人员可以搜索所有可以获取的代码库。 远程仓库如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。 举例说明，使用下面的 pom.xml，Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件。 1234567891011121314151617181920212223242526&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.companyname.projectgroup&lt;/groupId&gt; &lt;artifactId&gt;project&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.companyname.common-lib&lt;/groupId&gt; &lt;artifactId&gt;common-lib&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;companyname.lib1&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib1&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;companyname.lib2&lt;/id&gt; &lt;url&gt;http://download.companyname.org/maven2/lib2&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; Maven 依赖搜索顺序当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库： 步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。 步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。 步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。 步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。 Maven 阿里云(Aliyun)仓库Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库。 修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件，在 mirrors 节点上，添加内容如下： 123456&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; 如果想使用其它代理仓库，可在 &lt;repositories&gt;&lt;/repositories&gt; 节点中加入对应的仓库使用地址。以使用 spring 代理仓为例： 12345678910&lt;repository&gt; &lt;id&gt;spring&lt;/id&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt;&lt;/repository&gt; 在你的 pom.xml 文件 &lt;denpendencies&gt;&lt;/denpendencies&gt; 节点中加入你要引用的文件信息： 12345&lt;dependency&gt; &lt;groupId&gt;[GROUP_ID]&lt;/groupId&gt; &lt;artifactId&gt;[ARTIFACT_ID]&lt;/artifactId&gt; &lt;version&gt;[VERSION]&lt;/version&gt;&lt;/dependency&gt; 执行拉取命令： 1mvn install 第一步:修改 maven 根目录下的 conf 文件夹中的 setting.xml 文件，在 mirrors 节点上，添加内容如下： 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 第二步: pom.xml文件里添加： 123456789101112&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; maven使用spring单元测试test写在src/test/mapper/目录下 推荐Spring的项目就可以使用spring的单元测试，可以依赖注入我们需要的组件 1.导入springTest模块(meven导包) 2.@ContextConfiguration指定spring配置文件内容,@RunWith(SpringJUnit4ClassRunner.class) 3.直接autoWrited要使用的组件即可 1234567** * 测试dao工作层 * @author test */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:applicationContext.xml\"&#125;)public class MapperTest &#123; maven的pom.xml结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!--maven的pom.xml结构--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--组织名称 一般是公司名称的倒写，像包名--&gt; &lt;groupId&gt;com.sz&lt;/groupId&gt; &lt;!--项目，模块名称--&gt; &lt;artifactId&gt;helloworld1&lt;/artifactId&gt; &lt;!--版本号--&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目名--&gt; &lt;name&gt;helloworld1&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;!--属性的定义--&gt; &lt;!--项目构建使用字符编码--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!--编译源代码的版本--&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;!--目标代码的版本--&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;!--依赖集 你所需要的jar包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--要什么jar全部到maven中央仓库去找仓库中进行搜索即可--&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;!--这是一个依赖--&gt; &lt;dependency&gt; &lt;!--通过坐标来描述--&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; maven目录结构测试类一般是放在src/test/java,而不是放在src/main/java下.maven在编译的时候,src/main/java下是不引用test的jar,而编译src/test/java下的测试这会引用test的jar maven中classpath路径在Maven工程中，classpath的路径指java resources路径下的目录，即 src/main/java、 src/main/resource、src/test/java 、src/test/resource 四个目录所以在配置路径时需要注意文件名是否重名，导致加载文件失败 Maven 的 Snapshot 版本与 Release 版本1、Snapshot 版本代表不稳定、尚处于开发中的版本。 2、Release 版本则代表稳定的版本。 安装maven注意点maven配置文件 maven本地仓库位置 OtherMaven 多模块父子工程Maven 多模块父子工程：https://www.cnblogs.com/meitanzai/p/10945085.html [https://www.runoob.com/maven/maven-tutorial.html]:","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"maven","slug":"maven","permalink":"https://codeofli.github.io/tags/maven/"}]},{"title":"mybatis","slug":"java-note/mybatis/mybatis","date":"2019-10-12T02:40:06.000Z","updated":"2021-10-23T02:19:04.200Z","comments":true,"path":"2019/10/java-note/mybatis/mybatis/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/mybatis/mybatis/","excerpt":"[TOC]入门mybatis约定：输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个如果输入参数 ：是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx} 如果是对象类型，则必须是对象的属性 #{属性名}输出参数： 如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个， 再resultType都写成org.lanqiao.entity.Student 即 resultType=”org.lanqiao.entity.Student”","text":"[TOC]入门mybatis约定：输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个如果输入参数 ：是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx} 如果是对象类型，则必须是对象的属性 #{属性名}输出参数： 如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个， 再resultType都写成org.lanqiao.entity.Student 即 resultType=”org.lanqiao.entity.Student” 注意事项：如果使用的 事务方式为 jdbc,则需要 手工commit提交，即session.commit(); conf.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 通过environment的default值和environment的id值指定Mybatis数据库的运行环境 --&gt; &lt;environments default=\"development\"&gt; &lt;!-- development environment --&gt; &lt;environment id=\"development\"&gt; &lt;!-- 事务提交方式： JDBC：使用JDBC方式提交事务（commit rollback close） MANAGED:将事务交给其他组件去托管（spring，jobss）默认自动关闭 设置不关闭： &lt;transactionManager type=\"MANAGED\" /&gt; property name=\"closeConnection\" value=\"false\" /&gt; --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据源类型 UNPOOLED:传统jdbc方式(每次访问数据，均需要打开和关闭等数据库操作，但是打开和关闭都是很浪费资源和性能的） POLLED：使用数据库连接池 JNDI：从tomcat中获取一个内置数据库连接池（数据库连接池-数据源） --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置数据库信息 --&gt; &lt;property name=\"driver\" value=\"oracle.jdbc.OracleDriver\" /&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@localhost:1521:MLDN\" /&gt; &lt;property name=\"username\" value=\"scott\" /&gt; &lt;property name=\"password\" value=\"tigger\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- test environment--&gt; &lt;environment id=\"test\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置数据库信息 --&gt; &lt;property name=\"driver\" value=\"oracle.jdbc.OracleDriver\" /&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@111:11:11:1521:MLDN\" /&gt; &lt;property name=\"username\" value=\"scott\" /&gt; &lt;property name=\"password\" value=\"tigger\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 加载映射文件 --&gt; &lt;mapper resource=\"pers/nicolas/entity/studentMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper.xml1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace：该mapper.xml映射文件的唯一标识 --&gt;&lt;mapper namespace=\"pers.nicolas.entity.studnetMapper\"&gt; &lt;!-- 后续通过namespace.Id 定位该SQL语句--&gt; &lt;!-- parameterType：输入参数的类型 resultType：查询结果的返回类型 --&gt; &lt;select id=\"queryStudentBysno\" parameterType=\"int\" resultType=\"pers.nicolas.entity.Student\"&gt; select * from student where stuno = #&#123;stuno&#125;&lt;!-- 不能有分号！！！无效字符 --&gt; &lt;/select&gt; &lt;insert id=\"addStudent\" parameterType=\"pers.nicolas.entity.Student\" &gt; insert into student(stuno,stuname,stuage,graname) values(#&#123;stuNo&#125;,#&#123;stuName&#125;,#&#123;stuAge&#125;,#&#123;graName&#125;) &lt;/insert&gt; &lt;delete id=\"deleteStudentBySno\" parameterType=\"int\"&gt; delete from student where stuno=#&#123;stuno&#125; &lt;/delete&gt; &lt;update id=\"updateStudentBySno\" parameterType=\"pers.nicolas.entity.Student\"&gt; update student set stuno=#&#123;stuNo&#125;, stuname = #&#123;stuName&#125;, stuage=#&#123;stuAge&#125;,graname=#&#123;graName&#125; &lt;/update&gt; &lt;select id=\"queryAllStudents\" resultType=\"pers.nicolas.entity.Student\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; mybatis约定：输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个 如果输入参数 ：是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx} 如果是对象类型，则必须是对象的属性 #{属性名} 输出参数： 如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个， 再resultType都写成org.lanqiao.entity.Student 即 resultType=”org.lanqiao.entity.Student” 注意事项：如果使用的 事务方式为 jdbc,则需要 手工commit提交，即session.commit(); mapper动态代理方式的crud又称（MyBatis接口开发） 原则：约定优于配置 硬编码方式 abc.java Configuration conf = new Configuration(); con.setName(“myProject”) ; 配置方式： abc.xml myProject 约定：默认值就是myProject 具体实现的步骤：1.基础环境：mybatis.jar/ojdbc.jar、conf.xml、mapper.xml2.（不同之处） 约定的目标： 省略掉statement,即根据约定 直接可以定位出SQL语句 a.接口，接口中的方法必须遵循以下约定： 1.方法名和mapper.xml文件中标签的id值相同 2 .方法的 输入参数 和mapper.xml文件中标签的 parameterType类型一致 (如果mapper.xml的标签中没有 parameterType，则说明方法没有输入参数) 3.方法的返回值 和mapper.xml文件中标签的 resultType类型一致 （无论查询结果是一个 还是多个（student、List），在mapper.xml标签中的resultType中只写 一个（Student）；如果没有resultType，则说明方法的返回值为void） 除了以上约定，要实现 接口中的方法 和 Mapper.xml中SQL标签一一对应，还需要以下1点： namespace的值 ，就是 接口的全类名（ 接口 - mapper.xml 一一对应） 匹配的过程：（约定的过程）1.根据 接口名 找到 mapper.xml文件（根据的是namespace=接口全类名）2.根据 接口的方法名 找到 mapper.xml文件中的SQL标签 （方法名=SQL标签Id值） 以上2点可以保证： 当我们调用接口中的方法时，程序能自动定位到 某一个Mapper.xml文件中的sqL标签 习惯：SQL映射文件（mapper.xml） 和 接口放在同一个包中 （注意修改conf.xml中加载mapper.xml文件的路径） 以上，可以通过接口的方法-&gt;SQL语句 执行： StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; studentMapper.方法(); 通过session对象获取接口（session.getMapper(接口.class);），再调用该接口中的方法，程序会自动执行该方法对应的SQL。 配置别名https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases 1234&lt;typeAliases&gt; &lt;typeAlias alias=\"Problem\" type=\"com.yoj.web.bean.Problem\"/&gt; &lt;package name=\"com.yoj.web.bean\"/&gt;&lt;/typeAliases&gt; 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子： 1234@Alias(\"author\")public class Author &#123; ...&#125; 类型处理器（类型转换器）1.MyBatis自带一些常见的类型处理器 int - number 2.自定义MyBatis类型处理器 1java -数据库(jdbc类型) 示例：实体类Student : boolean stuSex true:男 false：女 表student： number stuSex 1:男 0：女自定义类型转换器（boolean -number）步骤：a.创建转换器：需要实现TypeHandler接口 通过阅读源码发现，此接口有一个实现类 BaseTypeHandler ，因此 要实现转换器有2种选择： i.实现接口TypeHandler接口 ii.继承BaseTypeHandlerb.配置conf.xml 需要注意的问题： INTEGER(需要大写) 1insert into student(stuno,stuname,stuage,graname,stusex) values(#&#123;stuNo&#125;,#&#123;stuName&#125;,#&#123;stuAge&#125;,#&#123;graName&#125; ,#&#123;stuSex ,javaType=boolean ,jdbcType=INTEGER &#125; ) 注意#{stuNo} 中存放的是 属性值，需要严格区分大小写。 resultMap可以实现2个功能：1.类型转换2.属性-字段的映射关系 select * from student where stuno = #{stuno} 12345678&lt;resultMap type=\"student\" id=\"studentMapping\"&gt; &lt;!-- 分为主键id 和非主键 result--&gt; &lt;id property=\"id\" column=\"stuno\" /&gt; &lt;result property=\"stuName\" column=\"stuname\" /&gt; &lt;result property=\"stuAge\" column=\"stuage\" /&gt; &lt;result property=\"graName\" column=\"graname\" /&gt; &lt;result property=\"stuSex\" column=\"stusex\" javaType=\"boolean\" jdbcType=\"INTEGER\"/&gt; &lt;/resultMap&gt; mybatis调用存储过程123456789&lt;select id=\"queryCountByGradeWithProcedure\" statementType=\"CALLABLE\" parameterType=\"HashMap\" &gt; &#123; CALL queryCountByGradeWithProcedure( #&#123;gName,jdbcType=VARCHAR,mode=IN&#125;, #&#123;scount,jdbcType=INTEGER,mode=OUT&#125; ) &#125; &lt;/select&gt; 其中 通过statementType=”CALLABLE”设置SQL的执行方式是存储过程。 存储过程的输入参数gName需要通过HashMap来指定在使用时，通过hashmap的put方法传入输入参数的值；通过hashmap的Get方法 获取输出参数的值。要注意Jar问题：ojdbc6.jar不能在 调存储过程时 打回车、tab，但是ojdbc7.jar可以。 如果报错： No enum constant org.apache.ibatis.type.JdbcType.xx，则说明mybatis不支持xx类型，需要查表。 存储过程 无论输入参数是什么值，语法上都需要 用map来传递该值； 只要 是 ，则增删改都需要手工commit ; mapper.xml-&gt;mapper接口-&gt;测试方法 输入和输出参数输入参数parameterType1.类型为 简单类型（8个基本类型+String）#{}、${}的区别a.#{任意值}${value} ，其中的标识符只能是value b.#{}自动给String类型加上’’ （自动类型转换） ${} 原样输出，但是适合于 动态排序（动态字段） select stuno,stuname,stuage from student where stuname = #{value} select stuno,stuname,stuage from student where stuname = ‘${value}’ 动态排序：select stuno,stuname,stuage from student order by ${value} asc c.#{}可以防止SQL注入 ${}不防止 ${}、#{}相同之处：a.都可以 获取对象的值 （嵌套类型对象） i.获取对象值：模糊查询，方式一： 1select stuno,stuname,stuage from student where stuage= #&#123;stuAge&#125; or stuname like #&#123;stuName&#125; 1234Student student = new Student(); student.setStuAge(24); student.setStuName(\"%w%\"); List&lt;Student&gt; students = studentMapper.queryStudentBystuageOrstuName(student) ;//接口的方法-&gt;SQL 模糊查询，方式二： student.setStuName(“w”); select stuno,stuname,stuage from student where stuage= #{stuAge} or stuname like ‘%${stuName}%’ ii.嵌套类型对象 2.对象类型#{属性名}${属性名} 输入对象为HashMap：where stuage= #{stuAge} 用map中key的值 匹配 占位符#{stuAge}，如果匹配成功 就用map的value替换占位符 输出参数resultType输出参数resultType1.简单类型（8个基本+String）2.输出参数为实体对象类型3.输出参数为实体对象类型的集合 ：虽然输出类型为集合，但是resultType依然写 集合的元素类型（resyltType=”Student”）4.输出参数类型为HashMap –HashMap本身是一个集合，可以存放多个元素， 但是根据提示发现 返回值为HashMap时 ，查询的结果只能是1个学生（no,name）；–&gt;结论：一个HashMap 对应一个学生的多个元素（多个属性） 【一个map，一个学生】 二维数组{ {1,zs,23,xa}, -一个HashMap对象 {2,ls,24,bj}, {3,ww,25,tj}} resultTyperesultMap:实体类的属性、数据表的字段： 类型、名字不同时（stuno,id）注意：当属性名 和字段名 不一致时，除了使用resultMap以外，还可以使用resultType+HashMap: a.resultMap b.resultType+HashMapselect 表的字段名 “类的属性名” from… 来制定字段名 和属性名的对应关系 select id “stuNo”,name “stuName” from student where id = #{id} 注意: 如果如果10个字段，但发现 某一个字段结果始终为默认值（0，0.0，null），则可能是 表的字段 和 类的属性名字写错。 //查询全部String statement = “select stuno,stuname from student”; //根据年龄查询学生 String statement = “select stuno,stuname from student where stuage = #{stuage}”; //根据姓名和年龄查询学生 String statement = “select stuno,stuname from student where stuage = #{stuage} and stuage = #{stuage} “; select stuno,stuname from student where stuname = #{stuName}and stuage = #{stuAge} 查询使用了类型转换器 1.如果类中属性和表中字段类型能够合理识别（String-varchar2），则可以使用resultType，(boolean-number)否则使用resultMap； 2.如果类中属性名和表中字段名能够合理识别（stuNo-stuno），则可以使用resultType，（stuno-id）否则使用resultMap； 1234&lt;!-- 别名作为HashMap的Key --&gt; &lt;select id=\"queryStudentOutByHashMap\" resultMap=\"HashMap\"&gt; select stuno \"no\", stuname \"name\" from student &lt;/select&gt; 1234567891011&lt;!--resultMap --&gt; &lt;select id=\"queryStudentById\" parameterType=\"int\" resultMap=\"queryStudentByIdMap\"&gt; select id,name from student where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap type=\"Student\" id=\"queryStudentByIdMap\"&gt; &lt;!-- 将类中属性和表中字段对应起来 --&gt; &lt;!-- 分为主键id和非主键 result --&gt; &lt;id property=\"stuNo\" column=\"id\"/&gt; &lt;result property=\"stuName\" column=\"name\"/&gt; &lt;/resultMap&gt; 12345&lt;!--resultType HashMap方式起别名--&gt; &lt;select id=\"queryStudentByIdWithHashMap\" parameterType=\"int\" resultType=\"Student\"&gt; select id \"stuNo\",name \"stuName\" from student where id = #&#123;id&#125; &lt;/select&gt; 动态sql官网地址 wherewhere 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除。 如果 where 元素没有按正常套路出牌，我们可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为： 123&lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"&gt; ...&lt;/trim&gt; 123456789101112&lt;!-- where标签 --&gt;&lt;select id=\"queryStudentBySqlTag\" parameterType=\"student\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"stuName != null and stuName !='' \"&gt; and stuName = #&#123;stuName&#125; &lt;/if&gt; &lt;if test=\"stuAge != null and stuAge !=0 \"&gt; and stuAge = #&#123;stuAge&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 简单类型的数组:无论编写代码时，传递的是什么参数名(stuNos)，在mapper.xml中 必须用array代替该数组 集合：无论编写代码时，传递的是什么参数名(stuNos)，在mapper.xml中 必须用list代替该数组 对象数组：Student[] students = {student0,student1,student2} 每个studentx包含一个学号属性注意的几点： parameterType=”Object[]” #{student.stuNo} SQL片段： java：方法 数据库：存储过程、存储函数 Mybatis :SQL片段 a.提取相似代码b.引用 if标签12345678910&lt;!-- 添加虚拟前缀 --&gt;&lt;select id=\"queryStudentBySqlTag\" parameterType=\"student\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student where 1=1 &lt;if test=\"stuName != null and stuName !='' \"&gt; and stuName = #&#123;stuName&#125; &lt;/if&gt; &lt;if test=\"stuAge != null and stuAge !=0 \"&gt; and stuAge = #&#123;stuAge&#125; &lt;/if&gt; &lt;/select&gt; foreach Tag12345678910111213&lt;!-- foreach迭代 使用对象属性--&gt; &lt;select id=\"queryStudentInGrade\" parameterType=\"grade\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"stuNos != null and stuNos.size &gt; 0\"&gt; &lt;foreach collection=\"stuNos\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 12345678910111213&lt;!-- foreach迭代 使用list集合--&gt; &lt;select id=\"queryStudentWithList\" parameterType=\"list\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"list != null and list.size &gt; 0\"&gt; &lt;foreach collection=\"list\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 12345678910111213&lt;!-- foreach迭代 使用简单数组--&gt; &lt;select id=\"queryStudentWithArray\" parameterType=\"int[]\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"array != null and array.length &gt; 0\"&gt; &lt;foreach collection=\"array\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 12345678910111213&lt;!-- foreach迭代 使用对象数组--&gt; &lt;select id=\"queryStudentWithObjectArray\" parameterType=\"Object[]\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"array != null and array.length &gt; 0\"&gt; &lt;foreach collection=\"array\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 1public List&lt;Student&gt; queryStudentWithObjectArray(Student[] stuNos); sql片段1234567891011121314151617&lt;sql id=\"ObjectArraySql\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"array != null and array.length &gt; 0\"&gt; &lt;foreach collection=\"array\" open=\"and stuno in(\" close=\")\" item=\"student\" separator=\",\"&gt; #&#123;student.stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt;&lt;select id=\"queryStudentWithObjectArray\" parameterType=\"Object[]\" resultType=\"student\"&gt; &lt;!-- 同一文件映射文件下可以省略当前namespace：namesapceId --&gt; &lt;include refid=\"pers.nicolas.mapper.StudentMapper.ObjectArraySql\"&gt;&lt;/include&gt; &lt;/select&gt; 查询关联查询：一对一:a.业务扩展类 核心：用resultType指定类(该类扩展了连接查询的所有属性)的属性 包含 多表查询的所有字段 b.resultMap i.通过 属性成员 将2个类建立起联系 -&gt;一对一：association 2. 1234567891011&lt;resultMap type=\"student\" id=\"student_card_map\"&gt; &lt;!-- 学生的信息 --&gt; &lt;id property=\"stuNo\" column=\"stuNo\"/&gt; &lt;result property=\"stuName\" column=\"stuName\" /&gt; &lt;result property=\"stuAge\" column=\"stuAge\" /&gt; &lt;!-- 一对一时，对象成员使用 association映射;javaType指定该属性的类型--&gt; &lt;association property=\"card\" javaType=\"StudentCard\" &gt; &lt;id property=\"cardId\" column=\"cardId\"/&gt; &lt;result property=\"cardInfo\" column=\"cardInfo\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 一对一：association一对多：collection 一对多：表：student studentclass (关联：classid)类：student studentClass (关联：List students ) 123456789101112131415161718192021222324&lt;!-- 利用resultMap实现一对多 --&gt; &lt;select id=\"queryClassAndStudents\" parameterType=\"int\" resultMap=\"class_student_map\"&gt; select s.*,c.* from student s inner join studentclass c on s.classid = c.classid where c.classid = #&#123;classId&#125; &lt;/select&gt; &lt;!-- 类与表一一对应 --&gt; &lt;resultMap type=\"StudentClass\" id=\"class_student_map\"&gt; &lt;id property=\"classId\" column=\"classId\" /&gt; &lt;result property=\"className\" column=\"className\" /&gt; &lt;!-- 一对多；属性类型javaType；（集合）属性的元素类型ofType --&gt; &lt;collection property=\"students\" ofType=\"Student\"&gt; &lt;id property=\"stuNo\" column=\"stuno\" /&gt; &lt;result property=\"stuName\" column=\"stuname\" /&gt; &lt;result property=\"stuAge\" column=\"stuAge\" /&gt; &lt;result property=\"graName\" column=\"graname\" /&gt; &lt;result property=\"stuSex\" column=\"stusex\" /&gt; &lt;association property=\"card\" javaType=\"StudentCard\"&gt; &lt;id property=\"cardId\" column=\"cardid\" /&gt; &lt;result property=\"cardInfo\" column=\"cardInfo\" /&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt; 一对多 （MyBatis:多对一，多对多的本质就是 一对多的变化） 多对一可以传入多个参数**column=”{prop1=col1,prop2=col2}” 123456789&lt;association property=\"userSolved\" javaType=\"INTEGER\" select=\"com.yoj.web.dao.SolutionMapper.querySolved\" column=\"&#123;userId = user_id,problemId = problem_id&#125;\"&gt;&lt;/association&gt;&lt;association property=\"userSubmitted\" javaType=\"INTEGER\" select=\"com.yoj.web.dao.SolutionMapper.querySubmitted\" column=\"&#123;userId = user_id,problemId = problem_id&#125;\"&gt;&lt;/association&gt;&lt;/resultMap&gt; 12@Select(\"SELECT solution_id FROM solution WHERE problem_id = #&#123;problemId&#125; and user_id = #&#123;userId&#125; and result = 0 LIMIT 1\")Integer querySolved(Map&lt;String, Object&gt; map); 关联的嵌套 Select 查询可以传入多个参数column=”{prop1=col1,prop2=col2}” 注意接收属性为Map 123456789&lt;association property=\"userSolved\" javaType=\"INTEGER\" select=\"com.yoj.web.dao.SolutionMapper.querySolved\" column=\"&#123;userId = user_id,problemId = problem_id&#125;\"&gt;&lt;/association&gt;&lt;association property=\"userSubmitted\" javaType=\"INTEGER\" select=\"com.yoj.web.dao.SolutionMapper.querySubmitted\" column=\"&#123;userId = user_id,problemId = problem_id&#125;\"&gt;&lt;/association&gt;&lt;/resultMap&gt; 12345@Select(\"SELECT solution_id FROM solution WHERE problem_id = #&#123;problemId&#125; and user_id = #&#123;userId&#125; and result = 0 LIMIT 1\")Integer querySolved(Map&lt;String,Object&gt; map);@Select(\"SELECT solution_id FROM solution WHERE problem_id = #&#123;problemId&#125; and user_id = #&#123;userId&#125; LIMIT 1\")Integer querySubmitted(Map&lt;String,Object&gt; map); 属性 描述 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 column=&quot;{prop1=col1,prop2=col2}&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 select 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 column=&quot;{prop1=col1,prop2=col2}&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 fetchType 可选的。有效值为 lazy 和 eager。 指定属性后，将在映射中忽略全局配置参数 lazyLoadingEnabled，使用属性的值。 示例： 1234567891011&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;association property=\"author\" column=\"author_id\" javaType=\"Author\" select=\"selectAuthor\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;select id=\"selectAuthor\" resultType=\"Author\"&gt; SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;&lt;/select&gt; 就是这么简单。我们有两个 select 查询语句：一个用来加载博客（Blog），另外一个用来加载作者（Author），而且博客的结果映射描述了应该使用 selectAuthor 语句加载它的 author 属性。 其它所有的属性将会被自动加载，只要它们的列名和属性名相匹配。 这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为“N+1 查询问题”。 概括地讲，N+1 查询问题是这样子的： 你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。 对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。 这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。 好消息是，MyBatis 能够对这样的查询进行延迟加载，因此可以将大量语句同时运行的开销分散开来。 然而，如果你加载记录列表之后立刻就遍历列表以获取嵌套的数据，就会触发所有的延迟加载查询，性能可能会变得很糟糕。 模糊查询使用#{}，${}容易sql注入 使用concat函数拼接 1234567891011&lt;select id=\"getProblemList\" parameterType=\"com.yoj.web.bean.Problem\" resultMap=\"ProblemList\"&gt; select problem_id,title,#&#123;userId&#125; as user_id from problem &lt;where&gt; &lt;if test=\"problemId != null\"&gt; and problem_id LIKE CONCAT('%',#&#123;problemId&#125;,'%') &lt;/if&gt; &lt;if test=\"title != null\"&gt; and title LIKE CONCAT('%',#&#123;title&#125;,'%') &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 日志：Log4ja.Log4j: log4j.jar (mybatis.zip中lib中包含此jar)b.开启日志，conf.xml 1234&lt;settings&gt; &lt;!-- 开启日志，并指定使用的具体日志 --&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt;&lt;/settings&gt; 如果不指定，Mybatis就会根据以下顺序 寻找日志SLF4J →Apache Commons Logging →Log4j 2 → Log4j →JDK logging c.编写配置日志输出文件 log4j.properties，内容 1234log4j.rootLogger=DEBUG, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 日志级别：​ DEBUG&lt;INFO&lt;WARN&lt;ERROR如果设置为info，则只显示 info及以上级别的信息；建议：在开发时设置debug，在运行时设置为info或以上。 可以通过日志信息，相信的阅读mybatis执行情况（ 观察mybatis实际执行sql语句 以及SQL中的参数 和返回结果） 延迟加载（懒加载）：一对一、一对多、多对一、多对多一对多：班级-学生 ，如果不采用延迟加载 （立即加载），查询时会将 一 和多 都查询，班级、班级中的所有学生。如果想要 暂时只查询1的一方， 而多的一方 先不查询 而是在需要的时候再去查询 –&gt;延迟加载 一对一：学生、学生证 mybatis中使用延迟加载，需要先配置：123456&lt;settings&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 关闭立即加载 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;/settings&gt; 如果增加了mapper.xml ,要修改conf.xml配置文件（将新增的mapper.xml加载进去） 通过debug可以发现， 如果程序只需要学生，则只向数据库发送了查询学生的SQL；当我们后续 需要用到学生证的时候，再第二次发送 查询学生证的SQL。 123456789101112131415161718192021222324252627&lt;mapper namespace=\"pers.nicolas.mapper.StudentCardMapper\"&gt; &lt;!-- 后续通过namespace.Id 定位该SQL语句 --&gt; &lt;!-- parameterType：输入参数的类型 resultType：查询结果的返回类型 --&gt; &lt;!-- 根据cardId查学生证信息--&gt; &lt;select id=\"qeuryCardById\" parameterType=\"int\" resultType=\"studentCard\"&gt; select * from studentcard where cardid = #&#123;cardId&#125; &lt;/select&gt;&lt;!-- 延迟加载 --&gt; &lt;select id=\"queryStudentWithLazyLoad\" resultMap=\"student_card_lazyload_map\"&gt; &lt;!-- 先查学生 --&gt; select * from student &lt;/select&gt; &lt;resultMap type=\"student\" id=\"student_card_lazyload_map\"&gt; &lt;id property=\"stuNo\" column=\"stuno\" /&gt; &lt;result property=\"stuName\" column=\"stuname\" /&gt; &lt;result property=\"stuAge\" column=\"stuAge\" /&gt; &lt;result property=\"graName\" column=\"graname\" /&gt; &lt;result property=\"stuSex\" column=\"stusex\" /&gt; &lt;!-- 延迟加载： 在加载学生时，并不立即加载学生证信息 通过调用sql column外键传参 --&gt; &lt;association property=\"card\" javaType=\"StudentCard\" select=\"pers.nicolas.mapper.StudentCardMapper.qeuryCardById\" column=\"cardid\"&gt; &lt;/association&gt; &lt;/resultMap&gt; 一对多：和一对一的延迟加载配置方法相同 延迟加载的步骤：先查班级，按需查询学生1.开启延迟加载conf.xml配置settings2.配置mapper.xml 写2个Mapper: 班级mapper.xml 123456789101112 &lt;select id=\"queryClassAndStudents\" resultMap=\"class_student_lazyLoad_map\"&gt; select c.* from studentclass c&lt;/select&gt;&lt;resultMap type=\"studentClass\" id=\"class_student_lazyLoad_map\"&gt; &lt;!-- 因为 type的主类是班级，因此先配置班级的信息--&gt; &lt;id property=\"classId\" column=\"classId\"/&gt; &lt;result property=\"className\" column=\"className\"/&gt; &lt;!-- 配置成员属性学生，一对多;属性类型：javaType，属性的元素类型ofType --&gt; &lt;!-- 2222222再查班级对应的学生 --&gt; &lt;collection property=\"students\" ofType=\"student\" select=\"org.lanqiao.mapper.StudentMapper.queryStudentsByClassId\" column=\"classid\"&gt;​ &lt;/collection&gt;​1234&lt;/resultMap&gt;​ 即查询 学生的sql是通过 select属性指定，并且通过column指定外键 ​1234567学生mapper.xml&lt;!-- 一对多,延迟加载需要的： 查询班级中的所有学生 --&gt;&lt;select id=\"queryStudentsByClassId\" parameterType=\"int\" resultType=\"student\"&gt; select * from student where classId = #&#123;classId&#125;&lt;/select&gt; 查询缓存一级缓存 ：同一个SqlSession对象 ​ MyBatis默认开启一级缓存，如果用同样的SqlSession对象查询相同的数据，​ 则只会在第一次 查询时 向数据库发送SQL语句，并将查询的结果 放入到 SQLSESSION中（作为缓存存在）； 后续再次查询该同样的对象时， 则直接从缓存中查询该对象即可（即省略了数据库的访问） 二级缓存​ MyBatis默认情况没有开启二级缓存，需要手工打开。​ a.conf.xml 12&lt;!-- 开启二级缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; ​ b.在具体的mapper.xml中声明开启(studentMapper.xml中) 123&lt;mapper namespace=\"org.lanqiao.mapper.StudentMapper\"&gt; &lt;!-- 声明次namespace开启二级缓存 --&gt;&lt;cache/&gt; 根据异常提示：NotSerializableException可知，MyBatis的二级缓存 是将对象 放入硬盘文件中 序列化：内存-&gt;硬盘 反序列化：硬盘-&gt;内存准备缓存的对象，必须实现了序列化接口 （如果开启的缓存Namespace=”org.lanqiao.mapper.StudentMapper”），可知序列化对象为Student，因此需要将Student序列化 （序列化Student类，以及Student的级联属性、和父类） 触发将对象写入二级缓存的时机：SqlSession对象的close()方法。 Mybatis自带二级缓存：【同一个namespace】生成的mapper对象回顾：namespace的值 就是 接口的全类名（包名.类名）， 通过接口可以产生代理对象（studentMapper对象） –&gt;namespace决定了studentMapper对象的产生结论：只要产生的xxxMapper对象 来自于同一个namespace，则 这些对象 共享二级缓存。注意：二级缓存 的范围是同一个namespace, 如果有多个xxMapper.xml的namespace值相同，则通过这些xxxMapper.xml产生的xxMapper对象 仍然共享二级缓存。 禁用 ：select标签中useCache=”false” 清理：a.与清理一级缓存的方法相同 commit(); （一般执行增删改时 会清理掉缓存；设计的原因 是为了防止脏数据）在二级缓存中，commit()不能是查询自身的commit。 commit会清理一级和二级缓存；但是 清理二级缓存时，不能是查询自身的commit； b. 在select标签中 增加属性 flushCache=”true” 命中率： 1:zs :0% 2: 50% 3: 2/3 0.666 4: 3/4 0.75 三方提供的二级缓存：ehcache、memcache 要想整合三方提供的二级缓存 （或者自定义二级缓存），必须实现org.apache.ibatis.cache.Cache接口，该接口的默认实现类是PerpetualCache 整合ehcache二级缓存：a.ehcache-core.jarmybatis-Ehcache.jarslf4j-api.jar b.编写ehcache配置文件 Ehcache.xml 12345678910111213141516171819202122232425&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"&gt; &lt;!--当二级缓存的对象 超过内存限制时（缓存对象的个数&gt;maxElementsInMemory），存放入的硬盘文件 --&gt; &lt;diskStore path=\"E:\\Ehcache\"/&gt; &lt;!-- maxElementsInMemory:设置 在内存中缓存 对象的个数 maxElementsOnDisk：设置 在硬盘中缓存 对象的个数 eternal：设置缓存是否 永远不过期 overflowToDisk：当内存中缓存的对象个数 超过maxElementsInMemory的时候，是否转移到硬盘中 timeToIdleSeconds：当2次访问 超过该值的时候，将缓存对象失效 timeToLiveSeconds：一个缓存对象 最多存放的时间（生命周期） diskExpiryThreadIntervalSeconds：设置每隔多长时间，通过一个线程来清理硬盘中的缓存 memoryStoreEvictionPolicy：当超过缓存对象的最大值时，处理的策略；LRU，FIFO,LFU --&gt; &lt;defaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"1000000\" eternal=\"false\" overflowToDisk=\"false\" timeToIdleSeconds=\"100\" timeToLiveSeconds=\"100\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; c.开启EhCache二级缓存 在xxxMapper.xml中开启 12345&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt; &lt;!-- 通过property覆盖Ehcache.xml中的值 --&gt; &lt;property name=\"maxElementsInMemory\" value=\"2000\"/&gt; &lt;property name=\"maxElementsOnDisk\" value=\"3000\"/&gt; &lt;/cache&gt; 逆向工程表、类、接口、mapper.xml四者密切相关，因此 当知道一个的时候 其他三个应该可以自动生成。表-&gt;其他三个 实现步骤： a. 导入依赖 mybatis-generator-core.jar、mybatis.jar、ojdbc.jar 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; b. 逆向工程的配置文件generator.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;!-- suppressAllComments属性值： true:自动生成实体类、SQL映射文件时没有注释 false:自动生成实体类、SQL映射文件，并附有注释 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\" /&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库连接信息 --&gt; &lt;jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\" connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:ORCL\" userId=\"scott\" password=\"tigger\"&gt; &lt;/jdbcConnection&gt; &lt;!-- forceBigDecimals属性值： true:把数据表中的DECIMAL和NUMERIC类型， 解析为JAVA代码中的java.math.BigDecimal类型 false(默认):把数据表中的DECIMAL和NUMERIC类型， 解析为解析为JAVA代码中的Integer类型 --&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject属性值:实体类的生成位置 targetPackage属性值：实体类所在包的路径 --&gt; &lt;javaModelGenerator targetPackage=\"org.lanqiao.entity\" targetProject=\".\\src\"&gt; &lt;!-- trimStrings属性值： true：对数据库的查询结果进行trim操作 false(默认)：不进行trim操作 --&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject属性值:SQL映射文件的生成位置 targetPackage属性值：SQL映射文件所在包的路径 --&gt; &lt;sqlMapGenerator targetPackage=\"org.lanqiao.mapper\" targetProject=\".\\src\"&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成动态代理的接口 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"org.lanqiao.mapper\" targetProject=\".\\src\"&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName=\"Student\"&gt; &lt;/table&gt; &lt;table tableName=\"studentCard\"&gt; &lt;/table&gt; &lt;table tableName=\"studentClass\"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; c. 执行 12345678File file = new File(\"src/generator.xml\"); // 配置文件 List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(file); DefaultShellCallback callback = new DefaultShellCallback(true); // 逆向工程核心类 MyBatisGenerator generator = new MyBatisGenerator(config, callback, warnings); generator.generate(null); 123456789101112131415161718192021import java.io.File;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;public class MybatisGeneratorTest &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(\"mybatis-generator.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; 常用方法取到最后生成的主键1&lt;!--取到最后生成的主键--&gt;&lt;insert id=\"insertSelective\" useGeneratedKeys=\"true\" keyColumn=\"problem_id\" keyProperty=\"problemId\" parameterType=\"com.yoj.web.bean.Problem\"&gt; [用Criteria实现多条件查询](https://blog.csdn.net/qjlhlh/article/details/6599557) 逆向工程产生的bean（entity class）的扩展类中的静态内部类。 mybatis注解版插入时返回主键id1234567@Mapperpublic interface UserMapper&#123; @Insert(\"insert into tbl_user (name, age) values (#&#123;name&#125;, #&#123;age&#125;)\") @Options(useGeneratedKeys=true, keyProperty=\"userId\", keyColumn=\"id\") void insertUser(User user);&#125; 调用其他方法1234567891011121314@Select(\"SELECT * FROM solution ORDER BY solution_id DESC\")@Results(&#123; @Result(id = true, column = \"solution_id\", property = \"solutionId\"), @Result(column = \"problem_id\", property = \"problem\", one = @One(select = \"com.yoj.web.dao.ProblemMapper.queryProblemTitleAndIdById\", fetchType = FetchType.EAGER)), @Result(column = \"language\", property = \"language\"), @Result(column = \"code\", property = \"code\"), @Result(column = \"result\", property = \"result\"), @Result(column = \"runtime\", property = \"runtime\"), @Result(column = \"memory\", property = \"memory\"), @Result(column = \"error_message\", property = \"errorMessage\"), @Result(column = \"submit_time\", property = \"submitTime\"), @Result(column = \"user_id\", property = \"user\", one = @One(select = \"com.yoj.web.dao.UserMapper.getUserById\", fetchType = FetchType.EAGER))&#125;)List&lt;Solution&gt; getAllWithUserAndProblemName(); other自动映射当自动映射查询结果时，MyBatis 会获取结果中返回的列名并在 Java 类中查找相同名字的属性（忽略大小写）。 这意味着如果发现了 ID 列和 id 属性，MyBatis 会将列 ID 的值赋给 id 属性。 通常数据库列使用大写字母组成的单词命名，单词间用下划线分隔；而 Java 属性一般遵循驼峰命名法约定。为了在这两种命名方式之间启用自动映射，需要将 mapUnderscoreToCamelCase 设置为 true。 批量操作https://blog.csdn.net/mahoking/article/details/46811865 批量增加操作 1234567&lt;!-- 批量增加操作 --&gt;&lt;insert id=\"batchInsertUsers\" parameterType=\"java.util.List\"&gt; insert into mhc_user(userName,password) values &lt;foreach collection=\"list\" item=\"item\" index=\"index\" separator=\",\"&gt; (#&#123;item.userName&#125;,#&#123;item.password&#125;) &lt;/foreach&gt;&lt;/insert&gt; 插入后取到最后生成的主键1&lt;!--取到最后生成的主键--&gt;&lt;insert id=\"insertSelective\" useGeneratedKeys=\"true\" keyColumn=\"problem_id\" keyProperty=\"problemId\" parameterType=\"com.yoj.web.bean.Problem\"&gt;","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"https://codeofli.github.io/tags/mybatis/"}]},{"title":"javaWeb","slug":"java-note/javaWeb/javaWeb","date":"2019-10-12T02:39:06.000Z","updated":"2021-10-23T02:19:04.195Z","comments":true,"path":"2019/10/java-note/javaWeb/javaWeb/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/javaWeb/javaWeb/","excerpt":"[TOC]基础知识JSP:动态网页静态、动态：1.不用 和 是否有“动感”混为一谈2.是否 随着 时间、地点、用户操作 的 改变而改变 动态网页 需要使用到 服务端脚本语言（JSP） 2架构CS：Client ServerCS不足：a.如果 软件升级， 那么全部软件都需要升级b.维护麻烦：需要维护每一台 客户端软件c.每一台客户端 都需要安装 客户端软件","text":"[TOC]基础知识JSP:动态网页静态、动态：1.不用 和 是否有“动感”混为一谈2.是否 随着 时间、地点、用户操作 的 改变而改变 动态网页 需要使用到 服务端脚本语言（JSP） 2架构CS：Client ServerCS不足：a.如果 软件升级， 那么全部软件都需要升级b.维护麻烦：需要维护每一台 客户端软件c.每一台客户端 都需要安装 客户端软件 BS ：Broswer Server客户端可以通过 浏览器 直接访问服务端 注意：bs和cs各有优势。 3.tomcat解压后目录：bin:可执行文件（startup.bat shutdown.bat）conf:配置文件（server.xml）lib：tomcat依赖的jar文件log:日志文件（记录出错等信息）temp:临时文件webapps：可执行的项目（将我们开发的项目 放入该目录）work:存放由jsp翻译成的java,以及编辑成的class文件(jsp -&gt;java -&gt;class) 4.配置tomcata.配置jdk (必须配置JAVA_HOME)java_home classPath pathb.配置catalina_home 双击bin/startup.bat启动tomacat，常见错误： 可能与其他服务的端口号冲突tomcat端口号默认8080 （此端口号较为常见，容易冲突），建议修改此端口 （8888） 修改端口号： 5.访问tomcathttp://localhost:8888/ 常见状态码：200：一切正常300/301: 页面重定向 （跳转）404:资源不存在403：权限不足 （如果访问a目录，但是a目录设置 不可见）500：服务器内部错误（代码有误）其他编码：积累 jsp：在html中嵌套的java代码 在项目/WEB-INF/web.xml中设置 默认的 初始页面 123&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 6.虚拟路径a.方式一将web项目配置到 webapps以外的目录conf/server.xml中配置host标签中： 1&lt;Context docBase=\"D:\\study\\JspProject\" path=\"/JspProject\" /&gt; docBase：实际路径path：虚拟路径 （绝对路径、相对路径【相对于webapps】）重启 b.方式二D:\\study\\apache-tomcat-8.5.30\\conf\\Catalina\\localhost中新建 “项目名.xml”中新增一行： 1&lt;Context docBase=\"D:\\study\\JspProject\" path=\"/JspProject\" /&gt; 7.虚拟主机通过www.test.com访问本机a. conf/server.xml 1&lt;Engine name=\"Catalina\" defaultHost=\"www.test.com\"&gt; 123&lt;Host appBase=\"D:\\study\\JspProject\" name=\"www.test.com\"&gt; &lt;Context docBase=\"D:\\study\\JspProject\" path=\"/\"/&gt; &lt;/Host&gt; b.C:\\Windows\\System32\\drivers\\etc\\host增加 1127.0.0.1 www.test.com 流程： 1www.test.com -&gt; host找映射关系 -&gt;server.xml找Engine的defaultHost -&gt;通过\"/\"映射到 D:\\study\\JspProject为了后续学习，将以上恢复成默认 7.JSP执行流程jsp- java(Servlet文件) -classD:\\study\\apache-tomcat-8.5.30\\work\\Catalina\\localhost\\JspProject\\org\\apache\\jsp Jsp 和Servlet 可以相互转换 因为第一请求服务端 会有翻译 和编译的过程，因此比较慢； 后续访问 可以直接访问class,因此速度较快。但是 如果 服务端修改了代码，则再次访问时 会重新的翻译、编译。 使用Eclipse开发Web项目(JSP项目) tomcat 在Eclipse中创建的Web项目：浏览器可以直接访问 WebContent中的文件，例如http://localhost:8888/MyJspProject/index1.jsp其中的index1.jsp就在WebContent目录中；但是WEB-INF中的文件 无法通过客户端（浏览器）直接访问，只能通过请求转发来访问 注意： 并不是 任何的内部跳转都能访问WEB-INF；原因是 跳转有2种方式：请求转发 、重定向 3.配置tomcat运行时环境 JSP&lt;=&gt;Servlet 将tomcat/lib中的servlet-api.jar加入项目的构建路径 右键项目-&gt;Build Path -&gt; Add library -&gt;Server Runtime 4.部署tomcat在servers面板 新建一个 tomcat实例 ， 再在该实例中 部署项目（右键-add）之后运行 注意：一般建议 将eclipse中的tomcat与 本地tomcat的配置信息保持一致： 将eclipse中的tomcat设置为托管模式： 【第一次】创建tomcat实例之后， 双击，选择Server Location的第二项 5.统一字符集编码 a.编码分类：设置jsp文件的编码（jsp文件中的pageEncoding属性）： jsp -&gt; java设置浏览器读取jsp文件的编码（jsp文件中content属性）一般将上述设置成 一致的编码，推荐使用UTF-8文本编码： i.将整个eclipse中的文件 统一设置 （推荐） ii.设置 某一个项目 iii.设置单独文件 JSPJAVA serve pages JSP的页面元素 HTML JAVA代码（脚本Scriptlet） 指令 注释 脚本Scriptleti. 1&lt;% 局部变量、java语句 %&gt; ii. 1&lt;%! 全局变量、定义方法 %&gt; iii. 1&lt;%=输出表达式 %&gt; 一般而言，修改web.xml、配置文件、java 需要重启tomcat服务 但是如果修改 Jsp\\html\\css\\js ，不需要重启 注意: out.println()不能回车； 要想回车：“”，即out.print() &lt;%= %&gt; 可以直接解析html代码 指令page指令 &lt;%@ page ....%&gt;page指定的属性：language: jsp页面使用的脚本语言import: 导入类pageEncoding: jsp文件自身编码 jsp -&gt;javacontentType:浏览器解析jsp的编码 12&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.Date\" %&gt; 注释HTML注释 1&lt;!-- --&gt; 可以被客户 通过浏览器查看源码 所观察到 JAVA注释 1// /*...*/ JSP注释 1&lt;%-- --%&gt; JSP九大内置对象自带的，不需要new 也能使用的对象 request：请求对象存储“客户端向服务端发送的请求信息”request对象的常见方法： name description String getParameter(String name) 根据请求的字段名key （input标签的name属性值） ，返回字段值value （input标签的value属性值） String[] getParameterValues(String name) 根据请求的字段名key ，返回多个字段值value （checkbox） void setCharacterEncoding (“编码格式utf-8”) ：设置post方式的请求编码 （tomcat7以前默认iso-8859-1，tomcat8以后改为了utf-8） getRequestDispatcher(“b.jsp”).forward(request,response) 请求转发 的方式跳转页面 A - &gt; B ServletContext getServerContext() 获取项目的ServletContext对象 response :响应对象提供的方法 function description void addCookie( Cookie cookie ); 服务端向客户端增加cookie对象 void sendRedirect(String location ) throws IOException; 页面跳转的一种方式（重定向） void setContetType(String type) 设置服务端响应的编码（设置服务端的contentType类型） session 会话对象1import javax.servlet.http.HttpSession; session(服务端) , Cookie（客户端，不是内置对象）:Cookie是由 服务端生成的 ，再发送给客户端保存。 相当于 本地缓存的作用： 客户端(hello.mp4,zs/abc)-&gt;服务端(hello.mp4；zs/abc) 作用：提高访问服务端的效率，但是安全性较差。 Cookie 不是内置对象，要使用必须new 但是，服务端会 自动生成一个(服务端自动new一个cookie) name=JSESIONID的cookie 并返回给客户端 Cookie： name=value 1javax.servlet.http.Cookie function description public Cookie(String name,String value) String getName() 获取name String getValue() 获取value void setMaxAge(int expiry) 最大有效期 （秒） 服务端准备Cookie： 1response.addCookie(Cookie cookie) 页面跳转（转发，重定向） 1客户端获取cookie: request.getCookies(); 服务端增加cookie :response对象；客户端获取对象：request对象 不能直接获取某一个单独对象，只能一次性将 全部的cookie拿到 通过F12可以发现 除了自己设置的Cookie对象外，还有一个name为 JsessionId的cookie 建议 cookie只保存 英文数字，否则需要进行编码、解码 使用Cookie实现 记住用户名 功能 4.session :会话a.浏览网站：开始-关闭b.购物： 浏览、付款、退出c.电子邮件：浏览、写邮件、退出 开始-结束 session机制客户端第一次请求服务端时，（jsessionId-sessionId）服务端会产生一个session对象（用于保存该客户的信息）；并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);服务端由会 产生一个cookie，并且 该cookie的name=JsessionId,value=服务端sessionId的值；然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JsessionId)；因此，客户端的cookie就可以和服务端的session一一对应（JsessionId- sessionId） 客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JsessionId 去服务端的session中匹配sessionId,如果匹配成功（cookie jsessionId和sesion sessionId），说明此用户 不是第一次访问,无需登录； 例子：客户端： 顾客（客户端）服务端: 存包处 - 商场(服务端) 顾客第一次存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙）。 如果是新顾客（没钥匙） ，分配一个钥匙 给该顾客； 钥匙 会和 柜子 一一对应； 第二/n次 存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙） 如果是老顾客（有钥匙），则不需要分配；该顾客手里的钥匙 会 和柜子 自动一一对应。 session: session存储在服务端 session是在 同一个用户（客户）请求时 共享 实现机制：第一次客户请求时 产生一个sessionId 并复制给 cookie的JsessionId然后发给客户端。最终 通过session的sessionId-cookie的JsessionId session方法 function description String getId() 获取sessionId boolean isNew() 判断是否是 新用户（第一次访问） void invalidate() 使session失效 （退出登录、注销） void setAttribute(String name, Object value) Object getAttribute(); void setMaxInactiveInterval(秒) 设置最大有效 非活动时间 int getMaxInactiveInterval() 获取最大有效 非活动时间 示例：登录 客户端在第一次请求服务端时，如果服务端发现 此请求没有 JsessionId,则会创建一个 name=JSESIONID的cookie 并返回给客户端 cookie和session的区别： session cookie 保存的位置 服务端 客户端 安全性 较安全 较不安全 保存的内容 Object String application全局对象String getContextPath() 虚拟路径String getRealPath(String name): 绝对路径（虚拟路径 相对的绝对路径） 其他五种不常用对象 Object description pageContext JSP页面容器 config 配置对象（服务器配置信息） page 当前JSP页面对象（相当于java中的this） exception 异常对象 out 输出对象，向客户端输出内容 get与post请求方式的区别：get提交方式 http://localhost:8888/MyJspProject/show.jsp?uname=aa&amp;upwd=123&amp;uage=22&amp;uhobbies=%E7%AF%AE%E7%90%83 1连接/文件?参数名1=参数值1 &amp; 参数名2=参数值2 &amp; 参数名1=参数值1 method=”get” 和 地址栏 、超链接(&lt;a href=&quot;xx&quot;&gt;)请求方式 默认都属于get提交方式 get方式 在地址栏显示 请求信息 (但是地址栏能够容纳的 信息有限，4-5KB；如果请求数据存在大文件，图片等 会出现地址栏无法容纳全部的数据而出错) ；post不会显示 文件上传操作，必须是post推荐使用post 8.统一请求的编码 requestget方式请求 如果出现乱码，解决： 统一每一个变量的 编码 （不推荐） 12new String( 旧编码，新编码); name = new String(name.getBytes(\"iso-8859-1\"),\"utf-8\"); 修改server.xml ，一次性的 更改tomcat默认get提交方式的编码 （utf-8）建议 使用tomcat时， 首先在server.xml中 统一get方式的编码.. URIEncoding=&quot;UTF-8&quot; tomcat7 (iso-8859-1) tomcat8（utf-8） post 1request.setCharacterEncoding(\"utf-8\") 请求转发和重定向请求转发 1request.getRequestDispatcher(\"b.jsp\").forward(request,response) 重定向 1reponse.sendRedirect(\"b.jsp\") 请求转发 重定向 地址栏是否改变 不变(check.jsp) 改变(success.jsp) 是否保留第一次请求时的数据 保留 不保留 请求的次数 1 2 跳转发生的位置 服务端 客户端发出的第二次跳转 转发、重定向： 转发： 张三（客户端） -&gt; 【 服务窗口 A （服务端 ） -&gt; 服务窗口B 】 重定向： 张三（客户端） -&gt; 服务窗口 A （服务端 ） -&gt;去找B ​ 张三（客户端） -&gt; 服务窗口 B （服务端 ） -&gt;结束 四种范围对象（小-&gt;大） object description scope pageContext JSP页面容器 （page对象）； 当前页面有效 request 请求对象 同一次请求有效 session 会话对象 同一次会话有效 application 全局对象 全局有效（整个项目有效） 以上4个对象共有的方法： function description Object getAttribute(String name) 根据属性名，获取属性值 void setAttribute(String name,Object obj) 设置属性值（新增，修改） void removeAttribute(String name) 根据属性名，删除对象 pageContext 当前页面有效 (页面跳转后无效) request 同一次请求有效；其他请求无效 （请求转发后有效；重定向后无效） session 同一次会话有效 （无论怎么跳转，都有效；关闭/切换浏览器后无效 ； 从 登陆-&gt;退出 之间 全部有效） application 全局变量；整个项目运行期间 都有效 (切换浏览器 仍然有效)；关闭服务、其他项目 无效 -&gt;多个项目共享、重启后仍然有效 ：JNDI 以上的4个范围对象，通过 setAttribute()复制，通过getAttribute()取值； 以上范围对象，尽量使用最小的范围。因为 对象的范围越大，造成的性能损耗越大。 ServletJava类必须符合一定的 规范： a.必须继承 javax.servlet.http.HttpServlet b.重写其中的service()之类的方法 123service(): 接受并识别和处理相应的所有提交的方法； doGet(): 接受并处理所有get提交方式的请求 doPost(): 接受并处理所有post提交方式的请求 Servlet要想使用，必须配置Serlvet2.5：web.xml 123456789101112&lt;web-app&gt; ... &lt;servlet&gt; &lt;servlet-name&gt;WelcomeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.lanqiao.servlet.WelcomeServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;WelcomeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/WelcomeServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Servlet3.0： @WebServlet 1@WebServlet( value=\"/WelcomeServlet\" ,loadOnStartup=1,initParams= &#123;@WebInitParam(name=\"serveltparaname30\",value=\"servletparavalue30\") &#125; ) Serlvet2.5：web.xml: 项目的根目录：WebContent 、src &lt;a href=&quot;WelcomeServlet&quot;&gt;所在的jsp是在 WebContent目录中，因此 发出的请求WelcomeServlet 是去请求项目的根目录。 Servlet流程： 请求 -&gt;&lt;url-pattern&gt; -&gt; 根据&lt;servlet-mapping&gt;中的&lt;servlet-name&gt; 去匹配 &lt;servlet&gt;中的&lt;servlet-name&gt;，然后寻找到，求中将请求交由该执行。 2个/:jsp:/ localhost:8888web.xml: / http://localhost:8888/项目名/ 编写Servlet步骤：1import javax.servlet.http.HttpServlet; 1.编写一个类继承HttpServlet 1public class LoginServlet extends HttpServlet &#123; 2.重写相应方法(doGet()、doPost()) 3.配置Servlet 编写web.xml 中的servlet映射关系 Servlet3.0，与Servlet2.5的区别： Servlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 匹配流程： 请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类 注解:@WebServlet(“url-pattern的值”) 注意:url-pattern 要带斜杆 2.借助于Eclipse快速生成Servlet直接新建Servlet即可！（继承、重写、web.xml 可以借助Eclipse自动生成） 3.项目根目录：WebContent、src（所有的构建路径）例如：WebContent中有一个文件index.jspsrc中有一个Servlet.java 如果: index.jsp中请求&lt;a href=&quot;abc&quot;&gt;...&lt;/a&gt;，则 寻找范围：既会在src根目录中找 也会在WebContent根目录中找 如果：index.jsp中请求&lt;a href=&quot;a/abc&quot;&gt;&lt;/a&gt;，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc web.xml中的 /:代表项目根路径http://localhost:8888/Servlet25Project/jsp中的/: 服务器根路径http://localhost:8888/ 构建路径、WebContent:根目录 Servlet生命周期 5个阶段 加载、初始化： init() ，该方法会在 Servlet被加载并实例化的以后 执行服务 ：service() -&gt;doGet() doPost init(): 默认第一次访问 Servlet时会被执行 （只执行这一次） 可以修改为 Tomcat启动时自动执行 销毁 ：destroy()Servlet被系统回收时执行 卸载 i.Servlet2.5： web.xml 1234&lt;servlet&gt; ... &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 其中的“1”代表第一个。 ii.Servlet3.0 1@WebServlet( value=\"/WelcomeServlet\" ,loadOnStartup=1 ) service() -&gt;doGet() doPost ：调用几次，则执行几次 destroy()：关闭tomcat服务时，执行一次。 5 Servlet API ： 由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包即Servlet API可以适用于 任何 通信协议。我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。 6.Servlet继承关系 ServletConfig:接口ServletContext getServletContext():获取Servlet上下文对象 applicationString getInitParameter(String name):在当前Servlet范围内，获取名为name的参数值（初始化参数） a.ServletContext中的常见方法(application)：getContextPath():相对路径getRealPath()：绝对路径setAttribute() 、getAttribute()—&gt;String getInitParameter(String name);在当前Web容器范围内，获取名为name的参数值（初始化参数） Servlet3.0方式 给当前Servlet设置初始值： 1@WebServlet( .... , initParams= &#123;@WebInitParam(name=\"serveltparaname30\",value=\"servletparavalue30\") &#125; ) 注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置） HttpServletRequest中的方法：(同request)，例如setAttrite()、getCookies()、getMethod()HttpServletResponse中的方法：同response Servlet使用层面： Eclipse中在src创建一个Servlet，然后重写doGet() doPost()就可以 （doGet() doPost()只需要编写一个）。 使用idea创建一个Maven java Web项目https://blog.csdn.net/qq_37856300/article/details/85776785 数据库连接JDBCJava Data Base Connectivity maven dependency 123456&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt; 可以为多种关系型数据库DBMS 提供统一的访问方式，用Java来操作数据库JDBC API 主要功能：三件事，具体是通过以下类/接口实现： 1234DriverManager ： 管理jdbc驱动 Connection： 连接（通过DriverManager产生） Statement（PreparedStatement） ：增删改查 （通过Connection产生 ） CallableStatement ： 调用数据库中的 存储过程/存储函数 （通过Connection产生 ） Result ：返回的结果集 （上面的Statement等产生 ） Connection产生操作数据库的对象： 123Connection产生Statement对象：createStatement() Connection产生PreparedStatement对象：prepareStatement() Connection产生CallableStatement对象：prepareCall(); Statement操作数据库： 12增删改：executeUpdate() 查询：executeQuery(); ResultSet：保存结果集 select * from xxx 123next():光标下移，判断是否有下一条数据；true/false previous(): true/false getXxx(字段名|位置):获取具体的字段值 PreparedStatement操作数据库： 1public interface PreparedStatement extends Statement 因此 12增删改：executeUpdate() 查询：executeQuery(); –此外赋值操作 setXxx(); PreparedStatement与Statement在使用时的区别： Statement: 12sql executeUpdate(sql) PreparedStatement: 1234sql(可能存在占位符?) 在创建PreparedStatement 对象时，将sql预编译 prepareStatement(sql) executeUpdate() setXxx()替换占位符 推荐使用PreparedStatement：原因如下：1.编码更加简便（避免了字符串的拼接） 123456789101112String name = \"zs\" ; int age = 23 ; stmt: String sql =\" insert into student(stuno,stuname) values('\"+name+\"', \"+age+\" ) \" ; stmt.executeUpdate(sql); pstmt: String sql =\" insert into student(stuno,stuname) values(?,?) \" ; pstmt = connection.prepareStatement(sql);//预编译SQL pstmt.setString(1,name); pstmt.setInt(2,age); 2.提高性能(因为 有预编译操作，预编译只需要执行一次)需要重复增加100条数 12345678910111213stmt: String sql =\" insert into student(stuno,stuname) values('\"+name+\"', \"+age+\" ) \" ; for(100) stmt.executeUpdate(sql); pstmt: String sql =\" insert into student(stuno,stuname) values(?,?) \" ; pstmt = connection.prepareStatement(sql);//预编译SQL pstmt.setString(1,name); pstmt.setInt(2,age); for( 100)&#123; pstmt.executeUpdate(); &#125; 3.安全（可以有效防止sql注入）sql注入： 将客户输入的内容 和 开发人员的SQL语句 混为一体 stmt:存在被sql注入的风险(例如输入 用户名：任意值 ‘ or 1=1 – 密码：任意值)分析： 12345select count(*) from login where uname='任意值 ' or 1=1 --' and upwd ='任意值' ; select count(*) from login where uname='任意值 ' or 1=1 ; select count(*) from login ; select count(*) from login where uname='\"+name+\"' and upwd ='\"+pwd+\"' pstmt:有效防止sql注入 推荐使用pstmt 3.jdbc访问数据库的具体步骤：a.导入驱动，加载具体的驱动类b.与数据库建立连接c.发送sql，执行d.处理结果集 （查询） 数据库驱动 驱动jar 具体驱动类 连接字符串 Oracle ojdbc-x.jar oracle.jdbc.OracleDriver jdbc:oracle:thin:@localhost:1521:ORCL MySQL mysql-connector-java-x.jar com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/数据库实例名 SqlServer sqljdbc-x.jar com.microsoft.sqlserver.jdbc.SQLServerDrive jdbc:microsoft:sqlserver:localhost:1433;databasename=数据库实例名 使用jdbc操作数据库时，如果对数据库进行了更换，只需要替换：驱动、具体驱动类、连接字符串、用户名、密码 jdbc总结（模板、八股文）： 12345678910111213141516171819202122try&#123; a.导入驱动包、加载具体驱动类Class.forName(\"具体驱动类\"); b.与数据库建立连接connection = DriverManager.getConnection(...); c.通过connection，获取操作数据库的对象（Statement\\preparedStatement\\callablestatement） stmt = connection.createStatement(); d.(查询)处理结果集rs = pstmt.executeQuery() while(rs.next())&#123; rs.getXxx(..) ;&#125; &#125;catch(ClassNotFoundException e ) &#123; ...&#125; catch(SQLException e) &#123;... &#125; catch(Exception e) &#123;... &#125; finally &#123; //打开顺序，与关闭顺序相反 if(rs!=null)rs.close() if(stmt!=null) stmt.close(); if(connection!=null)connection.close(); &#125; –jdbc中，除了Class.forName() 抛出ClassNotFoundException，其余方法全部抛SQLException 2.CallableStatement:调用 存储过程、存储函数connection.prepareCall(参数：存储过程或存储函数名)参数格式：存储过程（无返回值return，用out参数替代）： { call 存储过程名(参数列表) }存储函数（有返回值return）： { ? = call 存储函数名(参数列表) } 12345create or replace procedure addTwoNum ( num1 in number,num2 in number,result out number ) -- 1 + 2 -&gt;3 as begin result := num1+num2 ; end ; 强调：如果通过sqlplus 访问数据库，只需要开启：OracleServiceSID通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：OracleServiceSID、XxxListener JDBC调用存储过程的步骤：a.产生 调用存储过程的对象（CallableStatement） cstmt = connection.prepareCall( “…” ) ;b.通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);c.通过 registerOutParameter(…)处理输出参数类型d.cstmt.execute()执行e.接受 输出值（返回值）getXxx() 调存储函数： 12345678create or replace function addTwoNumfunction ( num1 in number,num2 in number) -- 1 + 2 return number as result number ; begin result := num1+num2 ; return result ; end ; JDBC调用存储函数：与调存储过程的区别：在调用时，注意参数：”{? = call addTwoNumfunction (?,?) }” 3.处理CLOB/BLOB类型处理稍大型数据： a.存储路径 E:\\JDK_API_zh_CN.CHM 通过JDBC存储文件路径，然后 根据IO操作处理 例如：JDBC将 E:\\JDK_API_zh_CN.CHM 文件 以字符串形式“E:\\JDK_API_zh_CN.CHM”存储到数据库中 获取：1.获取该路径“E:\\JDK_API_zh_CN.CHM” 2.IO b. CLOB：大文本数据 （小说-&gt;数据） BLOB：二进制 clob:大文本数据 字符流 Reader Writer存1.先通过pstmt 的? 代替小说内容 （占位符）2.再通过pstmt.setCharacterStream(2, reader, (int)file.length()); 将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型 取：1.通过Reader reader = rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据 保存到Reader对象中 将Reader通过Writer输出即可。 blob:二进制 字节流 InputStream OutputStream与CLOB步骤基本一致，区别：setBinaryStream(…) getBinaryStream(…) 4.JSP访问数据库 JSP就是在html中嵌套的java代码，因此 java代码可以写在jsp中（&lt;% … %&gt;） 导包操作：java项目 ：1 Jar复制到工程中 2.右键该Jar :build path -&gt;add to build Path Web项目：jar复制到WEB-INF/lib 核心：就是将 java中的JDBC代码，复制到 JSP中的&lt;% … %&gt; 注意：如果jsp出现错误：The import Xxx cannot be resolved 尝试解决步骤： a.(可能是Jdk、tomcat版本问题) 右键项目-&gt;build path，将其中 报错的 libary或Lib 删除后 重新导入 b.清空各种缓存：右键项目-&gt;Clean tomcat… clean （Project -clean或者 进tomcat目录 删除里面work的子目录） c.删除之前的tomcat，重新解压缩、配置tomcat，重启计算机 d.如果类之前没有包，则将该类加入包中 JavaBean刚才我们将 jsp中 登录操作的代码 转移到了LoginDao.java；其中LoginDao类 就称之为JavaBean。JavaBean的作用：a.减轻的jsp复杂度 b.提高代码复用（以后任何地方的 登录操作，都可以通过调用LoginDao实现） JavaBean（就是一个Java类）的定义：满足一下2点 ，就可以称为JavaBean a.public 修饰的类 ,public 无参构造 b.所有属性(如果有) 都是private，并且提供set/get (如果boolean 则get 可以替换成is) 使用层面，Java分为2大类：a.封装业务逻辑的JavaBean (LoginDao.java封装了登录逻辑) 逻辑 可以将jsp中的JDBC代码，封装到Login.java类中 （Login.java） b.封装数据的JavaBean （实体类，Student.java Person.java ） 数据 对应于数据库中的一张表 Login login = new Login(uname,upwd) ;//即用Login对象 封装了2个数据（用户名 和密码） 封装数据的JavaBean 对应于数据库中的一张表 (Login(name,pwd))封装业务逻辑的JavaBean 用于操作 一个封装数据的JavaBean 可以发现，JavaBean可以简化 代码(jsp-&gt;jsp+java)、提供代码复用(LoginDao.java) 1234567891011public void sleep(String name,String place, int time) &#123; &#125; public void sleep(Person per) &#123; per.getName() per.getPlace() ... &#125; 数据库连接池(DBCP)maven dependncy 123456&lt;!-- https://mvnrepository.com/artifact/commons-dbcp/commons-dbcp --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334353637383940datasource.connection.driver_class=com.mysql.jdbc.Driverdatasource.connection.url=jdbc:mysql://localhost:3306/jsd06_stu?useUnicode=true&amp;characterEncoding=utf-8datasource.connection.username=rootdatasource.connection.password=1234#连接池保持的最小连接数,default : 3（建议使用）datasource.connection.minPoolSize=3#连接池中拥有的最大连接数，如果获得新连接时会使连接总数超过这个值则不会再获取新连接，而是等待其他连接释放，所以这个值有可能会设计地很大,default : 15（建议使用）datasource.connection.maxPoolSize=15#连接的最大空闲时间，如果超过这个时间，某个数据库连接还没有被使用，则会断开掉这个连接。如果为0，则永远不会断开连接,即回收此连接。default : 0 单位 s（建议使用）datasource.connection.maxIdleTime=0#连接池在无空闲连接可用时一次性创建的新数据库连接数,default : 3（建议使用）datasource.connection.acquireIncrement=3#连接池为数据源缓存的PreparedStatement的总数。由于PreparedStatement属于单个Connection,所以这个数量应该根据应用中平均连接数乘以每个连接的平均PreparedStatement来计算。同时maxStatementsPerConnection的配置无效。default : 0（不建议使用）datasource.connection.maxStatements=0#连接池为数据源单个Connection缓存的PreparedStatement数，这个配置比maxStatements更有意义，因为它缓存的服务对象是单个数据连接，如果设置的好，肯定是可以提高性能的。为0的时候不缓存。default : 0（看情况而论）datasource.connection.maxStatementsPerConnection=0#连接池初始化时创建的连接数,default : 3（建议使用）datasource.connection.initialPoolSize=3#用来配置测试空闲连接的间隔时间。测试方式还是上面的两种之一，可以用来解决MySQL8小时断开连接的问题。因为它保证连接池会每隔一定时间对空闲连接进行一次测试，从而保证有效的空闲连接能每隔一定时间访问一次数据库，将于MySQL8小时无会话的状态打破。为0则不测试。default : 0(建议使用)datasource.connection.idleConnectionTestPeriod=0#连接池在获得新连接失败时重试的次数，如果小于等于0则无限重试直至连接获得成功。default : 30（建议使用）datasource.connection.acquireRetryAttempts=30#如果为true，则当连接获取失败时自动关闭数据源，除非重新启动应用程序。所以一般不用。default : false（不建议使用）datasource.connection.breakAfterAcquireFailure=false#性能消耗大。如果为true，在每次getConnection的时候都会测试，为了提高性能,尽量不要用。default : false（不建议使用）datasource.connection.testConnectionOnCheckout=false#配置当连接池所有连接用完时应用程序getConnection的等待时间。为0则无限等待直至有其他连接释放或者创建新的连接，不为0则当时间到的时候如果仍没有获得连接，则会抛出SQLException。其实就是acquireRetryAttempts*acquireRetryDelay。default : 0（与上面两个，有重复，选择其中两个都行）datasource.connection.checkoutTimeout=30000#如果为true，则在close的时候测试连接的有效性。default : false（不建议使用）datasource.connection.testConnectionOnCheckin=false#配置一个表名，连接池根据这个表名用自己的测试sql语句在这个空表上测试数据库连接,这个表只能由c3p0来使用，用户不能操作。default : null（不建议使用）datasource.connection.automaticTestTable=c3p0TestTable#连接池在获得新连接时的间隔时间。default : 1000 单位ms（建议使用）datasource.connection.acquireRetryDelay=1000#为0的时候要求所有的Connection在应用程序中必须关闭。如果不为0，则强制在设定的时间到达后回收Connection，所以必须小心设置，保证在回收之前所有数据库操作都能够完成。这种限制减少Connection未关闭情况的不是很适用。建议手动关闭。default : 0 单位 s（不建议使用）datasource.connection.unreturnedConnectionTimeout=0#这个配置主要是为了快速减轻连接池的负载，比如连接池中连接数因为某次数据访问高峰导致创建了很多数据连接，但是后面的时间段需要的数据库连接数很少，需要快速释放，必须小于maxIdleTime。其实这个没必要配置，maxIdleTime已经配置了。default : 0 单位 s（不建议使用）datasource.connection.maxIdleTimeExcessConnections=0#配置连接的生存时间，超过这个时间的连接将由连接池自动断开丢弃掉。当然正在使用的连接不会马上断开，而是等待它close再断开。配置为0的时候则不会对连接的生存时间进行限制。default : 0 单位 s（不建议使用）datasource.connection.maxConnectionAge=0 获取数据库连接 1.使用BasicDataSource直接设置 1234567891011121314151617181920212223242526272829public class DBUtil &#123; private static BasicDataSource ds = new BasicDataSource(); static &#123; Properties p = new Properties(); try &#123; p.load(DBUtil.class.getClassLoader().getResourceAsStream(\"db.properties\")); ds.setDriverClassName(p.getProperty(\"driverClassName\")); ds.setUrl(p.getProperty(\"url\")); ds.setUsername(p.getProperty(\"username\")); ds.setPassword(p.getProperty(\"password\")); ds.setInitialSize(Integer.parseInt(p.getProperty(\"minPoolSize\"))); ds.setMaxActive(Integer.parseInt(p.getProperty(\"maxPoolSize\"))); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; return ds.getConnection(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null; &#125;&#125; 2.使用BasicDataSourceFactory生产DataSource [官方配置文件属性解释][http://commons.apache.org/proper/commons-dbcp/configuration.html] 1BasicDataSourceFactory.createDataSource(p) Creates and configures aBasicDataSourceinstance based on the given properties. 注意：properties文件可能存在多余的空格导致难以发现 12345678910driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/java_web?useUnicode=true&amp;characterEncoding=utf-8username=rootpassword=123456#连接池保持的最小连接数,default : 3（建议使用）#minPoolSize=3initialSize=3#连接池中拥有的最大连接数，如果获得新连接时会使连接总数超过这个值则不会再获取新连接，而是等待其他连接释放，所以这个值有可能会设计地很大,default : 15（建议使用）#maxPoolSizemaxActive=15 12345678910111213141516171819202122232425262728public class MyDBUtil &#123; private static DataSource dataSource; private static Properties p = new Properties(); static &#123; // 加载配置文件 try &#123; p.load(MyDBUtil.class.getClassLoader().getResourceAsStream(\"db.properties\")); // 创建一个对象并返回 dataSource = BasicDataSourceFactory.createDataSource(p); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; return dataSource.getConnection(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null; &#125;&#125; DBUtil.javaexecuteQuery:中间插入解析函数 定义： 123456789101112131415161718192021222324252627282930/** * @param 接口规定解析方法 */public interface ParseResultSet &#123; Object parse(ResultSet rs);&#125;/** * @param sql * @param parseResultSet 解析ResultSet的函数 * @param args */public static Object executeQuery(String sql, ParseResultSet parseResultSet, Object... args) &#123; Connection conn = DBUtil.getConnection(); PreparedStatement pstmt = null; ResultSet rs = null; Object parse = null; try &#123; pstmt = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; pstmt.setObject(i + 1, args[i]); &#125; rs = pstmt.executeQuery(); parse = parseResultSet.parse(rs); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; DBUtil.closeAll(rs, pstmt, conn); return parse;&#125; 调用： 123456789101112131415161718public boolean queryByNameAndPwd(String username, String password) &#123; String sql = \"SELECT COUNT(*) FROM user WHERE username=? AND `password` = ?\"; Integer result = (Integer) DBUtil.executeQuery(sql, new DBUtil.ParseResultSet() &#123; @Override public Object parse(ResultSet rs) &#123; int result = 0; try &#123; if (rs.next()) &#123; result = rs.getInt(1); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return result; &#125; &#125;, username, password); return result &gt; 0;&#125; executeUpdate 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package util;import java.io.IOException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Properties;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSourceFactory;/** * @author 11623 * */public class DBUtil &#123; private static DataSource dataSource; private static Properties p = new Properties(); static &#123; // 加载配置文件 try &#123; p.load(DBUtil.class.getClassLoader().getResourceAsStream(\"db.properties\")); // 创建一个对象并返回 dataSource = BasicDataSourceFactory.createDataSource(p); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; return dataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static int executeUpdate(String sql, Object... args) &#123; Connection conn = DBUtil.getConnection(); PreparedStatement pstmt = null; int num = 0; try &#123; pstmt = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; pstmt.setObject(i + 1, args[i]); &#125; num = pstmt.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); // exception: roll back try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; close(pstmt, conn); &#125; return num; &#125; public static void close(PreparedStatement pstmt, Connection conn) &#123; if (pstmt != null) &#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void closeAll(ResultSet rs, PreparedStatement pstmt, Connection conn) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; close(pstmt, conn); &#125; /** * @param 接口规定解析方法 */ public interface ParseResultSet &#123; Object parse(ResultSet rs); &#125; /** * @param sql * @param parseResultSet 解析ResultSet的回调函数 * @param args */ public static Object executeQuery(String sql, ParseResultSet parseResultSet, Object... args) &#123; Connection conn = DBUtil.getConnection(); PreparedStatement pstmt = null; ResultSet rs = null; Object parse = null; try &#123; pstmt = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; pstmt.setObject(i + 1, args[i]); &#125; rs = pstmt.executeQuery(); parse = parseResultSet.parse(rs); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; DBUtil.closeAll(rs, pstmt, conn); return parse; &#125; public static void main(String[] args) &#123; System.out.println(dataSource);// System.out.println(MyDBUtil.dataSource.getInitialSize());// System.out.println(MyDBUtil.dataSource.getMaxActive()); &#125;&#125; EL和JSTLELExpression Language 为了消JSP中的Java代码 ,JSP自带语法 语法： 1$&#123;EL表达式&#125; a.EL不需要导包b.在el中调用属性，其实是调用的getXxx()方法 1$&#123;范围.对象.属性.属性的属性 &#125; 1$&#123;requestScope.loginMsg&#125; 操作符：操作：属性，不是对象.: 使用方便[] : 如果是常量属性，需要使用双引号/单引号 引起来;比点操作符更加强大 []强大之处：a.可以容纳一些 特殊符号 （. ? -）b.[]可以容纳 变量属性 （可以动态赋值） 12String x = \"a\"; $&#123;requestScope.a&#125;等价于$&#123;requestScope[\"a\"]&#125;等价于$&#123;$&#123;requestScope[x]&#125; c.可以处理数组 1$&#123;requestScope.arr[0] &#125; 普通对象、map中的变量 通过EL获取JSP 九大内置对象 123$&#123;pageContext &#125; $&#123;pageContext.request &#125; $&#123;pageContext.sessoin &#125; JSTL：比EL更加强大需要引入2个jar ：jstl.jar standard.jar 123456&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 引入tablib : 1&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt; 其中prefix=&quot;c&quot;:前缀 核心标签库： 通用标签库、条件标签库 迭代标签库 通用标签库&lt;c:set&gt;赋值i:在某个作用域之中（4个范围对象），给某个变量赋值 1234567&lt;%-- request.setAttribute(\"name\", \"zhangsan\") ; --%&gt; &lt;c:set var=\"name\" value=\"zhangsan\" scope=\"request\"/&gt; $&#123;requestScope.name &#125; &lt;c:set var=\"变量名\" value=\"变量值\" scope=\"4个范围对象的作用域\"/&gt; ii:给普通对象赋值在某个作用域之中（4个范围对象），给某个对象的属性复制 （此种写法，不能指定scope属性） 1&lt;c:set target=\"$&#123;requestScope.student&#125;\" property=\"sname\" value=\"zxs\" /&gt; 给map对象赋值 12&lt;c:set target=\"$&#123;requestScope.countries&#125;\" property=\"cn\" value=\"中国\" /&gt; &lt;c:set target=\"对象\" property=\"对象的属性\" value=\"赋值\" /&gt; 注意 &lt;c:set&gt;可以给不存在的变量赋值 （但不能给不存在的对象赋值） &lt;c:out&gt;：显示true:&lt;c:out value=’百度‘ default=”当value为空的，显示的默认值” escapeXml=”true” /&gt;false： &lt;c:out value=’百度‘ escapeXml=”false” /&gt; &lt;c:remove &gt;：删除属性&lt;c:remove var=”a” scope=”request”/&gt; 选择if(boolean)单重选择&lt;c:if test=”” &gt; if else if… esle if… else /switch 123456&lt;c:choose&gt; &lt;c:when test=\"...\"&gt; &lt;/c:when&gt; &lt;c:when test=\"...\"&gt; &lt;/c:when&gt; &lt;c:when test=\"...\"&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; 在使用 test=”” 一定要注意后面是否有空格例如：test=”${10&gt;2 }” true test=”${10&gt;2 } “ 非true 循环（迭代标签库）1for(int i=0;i&lt;5;i++) 123&lt;c:forEach var=\"name\" items=\"$&#123;requestScope.names &#125;\" &gt; -$&#123;name &#125;- &lt;/c:forEach&gt; 可以在foreach便签中items属性作用域（requestScope）中保存的对象 1234&lt;!--for(String str:names)--&gt; &lt;c:forEach var=\"student\" items=\"$&#123;requestScope.students &#125;\" &gt; $&#123;student.sname &#125;-$&#123;student.sno &#125; &lt;/c:forEach&gt; 设计和架构MVC设计模式M：Model ，模型 ：一个功能。用JavaBean实现。 V: View，视图： 用于展示、以及与用户交互。使用html js css jsp jquery等前端技术实现 C:Controller，控制器 ：接受请求，将请求跳转到模型进行处理；模型处理完毕后，再将处理的结果 返回给 请求处 。 可以用jsp实现， 但是一般建议使用 Servlet实现控制器。 JSP-&gt;Java(Servlet)-&gt;JSP 三层优化1.加入接口 建议面向接口开发： 先接口-再实现类 –service、dao加入接口 –接口与实现类的命名规范 接口：interface， 起名 I实体类Service IStudentService IStudentDao 实现类：implements 起名 实体类ServiceImpl StudentServiceImpl StudentDaoImpl 接口： I实体类层所在包名 IStudentService、IStudentDao 接口所在的包： xxx.service xx.dao 123456 实现类： 实体类层所在包名Impl StudentServiceImpl、StudentDaoImpl 实现类所在的包：xxx.service.impl xx.dao.impl 以后使用接口/实现类时，推荐写法： 接口 x = new 实现类(); IStudentDao studentDao = new StudentDaoImpl(); 2.DBUtil 通用的数据库帮助类，可以简化Dao层的代码量 帮助类 一般建议写在 xxx.util包 A{ 123a()&#123; B.connection &#125; } B{ static Connection connection =.. b{ 1&#125; } 方法重构： 将多个方法 的共同代码 提炼出来，单独写在一个方法中，然后引入该方法即可 123456789101112131415161718192021a() &#123; .. c(); .. &#125; b() &#123; .. c(); .. &#125; c() &#123; [.. .. ... ..] &#125; Web调试：与java代码的调试 区别：启动方式不同 index.jsp -&gt;index_jsp.java -&gt;index_jsp.class jsp-&gt;java-&gt;classjsp翻译成的Java 以及编译后的class文件 存在于tomcat中的work目录中 10000 过滤器、上传文件、分页过滤器实现一个Filter接口init()、destroy() 原理、执行时机 同Servlet配置过滤器，类似servlet通过doFilter()处理拦截，并且通过chain.doFilter(request, response);放行 filter映射 只拦截 访问MyServlet的请求 1&lt;url-pattern&gt;/MyServlet&lt;/url-pattern&gt; 拦截一切请求（每一次访问 都会被拦截） 1&lt;url-pattern&gt;/*&lt;/url-pattern&gt; 通配符 123456dispatcher请求方式： REQUEST：拦截HTTP请求 get post FORWARD：只拦截 通过 请求转发方式的请求 INCLUDE:只拦截拦截通过 request.getRequestDispatcher(\"\").include() 、通过&lt;jsp:include page=\"...\" /&gt;此种方式发出的请求 ERROR：只拦截&lt;error-page&gt;发出的请求 过滤器中doFilter方法参数：ServletRequest在Servlet中的方法参数：HttpServletRequest 过滤器链可以配置多个过滤器，过滤器的先后顺序 是由 &lt;filter-mapping&gt;的位置 决定 上传文件 引入2个jar 12apache: commons-fileupload.jar组件 commons-fileupload.jar依赖 commons-io.jar pom.xml 12345678910111213&lt;!--文件上传jar--&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; 2.文件上传一般是存在服务器的upload目录下,文件名陈存在数据库中,为了防止上传文件重名,一般我们用UUID,(绝不会重复) 3.index.jsp页面的代码如下:前台jsp： 123456&lt;div&gt; &lt;form action=\"/UploadServlet\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件：&lt;input type=\"file\" name=\"photo\" value=\"\"&gt;&lt;br&gt; &lt;input type=\"submit\" name=\"修改\" value=\"上传头像\"&gt; &lt;/form&gt;&lt;/div&gt; 表单提交方式必须为post在表单中必须增加一个属性 entype=&quot;multipart/form-data&quot; 后台servlet： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.net.ssl.HttpsURLConnection;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import java.util.List;@WebServlet(\"/pictureServlet\")public class PictureServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); response.setContentType(\"text/plain;charset=utf-8\"); //此处将新建的文件直接保存到项目的绝对路径中。File没有读写能力。 File savePath = new File(\"E:\\\\javaEE\\\\Project\\\\Picture\\\\web\\\\images\"); DiskFileItemFactory factory = new DiskFileItemFactory();//jar包的类 ServletFileUpload upload = new ServletFileUpload(factory);//jar包的类 try &#123; List&lt;FileItem&gt; items = upload.parseRequest(request); //将前端的表单数据封装成list。 //form表单必须加enctype=\"multipart/form-data\"，在使用包含文件上传控件的表单时，必须使用该值。 for (FileItem item:items)&#123; if(item.isFormField())&#123; //说明普通表单项 &#125;else &#123; //说明上传文件项 //获取上传文件的名称 String name = item.getName(); //获取相对路径 String path = request.getContextPath()+\"/images/\"+name; //将相对路径保存到数据库 Test test = new Test(); test.update(path); //使用绝对路径完成文件上传 item.write(new File(savePath,name)); //删除临时文件 item.delete(); &#125; &#125; &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; ​ 注意的问题： 上传的目录 upload ： 1.如果修改代码，则在tomcat重新启动时 会被删除 原因：当修改代码的时候,tomcat会重新编译一份class 并且重新部署（重新创建各种目录） 122.如果不修改代码，则不会删除 原因： 没有修改代码，class仍然是之前的class 因此，为了防止 上传目录丢失： a.虚拟路径 b.直接更换上传目录 到非tomcat目录 限制上传： 类型、 大小 注意 对文件的限制条件 写再parseRequest之前 2.下载：不需要依赖任何jar a.请求（地址a form），请求Servlet b.Servlet通过文件的地址 将文件转为输入流 读到Servlet中 c.通过输出流 将 刚才已经转为输入流的文件 输出给用户 注意：下载文件 需要设置2个 响应头：response.addHeader(“content-Type”,”application/octet-stream” );//MIME类型:二进制文件（任意文件）response.addHeader(“content-Disposition”,”attachement;filename=”+fileName );//fileName包含了文件后缀：abc.txt 1.下载时 ，文件名乱码问题：edge： URLEncoder.encode(fileName,”UTF-8”) firefox：给文件名 加：前缀 =?UTF-8?B? String构造方法Base64.encode后缀 ?=示例： 1response.addHeader(\"content-Disposition\",\"attachment;filename==?UTF-8?B?\"+ new String( Base64.encodeBase64(fileName.getBytes(\"UTF-8\")) ) +\"?=\" );//fileName包含了文件后缀：abc.txt 分页5变量（属性） 1.数据总数 （select count(*) from xxx ， 查数据库）2.页面大小（页面容量，每页显示的数据条数） （用户自定义）3.总页数 （自动计算） 800:10= 80页 总页数= 数据总数 /页面大小 12345802:10= 800/10 +1 ； 总页数= 数据总数 /页面大小 + 1; --&gt;通式 总页数= 数据总数 % 页面大小==0 ?数据总数 /页面大小:数据总数 /页面大小 + 1; 注意：自动计算的时机：当 数据总数 和 页面大小都被赋值以后，自动计算总页数。 4.当前页码 （用户自定义） 5.实体类对象集合（当前页的数据集合）：依赖于数据库 (查数据库) 假设： 每页显示10条（页面大小=10） 1select * from student where id&gt;=起始 and id&lt;=终止; 页数 起止 起止等价写法1 1-10 (页数-1)10+1-页数102 11-203 21-30 某一页的数据 起止： 1(页数-1)*10+1-页数*10 1select * from student where sno&gt;=(页数-1)*10+1 and sno&lt;=页数*10; 此种分页SQL 严格依赖sno的数据， 一旦sno出现了间隙（裂缝），则无法满足每页10条 -&gt;将此SQL 转换： 1.有rownum 2不能有rownum&gt;xx转换的核心： 将rownum从伪列 转换为 一个 临时表的 普通列。 123456select *from ( select rownum r,t.*from (select s.* from student s order by sno asc) t ) where r&gt;=(页数-1)*10+1 and r&lt;=页数*10; 优化： 123456select *from ( select rownum r,t.*from (select s.* from student s order by sno asc) t where rownum&lt;=页数*页面大小 ) where r&gt;=(页数-1)*页面大小+1 ; dao和DBUtil的区别：dao 是处理特定 类的 数据库操作类：DBUtil是通用 数据库操作类 分页实现要实现分页，必须知道 某一页的 数据 从哪里开始 到哪里结束 页面大小：每页显示的数据量 假设每页显示10条数据 mysql分页mysql:从0开始计数0 0 91 10 19 n n*10 (n+1)*10-1 MYSQL实现分页的sqllimit 开始,多少条第1页 1select * from student limit 0,10 ; 第2页 1select * from student limit 10,10 ; mysql的分页语句： 1select * from student limit （页数-1）*页面大小,页面大小 oracle分页sql server/oracle:从1开始计数 : (n-1)*10+1 --- n*10 第n页 开始 结束1 1 102 11 203 21 30n (n-1)10+1 n10 1select *from student where sno &gt;=(n-1)*10+1 and sno &lt;=n*10 ; --此种写法的前提：必须是Id连续 ，否则 无法满足每页显示10条数据 1select rownum,t.*from student t where rownum &gt;=(n-1)*10+1 and rownum &lt;=n*10 order by sno; 如果根据sno排序则rownum会混乱（解决方案：分开使用-&gt;先只排序，再只查询rownum） .rownum不能查询&gt;的数据 12345select s.* from student s order by sno asc; select rownum, t.* from (select s.* from student s order by sno asc) t where rownum &gt;=(n-1)*10+1 and rownum &lt;=n*10 ; oracle的分页查询语句： 123456select *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t 10000 ) where r&gt;=(n-1)*10+1 and &lt;=n*10 ; 优化： 123456789101112131415select *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t where rownum&lt;=n*10 ) where r&gt;=(n-1)*10+1 ; select *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t where rownum&lt;=页数*页面大小 ) where r&gt;=(页数-1)*页面大小+1 ; SQLServer分页 3种分页sqlrow_number() over(字段) ; sqlserver2003:top –此种分页SQL存在弊端（如果id值不连续，则不能保证每页数据量相等）select top 页面大小 * from student where id not in( select top (页数-1)*页面大小 id from student order by sno asc ) sqlserver2005之后支持： 123select *from ( select row_number() over (sno order by sno asc) as r,* from student 1where r&lt;=n*10 123) where r&gt;=(n-1)*10+1 and ; SQLServer此种分页sql与oralce分页sql的区别： 1.rownum ，row_number() 2.oracle需要排序（为了排序，单独写了一个子查询），但是在sqlserver 中可以省略该排序的子查询 因为sqlserver中可以通过over直接排序 sqlserver2012之后支持： 1234offset fetch next only select * from student oreder by sno offset (页数-1)*页面大小+1 rows fetch next 页面大小 rows only ; (n-1)10+1 — n10 mysql从0开始计数，Oracle/sqlserver 从1开始计数 分页实现5个变量（属性）1.数据总数(查数据库) 1select count(*).. 2.页面大小（每页显示的数据条数）20 (用户自定义)3.总页数 （程序自动计算） 总页数 = 100/20 =数据总数/页面大小 总页数 = 103/20 = 数据总数/页面大小+1 —&gt; 1总页数 = 数据总数%页面大小==0 ? 数据总数/页面大小:数据总数/页面大小+1 ; 4.当前页（页码） （用户自定义）5.当前页的对象集合（实体类集合）：每页所显示的所有数据 （10个人信息）List&lt;Student&gt; (查数据库,分页sql) web路径 web路径：1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名;就是http//localhost/端口号/crud/… 1234&lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath()); %&gt; $&#123;APP_PATH&#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css --&gt;","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"}]},{"title":"javaSE","slug":"java-note/javaSE/javaSE","date":"2019-10-12T02:32:06.000Z","updated":"2022-04-07T15:18:18.270Z","comments":true,"path":"2019/10/java-note/javaSE/javaSE/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/javaSE/javaSE/","excerpt":"[TOC]java控制台执行可以直接编译＋运行 1java Create.java基础类型int主要是有符号整数在计算机中存储采用的补码在java（任何 32 位字节存储整数的系统）中 -(-2147483648)==(-2147483648)，即1Integer.MIN_VALUE = -Integer.MIN_VALUE","text":"[TOC]java控制台执行可以直接编译＋运行 1java Create.java基础类型int主要是有符号整数在计算机中存储采用的补码在java（任何 32 位字节存储整数的系统）中 -(-2147483648)==(-2147483648)，即1Integer.MIN_VALUE = -Integer.MIN_VALUE 字符串String特点String内容不可改变 字符串常量就是String的匿名对象 所谓的直接赋值实际上就是相当于将一个匿名对象设置了一个名字而已 String类的匿名对象是由系统自动设置，而不是有用户自己定义的String当做参数传递没有改变，是因为新的String通过赋值指向了新的对象，所以对传入的String没有影响 修改类StringBuffer StringBuffer的内容可以修改 方法： public StringBuffer reverse() append insert delete 线程安全的，都是同步方法和String一样都实现了CharSequence接口StringBulid 是StringBuffer基本一样 线程不安全的 两种实例化方式直接赋值new构造方法 其内容不会保存在对象池中 使用new关键字，在堆上开辟一个内存 手动入池 public native String intern(); 容易找出空间浪费，不建议使用 常用类数字类大数类大整数类BigIntegerString构造方法 public BigInteger(String val) 大浮点数BigDecimal构造方法 String构造方法 double构造方法可实现准确的四舍五入操作 public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 除以1实现四舍五入 divide(new BigDecimal(1),scale,BigDecimal.ROUND_HALF_UP) round(new MathContext(setPrecision, RoundingMode.HALF_UP)) MathContext构造方法默认四舍五入 setScale(newScale, RoundingMode.HALF_UP) 小数位后保留 Math类 Math类里面提供的方法都是static方法，Math类里面都没有普通方法四舍五入round public static long round(double a) 如果负数进行四舍五入时，大于-0.5才为-1 JDBC1、加载数据库驱动 E:\\app\\test\\product\\11.2.0\\dbhome_1\\jdbc\\lib\\ojdbc6.jar Oracle驱动类：oracle.jdbc.dirver.OracleDrive 连接oracle 驱动程序下载oracle自带有 加载驱动类class.forName(“oracle.jdbc.dirver.OracleDrive”) 2、建立数据库连接 DriverManager.getConnection(url, user, password) 数据库链接地址（URL） oracle jdbc：oracle:连接方式：主机名称：端口号：数据库的SID（Security Identifier） 连接本机的mldn数据库： jdbc:oracle:thin:@localhost:1521:mldnjava之中所有的数据库操作类和接口在java.sql数据库驱动程序有数据库生成商提供JDBC在实现数据库驱动连接对象使用工厂设计设计模式，而DriverManager就是工厂类 所以客服端调用连接时，隐藏子类的具体连接实现 正则表达式Pattern类 获得此类对象必须通过Compile()方法，编译正则表达式 12Pattern p = Pattern.compile(\"\\\\d+\");Matcher m = p.matcher(fileName); Matcher类Pattern类获得 1package java.util.regex; name description public int start() 字符串的正则运用12345matches()：正则验证 replaceAll(String regex, String replacement):全部替换 replaceFirst(String regex, String replacement)：替换首个 split(String regex) ：全部拆分 split(String regex, int limit)：部分拆分 正则标记都在Pattern类定义 单个字符（匹配数量1）1234字符：由一个字符组成 '\\\\', 转移字符'\\' '\\t'制表符 '\\n' 换行符 字符集（数量1）[],字符集 [abc]表示字符a、b和c中的任意一个（或的关系）[ ^abc]表示不是abc中任意一个（^非的关系） [x-y] x的ascii到y的ascii码之间的值 [a-z]所有小写字母（也可以[e-i]) [a-zA-Z]任意字母 [0-9]任意一位数字 也可以组合使用，如[A-Z_]表示大写字母+_ 简化字符表达式（数量1） . :任意一位字符 \\w ,(word): == [a-zA-Z_0-9] 匹配包括下划线的任何单词字符 12//usagePattern.compile(\"\\\\w+\\\\.\"); \\W,匹配任何非单词字符 : = [ ^a-zA-Z_0-9] \\W 除了字母、数字、_ [ ^A-z0-9_] \\d： =[0-9] (d-&gt;digit) 任意的数字 \\D : = [ ^0-9] ， 除了数字 \\s: (s-&gt;space) 任意空白字符，如’\\t’,’\\n’ \\S: 任意非空白字符 \\b (b-&gt; boundary)单词边界 \\B 除了单词边界 小写字母包括，大写字母取反。 边界表达式（不要在java中用，javaScript中用） ^:正则开始 $:正则结束 数量表达式正则{n}：表示正则正好出现n次正则{n,}：表示正则出现n次及以上正则{n,m}：表示正则出现{n,m}次正则？：== {0,1}，表示正则可以出现0次或1次正则*：== {0,} 表示正则可以出现0次或1次或多次， &gt;= 0正则+：=={1,} 表示正则可以出现1次或1次以上 ，&gt;=1 逻辑表达式正则1正则2：判断第一个完成以后再判断第二个正则 ,如AB 正则1|正则2：两个正则的或 （正则）：将多个正则作为一组，可以为这一组单独设置次数注解 注解，Annotation3个最常用的基础注解 声明覆写操作@Override 明确告诉编译器覆写，如果没有覆写成功则会报错 声明过期操作@desperated 压制警告@SupperssWarming 更多详见：24 注解,Annotations 多线程实现 Thread实现 Runnable接口实现，能多继承 Thread类有Runnable的构造函数 Callable泛型接口实现，能有返回值 Thread类没有Callable的构造函数 FutureTask类负责接收call方法的返回值（接收Callable构造），实现RunnableFuture接口，RunnableFuture接口实现了Runnable接口、Future接口的get方法（负责接收返回值） 需要重写run方法，start开始 不用run方法是因为需要判断线程是否重复启动，并且需要不同操作系统提供start0的资源调配方法休眠Sleep（Thread） 几个线程一起休眠感觉是一起结束（时间长)，当是结束之后还是要抢占资源（时间短）,顺序是不固定的优先级 优先级越高，越有可能抢占到资源，越有可能执行同步synchronized 同步代码块 同步方法public synchronized 返回值等待wait(Object类） notify唤醒 对象克隆如果没有实现Cloneable的接口会上抛一个异常Cloneable接口 没有方法和全局常量 此为标识接口，表示一种能力需要覆写Object类的clone方法 protected native Object clone() throws CloneNotSupportedException; 反射“反”通过对象找到类的出处java.lang.Class反射的源头 三种实例化方式第一种：调用Object类中的getClass() 需要对象实例化第二种：类.class属性 不需要对象实例化，需要import Spring、Hibernate第三种：Class提供的forName()方法 不需要import导入类，类用String描述 1public static Class&lt;?&gt; forName(String className) 123456// 通过Class.forName方式Class feeClass = null;try &#123; feeClass = Class.forName(\"pojo.Fee\");&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); 获取属性1234// 获取属性 Field[] field01 = clazz.getFields(); // 返回属性为public的字段 Field[] field02 = clazz.getDeclaredFields(); // 返回所有的属性 Field field03 = clazz.getDeclaredField(\"id\"); // 获取属性为id的字段 Field方法:12String name = field.getName();Class&lt;?&gt; type = field.getType(); 123456789// 获取对象属性Fields[] fields = clazz.getDeclaredFields();for(Field field: fields)&#123; String name = field.getName(); field.setAccessible(true); // 私有属性必须设置访问权限 Object resultValue = field.get(obj); // 这里可以编写你的业务代码 System.out.println(name + \": \" + resultValue);&#125; 获取方法123// 获取普通方法 Method[] Method01 = clazz.getDeclaredMethods(); // 返回public方法 Method method = clazz.getDeclaredMethod(\"getId\", null); // 返回getId这个方法，如果没有参数，就默认为null Method使用 1method.invoke(obj, new Object[]&#123;&#125;); obj: 调用方法的对象 the object the underlying method is invoked from 1Method method = clazz.getMethod(methodName, new Class[]&#123;&#125;); 方法名+参数列表找到指定方法 1234567891011121314Object obj = clazz.newInstance();// 获取对象属性Fields[] fields = clazz.getDeclaredFields();for(Field field: fields)&#123; String fieldName = field.getName(); String upperChar = fieldName.substring(0,1).toUpperCase(); String anotherStr = fieldName.substring(1).; String methodName = \"get\" + upperChar + anotherStr; Method method = clazz.getMethod(methodName, new Class[]&#123;&#125;); method.setAccessiable(true); Object resultValue = method.invoke(obj, new Object[]&#123;&#125;); // 这里可以编写你的业务代码 System.out.println(fieldName + \": \" + resultValue);&#125; 反射对象实例化 Class类的无参构造方法：public T newInstance() new是耦合的主要元凶，当出现高耦合时大多数时能用反射降低 工厂模式构造方法调用 最好保留无参构造方法，以便构造 取得指定构造方法 public Constructor getConstructor(Class... parameterTypes) public类型构造方法 public Constructor getDeclaredConstructor(Class… parameterTypes) 所有构造方法 取得一些构造方法 函数式编程（Lambda）、流式编程函数式接口java.util.function 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。这主要是因为基本类型会产生一小部分接口。 如果你了解命名模式，顾名思义就能知道特定接口的作用。 以下是基本命名准则： 如果只处理对象而非基本类型，名称则为 Function，Consumer，Predicate 等。参数类型通过泛型添加。 如果接收的参数是基本类型，则由名称的第一部分表示，如 LongConsumer，DoubleFunction，IntPredicate 等，但基本 Supplier 类型例外。 如果返回值为基本类型，则用 To 表示，如 ToLongFunction &lt;T&gt; 和 IntToLongFunction。 如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 UnaryOperator，两个参数使用 BinaryOperator。 如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。 如果接收的两个参数类型不同，则名称中有一个 Bi。 下表描述了 java.util.function 中的目标类型（包括例外情况）： 特征 函数式方法名 示例 无参数； 无返回值 Runnable (java.lang) run() Runnable 无参数； 返回类型任意 Supplier get() getAs类型() Supplier&lt;T&gt; BooleanSupplier IntSupplier LongSupplier DoubleSupplier 无参数； 返回类型任意 Callable (java.util.concurrent) call() Callable&lt;V&gt; 1 参数； 无返回值 Consumer accept() Consumer&lt;T&gt; IntConsumer LongConsumer DoubleConsumer 2 参数 Consumer BiConsumer accept() BiConsumer&lt;T,U&gt; 2 参数 Consumer； 1 引用； 1 基本类型 Obj类型Consumer accept() ObjIntConsumer&lt;T&gt; ObjLongConsumer&lt;T&gt; ObjDoubleConsumer&lt;T&gt; 1 参数； 返回类型不同 Function apply() To类型 和 类型To类型 applyAs类型() Function&lt;T,R&gt; IntFunction&lt;R&gt; LongFunction&lt;R&gt; DoubleFunction&lt;R&gt; ToIntFunction&lt;T&gt; ToLongFunction&lt;T&gt; ToDoubleFunction&lt;T&gt; IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 1 参数； 返回类型相同 UnaryOperator apply() UnaryOperator&lt;T&gt; IntUnaryOperator LongUnaryOperator DoubleUnaryOperator 2 参数类型相同； 返回类型相同 BinaryOperator apply() BinaryOperator&lt;T&gt; IntBinaryOperator LongBinaryOperator DoubleBinaryOperator 2 参数类型相同; 返回整型 Comparator (java.util) compare() Comparator&lt;T&gt; 2 参数； 返回布尔型 Predicate test() Predicate&lt;T&gt; BiPredicate&lt;T,U&gt; IntPredicate LongPredicate DoublePredicate 参数基本类型； 返回基本类型 类型To类型Function applyAs类型() IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 2 参数类型不同 Bi操作 (不同方法名) BiFunction&lt;T,U,R&gt; BiConsumer&lt;T,U&gt; BiPredicate&lt;T,U&gt; ToIntBiFunction&lt;T,U&gt; ToLongBiFunction&lt;T,U&gt; ToDoubleBiFunction&lt;T&gt; 此表仅提供些常规方案。通过上表，你应该或多或少能自行推导出更多行的函数式接口。 可以看出，在创建 java.util.function 时，设计者们做出了一些选择。 例如，为什么没有 IntComparator，LongComparator 和 DoubleComparator 呢？有 BooleanSupplier 却没有其他表示 Boolean 的接口；有通用的 BiConsumer 却没有用于 int，long 和 double 的 BiConsumers 变体（我对他们放弃的原因表示同情）。这些选择是疏忽还是有人认为其他组合的使用情况出现得很少（他们是如何得出这个结论的）？ 流常用处理方法匹配，遍历中遇到function返回true中断 anyMatch anyMatch(Predicate)：如果流中的任意一个元素根据提供的 Predicate 返回 true 时，结果返回为 true。这个操作将会在第一个 true 之后短路；也就是不会在发生 true 之后继续执行计算。 forEach 遍历，全部遍历，不能中断 itearte 自定义序列 根据第一的seed参数应用于第二个function产生序列 1public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) &#123; Returns an infinite sequential ordered Stream produced by iterativeapplication of a function f to an initial elementseed, producing a Stream consisting ofseed, f(seed), f(f(seed)), etc. 1234List&lt;String&gt; list = java.util.Arrays.asList(\"a\",\"b\",\"c\");Stream.iterate(0, i -&gt; i + 1).limit(list.size()).forEach(i -&gt; &#123; System.out.println(String.valueOf(i) + list.get(i));&#125;); 流元素排序sorted()的默认比较器 12Stream&lt;T&gt; sorted();Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator); 1sorted(Comparator.reverseOrder()) 共享设计模式在JVM的底层实际上会存在有一个对象池（不一定只保存String），当String通过直接赋值创建一个String类对象时，会将此匿名对象如此保存，而后若果有新的String通过直接复制并且赋值内容和之前入池的相同，则不会开辟新的堆内存，而是使用之前对象池的引用。 4种代码块1、普通代码块 代码块写在了方法里面 改变变量作用域，能防止重名？（但是什么没有）2、构造块 代码写在了类里 构造块优先于构造块执行，每次构造执行一次（没什么用）3、静态代码块 非主类 主类 静态块在主方法前运行 为了静态变量的初始化，一个类只执行一次（也没什么用）4、同步代码块 多线程同步使用尽量不要使用代码块 io流transientjava语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程。 Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"}]},{"title":"jquery","slug":"js-note/jquery/jquery","date":"2019-10-12T02:25:41.000Z","updated":"2021-10-23T02:19:04.229Z","comments":true,"path":"2019/10/js-note/jquery/jquery/","link":"","permalink":"https://codeofli.github.io/2019/10/js-note/jquery/jquery/","excerpt":"[TOC]jQuery入口函数jQuery与JavaScript加载模式对比 多个window.onload只会执行一次, 后面的会覆盖前面的 12345678&lt;script&gt; window.onload = function () &#123; alert(\"hello lnj1\"); // 不会显示 &#125; window.onload = function () &#123; alert(\"hello lnj2\"); // 会显示 &#125;&lt;/script&gt;","text":"[TOC]jQuery入口函数jQuery与JavaScript加载模式对比 多个window.onload只会执行一次, 后面的会覆盖前面的 12345678&lt;script&gt; window.onload = function () &#123; alert(\"hello lnj1\"); // 不会显示 &#125; window.onload = function () &#123; alert(\"hello lnj2\"); // 会显示 &#125;&lt;/script&gt; 多个$(document).ready()会执行多次,后面的不会覆盖前面的 12345678&lt;script&gt; $(document).ready(function () &#123; alert(\"hello lnj1\"); //会显示 &#125;); $(document).ready(function () &#123; alert(\"hello lnj2\"); // 会显示 &#125;);&lt;/script&gt; 不会覆盖的本质(了解,后面jQuery原理会详细讲解) jQuery框架本质是一个闭包,每次执行我们都会给ready函数传递一个新的函数,不同函数内部的数据不会相互干扰 1234567891011121314151617181920212223242526&lt;script&gt; // 相当于这样写 var test1 = function () &#123; alert(\"hello lnj1\"); &#125; var test2 = function () &#123; alert(\"hello lnj2\"); &#125; $(document).ready(test1); $(document).ready(test2);&lt;/script&gt;&lt;script&gt; var test3 = function () &#123; var abc = \"123\";// 因为在同一个函数中,所以456覆盖123// var abc = \"456\"; alert(abc); &#125; test3(); var test4 = function () &#123; // 因为在不同函数中,所以不会影响 var abc = \"456\"; alert(abc); &#125; test4();&lt;/script&gt; window.onload $(document).ready() 执行时机 必须等待网页全部加载完毕(包括 图片等),然后再执行包裹代码 只需要等待网页中的DOM结构 加载完毕,就能执行包裹的代码 执行次数 只能执行一次,如果第二次,那么 第一次的执行会被覆盖 可以执行多次,第N次都不会被上 一次覆盖 简写方案 无 $(function () { }); 为什么我们能访问$符号? 因为$符号jQuery框架对外暴露的一个全局变量 JavaScript中如何定义一个全局变量? 所有全局变量是 window 对象的属性 1234567891011 function test () &#123; var customValue = 998; alert(customValue);// 1.没有如下代码customValue就不是一个全局变量,函数执行完毕之后// customValue会被自动释放,test函数以外的地方访问不到customValue// 2.加上如下代码之后customValue就会变成一个全局变量,函数执行完毕也不// 会被释放,test函数以外的地方可以访问customValue// window.customValue = customValue; &#125; test(); alert(customValue); 所以jQuery框架源码实现 1window.jQuery = window.$ = jQuery; 所以想要使用jQuery框架只有两种方式,一种是通过$,一种是通过jQuery jQuery入口函数的其它编写方式如下 12345&lt;script&gt; jQuery(function () &#123; alert(\"hello lnj\"); &#125;);&lt;/script&gt; 123456789101112131415161718&lt;script&gt; // 方式一 $(document).ready(function () &#123; alert(\"hello lnj\"); &#125;); // 方式二 $(function () &#123; alert(\"hello lnj\"); &#125;); // 方式三 jQuery(document).ready(function () &#123; alert(\"hello lnj\"); &#125;); // 方式四 jQuery(function () &#123; alert(\"hello lnj\"); &#125;);&lt;/script&gt; 解决$符号冲突问题 为什么是window.jQuery = window.$ = jQuery;,而不是window.jQuery = jQuery; jQuery框架之所以提供了jQuery访问还提供$访问,就是为了提升开发者的编码效率 $符号冲突怎么办? 很多js的框架都提供了类似jQuery这样的便捷访问方式,所以很有可能某一天我们在使用多个框架的时,多个框架作者提供的便捷访问方式冲突(A框架通过$访问,B框架也通过$访问) ***释放$使用权 当便捷访问符号发生冲突时,我们可以释放$使用权, 释放之后只能使用jQuery 12345678&lt;script&gt; // 在使用jQuery之前指定自定义符号 jQuery.noConflict(); // 使用 jQuery jQuery(\"div p\").hide(); // 使用其他库的 $() $(\"content\").style.display = 'none';&lt;/script&gt; 自定义便捷访问符号 当便捷访问符号发生冲突时,我们可以自定义便捷访问符号 12345678&lt;script&gt; // 在使用jQuery之前指定自定义符号 var nj = jQuery.noConflict(); // 和使用$一样通过自定义符号调用jQuery nj(function () &#123; alert(\"hello lnj\"); &#125;);&lt;/script&gt; 核心函数和静态方法jQuery核心函数 从jQuery文档中可以看出,jQuery核心函数一共3大类4小类 jQuery(callback) 当DOM加载完成后执行传入的回调函数 12345&lt;script&gt; $(function () &#123; alert(\"123\"); &#125;);&lt;/script&gt; jQuery([sel,[context]]) 接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素,并包装成jQuery对象 1234567891011&lt;script&gt; $(function () &#123; // 利用jquery获取所有div,得到的是一个jQuery对象 var $box = $(\"div\"); console.log($box); // 利用js原生语法获取所有div,得到的是一个js对象 var box = document.getElementsByTagName(\"div\"); console.log(box); &#125;);&lt;/script&gt; 原生JS对象和jQuery对象相互转换 1234567891011121314151617181920212223&lt;script&gt; $(function () &#123; var $box = $(\"#box\");// $box.text(\"新的数据\");// jQuery对象不能使用原生js对象的方法// $box.innerText = \"新的数据\";// 将jQuery对象转换为原生js对象// 注意: 不是eq(0),eq函数返回的是jQuery类型对象,get函数返回的是原生类型对象// var box = $box.get(0); var box = $box[0]; box.innerText = \"新的数据\"; var box2 = document.getElementById(\"box\");// 原生js对象不能使用jQuery对象的方法// box2.text(\"新的数据2\");// 原生js对象只能使用原生的js方法// box2.innerText = \"新的数据2\";// 将原生js对象转换为jQuery对象 var $box2 = $(box); $box2.text(\"新的数据2\"); &#125;);&lt;/script&gt; Tips:为了方便开发者之间沟通和阅读,一般情况下所有jQuery操作相关的变量前面加上$ jQuery(html,[ownerDoc]) 根据 HTML 标记字符串，动态创建DOM 元素 123456789&lt;script&gt; $(function () &#123; var $eles = $(\"&lt;p&gt;我是span&lt;/p&gt;&lt;u&gt;我是u&lt;/u&gt;\"); // 无论是jQuery找到的还是创建的,我们最终拿到的永远都是jQuery对象 console.log($eles); // 将创建好的DOM元素添加到body中 $(\"body\").append($eles); &#125;);&lt;/script&gt; jQuery对象 jQuery对象的本质是什么? jQuery对象的本质是一个伪数组 12345var $div = $(\"div\");console.log($div);var arr = [1, 3, 5];console.log(arr); 什么是伪数组? 有0到length-1的属性 并且有length属性 1var obj = &#123;0:\"lnj\", 1:\"33\", 2:\"male\", length: 3&#125; jQuery静态方法 什么是静态方法? 静态方法对应的是对象方法,对象方法用实例对象调用,而静态方法用类名调用 1234567891011121314151617 &lt;script&gt; window.onload = function () &#123; function AClass()&#123;&#125; AClass.staticMethof = function()&#123; alert('静态方法'); &#125; AClass.prototype.instaceMethod = function()&#123; alert('实例方法'); &#125; //静态方法用类名直接调用 AClass.staticMethof(); //实例方法必须用类的实例对象调用 var instace = new AClass(); instace.instaceMethod(); &#125;&lt;/script&gt; jQuery.holdReady(hold) 暂停或者恢复jQuery.ready()事件 传入true或false 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;04-jQuery静态方法&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; // 使用$直接调用,是静态方法 $.holdReady(true); $(function () &#123; $(\"#first\").click(function () &#123; alert(\"我是你想要的弹窗\"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=\"first\"&gt;点击测试弹出&lt;/button&gt;&lt;button id=\"second\"&gt;解除延迟&lt;/button&gt;&lt;script&gt; $(\"#second\").click(function()&#123; $.holdReady(false); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $.each(object,[callback]) 遍历对象或数组 优点统一遍历对象和数组的方式 回调参数的顺序更符合我们的思维模式 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; $(function () &#123; // 3.1遍历数组 var arr = [1, 3, 5, 7, 9]; // 3.1.1通过原生方法遍历数组 // 第一个回调函数参数是遍历到的元素 // 第二个回调函数参数是当前遍历的索引 // 返回值: 没有返回值 var res = arr.forEach(function (ele, idx) &#123; console.log(idx, ele); &#125;); console.log(res); // 3.1.2通过jQuery静态方法遍历数组 // 第一个回调函数参数是当前遍历的索引 // 第二个回调函数参数是遍历到的元素 // 返回值: 被遍历的数组 var $res2 = $.each(arr, function (idx, ele) &#123; console.log(idx, ele); &#125;); console.log($res2); // 3.2遍历对象 var obj = &#123;name: \"lnj\", age:\"33\", gender:\"male\"&#125;; // 3.2.1js对象没有forEach方法,所以通过forin方法遍历对象 for(var key in obj)&#123; console.log(key, obj[key]); &#125; // 3.2.2通过jQuery静态方法遍历对象 $.each(obj,function (key, value) &#123; console.log(key, value); &#125;); &#125;); &lt;/script&gt; $.map(arr|obj,callback) 遍历对象或数组,将回调函数的返回值组成一个新的数组返回 1234567891011121314151617181920212223242526272829303132333435363738$(function () &#123; // 4.1遍历数组 var arr = [1, 3, 5, 7, 9]; // 4.1.1通过原生方法遍历数组 // 第一个回调函数参数是遍历到的元素 // 第二个回调函数参数是当前遍历的索引 // 第三个回调函数参数是当前被遍历的数组 // 返回值: 将回调函数返回值收集起来组成一个新的数组 var res = arr.map(function (ele, idx, arr) &#123; console.log(idx, ele, arr); return ele + idx; &#125;); console.log(res); // 4.1.2通过jQuery静态方法遍历数组 // 第一个回调函数参数是遍历到的元素 // 第二个回调函数参数是当前遍历的索引 // 返回值: 将回调函数返回值收集起来组成一个新的数组 var $res2 = $.map(arr, function (ele,idx) &#123; console.log(idx, ele); return ele + idx; &#125;); console.log($res2); // 4.2遍历对象 var obj = &#123;name: \"lnj\", age:\"33\", gender:\"male\"&#125;; /* obj.map(function (ele, idx, obj) &#123; // 报错,原生JS没有map方法 console.log(idx, ele, obj); &#125;); */ var $res = $.map(obj, function (value, key) &#123; console.log(key, value); return key + value; &#125;); console.log($res);&#125;); $.trim(str) 去掉字符串起始和结尾的空格。 12345678&lt;script&gt; $(function () &#123; var str = \" lnj \"; console.log(\"---\"+str+\"---\"); var $res = $.trim(str); console.log(\"---\"+$res+\"---\"); &#125;);&lt;/script&gt; $.isArray(obj) 判断是否是数组 123456789101112&lt;script&gt; $(function () &#123; // 对象 var obj = &#123;name:\"lnj\",age: \"33\", gender:\"male\"&#125;; // 真数组 var arr = [1, 3, 5, 7, 9]; var $res = $.isArray(obj); console.log($res);// false var $res2 = $.isArray(arr); console.log($res2);// true &#125;);&lt;/script&gt; $.isFunction(obj) 判断是否是函数 jQuery框架本质是一个匿名函数 12345678910111213141516171819&lt;script&gt; $(function () &#123; var obj = &#123;name:\"lnj\",age: \"33\", gender:\"male\"&#125;; var arr = [1, 3, 5, 7, 9]; var fn = function () &#123;&#125; var $res = $.isFunction(obj); console.log($res);// false $res = $.isFunction(arr); console.log($res); $res = $.isFunction(fn); console.log($res); // 通过该方法验证了我们前面所说的,jQuery框架本质是一个匿名函数 (function(window,undefined)&#123; xxxx.... &#125;)(window); $res = $.isFunction($); console.log($res); &#125;);&lt;/script&gt; $.isWindow(obj) 判断是否是window对象 12345678910111213&lt;script&gt; $(function () &#123; var obj = window; var arr = [1, 3, 5, 7, 9]; var arrlike = &#123;0:\"zs\", 1:\"ls\", length:2&#125;; var $res = $.isWindow(obj); console.log($res); // true $res = $.isWindow(arr); console.log($res); // false $res = $.isWindow(arrlike); console.log($res); // false &#125;);&lt;/script&gt; 为什么要讲解以上极度简单的工具方法? 江哥提示: 这是为后面放大招做铺垫,一定要认真记住以上方法哦 基础选择器 视频参考第十章-CSS选择器 选择器 名称 描述 返回 示例 #id id选择器 根据给定的id匹配一个元素 单个元素 $(“#box”);选取id为box元素 .class 类选择器 根据给定的类名匹配元素 集合元素 $(“.box”);选取所有类名为box元素 element 元素选择器 根据给定的元素名称匹配元素 集合元素 $(“p”);选取所有元素 * 通配符选择器 匹配所有元素 集合元素 $(“*”);选取所有元素 selector1,selector2,selectorN 并集选择器 将所有选择器匹配到的元素合并后一起返回 集合元素 $(“div,p,.box”);选取所有元素,所有元素和所有类名为box元素 层次选择器 选择器 名称 描述 返回 示例 $(“ancestor descendant”) 后代选择器 选取ancestor元素的所有descendant后代标签(不光是儿子,包括孙子/重孙子等) 集合元素 $(“div span”);选取元素里所有的元素 $(“parent &gt; child”) 子元素选择器 找到选取parent 元素中所有直接子元素child(只有儿子,不包括孙子/重孙子等) 集合元素 $(“div&gt;span”);选取元素下元素名称是的子元素 $(“prev + next”) 相邻兄弟选择器 选取prev元素后面紧跟的那个next元素 集合元素 $(“.one+div”);选取类名为one的下一个同级的元素 $(“prev ~ siblings”) 通用兄弟选择器 选取prev元素后面的所有next元素 集合元素 $(“#two~div”);选取id名为two元素后面所有同级的元素 序选择器 视频参考第十章-CSS选择器 如上内容不再一一赘述,观看第十章-CSS选择器,使用时查询文档即可 做开发是脑力活,我们需要掌握的是解决问题的方法,而不是死记硬背 属性选择器 视频参考第十章-CSS选择器 如上内容不再一一赘述,观看第十章-CSS选择器,使用时查询文档即可 做开发是脑力活,我们需要掌握的是解决问题的方法,而不是死记硬背 内容过滤选择器 选择器 描述 返回 :empty 选取不包含子元素或文本为空的元素 集合元素 :parent 选取含有子元素或文本的元素 集合元素 :contains(text) 选取含有文本内容为text的元素 集合元素 :has(selector) 选取含有选择器所匹配的元素的元素 集合元素 :empty 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中不包含文本内容或子元素的元素 var $res = $(\"div:empty\"); console.log($res.length); // 找到1个元素 $res.each(function (idx,ele) &#123; console.log(idx, ele); // one &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;zs&lt;/div&gt;&lt;!--包含内容不会被找到--&gt;&lt;div class=\"three\"&gt;&lt;!--包含子元素不会被找到--&gt; &lt;span&gt;lnj&lt;/span&gt;&lt;/div&gt;&lt;span class=\"five\"&gt;&lt;/span&gt;&lt;!--不是指定元素不会被找到--&gt;&lt;/body&gt;&lt;/html&gt; :parent 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中包含文本内容或子元素的元素 var $res = $(\"div:parent\"); console.log($res.length); $res.each(function (idx, ele) &#123; console.log(idx, ele); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;zs&lt;/div&gt;&lt;!--有文本内容会被找到--&gt;&lt;div class=\"three\"&gt;&lt;!--有子元素会被找到--&gt; &lt;span&gt;lnj&lt;/span&gt;&lt;/div&gt;&lt;span class=\"five\"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; :contains(text) 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中包含文本内容为lnj的元素 var $res = $(\"div:contains('lnj')\"); console.log($res.length);// 找到2个元素 $res.each(function (idx, ele) &#123; console.log(idx, ele);// one,three,four &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt;lnj&lt;/div&gt;&lt;div class=\"two\"&gt;zs&lt;/div&gt;&lt;div class=\"three\"&gt;lnj&lt;/div&gt;&lt;div class=\"four\"&gt;&lt;!--子元素中包含该文本也会被找到--&gt; &lt;span&gt;lnj&lt;/span&gt;&lt;/div&gt;&lt;span class=\"five\"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; :has(selector) 和:parent区别,parent只要有子元素就会被找到,:has(selector)不仅要有子元素,而且子元素还必须满足我们的条件 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中包含后代元素为span的元素 var $res = $(\"div:has('span')\"); console.log($res.length); $res.each(function (idx, ele) &#123; console.log(idx, ele); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt; &lt;!--后代中包含span元素会被找到--&gt; &lt;span&gt;jjj&lt;/span&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;&lt;!--后代中不包含span元素不会被找到--&gt; &lt;p&gt;zs&lt;/p&gt;&lt;/div&gt;&lt;div class=\"three\"&gt;&lt;!--后代中包含span元素会被找到--&gt; &lt;p&gt; &lt;span&gt;lnj&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 属性相关##属性和属性节点 什么是属性? 属性就是对象身上的变量 只要对象身上都可以添加属性(无论是自定义对象,还是DOM对象) 123456789&lt;script&gt; // 1.自定义一个对象 var obj = &#123;&#125;; console.log(obj); // 2.动态给自定义对象添加属性 obj.name = \"lnj\"; // name就是对象obj的一个属性 obj.age = 33; // age就是对象obj的一个属性 console.log(obj);&lt;/script&gt; image.png 什么是属性节点? 在html中编写的所有标签，里面的属性都是属性节点 &lt;span class = &#39;box&#39; nj = &#39;666&#39;&gt;&lt;/span&gt; // 这里的class和nj就是属性节点 image.png 如果操作属性? 添加或修改属性(没有就会添加,有就会修改) 对象.属性名称 = 值; 对象[&quot;属性名称&quot;] = 值; 获取属性 对象.属性名称 对象[&quot;属性名称&quot;] 如何操作属性节点? 获取属性节点 DOM对象.getAttribute(&quot;属性节点名称&quot;) 设置属性节点 DOM对象.setAttribute(&quot;属性节点名称&quot;, &quot;值&quot;); jQuery中的attr和prop方法 attr(name|pro|key,val|fn)方法 用于设置或获取属性节点的值 12345678910111213141516&lt;script&gt; $(function () &#123; // 1.获取指定属性节点值 var $res = $(\".span1\").attr(\"nj\"); console.log($res); // 2.设置属性节点 $(\".span1\").attr(\"nj\", \"666\"); $(\".span2\").attr(\"id\", \"box1 box2\"); // 3.注意点: // 3.1.获取属性节点时,只会获取找到所有元素中第一个元素的属性节点 $res = $(\"span\").attr(\"class\"); console.log($res); $(\"span\").attr(\"class\", \"lnj\"); &#125;);&lt;/script&gt; removeAttr(name)方法 用于删除指定属性节点 12345678&lt;script&gt; $(function () &#123; // 1.设置属性节点时,会给所有找到元素设置属性节点 $(\"span\").attr(\"test\", \"jonathan\"); // 2.删除属性节点时,会删除所有找到元素的属性节点 $(\"span\").removeAttr(\"test\"); &#125;);&lt;/script&gt; prop(n|p|k,v|f)方法 用于设置或者获取元素的属性值 12345678910&lt;script&gt; $(function () &#123; // 1.设置属性 // 1.1.设置属性时,会设置所有找到元素的属性 $(\"span\").prop(\"demo\", \"lnj\"); // 2.获取属性 // 2.1.获取属性时,只会获取找到第一个元素的属性 console.log($(\"span\").prop(\"demo\")); &#125;);&lt;/script&gt; removeProp(name)方法 123456&lt;script&gt; $(function () &#123; // 删除所有找到元素的demo属性 $(\"span\").removeProp(\"demo\"); &#125;);&lt;/script&gt; attr方法和prop方法区别 既然所有的DOM对象，都有一个attributes属性,而prop可以操作属性,所以也可以操作属性节点 官方推荐在操作属性节点时,具有 true 和 false 两个属性的属性节点，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr() 因为如果具有 true 和 false 两个属性的属性节点,如果没有编写默认attr返回undefined,而prop返回false 12345678910111213141516171819&lt;script&gt; $(function () &#123; // 1.可以通过prop获取属性节点 console.log($(\"input\").prop(\"class\")); // 2.可以通过prop设置属性节点 $(\"input\").prop(\"class\", \"tag\"); // 3.如果没有默认值,那么attr获取返回undefined// console.log($(\"input[type=checkbox]\").attr(\"checked\")); // 4.如果没有默认值,那么prop获取返回false console.log($(\"input[type=checkbox]\").prop(\"checked\")); // 5.通过attr设置选中// $(\"input[type=checkbox]\").attr(\"checked\", true); // 6.通过prop设置选中 $(\"input[type=checkbox]\").prop(\"checked\", true) &#125;);&lt;/script&gt; jQuery增删Class jQuery CSS类相关方法都是用于操作DOM对象的class属性节点的值 addClass(class|fn) 给元素添加一个或多个类 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;08-jQueryCSS类&lt;/title&gt; &lt;style&gt; .class1&#123; width: 200px; height: 200px; background-color: red; &#125; .class2&#123; border: 5px solid #000; &#125; &lt;/style&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.添加一个类// $(\"div\").addClass(\"class1\"); // 2.再添加一个类// $(\"div\").addClass(\"class2\"); // 3.一次性添加多个类(用空格隔开) $(\"div\").addClass(\"class1 class2\"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加&lt;/button&gt;&lt;button&gt;删除&lt;/button&gt;&lt;button&gt;切换&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; removeClass([class|fn]) 删除元素的一个或多个类 12345678910111213&lt;script&gt; $(function () &#123; $(\"button\").eq(1).click(function () &#123; // 4.删除一个类// $(\"div\").removeClass(\"class2\"); // 5.再删除一个类// $(\"div\").removeClass(\"class1\"); // 6.一次性删除多个类(用空格隔开) $(\"div\").removeClass(\"class1 class2\"); &#125;); &#125;);&lt;/script&gt; toggleClass(class|fn[,sw]) 添加或删除一个类(存在就删除不存在就添加) 12345678910&lt;script&gt; $(function () &#123; $(\"button\").eq(2).click(function () &#123; // 7.切换一个类// $(\"div\").toggleClass(\"class2\"); // 8.切换多个类 $(\"div\").toggleClass(\"class1 class2\"); &#125;); &#125;); &lt;/script&gt; jQuery代码/文本/值 html([val|fn]) 添加或获取元素中的HTML 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;09-jQuery代码文本值&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var $btns = $(\"button\"); var $div = $(\"div\"); $btns.eq(0).click(function () &#123; // 1.添加html, 相当于innerHTML// $div.html(\"&lt;p&gt;我是p标签&lt;/p&gt;\");// $div.html(\"&lt;p&gt;&lt;span&gt;我是span标签&lt;/span&gt;&lt;/p&gt;\"); $div.html(\"我是文本\"); &#125;); $btns.eq(1).click(function () &#123; // 2.获取html console.log($div.html()); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加html&lt;/button&gt;&lt;button&gt;获取html&lt;/button&gt;&lt;button&gt;添加文本&lt;/button&gt;&lt;button&gt;获取文本&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text([val|fn]) 添加或获取元素中的文本 text方法能做的html方法都能做,所以一般使用html方法即可 12345678910111213&lt;script&gt; $(function () &#123; $btns.eq(2).click(function () &#123; // 3.添加文本, 相当于innerText // 如下内容不会被转换为标签// $div.text('&lt;p&gt;我是段落&lt;/p&gt;'); $div.text('我是文本'); &#125;); $btns.eq(3).click(function () &#123; // 4.获取文本 console.log($div.text()); &#125;);&lt;/script&gt; val([val|fn|arr]) 添加或获取元素value属性的值 123456789101112&lt;script&gt; $(function () &#123; $btns.eq(4).click(function () &#123; // 4.添加value值 $(\"input\").val(\"我是一个输入框\"); &#125;); $btns.eq(5).click(function () &#123; // 4.获取value值 console.log($(\"input\").val()); &#125;); &#125;);&lt;/script&gt; CSS操作jQuery操作CSS样式 css(name|pro|[,val|fn])方法 用于设置或获取元素CSS样式 格式1:DOM元素.css(&quot;样式名称&quot;, &quot;值&quot;); 格式2:DOM元素.css({&quot;样式名称1&quot;:&quot;值1&quot;,&quot;样式名称2&quot;:&quot;值2&quot;}); 1234567891011121314151617181920212223 &lt;script&gt; $(function () &#123; $(\"button\").click(function () &#123; // 1.单个样式设置// $(\"div\").css(\"width\", \"100px\");// $(\"div\").css(\"height\", \"100px\");// $(\"div\").css(\"background\", \"red\"); // 2.链式设置样式// $(\"div\").css(\"width\", \"100px\").css(\"height\", \"100px\").css(\"background\", \"red\"); // 3.传入对象一次性设置样式 $(\"div\").css(&#123; \"width\":\"100px\", \"height\":\"100px\", \"background\":\"blue\" &#125;); // 4.获取指定样式的值 console.log($(\"div\").css(\"width\")); &#125;); &#125;); &lt;/script&gt; jQuery操作元素尺寸 width([val|fn])方法 设置或获取元素宽度(相当于获取width属性值) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;11-jQuery操作位置和尺寸&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .father&#123; width: 250px; height: 250px; background-color: red; margin-left: 50px; position: relative; &#125; .son&#123; width: 100px; height: 100px; background-color: blue; position: absolute; left: 50px; top: 50px; &#125; &lt;/style&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.获取元素宽度(不包括padding和border)// alert($('.son').width()); &#125;); $(\"button\").eq(1).click(function () &#123; // 2.设置元素宽度(不包括padding和border)// $(\".son\").width(\"50px\"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;button&gt;获取&lt;/button&gt;&lt;button&gt;设置&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; height([val|fn])方法 设置或获取元素宽度(相当于获取height属性值) 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) innerHeight()/innerWidth() 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) outerHeight/outerWidth() 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) jQuery操作元素位置 offset([coordinates]) 获取或设置元素相对窗口的偏移位 123456789101112&lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.获取距离窗口的偏移位(从border开始) alert($('.son').offset().left); // 100 &#125;); $(\"button\").eq(1).click(function () &#123; // 2.设置距离窗口的偏移位 $('.son').offset(&#123;left:10, top:10&#125;); &#125;); &#125;);&lt;/script&gt; position() 获取相对于它最近的具有相对位置(position:relative或position:absolute)的父级元素的距离 123456789101112&lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.获取匹配元素相对父元素的偏移 alert($('.son').position().left);// 50 &#125;); $(\"button\").eq(1).click(function () &#123; // 2.无效,不能设置相对定位元素的偏移位 $('.son').position(&#123;left:10, top:10&#125;) &#125;); &#125;);&lt;/script&gt; scrollTop([val]) 设置或获取匹配元素相对滚动条顶部的偏移。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;12-jQuery操作位置&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .scroll&#123; margin-top: 100px; margin-left: 100px; width: 100px; height: 200px; border: 1px solid #000; overflow: auto; &#125; &lt;/style&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 7.获取匹配元素相对滚动条顶部的偏移// alert($('.scroll').scrollTop());// alert($('html').scrollTop()); // 兼容所有浏览器写法 alert($('html').scrollTop()+$('body').scrollTop()); &#125;); $(\"button\").eq(1).click(function () &#123; // 8.设置匹配元素相对滚动条顶部的偏移// $('.scroll').scrollTop(100);// $('html').scrollTop(100); // 兼容所有浏览器写法 $('html,body').scrollTop(100); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"scroll\"&gt; 我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字&lt;/div&gt;&lt;button&gt;获取&lt;/button&gt;&lt;button&gt;设置&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; scrollLeft([val]) 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) AJAX1jQuery.ajax([settings]) 参数 描述 settings 可选。用于配置 Ajax 请求的键值对集合。可以通过 $.ajaxSetup() 设置任何选项的默认值。 参数 options 类型：Object可选。AJAX 请求设置。所有选项都是可选的。 async 类型：Boolean默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 beforeSend(XHR) 类型：Function发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。XMLHttpRequest 对象是唯一的参数。这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。 cache 类型：Boolean默认值: true，dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。jQuery 1.2 新功能。 complete(XHR, TS) 类型：Function请求完成后回调函数 (请求成功或失败之后均调用)。参数： XMLHttpRequest 对象和一个描述请求类型的字符串。这是一个 Ajax 事件。 contentType 类型：String默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。默认值适合大多数情况。如果你明确地传递了一个 content-type 给 $.ajax() 那么它必定会发送给服务器（即使没有数据要发送）。 context 类型：Object这个对象用于设置 Ajax 相关回调函数的上下文。也就是说，让回调函数内 this 指向这个对象（如果不设定这个参数，那么 this 就指向调用本次 AJAX 请求时传递的 options 参数）。比如指定一个 DOM 元素作为 context 参数，这样就设置了 success 回调函数的上下文为这个 DOM 元素。就像这样：$.ajax({ url: &quot;test.html&quot;, context: document.body, success: function(){ $(this).addClass(&quot;done&quot;); }}); data 类型：String发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 dataFilter 类型：Function给 Ajax 返回的原始数据的进行预处理的函数。提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。函数返回的值将由 jQuery 进一步处理。 dataType 类型：String预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。在 1.4 中，JSON 就会生成一个 JavaScript 对象，而 script 则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值:”xml”: 返回 XML 文档，可用 jQuery 处理。”html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。”script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）”json”: 返回 JSON 数据 。”jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。”text”: 返回纯文本字符串 error 类型：Function默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。这是一个 Ajax 事件。 global 类型：Boolean是否触发全局 AJAX 事件。默认值: true。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的 Ajax 事件。 ifModified 类型：Boolean仅在服务器数据改变时获取新数据。默认值: false。使用 HTTP 包 Last-Modified 头信息判断。在 jQuery 1.4 中，它也会检查服务器指定的 ‘etag’ 来确定数据没有被修改过。 jsonp 类型：String在一个 jsonp 请求中重写回调函数的名字。这个值用来替代在 “callback=?” 这种 GET 或 POST 请求中 URL 参数里的 “callback” 部分，比如 {jsonp:’onJsonPLoad’} 会导致将 “onJsonPLoad=?” 传给服务器。 jsonpCallback 类型：String为 jsonp 请求指定一个回调函数名。这个值将用来取代 jQuery 自动生成的随机函数名。这主要用来让 jQuery 生成度独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存 GET 请求的时候，指定这个回调函数名。 password 类型：String用于响应 HTTP 访问认证请求的密码 processData 类型：Boolean默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。 scriptCharset 类型：String只有当请求时 dataType 为 “jsonp” 或 “script”，并且 type 是 “GET” 才会用于强制修改 charset。通常只在本地和远程的内容编码不同时使用。 success 类型：Function请求成功后的回调函数。参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。这是一个 Ajax 事件。 traditional 类型：Boolean如果你想要用传统的方式来序列化数据，那么就设置为 true。请参考工具分类下面的 jQuery.param 方法。 timeout 类型：Number设置请求超时时间（毫秒）。此设置将覆盖全局设置。 type 类型：String默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 url 类型：String默认值: 当前页地址。发送请求的地址。 username 类型：String用于响应 HTTP 访问认证请求的用户名。 xhr 类型：Function需要返回一个 XMLHttpRequest 对象。默认在 IE 下是 ActiveXObject 而其他情况下是 XMLHttpRequest 。用于重写或者提供一个增强的 XMLHttpRequest 对象。这个参数在 jQuery 1.3 以前不可用。 回调函数如果要处理 $.ajax() 得到的数据，则需要使用回调函数：beforeSend、error、dataFilter、success、complete。 beforeSend在发送请求之前调用，并且传入一个 XMLHttpRequest 作为参数。 error在请求出错时调用。传入 XMLHttpRequest 对象，描述错误类型的字符串以及一个异常对象（如果有的话） dataFilter在请求成功之后调用。传入返回的数据以及 “dataType” 参数的值。并且必须返回新的数据（可能是处理过的）传递给 success 回调函数。 success当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。 complete当请求完成之后调用这个函数，无论成功或失败。传入 XMLHttpRequest 对象，以及一个包含成功或错误代码的字符串。 otherjquery中val()和value区分1.jQuery中的val()方法用来获取或设定输入框或选择框的值。 获取值：$(“##text”).val() 设置值：$(“##text”).val(“value”) 也可以来获取或设置select标签的值 select1 select2 获取值：$(“##select”).val() 设置值：$(“##select”).val(“select1”) 2.jQuery中没有value方法，可以通过attr方法获取或设置标签中的value属性的值","categories":[{"name":"js","slug":"js","permalink":"https://codeofli.github.io/categories/js/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://codeofli.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://codeofli.github.io/tags/js/"}]},{"title":"springBoot高级","slug":"java-note/SpringBootHigh/springBoot-high","date":"2019-10-09T07:43:44.000Z","updated":"2022-03-16T03:12:18.454Z","comments":true,"path":"2019/10/java-note/SpringBootHigh/springBoot-high/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/SpringBootHigh/springBoot-high/","excerpt":"spring boot高级[TOC]一.Spring Boot与缓存1、JSR107Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。•CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。","text":"spring boot高级[TOC]一.Spring Boot与缓存1、JSR107Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。•CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。 •CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。 •Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。 •Entry是一个存储在Cache中的key-value对。 •Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。 Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（**Cache**）组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @**CacheEvict** 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存。 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 一、搭建基本环境 1、导入数据库文件 创建出department和employee表 2、创建javaBean封装数据 3、整合MyBatis操作数据库 1.配置数据源信息 2.使用注解版的MyBatis； 1）、@MapperScan指定需要扫描的mapper接口所在的包 2、快速体验缓存==注意：cache注解（CachePut、Cacheable、@CachePut）的key保持一致，这样才能在cachemap中拿到同一个数据== @CacheConfig注解抽取缓存的公共配置 123@CacheConfig(cacheNames=\"emp\",cacheManager = \"employeeCacheManager\") //抽取缓存的公共配置@Servicepublic class EmployeeService &#123; 步骤： ==1、开启基于注解的缓存 @EnableCaching== 123456789@EnableCaching@MapperScan(value = \"com.yoj.web.dao\")@SpringBootApplicationpublic class YojApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(YojApplication.class, args); &#125;&#125; 2、标注缓存注解即可 @Cacheable @CacheEvict @CachePut 123456/* * 默认使用的是ConcurrentMapCacheManager==ConcurrentMapCache；将数据保存在 ConcurrentMap&lt;Object, Object&gt;中 * 开发中使用缓存中间件；redis、memcached、ehcache； * * */ service层使用cache注解 缓存中能使用的spel表达式 Cache* SpEL available metadata 名字 位置 描述 示例 methodName root object 当前被调用的方法名 #root.methodName method root object 当前被调用的方法 #root.method.name target root object 当前被调用的目标对象 #root.target targetClass root object 当前被调用的目标对象类 #root.targetClass args root object 当前被调用的方法的参数列表 #root.args[0] caches root object 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache #root.caches[0].name argument name evaluation context 方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的形式，0代表参数的索引； #iban 、 #a0 、 #p0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache put’的表达式 ’cache evict’的表达式beforeInvocation=false） #result @Cacheable注解原理： 1、自动配置类；CacheAutoConfiguration 2、缓存的配置类(11) 1234567891011org.springframework.boot.autoconfigure.cache.GenericCacheConfigurationorg.springframework.boot.autoconfigure.cache.JCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.EhCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.HazelcastCacheConfigurationorg.springframework.boot.autoconfigure.cache.InfinispanCacheConfigurationorg.springframework.boot.autoconfigure.cache.CouchbaseCacheConfigurationorg.springframework.boot.autoconfigure.cache.RedisCacheConfigurationorg.springframework.boot.autoconfigure.cache.CaffeineCacheConfigurationorg.springframework.boot.autoconfigure.cache.GuavaCacheConfigurationorg.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration 3、哪个配置类默认生效：SimpleCacheConfiguration； 4、给容器中注册了一个CacheManager：ConcurrentMapCacheManager 5、可以获取和创建ConcurrentMapCache类型的缓存组件；他的作用将数据保存在ConcurrentMap中； 运行流程：(ConcurrentMapCacheManager.class) @Cacheable： 1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取； （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。 123456789101112131415@Override@Nullablepublic Cache getCache(String name) &#123; Cache cache = this.cacheMap.get(name); if (cache == null &amp;&amp; this.dynamic) &#123; synchronized (this.cacheMap) &#123; cache = this.cacheMap.get(name); if (cache == null) &#123; cache = createConcurrentMapCache(name); this.cacheMap.put(name, cache); &#125; &#125; &#125; return cache;&#125; 2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数； 123protected Object lookup(Object key) &#123; return this.store.get(key);&#125; key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key； 12345678public abstract class CacheAspectSupport extends AbstractCacheInvokerprotected Object generateKey(@Nullable Object result) &#123; if (StringUtils.hasText(this.metadata.operation.getKey())) &#123; EvaluationContext evaluationContext = createEvaluationContext(result); return evaluator.key(this.metadata.operation.getKey(), this.metadata.methodKey, evaluationContext); &#125; return this.metadata.keyGenerator.generate(this.target, this.metadata.method, this.args);&#125; SimpleKeyGenerator生成key的默认策略； 如果没有参数；key=new SimpleKey()； 如果有一个参数：key=参数的值 如果有多个参数：key=new SimpleKey(params)； 12345678910111213141516public class SimpleKeyGenerator implements KeyGenerator &#123; /*** Generate a key based on the specified parameters.*/public static Object generateKey(Object... params) &#123; if (params.length == 0) &#123; return SimpleKey.EMPTY; &#125; if (params.length == 1) &#123; Object param = params[0]; if (param != null &amp;&amp; !param.getClass().isArray()) &#123; return param; &#125; &#125; return new SimpleKey(params);&#125; 3、没有查到缓存就调用目标方法； 4、将目标方法返回的结果，放进缓存中 123public void put(Object key, @Nullable Object value) &#123; this.store.put(key, toStoreValue(value));&#125; @Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存， 如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据； ==核心：== 1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件 2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator 几个属性： cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存； key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值 编写SpEL； #i d;参数id的值 #a0 #p0 #root.args[0] getEmp[2] ： **key = &quot;#root.methodName+&apos;[&apos;+#id+&apos;]&apos;&quot;**1@Cacheable(cacheNames = &#123;\"emp\"&#125;,key = \"#root.methodName+'['+#id+']'\") keyGenerator：key的生成器；可以自己指定key的生成器的组件id key/keyGenerator：二选一使用;123456789101112131415@Configurationpublic class MyCacheConfig &#123; @Bean(\"myKeyGenerator\") public KeyGenerator keyGenerator()&#123; return new KeyGenerator()&#123; @Override public Object generate(Object target, Method method, Object... params) &#123; return method.getName()+\"[\"+ Arrays.asList(params).toString()+\"]\"; &#125; &#125;; &#125;&#125;//调用 @Cacheable(cacheNames = &#123;\"emp\"&#125;,keyGenerator = \"myKeyGenerator\") cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 condition：指定符合条件的情况下才缓存； ,condition = &quot;#id&gt;0&quot; condition = &quot;#a0&gt;1&quot;：第一个参数的值 &gt;1的时候才进行缓存 unless==:否定缓存==；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断 unless = &quot;#result == null&quot; unless = &quot;#a0==2&quot;:如果第一个参数的值是2，结果不缓存； sync：是否使用异步模式,启用sync就不能使用unless属性了 1234567891011121314151617181920212223242526272829303132333435363738@CacheConfig(cacheNames=\"emp\"/*,cacheManager = \"employeeCacheManager\"*/) //抽取缓存的公共配置@Servicepublic class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; /** * 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法； * CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字； * * @param id * @return * */ @Cacheable(value = &#123;\"emp\"&#125;/*,keyGenerator = \"myKeyGenerator\",condition = \"#a0&gt;1\",unless = \"#a0==2\"*/) public Employee getEmp(Integer id)&#123; System.out.println(\"查询\"+id+\"号员工\"); Employee emp = employeeMapper.getEmpById(id); return emp; &#125; // @Caching 定义复杂的缓存规则 @Caching( cacheable = &#123; @Cacheable(/*value=\"emp\",*/key = \"#lastName\") &#125;, put = &#123; @CachePut(/*value=\"emp\",*/key = \"#result.id\"), @CachePut(/*value=\"emp\",*/key = \"#result.email\") &#125; ) public Employee getEmpByLastName(String lastName)&#123; return employeeMapper.getEmpByLastName(lastName); &#125;&#125; @CachePut注解@CachePut：既调用方法，又更新缓存数据；同步更新缓存 修改了数据库的某个数据，同时更新缓存； 运行时机：1、先调用目标方法2、将目标方法的结果缓存起来 12345678910111213141516171819202122/** * 测试步骤： * 1、查询1号员工；查到的结果会放在缓存中； * key：1 value：lastName：张三 * 2、以后查询还是之前的结果 * 3、更新1号员工；【lastName:zhangsan；gender:0】 * 将方法的返回值也放进缓存了； * key：传入的employee对象 值：返回的employee对象； * 4、查询1号员工？ * 应该是更新后的员工； * key = \"#employee.id\":使用传入的参数的员工id； * key = \"#result.id\"：使用返回后的id * @Cacheable的key是不能用#result * 为什么是没更新前的？【1号员工没有在缓存中更新】 * */@CachePut(/*value = \"emp\",*/key = \"#result.id\")public Employee updateEmp(Employee employee)&#123; System.out.println(\"updateEmp:\"+employee); employeeMapper.updateEmp(employee); return employee;&#125; @CacheEvict注解evict：驱逐，逐出 @CacheEvict：缓存清除 key：指定要清除的数据 -allEntries = true：指定清除这个缓存中所有的数据 beforeInvocation = false：缓存的清除是否在方法之前执行默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除 beforeInvocation = true：代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除 123456@CacheEvict(value=\"emp\",beforeInvocation = true/*key = \"#id\",*/)public void deleteEmp(Integer id)&#123; System.out.println(\"deleteEmp:\"+id); //employeeMapper.deleteEmpById(id); int i = 10/0;&#125; @Caching注解定义复杂的缓存规则 12345678910111213// @Caching 定义复杂的缓存规则 @Caching( cacheable = &#123; @Cacheable(/*value=\"emp\",*/key = \"#lastName\") &#125;, put = &#123; @CachePut(/*value=\"emp\",*/key = \"#result.id\"), @CachePut(/*value=\"emp\",*/key = \"#result.email\") &#125; ) public Employee getEmpByLastName(String lastName)&#123; return employeeMapper.getEmpByLastName(lastName); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package com.atguigu.springboot01cache.service;import com.atguigu.springboot01cache.bean.Employee;import com.atguigu.springboot01cache.mapper.EmployeeMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.*;import org.springframework.stereotype.Service;@CacheConfig(cacheNames = \"emp\"/*,cacheManager = \"employeeCacheManager\"*/) //抽取缓存的公共配置@Servicepublic class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; /** * 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法； * CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字； * &lt;p&gt; * &lt;p&gt; * &lt;p&gt; * 原理： * 1、自动配置类；CacheAutoConfiguration * 2、缓存的配置类 * org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration * org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration * org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration * org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration * org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration * org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration * org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration * org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration * org.springframework.boot.autoconfigure.cache.GuavaCacheConfiguration * org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】 * org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration * 3、哪个配置类默认生效：SimpleCacheConfiguration； * &lt;p&gt; * 4、给容器中注册了一个CacheManager：ConcurrentMapCacheManager * 5、可以获取和创建ConcurrentMapCache类型的缓存组件；他的作用将数据保存在ConcurrentMap中； * &lt;p&gt; * 运行流程： * * @param id * @return * @Cacheable： 1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取； * （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。 * 2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数； * key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key； * SimpleKeyGenerator生成key的默认策略； * 如果没有参数；key=new SimpleKey()； * 如果有一个参数：key=参数的值 * 如果有多个参数：key=new SimpleKey(params)； * 3、没有查到缓存就调用目标方法； * 4、将目标方法返回的结果，放进缓存中 * @Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存， 如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据； * &lt;p&gt; * 核心： * 1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件 * 2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator * &lt;p&gt; * &lt;p&gt; * 几个属性： * cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存； * &lt;p&gt; * key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值 * 编写SpEL； #i d;参数id的值 #a0 #p0 #root.args[0] * getEmp[2] * &lt;p&gt; * keyGenerator：key的生成器；可以自己指定key的生成器的组件id * key/keyGenerator：二选一使用; * &lt;p&gt; * &lt;p&gt; * cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 * &lt;p&gt; * condition：指定符合条件的情况下才缓存； * ,condition = \"#id&gt;0\" * condition = \"#a0&gt;1\"：第一个参数的值》1的时候才进行缓存 * &lt;p&gt; * sync：是否使用异步模式 */ @Cacheable(value = &#123;\"emp\"&#125;/*,keyGenerator = \"myKeyGenerator\",condition = \"#a0&gt;1\",unless = \"#a0==2\"*/) public Employee getEmp(Integer id) &#123; System.out.println(\"查询\" + id + \"号员工\"); Employee emp = employeeMapper.getEmpById(id); return emp; &#125; /** * @CachePut：既调用方法，又更新缓存数据；同步更新缓存 修改了数据库的某个数据，同时更新缓存； * 运行时机： * 1、先调用目标方法 * 2、将目标方法的结果缓存起来 * &lt;p&gt; * 测试步骤： * 1、查询1号员工；查到的结果会放在缓存中； * key：1 value：lastName：张三 * 2、以后查询还是之前的结果 * 3、更新1号员工；【lastName:zhangsan；gender:0】 * 将方法的返回值也放进缓存了； * key：传入的employee对象 值：返回的employee对象； * 4、查询1号员工？ * 应该是更新后的员工； * key = \"#employee.id\":使用传入的参数的员工id； * key = \"#result.id\"：使用返回后的id * @Cacheable的key是不能用#result 为什么是没更新前的？【1号员工没有在缓存中更新】 */ @CachePut(value = \"emp\", key = \"#result.id\") public Employee updateEmp(Employee employee) &#123; System.out.println(\"updateEmp:\" + employee); employeeMapper.updateEmp(employee); return employee; &#125; /** * @CacheEvict：缓存清除 key：指定要清除的数据 * allEntries = true：指定清除这个缓存中所有的数据 * beforeInvocation = false：缓存的清除是否在方法之前执行 * 默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除 * &lt;p&gt; * beforeInvocation = true： * 代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除 */ @CacheEvict(value = \"emp\", beforeInvocation = true/*key = \"#id\",*/) public void deleteEmp(Integer id) &#123; System.out.println(\"deleteEmp:\" + id); //employeeMapper.deleteEmpById(id); int i = 10 / 0; &#125; // @Caching 定义复杂的缓存规则 @Caching( cacheable = &#123; @Cacheable(/*value=\"emp\",*/key = \"#lastName\") &#125;, put = &#123; @CachePut(/*value=\"emp\",*/key = \"#result.id\"), @CachePut(/*value=\"emp\",*/key = \"#result.email\") &#125; ) public Employee getEmpByLastName(String lastName) &#123; return employeeMapper.getEmpByLastName(lastName); &#125;&#125; 3.整合redis作为缓存 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 原理：CacheManager===Cache 缓存组件来实际给缓存中存取数据 1）、引入redis的starter，容器中保存的是 RedisCacheManager； 2）、RedisCacheManager 帮我们创建 RedisCache 来作为缓存组件；RedisCache通过操作redis缓存数据的 3）、默认保存数据 kv 都是Object；利用序列化保存；如何保存为json 1、引入了redis的starter，cacheManager变为 RedisCacheManager； 2、默认创建的 RedisCacheManager 操作redis的时候使用的是 RedisTemplate&lt;Object, Object&gt; 3、RedisTemplate&lt;Object, Object&gt; 是 默认使用jdk的序列化机制 4）、自定义CacheManager； 1、安装redis：使用docker；启动redis，默认端口6379 123456[root@MiWiFi-R3A-srv ~]# docker run -d -p 6379:6379 --name myredis redisba86c7f5d285b74828df3ec4f0179cfcd3682dc58f2cfabe354a63336d94919e#开启持久化docker run -d -p 6379:6379 --name persistent-redis redis --appendonly yesdocker run --name=\"redis-2\" -d -p 6378:6379 -v /home/fr/redis:/opt royfans/redis:v1 /usr/local/redis/bin/redis-server /usr/local/redis/redis.conf --appendonly yes ==注意==：如果不开启持久化，会导致一段时间不用缓存之后，连接不上redis start with persistent storage 123docker run -v /myredis/conf/redis.conf:/home/ubuntu/redis/redis.conf -d -p 6379:6379 --name config-redis redis --appendonly yes$ docker run --name some-redis -d redis redis-server --appendonly yes 1$ docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name myredis redis redis-server /usr/local/etc/redis/redis.conf Where /myredis/conf/ is a local directory containing your redis.conf file. Using this method means that there is no need for you to have a Dockerfile for your redis container. 123456这个问题我们在项目中遇到同样的问题，目前已经解决了。最终得到的答案是： 服务器不稳定造成的。您可以尝试这样解决：1.推荐使用生产环境的服务器，并且将redis 绑定生产环境的ip;因为云服务器的ip 地址是很稳定的，而本地服务的ip地址经常是变动的；经 过测试，这种每过10分就会重新请求连接，还会发生重试失败的情况，就是因为服务器不稳定造成的；2.如果你在生产环境中，使用docker 部署，建议 不要在docker容器中 安装redis; 因为docker 容器 默认分配的ip 地址，也可能是变化的； 您可以直接将redis 安装在 服务器目录下，即可； redis desktop manager连接 ![1565350310934](.\\springBoot-high\\redis desktop manager连接.png) 2、引入redis的starter1.引入spring-boot-starter-data-redis 12345&lt;!--引入redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 3、配置redis12#指定主机端口号spring.redis.host=192.168.31.39 4、测试缓存3.使用RestTemplate操作redis 1.redisTemplate.opsForValue();//操作字符串 2.redisTemplate.opsForHash();//操作hash 3.redisTemplate.opsForList();//操作list 4.redisTemplate.opsForSet();//操作set 5.redisTemplate.opsForZSet();//操作有序set 4.配置缓存、CacheManagerCustomizers 5.测试使用缓存、切换缓存、 CompositeCacheManager ==stringRedisTemplate== //操作k-v都是字符串的 1234567891011121314151617181920212223@AutowiredStringRedisTemplate stringRedisTemplate; //操作k-v都是字符串的/** * Redis常见的五大数据类型 * String（字符串）、List（列表）、Set（集合）、Hash（散列）、ZSet（有序集合） * stringRedisTemplate.opsForValue()[String（字符串）] * stringRedisTemplate.opsForList()[List（列表）] * stringRedisTemplate.opsForSet()[Set（集合）] * stringRedisTemplate.opsForHash()[Hash（散列）] * stringRedisTemplate.opsForZSet()[ZSet（有序集合）] */@Testpublic void test01()&#123; //给redis中保存数据 //stringRedisTemplate.opsForValue().append(\"msg\",\"hello\"); //获取数据 // String msg = stringRedisTemplate.opsForValue().get(\"msg\"); // System.out.println(msg); //保存list集合数据 stringRedisTemplate.opsForList().leftPush(\"mylist\",\"1\"); stringRedisTemplate.opsForList().leftPush(\"mylist\",\"2\");&#125; ==redisTemplate== k-v都是对象 12345678910111213141516 @Autowired RedisTemplate redisTemplate; //k-v都是对象的 @Autowired RedisTemplate&lt;Object,Object&gt; empRedisTemplate; //自定义缓存规则配置的redisTemplate//测试保存对象 @Test public void test02()&#123; Employee empById = employeeMapper.getEmpById(1); //默认如果保存对象，使用jdk序列化机制，序列化后的数据保存到redis中 //redisTemplate.opsForValue().set(\"emp-01\",empById); //1、将数据以json的方式保存 //(1)自己将对象转为json //(2)redisTemplate默认的序列化规则；改变默认的序列化规则； empRedisTemplate.opsForValue().set(\"emp-01\",empById); &#125; 5.使用Json格式序列化对象1.使用setKey和value的Serializer方法 123redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class)); redisTemplate.setKeySerializer(new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class)); redisTemplate.opsForValue().set(\"emp-02\",empById); 123456789101112@Configurationpublic class MyRedisConfig &#123; @Bean public RedisTemplate&lt;Object, Object&gt; empRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; serializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(serializer); return template; &#125; 2.0配置redis的CacheManager1234spring: cache: redis: timeToLive: 1000000 #毫秒 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.springboot01cache.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.CacheManager;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializationContext;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.time.Duration;@Configurationpublic class MyRedisConfig &#123;// @Bean// public RedisTemplate&lt;Object, Object&gt; empRedisTemplate(RedisConnectionFactory redisConnectionFactory)// throws UnknownHostException &#123;// RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();// template.setConnectionFactory(redisConnectionFactory);// Jackson2JsonRedisSerializer&lt;Employee&gt; serializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);// template.setDefaultSerializer(serializer);// return template;// &#125; private Duration timeToLive = Duration.ZERO; public void setTimeToLive(Duration timeToLive) &#123; this.timeToLive = timeToLive; &#125; @Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题） RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(timeToLive) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; &#125;&#125; 4.注意1.@CachePut 获取就是返回的值所有想要存入缓存的都是返回的值 my_redis设置缓存时间1stringRedisTemplate.opsForValue().set(email, checkCode,60*10,TimeUnit.SECONDS);//向redis里存入数据和设置缓存时间 删除缓存byKey1stringRedisTemplate.delete(user.getEmail()); 检查时间1stringRedisTemplate.hasKey(\"546545\");//检查key是否存在，返回boolean值 问题redis一段时间之后不连接就连不上==内存原因，设置maxmemory和替换算法== 在Linux上，如果开了redis的守护进程，kill -9和redis-cli shutdown 命令是无法杀掉 redis 进程的 ，杀掉就会重新启动一个新的进程 最后在网上找到这个命令： 1/etc/init.d/redis-server stop 二.Spring Boot与消息JMS、AMQP、RabbitMQ 一、概述1.大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力 2.消息服务中两个重要概念： ​ 消息代理（message broker）和目的地（destination） 当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地。 3.消息队列主要有两种形式的目的地 1.队列（queue）：点对点消息通信（point-to-point） 2.主题（topic）：发布（publish）/订阅（subscribe）消息通信 4.点对点式： –消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列 –消息只有唯一的发送者和接受者，但并不是说只能有一个接收者 5.发布订阅式： –发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息 6.JMS（Java Message Service）JAVA消息服务： –基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现 7.AMQP（Advanced Message Queuing Protocol） –高级消息队列协议，也是一个消息代理的规范，兼容JMS –RabbitMQ是AMQP的实现 JMS AMQP 定义 Java api 网络线级协议 跨语言 否 是 跨平台 否 是 Model 提供两种消息模型： （1）、Peer-2-Peer （2）、Pub/sub 提供了五种消息模型： （1）、direct exchange （2）、fanout exchange （3）、topic change （4）、headers exchange （5）、system exchange 本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分； 支持消息类型 多种消息类型： TextMessage MapMessage BytesMessage StreamMessage ObjectMessage Message （只有消息头和属性） byte[] 当实际应用时，有复杂的消息，可以将消息序列化后发送。 综合评价 JMS 定义了JAVA API层面的标准；在java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差； AMQP定义了wire-level层的协议标准；天然具有跨平台、跨语言特性。 8.Spring支持 –spring-jms提供了对JMS的支持 –spring-rabbit提供了对AMQP的支持 –需要ConnectionFactory的实现来连接消息代理 –提供JmsTemplate、RabbitTemplate来发送消息 –@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息 –@EnableJms、@EnableRabbit开启支持 9.Spring Boot自动配置 –JmsAutoConfiguration –RabbitAutoConfiguration 二、RabbitMQ简介RabbitMQ简介： RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。 核心概念 Message 消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 Publisher 消息的生产者，也是一个向交换器发布消息的客户端应用程序。 Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别 三、Spring Boot与检索 四.Spring Boot与任务异步任务、定时任务、邮件任务一、异步任务在Java应用中，绝大多数情况下都是通过同步的方式来实现交互处理的；但是在处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用多线程来完成此类任务，其实，在Spring 3.x之后，就已经内置了@Async来完美解决这个问题。 两个注解： @EnableAysnc、@Aysnc springbootApplication添加@EnableAysnc注解 12345678@EnableAsync //开启异步注解功能@SpringBootApplicationpublic class Springboot04TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04TaskApplication.class, args); &#125;&#125; 编写异步方法，同时执行，并不会等3s才有success 1234567891011121314@Servicepublic class AsyncService &#123; //告诉Spring这是一个异步方法 @Async public void hello()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"处理数据中...\"); &#125;&#125; 二、定时任务@EnableScheduling //开启基于注解的定时任务 123456789@EnableScheduling //开启基于注解的定时任务@SpringBootApplicationpublic class Springboot04TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04TaskApplication.class, args); &#125;&#125; 编写定时方法 1234567891011121314151617181920@Servicepublic class ScheduledService &#123; /** * second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）. * 0 * * * * MON-FRI * 【0 0/5 14,18 * * ?】 每天14点整，和18点整，每隔5分钟执行一次 * 【0 15 10 ? * 1-6】 每个月的周一至周六10:15分执行一次 * 【0 0 2 ? * 6L】每个月的最后一个周六凌晨2点执行一次 * 【0 0 2 LW * ?】每个月的最后一个工作日凌晨2点执行一次 * 【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次； */// @Scheduled(cron = \"0 * * * * MON-SAT\")// @Scheduled(cron = \"0,1,2,3,4 * * * * MON-SAT\") // @Scheduled(cron = \"0-4 * * * * MON-SAT\") @Scheduled(cron = \"0/4 * * * * MON-SAT\") //每4秒执行一次 public void hello()&#123; System.out.println(\"hello ... \"); &#125;&#125; 两个注解：@EnableScheduling、@Scheduled cron表达式： 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 , - * / 星期 0-7或SUN-SAT 0,7是SUN , - * ? / L C # 特殊字符 代表含义 , 枚举 - 区间 * 任意 / 步长 ? 日/星期冲突匹配 L 最后 W 工作日 C 和calendar联系后计算过的值 # 星期，4#2，第2个星期四 三、邮件任务•邮件发送需要引入spring-boot-starter-mail •Spring Boot 自动配置MailSenderAutoConfiguration •定义MailProperties内容，配置在application.yml中 •自动装配JavaMailSender •测试邮件发送 1.导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 2.配置信息 1)首先在qq邮箱开通相关的服务 拿到的授权码即为password application.properties配置 123456789101112131415161718## QQ邮箱配置spring.mail.host=smtp.qq.com#发送的QQ邮箱spring.mail.username=1162314270@qq.com# 如果是qq邮箱,这个地方是授权码 ,不是密码spring.mail.password=wfqdmurtsvsgiecfspring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.ssl.enable=truespring.mail.default-encoding=utf-8spring.mail.properties.mail.smtp.ssl.trust=smtp.qq.com#SSL证书Socket工厂spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#使用SMTPS协议465端口spring.mail.properties.mail.smtp.socketFactory.port=465spring.mail.properties.mail.smtp.auth=true#503错误，我的没有这个错#spring.mail.properties.mail.smtp.ssl.enable=true 123456789101112131415161718192021222324252627282930313233343536373839404142@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot04TaskApplicationTests &#123; @Autowired JavaMailSenderImpl mailSender; @Test public void contextLoads() &#123; SimpleMailMessage message = new SimpleMailMessage(); //邮件设置 message.setSubject(\"通知-今晚开会\"); message.setText(\"今晚7:30开会\"); message.setTo(\"407820388@qq.com\"); message.setFrom(\"1162314270@qq.com\"); mailSender.send(message); &#125; @Test public void test02() throws Exception&#123; //1、创建一个复杂的消息邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); //邮件设置 helper.setSubject(\"通知-今晚开会\"); helper.setText(\"&lt;b style='color:red'&gt;今天 7:30 开会&lt;/b&gt;\",true); helper.setTo(\"407820388@qq.com\"); helper.setFrom(\"1162314270@qq.com\"); //上传文件 helper.addAttachment(\"1.jpg\",new File(\"E:\\\\pictures\\\\desktop view.png\")); helper.addAttachment(\"2.jpg\",new File(\"E:\\\\pictures\\\\e.png\")); mailSender.send(mimeMessage); &#125;&#125; 实现邮箱激活链接学习来自 https://www.cnblogs.com/smfx1314/p/10332330.html 12345678910public class User &#123; /** * 状态：0代表未激活，1代表激活 */ private Integer status; /** * 利用UUID生成一段数字，发动到用户邮箱，当用户点击链接时 * 在做一个校验如果用户传来的code跟我们发生的code一致，更改状态为“1”来激活用户 */ private String code; 说明： 用户状态status：0代表未激活，1代表激活，注册的时候，默认是0，只有激活邮箱激活码可以更改为1 邮箱激活码code：利用UUID生成一段数字，发动到用户邮箱，当用户点击链接时，在做一个校验，如果用户传来的code跟我们发送的code一致，更改状态为“1”来激活用户 123456789101112131415161718192021222324252627public interface UserDao &#123; /** * 用户注册，注册的时候默认状态为0：未激活，并且调用邮件服务发送激活码到邮箱 * @param user */ void register(User user); /** * 点击邮箱中的激活码进行激活，根据激活码查询用户，之后再进行修改用户状态为1进行激活 * @param code * @return */ User checkCode(String code); /** * 激活账户，修改用户状态为“1”进行激活 * @param user */ void updateUserStatus(User user); /** * 登录，根据用户状态为“1”来查询 * @param user * @return */ User loginUser(User user);&#125; UUIDUtils 随机生成激活码12345public class UUIDUtils &#123; public static String getUUID()&#123; return UUID.randomUUID().toString().replace(\"-\",\"\"); &#125;&#125; UserController控制类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Controller@RequestMapping(\"/user\")public class UserController &#123; @Autowired private UserService userService; /** * 注册 * @param user * @return */ @RequestMapping(value = \"/registerUser\") public String register(User user)&#123; user.setStatus(0); String code = UUIDUtils.getUUID()+ UUIDUtils.getUUID(); user.setCode(code); userService.register(user); return \"success\"; &#125; /** *校验邮箱中的code激活账户 * 首先根据激活码code查询用户，之后再把状态修改为\"1\" */ @RequestMapping(value = \"/checkCode\") public String checkCode(String code)&#123; User user = userService.checkCode(code); System.out.println(user); //如果用户不等于null，把用户状态修改status=1 if (user !=null)&#123; user.setStatus(1); //把code验证码清空，已经不需要了 user.setCode(\"\"); System.out.println(user); userService.updateUserStatus(user); &#125; return \"login\"; &#125; /** * 跳转到登录页面 * @return login */ @RequestMapping(value = \"/loginPage\") public String login()&#123; return \"login\"; &#125; /** * 登录 */ @RequestMapping(value = \"/loginUser\") public String login(User user, Model model)&#123; User u = userService.loginUser(user); if (u !=null)&#123; return \"welcome\"; &#125; return \"login\"; &#125;&#125; 1234567891011121314@Repository@Mapperpublic interface UserMapper &#123; //根据激活码code查询用户 @Select(\"select * from user where code = #&#123;code&#125;\") User checkCode(String code); // 激活账户，修改用户状态 @Update(\"update user set status=1,code=null WHERE user_id = #&#123;userId&#125;\") void updateUserStatus(Integer userId); // 根据用户名，返回激活状态的用户 @Select(\"SELECT * FROM `user` WHERE username = #&#123;username&#125; and status = 1 LIMIT 1\") User getActiveUserByName(String username); public class EmailSender { @Value(&quot;${spring.mail.username}&quot;) private String from; @Autowired EmailCache emailCache; @Autowired JavaMailSenderImpl mailSender; /** * @Description: 发送注册邮件和验证码,send email is take long time so add async * @Param: [email] * @return: java.lang.String null:发送邮件失败 * @Author: lmz * @Date: 2019/10/20 */ @Async public String sendResetPasswordEmail(String email) { String checkCode = String.valueOf(new Random().nextInt(899999) + 100000); try{ //发送邮件 sendEmailMessage(email, &quot;YOJ重置验证码&quot;, &quot;您的重置验证码为：&quot; + checkCode); }catch (Exception e){ e.printStackTrace(); return null; } //设置缓存 emailCache.setEmailCheckCode(email,checkCode); return checkCode; } /** * @Description: 发送注册邮件和验证码 * @Param: [email] * @return: java.lang.String null:发送邮件失败 * @Author: lmz * @Date: 2019/10/20 */ @Async public String sendRegisterEmail(String email) { //删除缓存EmailSender 12345678910111213141516171819202122232425262728293031public class EmailSender &#123; @Value(\"$&#123;spring.mail.username&#125;\") private String from; @Autowired EmailCache emailCache; @Autowired JavaMailSenderImpl mailSender; /** * 发送HTML邮件 * @param to 收件者 * @param subject 邮件主题 * @param content 文本内容 */ public void sendHtmlMail(String to,String subject,String content) &#123; MimeMessage message = mailSender.createMimeMessage(); MimeMessageHelper helper = null; try &#123; helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(subject); helper.setTo(to); helper.setText(content, true); mailSender.send(message); //日志信息 log.info(\"邮件已经发送。\"); &#125; catch (MessagingException e) &#123; log.error(\"发送邮件时发生异常！\", e); &#125; &#125;&#125; } 五.Spring Boot与安全一、安全Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。 几个类： WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式 “认证”和“授权”•应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是Spring Security 的两个目标。 •“认证”（Authentication），是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）。 •“授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立。 •这个概念是通用的而不只在Spring Security中。 二、Web&amp;安全1.登陆/注销 –HttpSecurity配置登陆、注销功能 2.Thymeleaf提供的SpringSecurity标签支持 –需要引入thymeleaf-extras-springsecurity5（版本要一致） –sec:authentication=“name”获得当前用户的用户名 –sec:authorize=“hasRole(‘ADMIN’)”当前用户必须拥有ADMIN权限时才会显示标签内容 3.remember me –表单添加remember-me的checkbox –配置启用remember-me功能 4.CSRF（Cross-site request forgery）跨站请求伪造 HttpSecurity启用功能，会为表单添加csrfCSRF 使用SpringSecurity官方文档 1、引入SpringSecurity；1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 2、编写SpringSecurity的配置类；使用之间需要PasswordEncoder的bean存在 使用springboot，权限管理使用spring security，使用内存用户验证，但无响应报错：java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id “null”解决方法：这是因为Spring boot 2.0.3引用的security 依赖是 spring security 5.X版本，此版本需要提供一个PasswordEncorder的实例，否则后台汇报错误：java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id “null”并且页面毫无响应。因此，需要创建PasswordEncorder的实现类。 1234567891011121314151617package springboot05security.nicolas.config;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component;@Componentpublic class MyPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; return s.equals(charSequence.toString()); &#125;&#125; 自定义securityConfig需要继承WebSecurityConfigurerAdapter 3、控制请求的访问权限：configure(HttpSecurity http) {http.authorizeRequests().antMatchers(“/“).permitAll().antMatchers(“/level1/**”).hasRole(“VIP1”)} 4、定义认证规则：configure(AuthenticationManagerBuilder auth){auth.inMemoryAuthentication().withUser(“zhangsan”).password(“123456”).roles(“VIP1”,”VIP2”)} 123456789101112131415161718192021//定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //super.configure(auth); auth.inMemoryAuthentication() .withUser(\"zhangsan\").password(\"123456\").roles(\"VIP1\", \"VIP2\") .and() .withUser(\"lisi\").password(\"123456\").roles(\"VIP2\", \"VIP3\") .and() .withUser(\"wangwu\").password(\"123456\").roles(\"VIP1\", \"VIP3\"); /**有以下几种形式，使用第3种*/ //inMemoryAuthentication 从内存中获取 //auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(\"user1\").password(new BCryptPasswordEncoder().encode(\"123123\")).roles(\"USER\"); //jdbcAuthentication从数据库中获取，但是默认是以security提供的表结构 //usersByUsernameQuery 指定查询用户SQL //authoritiesByUsernameQuery 指定查询权限SQL //auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery(query).authoritiesByUsernameQuery(query); //注入userDetailsService，需要实现userDetailsService接口 auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); ==使用注入userDetailsService，需要实现userDetailsService接口== 1234567891011121314151617@Servicepublic class UserService implements UserDetailsService &#123; @Autowired UserMapper userMapper; @Autowired PrivilegeService privilegeService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User user = userMapper.getUserByName(username); if(user == null)&#123; throw new UsernameNotFoundException(\"没有该用户\"); &#125; return new UserDetailsImpl(user, privilegeService.queryByUserId(user.getUserId())); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@ToStringpublic class UserDetailsImpl implements UserDetails&#123; private User user; private String username; private String password; //包含着用户对应的所有Privilege，在使用时调用者给对象注入Privileges private List&lt;Privilege&gt; privilege; @Autowired private com.yoj.web.service.PrivilegeService PrivilegeService; public void setPrivilege(List&lt;Privilege&gt; privilege) &#123; this.privilege = privilege; &#125; //无参构造 public UserDetailsImpl() &#123; &#125; //用User构造 public UserDetailsImpl(User user) &#123; this.username = user.getUserName(); this.password = user.getPassword(); this.user = user; &#125; //用User和List&lt;Privilege&gt;构造 public UserDetailsImpl(User user,List&lt;Privilege&gt; Privileges) &#123; this.user = user; this.username = user.getUserName(); this.password = user.getPassword(); this.privilege = Privileges; &#125; public List&lt;Privilege&gt; getPrivilege() &#123; return privilege; &#125; @Override //返回用户所有角色的封装，一个Privilege对应一个GrantedAuthority public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for(Privilege Privilege : privilege) &#123; authorities.add(new SimpleGrantedAuthority(Privilege.getRight())); &#125; return authorities; &#125; @Override public String getPassword() &#123; return password; &#125; @Override public String getUsername() &#123; return username; &#125; @Override //判断账号是否已经过期，默认没有过期 public boolean isAccountNonExpired() &#123; return true; &#125; @Override //判断账号是否被锁定，默认没有锁定 public boolean isAccountNonLocked() &#123; return true; &#125; @Override //判断信用凭证是否过期，默认没有过期 public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override //判断账号是否可用，默认可用 public boolean isEnabled() &#123; return true; &#125;&#125; 5、开启自动配置的登陆功能：1、/login来到登陆页2、重定向到/login?error表示登陆失败3、更多详细规定4、默认post形式的 /login代表处理登陆5、一但定制loginPage；那么 loginPage的post请求就是登陆 123456@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin().usernameParameter(\"user\").passwordParameter(\"pwd\") .loginPage(\"/userlogin\"); configure(HttpSecurity http){http.formLogin();} 6、注销：http.logout();注意logout时需要表单中的按钮 1、访问 /logout 表示用户注销，清空session2、注销成功会返回 /login?logout 页面； 1http.logout().logoutSuccessUrl(\"/\");//注销成功以后来到首页 123&lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"注销\"/&gt;&lt;/form&gt; 7、记住我：Remeberme() 123456&lt;form th:action=\"@&#123;/userlogin&#125;\" method=\"post\"&gt; 用户名:&lt;input name=\"user\"/&gt;&lt;br&gt; 密码:&lt;input name=\"pwd\"&gt;&lt;br/&gt; &lt;input type=\"checkbox\" name=\"remember\"&gt; 记住我&lt;br/&gt; &lt;input type=\"submit\" value=\"登陆\"&gt;&lt;/form&gt; 8获取UserDetails 12UserDetailsImpl userDetails = (UserDetailsImpl) SecurityContextHolder.getContext().getAuthentication().getPrincipal(); System.out.println(userDetails); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); //定制请求的授权规则 http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"VIP1\") .antMatchers(\"/level2/**\").hasRole(\"VIP2\") .antMatchers(\"/level3/**\").hasRole(\"VIP3\"); //开启自动配置的登陆功能，效果，如果没有登陆，没有权限就会来到登陆页面 //http.formLogin(); //1、/login来到登陆页 //2、重定向到/login?error表示登陆失败 //3、更多详细规定 //4、默认post形式的 /login代表处理登陆 //5、一但定制loginPage；那么 loginPage的post请求就是登陆 http.formLogin().usernameParameter(\"user\").passwordParameter(\"pwd\") .loginPage(\"/userlogin\"); //开启自动配置的注销功能。// http.logout(); //1、访问 /logout 表示用户注销，清空session //2、注销成功会返回 /login?logout 页面； http.logout().logoutSuccessUrl(\"/\");//注销成功以后来到首页 //开启记住我功能// http.rememberMe(); //登陆成功以后，将cookie发给浏览器保存，以后访问页面带上这个cookie，只要通过检查就可以免登录 //点击注销会删除cookie http.rememberMe().rememberMeParameter(\"remember\"); &#125; //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //super.configure(auth); auth.inMemoryAuthentication() .withUser(\"zhangsan\").password(\"123456\").roles(\"VIP1\", \"VIP2\") .and() .withUser(\"lisi\").password(\"123456\").roles(\"VIP2\", \"VIP3\") .and() .withUser(\"wangwu\").password(\"123456\").roles(\"VIP1\", \"VIP3\"); /**有以下几种形式，使用第3种*/ //inMemoryAuthentication 从内存中获取 //auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(\"user1\").password(new BCryptPasswordEncoder().encode(\"123123\")).roles(\"USER\"); //jdbcAuthentication从数据库中获取，但是默认是以security提供的表结构 //usersByUsernameQuery 指定查询用户SQL //authoritiesByUsernameQuery 指定查询权限SQL //auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery(query).authoritiesByUsernameQuery(query); //注入userDetailsService，需要实现userDetailsService接口 auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); &#125;&#125; 定义认证用户信息获取来源，密码校验规则等 Thymeleaf Extras Springsecurity注意：thymeleaf和springsecurity版本一致，Thymeleaf Extras Springsecurity5 123456&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity5 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819div sec:authorize=\"!isAuthenticated()\"&gt; &lt;h2 align=\"center\"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href=\"@&#123;/userlogin&#125;\"&gt;请登录&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt;&lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;h2&gt;&lt;span sec:authentication=\"name\"&gt;&lt;/span&gt;，您好,您的角色有： &lt;span sec:authentication=\"principal.authorities\"&gt;&lt;/span&gt;&lt;/h2&gt; &lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"注销\"/&gt; &lt;/form&gt;&lt;/div&gt;&lt;hr&gt;&lt;div sec:authorize=\"hasRole('VIP1')\"&gt; &lt;h3&gt;普通武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/1&#125;\"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/2&#125;\"&gt;武当长拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/3&#125;\"&gt;全真剑法&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 在Spring Security中使用AJAX向后台传送数据本文链接：https://blog.csdn.net/bnrmaster/article/details/52939212 环境：spring 4.2.3 spring security 4.1.3 表现： 2016-10-26 22:44:02 [http-apr-9080-exec-10] DEBUG org.springframework.security.web.csrf.CsrfFilter - Invalid CSRF token found for XXX2016-10-26 22:44:02 [http-apr-9080-exec-10] DEBUG org.springframework.security.web.header.writers.HstsHeaderWriter - Not injecting HSTS header since it did not match the requestMatcher org.springframework.security.web.header.writers.HstsHeaderWriter$SecureRequestMatcher@c3339ef2016-10-26 22:44:02 [http-apr-9080-exec-10] DEBUG org.springframework.security.web.context.SecurityContextPersistenceFilter - SecurityContextHolder now cleared, as request processing completed 前台使用AJAX向后台传输数据时候控制台报出上述错误，再未集成Spring Security时不会出现此现象 解决方法： 如果前端使用的JSP 可以在前端页面的标签中增加两个标签 如下 1234567&lt;html&gt;&lt;head&gt; &lt;meta name=\"_csrf\" content=\"$&#123;_csrf.token&#125;\"/&gt; &lt;!-- default header name is X-CSRF-TOKEN --&gt; &lt;meta name=\"_csrf_header\" content=\"$&#123;_csrf.headerName&#125;\"/&gt; &lt;!-- ... --&gt;&lt;/head&gt; 如果前端使用的是Thymeleaf分两种情况 1.前端无form表单,也要再头部增加两个meta标签，形式为 1234567&lt;html&gt;&lt;head&gt; &lt;meta name=\"_csrf\" th:content=\"$&#123;_csrf.token&#125;\" content=\"\"/&gt; &lt;!-- default header name is X-CSRF-TOKEN --&gt; &lt;meta name=\"_csrf_header\" th:content=\"$&#123;_csrf.headerName&#125;\" content=\"\"/&gt; &lt;!-- ... --&gt;&lt;/head&gt; 2.前端有form表单 Spring Security为Thymeleaf中的表单中自动添加一个 (xxxx为crrf.token) 添加完meta之后不妨运行下，在页面代码中搜索_csrf，可以看看附近代码的样子，应该就会明白了 这样在使用AJAX时，需要增加一个头部 12345678910111213141516var token = $(\"meta[name='_csrf']\").attr(\"content\");var header = $(\"meta[name='_csrf_header']\").attr(\"content\"); $.ajax(&#123; type: \"POST\", url: \"myposturl\", data: entID, contentType:\"application/json; charset=utf-8\", headers : &#123;header:token&#125;, async:false, success:function(data)&#123; //do something &#125;, error: function () &#123; //deal width error &#125; &#125;); 实际上，这里的header使用为值”X-CSRF-TOKEN” 这样就可以成功向后台请求了 spring security reference 123456789101112131415161718var csrfHeader = $(\"meta[name='_csrf_header']\").attr(\"content\");var csrfToken = $(\"meta[name='_csrf']\").attr(\"content\");var headers = &#123;&#125;;headers[csrfHeader] = csrfToken;console.log(problem);$.ajax(&#123; url: \"/p/add\", type: \"POST\", headers : headers, data: problem, success(res)&#123; // $(\"id\").add(res); console.log(res); &#125;, error(res)&#123; console.log(res); &#125;&#125;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;CSRF Protected JavaScript Page&lt;/title&gt; &lt;meta name=\"description\" content=\"This is the description for this page\" /&gt; &lt;sec:csrfMetaTags /&gt; &lt;script type=\"text/javascript\" language=\"javascript\"&gt; var csrfParameter = $(\"meta[name='_csrf_parameter']\").attr(\"content\"); var csrfHeader = $(\"meta[name='_csrf_header']\").attr(\"content\"); var csrfToken = $(\"meta[name='_csrf']\").attr(\"content\"); // using XMLHttpRequest directly to send an x-www-form-urlencoded request var ajax = new XMLHttpRequest(); ajax.open(\"POST\", \"https://www.example.org/do/something\", true); ajax.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded data\"); ajax.send(csrfParameter + \"=\" + csrfToken + \"&amp;name=John&amp;...\"); // using XMLHttpRequest directly to send a non-x-www-form-urlencoded request var ajax = new XMLHttpRequest(); ajax.open(\"POST\", \"https://www.example.org/do/something\", true); ajax.setRequestHeader(csrfHeader, csrfToken); ajax.send(\"...\"); // using JQuery to send an x-www-form-urlencoded request var data = &#123;&#125;; data[csrfParameter] = csrfToken; data[\"name\"] = \"John\"; ... $.ajax(&#123; url: \"https://www.example.org/do/something\", type: \"POST\", data: data, ... &#125;); // using JQuery to send a non-x-www-form-urlencoded request var headers = &#123;&#125;; headers[csrfHeader] = csrfToken; $.ajax(&#123; url: \"https://www.example.org/do/something\", type: \"POST\", headers: headers, ... &#125;); &lt;script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 六、Spring Boot与分布式 七、Spring Boot与监控管理 八、Spring Boot与部署 七.开发热部署一、热部署在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，如何能实现热部署。 •1、模板引擎 –在Spring Boot中开发情况下禁用模板引擎的cache –页面模板改变ctrl+F9可以重新编译当前页面并生效 2、Spring Loaded Spring官方提供的热部署程序，实现修改类文件的热部署 –下载Spring Loaded（项目地址https://github.com/spring-projects/spring-loaded） –添加运行时参数； -javaagent:C:/springloaded-1.2.5.RELEASE.jar –noverify 3、JRebel –收费的一个热部署软件 –安装插件使用即可 4、Spring Boot Devtools（推荐）–引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; –IDEA使用ctrl+F9 –或做一些小调整 Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下才会自动编译（前提是你已经设置了Auto-Compile）。 •设置自动编译（settings-compiler-make project automatically） •ctrl+shift+alt+/（maintenance） •勾选compiler.automake.allow.when.app.running","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://codeofli.github.io/tags/spring/"},{"name":"springBoot","slug":"springBoot","permalink":"https://codeofli.github.io/tags/springBoot/"}]},{"title":"hexo","slug":"hexo/hexo","date":"2019-09-27T14:19:09.000Z","updated":"2022-03-02T01:21:40.164Z","comments":true,"path":"2019/09/hexo/hexo/","link":"","permalink":"https://codeofli.github.io/2019/09/hexo/hexo/","excerpt":"[TOC]hexo官方文档安装hexonpm安装hexo1npm install -g hexo-clihttps://blog.csdn.net/xuezhisdc/article/details/53130328如：E:\\Program Files\\nodejs\\my_node\\node_global\\hexo.cmd","text":"[TOC]hexo官方文档安装hexonpm安装hexo1npm install -g hexo-clihttps://blog.csdn.net/xuezhisdc/article/details/53130328如：E:\\Program Files\\nodejs\\my_node\\node_global\\hexo.cmd 可查看是否完成安装，使用 1hexo v 开始构建条件 npm+git 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） 1234deploy: type: git repository: git@github.com:Li-MingZhong/Li-MingZhong.github.io.git(自己仓库的ssh链接) branch: master 在生成以及部署文章之前，需要安装一个扩展： 1npm install hexo-deployer-git --save 新建一篇博客，在cmd执行命令：hexo new post “博客名” 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署(即自动提交）了 注意：提交到Github先修改url 1234# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://codeofli.github.io# url: http://localhost:4000 修改配置文件，最好clean一下，反正配置文件未生效 1hexo clean 最后 1hexo d -g 然后提交 使用启动 12hexo shexo serve md解析头格式在 source 文件夹下的所有 md 文件或者 html 文件都会被渲染 在sourece/_post目录下相应的md添加相应的头信息由hexo解析。 1234567891011121314---title: mybatis(网页显示和文章标题)p: java-note/mybatis/mybatis（java-note/mybatis/mybatis.md(省略了.md)在_post路径下的位置，需要创建对于文件夹）,不需要p参数也能被解析date: 2019-11-12 10:40:06 (创建时间)categories: java tags: [java,mybatis]--- 案例 1234567891011---title: mybatisdate: 2021-10-24 10:40:06categories: javatags: [java,mybatis]--- [命令][https://hexo.io/zh-cn/docs/commands]generate1$ hexo generate 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 -b, --bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, --force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, --concurrency 最大同时生成文件的数量，默认无限制 该命令可以简写为 1$ hexo g new1hexo n -p js-note/vue/vue 'vue' 能挂载图片和创建路径 1$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 1$ hexo new \"post title with whitespace\" 参数 描述 -p, --path 自定义新文章的路径 -r, --replace 如果存在同名文章，将其替换 -s, --slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 --path 参数来覆盖上述行为、自行决定文件的目录： 1hexo new page --path about/me \"About me\" 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot; 注意！title 是必须指定的！如果你这么做并不能达到你的目的： 1hexo new page --path about/me 此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 &quot;page&quot;。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。 解决markdown插入图片问题hexo默认无法自动处理文章插入本地图片，需要通过扩展插件支持。 图片路径问题1.配置_config.yml里面的post_asset_folder:false这个选项设置为true。 2.安装hexo-asset-image 1npm install hexo-asset-image --save 3.运行hexo n &quot;xxxx&quot;来生成md博文，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹，把图片放入该文件夹。 1hexo n \"xxxx\" 4.使用![xxx](xxx/xxx.png)直接插入图片即可。 配置typora进行本地图片的粘贴及正常显示 设置typora,图像 注意1.图片名中间不能有空格 注意测试时配置文件_config.yml中url使用localhost 1234# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'# url: https://codeofli.github.iourl: http://localhost:4000 hexo设置多标签和多分类分类↓↓↓↓categories: 一级分类-二级分类 例如 categories: java-SpringMVC标签↓↓↓↓tags: [标签1,标签2，…] 例如 tags: [java,SpringMVC] hexo clean12PS E:\\Codes\\other\\hexo\\my-blog&gt; hexo cleanINFO Deleted database. hexo会记录以前的配置信息和tags之类的，所以，清楚标签之后，hexo clear一下 设置跳过的渲染文件skip_render: 1skip_render: [README.md, \"**/*.js\",\"**/source/**\",\"**/other/**\",\"**/src/**\"] markdwon解析错误1.一个#后面没有内容，解析失败 next主题[]: next主题优化 4.添加动态背景5. 修改标签样式9.文章阴影设置10. 添加文章版权信息12. 添加打赏13. 添加页面宠物18.增加阅读次数/时长和访客数19.加入网易云音乐播放器","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"mysql","slug":"数据库/mysql/mysql","date":"2019-03-27T14:19:09.000Z","updated":"2022-04-08T10:09:53.490Z","comments":true,"path":"2019/03/数据库/mysql/mysql/","link":"","permalink":"https://codeofli.github.io/2019/03/数据库/mysql/mysql/","excerpt":"[TOC]六、DML语言的学习 ★ 插入语句 修改语句 删除语句 七、DDL语言的学习 库和表的管理 √ 常见数据类型介绍 √ 常见约束 √ 八、TCL语言的学习 事务和事务处理 九、视图的讲解 √ 十、变量 十一、存储过程和函数 十二、流程控制结构","text":"[TOC]六、DML语言的学习 ★ 插入语句 修改语句 删除语句 七、DDL语言的学习 库和表的管理 √ 常见数据类型介绍 √ 常见约束 √ 八、TCL语言的学习 事务和事务处理 九、视图的讲解 √ 十、变量 十一、存储过程和函数 十二、流程控制结构 数据库简介MySQL - 菜鸟教程 数据库相关概念数据库的好处1.持久化数据到 本地 2.可以实现结构化查询，方便管理数据库相关概念1、DB：数据库，保存一组有组织的数据的容器 2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据 3、SQL:结构化查询语言，用于和DBMS通信的语言数据库存储数据的特点1、将数据放到表中，表再放到库中 2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。 3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。 4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性” 5、表中的数据是按行存储的，每一行类似于java中的“对象”。MySQL产品的介绍和安装MySQL服务的启动和停止1234方式一：计算机——右击管理——服务方式二：通过管理员身份运行net start 服务名（启动服务）net stop 服务名（停止服务） MySQL服务的登录和退出12方式一：通过mysql自带的客户端只限于root用户 123456方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C SQL的语言分类12345678DQL（Data Query Language）：数据查询语言 select DML(Data Manipulate Language):数据操作语言 insert 、update、deleteDDL（Data Define Languge）：数据定义语言 create、drop、alterTCL（Transaction Control Language）：事务控制语言 commit、rollback MySQL的语法规范1.不区分大小写,但建议关键字大写，表名、列名小写2.每条命令最好用分号结尾3.每条命令根据需要，可以进行缩进 或换行4.注释 123单行注释：#注释文字单行注释：-- 注释文字多行注释：/* 注释文字 */ 查询-DQL语言基础查询12语法：SELECT 要查询的东西【FROM 表名】; 1234类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数 DISTINCT相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。 12SELECT DISTINCT col1, col2FROM mytable; 计算字段在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。 12345678910SELECT col1 * col2 AS aliasFROM mytable;#起别名#方式一：使用asSELECT last_name AS 姓,first_name AS 名 FROM employees;#方拾二：省略as(使用空格)SELECT last_name 姓,first_name 名 FROM employees;#包含特殊字符使用\"\"('')标注为字符串SELECT last_name \"姓 X\",first_name 名 FROM employees; CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。 123456SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_colFROM mytable; # +#只要有一方为null，则+和拼接都为nullSELECT CONCAT(first_name,' ',last_name) `name` FROM emplyees; 条件查询where 关键字 条件查询：根据条件过滤原始表的数据，查询到想要的数据语法： 123select 要查询的字段|表达式|常量值|函数from 表where 条件; 下表显示了 WHERE 子句可用的操作符 操作符 说明 = 等于 &lt; 小于 &gt; 大于 &lt;&gt; , != 不等于 &lt;= , !&gt; 小于等于 &gt;= , !&lt; 大于等于 BETWEEN 在两个值之间 IS NULL 为 NULL 值 应该注意到，NULL 与 0、空字符串都不同。 AND 和 OR 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。 IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。 NOT 操作符用于否定一个条件。 分类： 1条件表达式​ 示例：salary &gt; 10000​ 条件运算符：​ &gt; ,&lt; ,&gt;=, &lt;=, =, !=, &lt;&gt; 2逻辑表达式示例：salary &gt;10000 &amp;&amp; salary &lt; 20000 逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为falseor(||)：两个条件只要有一个成立，结果为true，否则为falsenot(!)：如果条件成立，则not后为false，否则为true between and 等价于并简化了 &gt;= &lt;= 语句in 判断某字段的值是否属于in列表中的某一项，in中列表值类型必须一致或兼容 1SELECT * FROM employees WHERE job_id IN(&apos;IT_PROT&apos;,&apos;AD_VP&apos;); is null| is not null只能判断null值，= 和&lt;&gt; 不能判断null值安全等于&lt;=&gt;既能判断是否为null，也能判断其他类型 3模糊查询LIKE 通配符通配符也是用在过滤语句中，但它只能用于文本字段。 % 匹配 &gt;=0 个任意字符； _ 匹配 ==1 个任意字符； [ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。 特殊字符：使用转义字符 使用 Like 来进行通配符匹配。 123SELECT *FROM mytableWHERE col LIKE '[^AB]%'; -- 不以 A 和 B 开头的任意文本 不要滥用通配符，==通配符位于开头处匹配会非常慢。== 排序查询 ASC : 升序(默认) DESC : 降序 1234567语法：select 要查询的东西from 表where 条件 order by 排序的字段|表达式|函数|别名 【asc|desc】,次要排序内容(通前面格式一致)#默认升序 常见函数各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。 调用 1select 函数名（实参列表）【form 表】 函数可以嵌套 分组函数，聚合函数，汇总函数，是同一种概念的不同称呼。都是指对一组值执行计算并返回单一的值。 1单行函数单行函数分为：字符串函数、数值函数、日期函数、转换函数、通用函数。所有的单行函数可以在SQL语句的任意位置上出现。 1、字符函数 concat()拼接（字符串） substr()截取子串 upper()转换成大写 lower()转换成小写 trim()去前后指定的空格和字符 ltrim()去左边空格 rtrim()去右边空格 replace()替换 lpad()左填充 rpad()右填充 instr()返回子串第一次出现的索引，如果找不到返回0 length() 获取字节个数 2数值函数 函数 说明 round() 四舍五入 floor() 向下取整 ceil() 向上取整 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 SIN() 正弦 COS() 余弦 TAN() 正切 mod() 取余 mod(a,b) = a-a/b*b（有效解决负数问题） truncate() 截断 ​ 3日期函数 日期格式: YYYY-MM-DD 时间格式: HH:MM:SS 函 数 说 明 AddDate() 增加一个日期(天、周等) AddTime() 增加一个时间(时、分等) CurDate() 返回当前系统日期 CurTime() 返回当前系统时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间(字符)串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前（系统）日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 str_to_date() 将字符转换成日期 12mysql&gt; SELECT NOW();2018-4-14 20:25:11 4、流程控制函数​ if (条件表达式，成立值，false值)处理双分支 ，和三元运算符相当​ case语句 处理多分支​ 情况1：处理等值判断 123456789101112131415case 要判断的字段或表达式when 常量1 then 要显示的值1或语句1;when 常量2 then 要显示的值2或语句2;···else 要显示的值n或语句n;endSELECT salary init,department_id,CASE department_idWHEN 30 THEN salary*1.1WHEN 40 THEN salary*1.2WHEN 50 THEN salary*1.3ELSE salaryEND AS `new`FROM employees; 情况2：处理条件判断123456789101112131415casewhen 常量1 then 要显示的值1或语句1;when 常量2 then 要显示的值2或语句2;···else 要显示的值n或语句n;end#相当于多重if语句SELECT salary,CASEWHEN salary &gt; 20000 THEN 'a'WHEN salary &gt; 15000 THEN 'b'WHEN salary &gt; 10000 THEN 'b'ELSE 'd'END AS gradeFROM employees; 5、其他函数​ version版本​ database当前库​ user当前连接用户 2分组(汇总，聚合)函数聚合函数：对一组值执行计算并返回单一的值 又称统计函数,也成汇总函数，也称为聚合函数;分组函数是对表中一组记录进行操作，每组值返回一个结果，即首先要对表记录进行分组，然后再进对表记录进行分组，然后在进行操作汇总，每组返回一个结果，分组是可能是整个表分为一个组，也可能根据条件分成多组。 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG() 会忽略 NULL 行。 使用 DISTINCT 可以让汇总函数值汇总不同的值。 12SELECT AVG(DISTINCT col1) AS avg_colFROM mytable; 特点： 以上五个分组函数都忽略null值，除了count(*) sum和avg一般用于处理数值型max、min、count可以处理任何数据类型 都可以搭配distinct使用，用于统计去重后的结果 count的参数可以支持：字段、*、常量值，一般放1 建议使用 count(*) 可以搭配group by使用 1SELECT MAX(column_name) FROM table_name GROUP BY column_name; SQL MAX() 语法1SELECT MAX(column_name) FROM table_name; 分组查询GROUP BY 语句，分组就是把具有相同的数据值的行放在同一组中，即根据一个或多个列对结果集进行分组。 可以对同一分组数据使用汇总(分组)函数进行处理，在分组的列上我们可以使用 COUNT, SUM, AVG,等函数，例如求分组数据的平均值等。 GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。 WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。 12345SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name HAVING column_name operator; 分组规定: GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总（分组）字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。 having后可以支持别名 123456789101112mysql&gt; SELECT * FROM employee_tbl;+----+--------+---------------------+--------+| id | name | date | signin |+----+--------+---------------------+--------+| 1 | 小明 | 2016-04-22 15:25:33 | 1 || 2 | 小王 | 2016-04-20 15:25:47 | 3 || 3 | 小丽 | 2016-04-19 15:26:02 | 2 || 4 | 小王 | 2016-04-07 15:26:14 | 4 || 5 | 小明 | 2016-04-11 15:26:40 | 4 || 6 | 小明 | 2016-04-04 15:26:54 | 2 |+----+--------+---------------------+--------+6 rows in set (0.00 sec) 接下来我们使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录： 123456789mysql&gt; SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;+--------+----------+| name | COUNT(*) |+--------+----------+| 小丽 | 1 || 小明 | 3 || 小王 | 2 |+--------+----------+3 rows in set (0.01 sec) 使用 WITH ROLLUPWITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。 例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数： 12345678910mysql&gt; SELECT name, SUM(signin) as signin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------+--------------+| name | signin_count |+--------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || NULL | 16 |+--------+--------------+4 rows in set (0.00 sec) 其中记录 NULL 表示所有人的登录次数。 我们可以使用 coalesce 来设置一个可以取代 NULL 的名称，coalesce 语法： 1select coalesce(a,b,c); 参数说明：如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。 以下实例中如果名字为空我们使用总数代替： 12345678910mysql&gt; SELECT coalesce(name, &apos;总数&apos;), SUM(signin) as signin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------------------------+--------------+| coalesce(name, &apos;总数&apos;) | signin_count |+--------------------------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || 总数 | 16 |+--------------------------+--------------+4 rows in set (0.01 sec) group by能用于多列去重 123SELECT solution_id,s.problem_id,user_id,user_name,score FROM solution s,contest_problem cp where s.contest_id = 19 AND s.problem_id = cp.problem_id AND s.contest_id = cp.contest_id AND result = 0 GROUP BY s.problem_id,user_id 参考链接：菜鸟教程—MySQL GROUP BY 语句 连接查询连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。 连接可以替换子查询，并且比子查询的效率一般会更快。 可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。 MySQL中的inner和outer可以省略 建议写上，可读性更好 在MySQL中主要区分内连接和外链接的根本原因并不是这两个关键字 如果SQL语句中 带有left join或者 left outer join时 那这条SQL语句一定是外连接， 在写SQL语句时这两个关键字都可以省略 ，写上这两个关键字只是意味着可读性好（） 语法： 12345678select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on 连接条件【inner|left outer|right outer|cross】join 表3 on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】 内连接内连接又称等值连接，使用 INNER JOIN 关键字。 123SELECT A.value, B.valueFROM tablea AS A INNER JOIN tableb AS BON A.key = B.key; 尽量使用INNER JOIN，好处：语句上，连接条件和筛选条件实现了分离，简洁明了！ 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。 123SELECT A.value, B.valueFROM tablea AS A, tableb AS BWHERE A.key = B.key; 在没有条件语句的情况下返回笛卡尔积。 扩展： Cross join：（很少用） cross join，交叉连接，实际上就是将两个表进行笛卡尔积运算，结果表的行数等于两表行数之积 笛卡尔积笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尔积（Cartesian product），又称直积，表示为X×Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员 [3] 。 假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。 类似的例子有，如果A表示某学校学生的集合，B表示该学校所有课程的集合，则A与B的笛卡尔积表示所有可能的选课情况。A表示所有声母的集合，B表示所有韵母的集合，那么A和B的笛卡尔积就为所有可能的汉字全拼。 设A,B为集合，用A中元素为第一元素，B中元素为第二元素构成有序对，所有这样的有序对组成的集合叫做A与B的笛卡尔积，记作AxB. 笛卡尔积的符号化为： A×B={(x,y)|x∈A∧y∈B} 例如，A={a,b}, B={0,1,2}，则 A×B={(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)} B×A={(0, a), (0, b), (1, a), (1, b), (2, a), (2, b)} ¶ 自连接自连接可以看成内连接的一种，只是连接的表是自身而已。 一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。 子查询版本 123456SELECT nameFROM employeeWHERE department = ( SELECT department FROM employee WHERE name = \"Jim\"); 自连接版本 1234SELECT e1.nameFROM employee AS e1 INNER JOIN employee AS e2ON e1.department = e2.department AND e2.name = \"Jim\"; ¶ 自然连接自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。 内连接和自然连接的区别: 内连接提供连接的列，而自然连接自动连接==所有同名列==。 12SELECT A.value, B.valueFROM tablea AS A NATURAL JOIN tableb AS B; ¶ 外连接1LEFT|RIGHT OUTER JOIN 外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行，右表选择列置为null。 检索所有顾客的订单信息，包括还没有订单信息的顾客。 123SELECT Customers.cust_id, Orders.order_numFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_id; customers 表: cust_id cust_name 1 a 2 b 3 c orders 表: order_id cust_id 1 1 2 1 3 3 4 3 结果: cust_id cust_name order_id 1 a 1 1 a 2 3 c 3 3 c 4 2 b Null 总结 子查询子查询中只能返回一个字段的数据。 可以将子查询的结果作为 WHRER 语句的过滤条件: 1234SELECT *FROM mytable1WHERE col1 IN (SELECT col2 FROM mytable2); 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次: 123456SELECT cust_name, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders_numFROM CustomersORDER BY cust_name; 含义：12一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询 特点： 123456789101112131415161、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询 结果集只有一行 一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 非法使用子查询的情况： a、子查询的结果为一组值 b、子查询的结果为空 ② 多行子查询 结果集有多行 一般搭配多行操作符使用：any、all、in、not in in： 属于子查询结果中的任意一个就行 any和all往往可以用其他查询代替 12SELECT solution_id,problem_id,user_id,MIN(runtime) as runtime FROM solution WHERE contest_id = 19 AND result = 0 GROUP BY problem_id,user_id 分页查询¶ LIMIT限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 应用场景： 1实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句 语法： 123456789101112131415select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始行，】条目数;# 使用offsetselect 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 条目数 offset 起始行; 特点： 起始条目索引从0开始 limit子句放在查询语句的最后 公式： 1select * from 表 limit （page-1）*sizePerPage,sizePerPage 假如: 每页显示条目数sizePerPage 要显示的页数 page 返回前 5 行: 123SELECT *FROM mytableLIMIT 5; 123SELECT *FROM mytableLIMIT 0, 5; 返回第 3 ~ 5 行: 123SELECT *FROM mytableLIMIT 2, 3; offset当 limit和offset组合使用的时候，limit后面只能有一个参数，表示要取的的数量,offset表示要跳过的数量 。 12select * from article LIMIT 3 OFFSET 1 表示跳过1条数据,从第2条数据开始取，取3条数据，也就是取2,3,4三条数据 联合查询，组合查询使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。 每个查询必须包含相同的列、表达式和聚集函数。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 语法： 1234select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 1234567SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2; 视图视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。 对视图的操作和对普通表的操作一样。 视图具有如下好处: 简化复杂的 SQL 操作，比如复杂的连接； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 1234CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_colFROM mytableWHERE col5 = val; 视图的创建​ 语法： 123CREATE VIEW 视图名AS查询语句; 视图的增删改查​ 1、查看视图的数据 ★ 123456789SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name='Partners';2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES('虚竹',90);3、修改视图的数据UPDATE my_v4 SET last_name ='梦姑' WHERE last_name='虚竹'; 4、删除视图的数据 DELETE FROM my_v4;某些视图不能更新​ 包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all​ 常量视图​ Select中包含子查询​ join​ from一个不能更新的视图​ where子句的子查询引用了from子句中的表 视图逻辑的更新​ #方式一：​ CREATE OR REPLACE VIEW test_v7​ AS​ SELECT last_name FROM employees​ WHERE employee_id&gt;100;​ #方式二: ALTER VIEW test_v7 AS SELECT employee_id FROM employees; SELECT * FROM test_v7;视图的删除​ DROP VIEW test_v1,test_v2,test_v3; 视图结构的查看​ DESC test_v7;​ SHOW CREATE VIEW test_v7; 著作权归https://pdai.tech所有。 链接：https://pdai.tech/md/db/sql-lan/sql-lan.html 存储过程存储过程可以看成是对一系列 SQL 操作的批处理。 使用存储过程的好处: 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。 包含 in、out 和 inout 三种参数。 给变量赋值都需要用 select into 语句。 每次只能给一个变量赋值，不支持集合的操作。 创建存储过程语法： 12345create procedure 存储过程名(in|out|inout 参数名 参数类型,...)begin 存储过程体end 类似于方法： 1234修饰符 返回类型 方法名(参数类型 参数名,...)&#123; 方法体;&#125; 参数类型：参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出 注意：in、out、inout都可以在一个存储过程中带多个 注意1、需要设置新的结束标记 1delimiter 新的结束标记 示例： 12345678delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)BEGIN sql语句1; sql语句2;END $ 2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end 调用存储过程1call 存储过程名(实参列表) 用例123456789101112delimiter //create procedure myprocedure( out ret int ) begin declare y int; select sum(col1) from mytable into y; select y*y into ret; end //delimiter ; 12call myprocedure(@ret);select @ret; 著作权归https://pdai.tech所有。 链接：https://pdai.tech/md/db/sql-lan/sql-lan.html 游标在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。 使用游标的四个步骤: 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标； 1234567891011121314151617181920delimiter //create procedure myprocedure(out ret int) begin declare done boolean default 0; declare mycursor cursor for select col1 from mytable; # 定义了一个 continue handler，当 sqlstate &apos;02000&apos; 这个条件出现时，会执行 set done = 1 declare continue handler for sqlstate &apos;02000&apos; set done = 1; open mycursor; repeat fetch mycursor into ret; select ret; until done end repeat; close mycursor; end // delimiter ; 著作权归https://pdai.tech所有。 链接：https://pdai.tech/md/db/sql-lan/sql-lan.html 触发器触发器会在某个表执行以下语句（修改语句）时而自动执行: DELETE、INSERT、UPDATE。 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。 INSERT 触发器包含一个名为 NEW 的虚拟表。 1234CREATE TRIGGER mytrigger AFTER INSERT ON mytableFOR EACH ROW SELECT NEW.col into @result;SELECT @result; -- 获取结果 DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。 UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。 MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。 著作权归https://pdai.tech所有。 链接：https://pdai.tech/md/db/sql-lan/sql-lan.html 函数创建函数学过的函数：LENGTH、SUBSTR、CONCAT等语法： 12345CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN 函数体END 调用函数​ SELECT 函数名（实参列表） 函数和存储过程的区别123 关键字 调用语法 返回值 应用场景函数 FUNCTION SELECT 函数() 只能是一个 一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程 PROCEDURE CALL 存储过程() 可以有0个或多个 一般用于更新 字符集基本术语: 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对字符指定如何比较，主要用于排序和分组。 除了给表指定字符集和校对外，也可以给列指定: 123CREATE TABLE mytable(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; 可以在排序、分组时指定校对: 123SELECT *FROM mytableORDER BY col COLLATE latin1_general_ci; 增删改，DML语言DML（Data Manipulation Language），数据操纵语言，即增删改，INSERT、UPDATE、DELETE。 数据操纵语言DML主要有三种形式： 1) 插入：INSERT2) 更新：UPDATE3) 删除：DELETE 插入语法： 1234insert into 表名(字段名，...)values(值1，...);INSERT INTO mytable(col1, col2)VALUES(val1, val2); 特点： 123451、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 插入检索出来的数据 123INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2; 将一个表的内容插入到一个新表 12CREATE TABLE newtable ASSELECT * FROM mytable; 修改（更新）修改单表语法： 12345update 表名 set 字段=新值,字段=新值【where 条件】UPDATE mytableSET col = valWHERE id = 1; 修改多表语法： 1234update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件 删除方式1：delete语句 单表的删除： ★ 1234delete from 表名【where 筛选条件】DELETE FROM mytableWHERE id = 1; 多表的删除： 1234delete 别名1，别名2from 表1 别名1，表2 别名2where 连接条件and 筛选条件; 方式2：truncate语句 TRUNCATE TABLE 可以清空表，也就是删除所有行。 truncate v. 截断,截取 12truncate table 表名TRUNCATE TABLE mytable; 两种方式的区别【面试题】删除 使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。 1.truncate不能加where条件，而delete可以加where条件 2.truncate的效率高一丢丢 3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始 4.truncate删除不能回滚，delete删除可以回滚 定义-DDL语句，DDL（data definition language）：数据库模式定义语言 数据定义语言，DDL用来创建数据库中的各种对象–—表、视图、索引、同义词、聚簇等如：CREATE TABLE / VIEW / INDEX / SYN / CLUSTER| 表 视图 索引 同义词 簇。DDL操作是隐性提交的！不能rollback。 DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用 数据库、表的操作(命令)创建数据库 1CREATE DATABASE IF NOT EXISTS yoj DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 创建数据库，该命令的作用： \\1. 如果数据库不存在则创建，存在则不创建。 \\2. 创建yoj数据库，并设定编码集为utf8 删除数据库。 1DROP DATABASE dbName; 创建数据库。 1create database yoj; 1.查看当前所有的数据库 1show databases; 2.打开(使用)指定的库 1use 库名 3.查看当前库的所有表 1show tables; 4.查看其它库的所有表 1show tables from 库名; 5.创建表 123456789101112131415create table 表名( 列名 列类型, 列名 列类型， 。。。);CREATE TABLE mytable ( id INT NOT NULL AUTO_INCREMENT, col1 INT NOT NULL DEFAULT 1, col2 VARCHAR(45) NULL, col3 DATE NULL, PRIMARY KEY (`id`)); 6.查看表结构 1desc 表名; 修改表结构添加列 12ALTER TABLE mytableADD col CHAR(20); 删除列 12ALTER TABLE mytableDROP COLUMN col; 删除表 1DROP TABLE mytable; 修改字段类型和列级约束1ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ; 唯一约束（UNIQUE KEY）MySQL唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。 在创建表时设置唯一约束在定义完列之后直接使用 UNIQUE 关键字指定唯一约束，语法规则如下： &lt;字段名&gt; &lt;数据类型&gt; UNIQUE 【实例 1】创建数据表 tb_dept2，指定部门的名称唯一，输入的 SQL 语句和运行结果如下所示。 CREATE TABLE tb_dept2( id INT(11) PRIMARY KEY, name VARCHAR(22) UNIQUE, location VARCHAR(50)); 查询tb_dept2结构 mysql&gt; DESC tb_dept2;+———-+————-+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+———-+————-+——+—–+———+——-+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | YES | UNI | NULL | || location | varchar(50) | YES | | NULL | |+———-+————-+——+—–+———+——-+3 rows in set (0.03 sec) UNI 就是唯一约束 提示：UNIQUE 和 PRIMARY KEY 的区别：一个表可以有多个字段声明为 UNIQUE，但只能有一个 PRIMARY KEY 声明；声明为 PRIMAY KEY 的列不允许有空值，但是声明为 UNIQUE 的字段允许空值的存在。 因为是创建时候指定的所以他的唯一约束名称就是他本身 在修改表时添加唯一约束在修改表时添加唯一约束的语法格式为： 1ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;唯一约束名&gt; UNIQUE(&lt;列名&gt;); 【实例 2】修改数据表 tb_dept1，指定部门的名称唯一，输入的 SQL 语句和运行结果如下所示。 1ALTER TABLE tb_dept1 ADD CONSTRAINT unique_name UNIQUE(name); 查询tb_dept1结构 123456789mysql&gt; DESC tb_dept1;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | UNI | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.04 sec) 删除唯一约束 在 MySQL 中删除唯一约束的语法格式如下： ALTER TABLE &lt;表名&gt; DROP INDEX &lt;唯一约束名&gt;;1【实例 3】删除数据表 tb_dept1 中的唯一约束 unique_name，输入的 SQL 语句和运行结果如下所示。 ALTER TABLE tb_dept1DROP INDEX unique_name;12查询tb_dept1结构 mysql&gt; DESC tb_dept1;+———-+————-+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+———-+————-+——+—–+———+——-+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | YES | | NULL | |+———-+————-+——+—–+———+——-+3 rows in set (0.03 sec) 可以发现name的key 没有UNI了 参考链接：https://blog.csdn.net/weixin_45203607/article/details/120248076 12345677.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V 库和表的管理库的管理： 1234一、创建库create database 库名二、删除库drop database 库名 表的管理： # 1.创建表12345CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME ); DESC studentinfo;2.修改表 alter12345678910111213141516语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO] studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email; ​ # 3.删除表​​ DROP TABLE [IF EXISTS] studentinfo; ​ 常见类型12345678整型： 小数： 浮点型 定点型字符型：日期型：Blob类型： 常见约束123456NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY 流程控制结构系统变量一、全局变量 作用域：针对于所有会话（连接）有效，但不能跨重启 123456789查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE '%char%';查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0; 二、会话变量 作用域：针对于当前会话（连接）有效 12345678910查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE '%char%';查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation='read-uncommitted';SET SESSION tx_isolation='read-committed'; ###自定义变量一、用户变量 声明并初始化： 123SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值; 赋值： 1234方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值; 123方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表; 使用： 1select @变量名; 二、局部变量 声明： 1declare 变量名 类型 【default 值】; 赋值： 1234方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值; 123方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表; 使用： 1select 变量名 二者的区别： 1作用域 定义位置 语法 用户变量 当前会话 会话的任何地方 加@符号，不用指定类型局部变量 定义它的BEGIN END中 BEGIN END的第一句话 一般不用加@,需要指定类型 ###分支一、if函数 语法：if(条件，值1，值2) 特点：可以用在任何位置 二、case语句 语法： 123456789101112131415情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要） 特点： 可以用在任何位置 三、if elseif语句 语法： 12345if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if; 特点： 只能用在begin end中！！！！！！！！！！！！！！！ 三者比较： 应用场合 if函数 简单双分支 case结构 等值判断 的多分支 if结构 区间判断 的多分支 ###循环 语法： 123【标签：】WHILE 循环条件 DO 循环体END WHILE 【标签】; 特点： 12345只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！ DCL,数据控制，事务，权限DCL,数据控制语言 数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如： 1) GRANT：授权。2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚—ROLLBACK回滚命令使数据库状态回到上次最后提交的状态。其格式为：SQL&gt;ROLLBACK;3) COMMIT [WORK]：提交。在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。提交数据有三种类型：显式提交、隐式提交及自动提交。下面分别说明这三种类型。 (1) 显式提交用COMMIT命令直接完成的提交为显式提交。其格式为：SQL&gt;COMMIT； (2) 隐式提交用SQL命令间接完成的提交为隐式提交。这些命令是：ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。 (3) 自动提交若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。其格式为：SQL&gt;SET AUTOCOMMIT ON； 事务管理基本术语: 事务(transaction)指一组 SQL 语句； 回退(rollback)指撤销指定 SQL 语句的过程； 提交(commit)指将未存储的 SQL 语句结果写入数据库表； 保留点(savepoint)指事务处理中设置的临时占位符(placeholder)，你可以对它发布回退(与回退整个事务处理不同)。 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。 MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。 通过设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。 如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。 1234567START TRANSACTION// ...SAVEPOINT delete1// ...ROLLBACK TO delete1// ...COMMIT 数据库事务含义​ 通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态 特点​ （ACID） 原子性：要么都执行，要么都回滚 一致性：保证数据的状态操作前和操作后保持一致 隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰 持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改 相关步骤： 1231、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务 事务的分类：隐式事务，没有明显的开启和结束事务的标志 12比如insert、update、delete语句本身就是一个事务 显式事务，具有明显的开启和结束事务的标志 1234567891、开启事务取消自动提交事务的功能2、编写事务的一组逻辑操作单元（多条sql语句）insertupdatedelete3、提交事务或回滚事务 使用到的关键字12345678set autocommit=0;start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点 事务的隔离级别:事务并发问题如何发生？ 1当多个事务同时操作同一个数据库的相同数据时 事务的并发问题有哪些？ 123脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据 如何避免事务的并发问题？ 12345通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读 设置隔离级别： 1set session|global transaction isolation level 隔离级别名; 查看隔离级别： 1select @@tx_isolation; 著作权归https://pdai.tech所有。 链接：https://pdai.tech/md/db/sql-lan/sql-lan.html 权限管理MySQL 的账户信息保存在 mysql 这个数据库中。 12USE mysql;SELECT user FROM user; 创建账户 新创建的账户没有任何权限。 1CREATE USER myuser IDENTIFIED BY 'mypassword'; 修改账户名 1RENAME myuser TO newuser; 删除账户 1DROP USER myuser; 查看权限 1SHOW GRANTS FOR myuser; 授予权限 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 1GRANT SELECT, INSERT ON mydatabase.* TO myuser; 删除权限 GRANT 和 REVOKE 可在几个层次上控制访问权限: 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 1REVOKE SELECT, INSERT ON mydatabase.* FROM myuser; 更改密码 必须使用 Password() 函数 1SET PASSWROD FOR myuser = Password('new_password'); SQL语言 - SQL语句练习SQL语言 - SQL语句练习 leetcode数据库相关练习 1,[2,200],[3,300] 查看第N高的数据，没有则返回为null12345678/*临时表解决null问题select NULL，返回null值n为数值*/SELECT (SELECT DISTINCT salary AS SecondHighestSalary FROM Employee ORDER BY salary DESC LIMIT n-1,1) AS SecondHighestSalary SQL语言 - SQL语句优化 最后，再总结一些SQL语句的优化建议。@pdai SQL语言 - SQL语句优化 负向查询不能使用索引 前导模糊查询不能使用索引 数据区分不明显的不建议创建索引 字段的默认值不要为 null 在字段上进行计算不能命中索引 最左前缀问题 如果明确知道只有一条记录返回 不要让数据库帮我们做强制类型转换 如果需要进行 join 的字段两表的字段类型要相同 参考 ¶ 负向查询不能使用索引123select name from user where id not in (1,3,4); @pdai: 代码已经复制到剪贴板 1 应该修改为: 123select name from user where id in (2,5,6); @pdai: 代码已经复制到剪贴板 1 ¶ 前导模糊查询不能使用索引如: 123select name from user where name like '%zhangsan' @pdai: 代码已经复制到剪贴板 1 非前导则可以: 123select name from user where name like 'zhangsan%' @pdai: 代码已经复制到剪贴板 1 建议可以考虑使用 Lucene 等全文索引工具来代替频繁的模糊查询。 ¶ 数据区分不明显的不建议创建索引如 user 表中的性别字段，可以明显区分的才建议创建索引，如身份证等字段。 ¶ 字段的默认值不要为 null这样会带来和预期不一致的查询结果。 ¶ 在字段上进行计算不能命中索引123select name from user where FROM_UNIXTIME(create_time) &lt; CURDATE(); @pdai: 代码已经复制到剪贴板 1 应该修改为: 123select name from user where create_time &lt; FROM_UNIXTIME(CURDATE()); @pdai: 代码已经复制到剪贴板 1 ¶ 最左前缀问题如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引: 1234567select username from user where username='zhangsan' and pwd ='axsedf1sd'select username from user where pwd ='axsedf1sd' and username='zhangsan'select username from user where username='zhangsan' @pdai: 代码已经复制到剪贴板 12345 但是使用 123select username from user where pwd ='axsedf1sd' @pdai: 代码已经复制到剪贴板 是不能命中索引的。 ¶ 如果明确知道只有一条记录返回1select name from user where username='zhangsan' limit 1 可以提高效率，可以让数据库停止游标移动。 ¶ 不要让数据库帮我们做强制类型转换1select name from user where telno=18722222222 这样虽然可以查出数据，但是会导致全表扫描。 需要修改为 1select name from user where telno=&apos;18722222222&apos; ¶ 如果需要进行 join 的字段两表的字段类型要相同不然也不会命中索引。 ¶ 参考 https://github.com/realpdai/JCSprout/blob/master/MD/SQL-optimization.md http://blog.csdn.net/u010003835/article/details/54381080 MySQL 大表优化方案 SQL的常见命令1234567891011show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名( 字段名 字段类型, 字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据 1create database db_name 修改字段编码123alter database name character set utf8;#修改数据库成utf8的.alter table type character set utf8;#修改表用utf8.alter table type modify type_name varchar(50) CHARACTER SET utf8;#修改字段用utf8 mysqldump数据导出MySQL mysqldump数据导出详解mysqldump是导出数据过程中使用非常频繁的一个工具 mysqldump备份： mysqldump -u用户名 -p密码 -h主机 数据库 a -w “sql条件” –lock-all-tables &gt; 路径 案例： mysqldump -uroot -p1234 -hlocalhost db1 a -w “id in (select id from b)” –lock-all-tables &gt; c:\\aa.txt mysqldump还原： mysqldump -u用户名 -p密码 -h主机 数据库 &lt; 路径 案例： mysql -uroot -p1234 db1 &lt; c:\\aa.txt mysqldump按条件导出： mysqldump -u用户名 -p密码 -h主机 数据库 a –where “条件语句” –no-建表&gt; 路径 mysqldump -uroot -p1234 dbname a –where “tag=’88’” –no-create-info&gt; c:\\a.sql mysqldump按导入： 1mysqldump -u用户名 -p密码 -h主机 数据库 &lt; 路径 1.导出所有数据库 该命令会导出包括系统数据库在内的所有数据库 1mysqldump -uroot -proot --all-databases &gt;/tmp/all.sql 2.导出db1、db2两个数据库的所有数据 1mysqldump -uroot -proot --databases db1 db2 &gt;/tmp/user.sql 3.导出db1中的a1、a2表 注意导出指定表只能针对一个数据库进行导出，且导出的内容中和导出数据库也不一样，导出指定表的导出文本中没有创建数据库的判断语句，只有删除表-创建表-导入数据 1mysqldump -uroot -proot --databases db1 --tables a1 a2 &gt;/tmp/db1.sql 4.条件导出，导出db1表a1中id=1的数据 如果多个表的条件相同可以一次性导出多个表 字段是整形 1mysqldump -uroot -proot --databases db1 --tables a1 --where='id=1' &gt;/tmp/a1.sql mymysql安装本文mysql的安装环境为win10 64位，mysql版本为MySQL5.7 1、运行 —— cmd ,打开面板，切换到mysql安装的bin目录下 2、在命令行输入 mysql -u root -p 登录 mysql，可以随意输入一个密码，返回”Can’t connect to MySQL server on localhost (10061)”错误 3、将mysql加入到Windows的服务中。切换到mysql安装目录下的bin文件夹，命令行运行”mysqld –install” 4、初始化mysql数据库，输入“mysqld –initialize –user=root –console”。最后面的 root@localhost后的文字为初始化后的root 密码，一定要记住 5、此时使用“net start mysql”成功启动msyql 6、用生成的密码登录mysql 7、通过“set password=password(‘root’)”修改密码。此处将root密码设置为root mysql用户名、密码修改成功，均为 root 现在mysql密码 ：123456, 22-3-17 获取val最大值所在行的数据方法一：子查询首先，查找某字段的最大值 1select max(weight) from apple; 接着，根据最大值，查找其所在行 1select * from apple where weight =7888; 合并在一起就是 1select * from apple where weight = (select max(weight) from apple); 方法二：GROUP BY +LIMIT 11select * from apple GROUP BY weight LIMIT 1 其他一、按name分组取val最大的值所在行的数据。–方法1： select a.* from tb a where val = (select max(val) from tb where name = a.name) order by a.name –方法2： select a.* from tb a where not exists(select 1 from tb where name = a.name and val &gt; a.val) –方法3： select a.* from tb a,(select name,max(val) val from tb group by name) b where a.name = b.name and a.val = b.val order by a.name –方法4： select a.* from tb a inner join (select name , max(val) val from tb group by name) b on a.name = b.name and a.val = b.val order by a.name –方法5 select a.* from tb a where 1 &gt; (select count(*) from tb where name = a.name and val &gt; a.val ) order by a.name————————————————其他方法原文链接： mysql命令行执行sql文件说明：result.sql文件中是多条插入数据的sql语句。现将这些sql语句导入到数据库中，（不用打开文件拷贝然后粘贴执行，如果数据量大的话这种操作非常繁琐，应使用以下方法）。注：提前将文件拷贝至当前目录下。如果文件不在当前目录，在source 后应加上文件的绝对路径1、登录mysql mysql -u root -p ;12、输入密码，选择数据库 use my_database;13、执行sql文件。 source result.sql ; 修改时区方法一：通过mysql命令行模式下动态修改 1show variables like \"%time_zone%\"; 查看时区 12345678+``------------------+--------+| Variable_name | Value |+``------------------+--------+| system_time_zone | CST || time_zone | SYSTEM |+``------------------+--------+2 ``rows` `in` `set` `(0.00 sec)#time_zone说明mysql使用system的时区，system_time_zone说明system使用CST时区 修改时区 123&gt; set global time_zone = '+8:00'; ##修改mysql全局时区为北京时间，即我们所在的东8区&gt; set time_zone = '+8:00'; ##修改当前会话时区&gt; flush privileges; #立即生效 my othermysql jdbc 参数MySQL Connector/J Driver 驱动程序包名：mysql-connector-java-x.x.xx-bin.jar 驱动程序类名: com.mysql.jdbc.Driver JDBC URL: jdbc:mysql://:/ 默认端口3306，如果服务器使用默认端口则port可以省略 MySQL Connector/J Driver 允许在URL中添加额外的连接属性 jdbc:mysql://:/?property1=value1&amp;property2=value2 注意： 需要操作记录为了避免乱码应该加上属性 useUnicode=true&amp;characterEncoding=utf8 ，比如 1jdbc:mysql://192.168.177.129:3306/report?useUnicode=true&amp;characterEncoding=utf8 mysql环境变量如果添加到环境变量中还是无效，建议将mysql环境变量放在path路径的最前面 windows的path路径是通过path文本从前往后找，如果在最后有可能解析path失败 mysql执行脚本命令12345678910show databases; create database xxx;mysql&gt; use yoj;show tables;##需要先选择数据库source xxx.sql(sql文件的目录); mysql注意null的判断都必须用is， = 没有用1DELETE FROM solution where submit_time is Null mysql导入数据时的外键约束问题 这个问题可通过FOREIGN_KEY_CHECKS解决，用法如下： 1、set FOREIGN_KEY_CHECKS=0; #在导入的脚本命令行最前面设置为不检查外键约束 2、。。。。。。。。。。。。 #导入数据的命令行 3、set FOREIGN_KEY_CHECKS=1; #在导入后恢复检查外键约束 mysql 索引https://blog.csdn.net/liutong123987/article/details/79384395 索引不仅能提高查询速度，还可以添加排序速度，如果order by 后面的语句用到了索引，那么将会提高排序的速度。 主键具备索引的功能了。 当你创建或设置主键的时候,mysql会自动添加一个与主键对应的唯一索引,不需要再做额外的添加。 索引类型Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。 FULLTEXT即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。 全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%”这类针对文本的模糊查询效率较低的问题。 HASH 由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。 HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。 BTREEBTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。 RTREE RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。 相对于BTREE，RTREE的优势在于范围查找。 ps. 此段详细内容见此片博文：Mysql几种索引类型的区别及适用情况 三、索引种类普通索引：仅加速查询 唯一索引：加速查询 + 列值唯一（可以有null） 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并 全文索引：对文本的内容进行分词，进行搜索 count(*)和count(1)如果你要统计行数就用count(*)或者count(1)，推荐前者 如果要统计某个字段不为NULL值的个数就用count(字段) 1.当mysql确认括号内的表达式值不可能为空时，实际上就是在统计行数 2.如果mysql知道某列col不可能为NULL值，那么mysql内部会将count(col)表达式优化为count(*) 这2句话出自&lt;&lt;高性能MySQL&gt;&gt;一书 也就是说count(1)和count(主键字段)还是要优化到count(*)的 update使用select结果,count(distinct xx)1UPDATE user SET solved = (SELECT COUNT(DISTINCT problem_id) FROM solution WHERE user_id = #&#123;userId&#125;) WHERE user_id = #&#123;userId&#125; varchar()的长度问题根据不同的字符集，解析中文占的位数是不一样的，如果是utf8的字符集，varchar(20)可以存放20个中文，这里中文跟英文存放的位数是一样的。但如果是latin字符集，中文估计解析不了，变成乱码 mysql 导入时自己制定库名在到处的sql文件中添加 123DROP DATABASE IF EXISTS `ssm_crud`;CREATE DATABASE ssm_crud;USE ssm_crud; 修改用户的密码方法1： 用SET PASSWORD命令首先登录MySQL。 12格式：mysql&gt; set password for 用户名@localhost = password('新密码'); 例子：mysql&gt; 1set password for root@localhost = password('123'); 将表结构查询为表格1234567891011121314151617181920SELECT COLUMN_NAME 列名, COLUMN_TYPE 数据类型, DATA_TYPE 字段类型, CHARACTER_MAXIMUM_LENGTH 长度, IF(IS_NULLABLE = &apos;YES&apos;,&apos;是&apos;,&apos;否&apos;) AS &apos;是否为空&apos;, COLUMN_DEFAULT 默认值, IF(COLUMN_KEY=&apos;PRI&apos;,&apos;是&apos;,&apos;否&apos;) AS &apos;主键&apos;, IF(COLUMN_KEY=&apos;MUL&apos;,&apos;是&apos;,&apos;否&apos;) AS &apos;外键&apos;, COLUMN_COMMENT 备注, COLUMN_KEYFROM INFORMATION_SCHEMA.COLUMNSwhere-- yoj为数据库名称，到时候只需要修改成你要导出表结构的数据库即可table_schema =&apos;yoj&apos;AND-- user为表名，到时候换成你要导出的表的名称-- 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称table_name = &apos;problem&apos; 参考资料SQL语言 - SQL语法基础","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://codeofli.github.io/tags/mysql/"}]}]}